## 一、JavaScript DOM 概念
HTML DOM 是进行获取, 更改, 添加和删除 HTML 元素的标准。
![[Excalidraw/4. DOM 节点和事件处理程序 2024-10-28 16.27.55|300]]
由于上述每个元素都是对应的节点, 节点中的数值可以采用 innerHTML 进行访问, 也可以通过 innerText 获取(但是有时是 textContent, 因此需要判断如果innerText 为 undefined 时可能需要进行逻辑处理,  例如获取, 设置等等) 
语言参考 [language ccodes](https://www.w3schools.com/tags/ref_language_codes.asp) 
主要操作对象: 参考[[📘ClassNotes/⌨️ Pre-front Programming/🍵JavaScript/3. JavaScript 语法入门和对象#(5) JS 预定义对象|JS 预定义对象]]  

### (1) DOM 中查找和元素选择器(节点元素获取)

| getElementById()         | Returns the element that has the ID attribute with the specified value                                     |
| ------------------------ | ---------------------------------------------------------------------------------------------------------- |
| getElementsByClassName() | Returns an HTMLCollection containing all elements with the specified class name                            |
| getElementsByName()      | Returns an live NodeList containing all elements with the specified name                                   |
| getElementsByTagName()   | Returns an HTMLCollection containing all elements with the specified tag name                              |
| querySelector()          | Returns the first element that matches a specified CSS selector(s) in the document                         |
| querySelectorAll()       | Returns a static NodeList containing all elements that matches a specified CSS selector(s) in the document |
获取对应的元素值; 
其中元素`<>` 中的属性设置可以采用 `element.getAttribute` 获取;
```js
element.getAttribute(name)
```
而所有的 css 样式设置相关都可以从 [element.style](https://www.w3schools.com/jsref/prop_html_style.asp) 进行访问; 
css 选择器参考[[📘ClassNotes/⌨️ Pre-front Programming/✳️ HTML & CSS sheet/2. CSS3 基础和组件知识#一、CSS 选择器概念|2. CSS3 基础和组件知识]]
```js
document.querySelector("div > p");
document.querySelector("#demo").innerHTML = "Hello World!";
document.querySelector("a[target]");  /* 第一个带有  target  的 a 元素*/
```
需要说明的是, querySelector 当采用多选择器时, 会选择第一个其中有的元素
html 的节点模型

<b><mark style="background: transparent; color: orange">常用方法</mark></b>如下: 
async :  加载方式
body : 返回 body 元素
url = document.url 获取链接
**lastModified** : 返回最后一次修改的时间
doctype 
```js
document.activeElement();// 当前激活元素
document.open()
document.close();  // 关闭事件‘
document.dir = "ltr" 
```

| designMode | Controls whether the entire document should be editable or not. |
| ---------- | --------------------------------------------------------------- |
|            | document 下所有的 form                                              |

对于选中的内容, 可以采用 js 中 textArea的 selectionStart 和 selectionEnd 进行获取, 
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>获取选中文本</title>
</head>
<body>
    <textarea id="myTextArea" rows="5" cols="30">
这是一个示例文本。你可以选中其中的任何部分。
    </textarea>
    <p>选中的文本: <span id="selectedText"></span></p>
    <script>
        const textArea = document.getElementById('myTextArea');
        const selectedTextSpan = document.getElementById('selectedText');

        textArea.addEventListener('mouseup', () => {
            const selectedText = getSelectedText(textArea);
            selectedTextSpan.textContent = selectedText;
        });

        function getSelectedText(textArea) {
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            return textArea.value.substring(start, end);
        }
    </script>
</body>
</html>
```

### (2) 添加和删除元素
参考[HTML documents](https://www.w3schools.com/jsref/dom_obj_document.asp), 常见的创建元素方法有:

| 创建元素                         | description                                    |
| ---------------------------- | ---------------------------------------------- |
| **createAttribute()**        | Creates an attribute node                      |
| **createComment()**          | Creates a Comment node with the specified text |
| **createDocumentFragment()** | Creates an empty DocumentFragment node         |
| **createElement()**          | Creates an Element node                        |
| **createEvent()**            | Creates a new event                            |
| **createTextNode()**         | Creates a Text node                            |

例如, 可以整体创建一个 DocumentFragment, 然后采用 appendChild 方法拼接到 myList 中:
```html
<!DOCTYPE html>
<html>
	<body>
		<h1>The Document Object</h1>
		<h2>The createDocumenFragment() Method</h2>
		<p>Add array items to an existing list:</p>
		<ul id="myList">
		<li>Apple</li> 
		<li>Pear</li>
		</ul>
		<script>
		const fruits = ["Banana", "Orange", "Mango"];
		// Create a document fragment:
		const dFrag = document.createDocumentFragment();
		for (let x in fruits) {
		  const li = document.createElement('li');
		  li.textContent = fruits[x];
		  dFrag.appendChild(li);
		}
		// Add fragment to a list: 
		document.getElementById('myList').appendChild(dFrag);
		</script>
	</body>
</html>
```

需要注意的是, document.createElement 实际上并不会将某个节点添加进文档, 实际上都是通过 body 进行添加的。例如:
```js
ul = document.createElement("ul");
li1 = document.createElement("li");
li1.appendChild(text2) 
ul.append(li1) ;
document.getElementsByTagName("Body")[0].appendChild(ul);
```

需要说明的是, 一般采用如下的:
```js
document.body.appendChild(ul);
document.querySelector("body").appendChild(ul);
```


cookie 属性是保存在浏览器中的小文本, 并允许保存特定长时间。可以直接设定 document.cookies 的值

open() 方法和 close() 方法 (基本上不适用):
documnet.open() : 打开一个新文档并完全采用 document.write 生成内容
document.close() : 完成新的界面 (关闭并显示其内容)

一般地, **对于 React, Vue, Angular 等提供了更加灵活的方式来管理 DOM 和更新内容，而不是直接操作整个文档。例如，这些框架会使用虚拟 DOM、组件化结构和数据绑定来处理页面更新**。

一般采用 appendChild, replaceChild 进行 DOM 的操作。

### (3) 元素级操作 
对应的元素参考 [HTML elements](https://www.w3schools.com/jsref/dom_obj_all.asp) 

重点如下: 

| hasAttribute()  | Returns true if an element has a given attribute |
|-----------------|--------------------------------------------------|
| hasAttributes() | Returns true if an element has any attributes    |
| hasChildNodes() | Returns true if an element has any child nodes   |

| click()                 | Simulates a mouse-click on an element                                    |
| ----------------------- | ------------------------------------------------------------------------ |
| classList               | Returns the class name(s) of an element                                  |
| blur()                  | Removes focus from an element                                            |
| appendChild()           | Adds (appends) a new child node to an element                            |
| focus()                 | Gives focus to an element                                                |
| getAttribute()          | Returns the value of an element's attribute                              |
| getAttributeNode()      | Returns an attribute node                                                |
| getBoundingClientRect() | Returns the size of an element and its position relative to the viewport |

| childElementCount | Returns an elements's number of child elements           |
|-------------------|----------------------------------------------------------|
| childNodes        | Returns a NodeList of an element's child nodes           |
| children          | Returns an HTMLCollection of an element's child elements |

| clientHeight | Returns the height of an element, including padding |
|--------------|-----------------------------------------------------|
| clientLeft   | Returns the width of the left border of an element  |
| clientTop    | Returns the width of the top border of an element   |
| clientWidth  | Returns the width of an element, including padding  |

| innerHTML | Sets or returns the content of an element                      |
|-----------|----------------------------------------------------------------|
| innerText | Sets or returns the text content of a node and its descendants |

| insertAdjacentElement() | Inserts a new HTML element at a position relative to an element     |
|-------------------------|---------------------------------------------------------------------|
| insertAdjacentHTML()    | Inserts an HTML formatted text at a position relative to an element |
| insertAdjacentText()    | Inserts text into a position relative to an element                 |
| insertBefore()          | Inserts a new child node before an existing child node              |

| nodeName      | Returns the name of a node                                |
| ------------- | --------------------------------------------------------- |
| nodeType      | Returns the node type of a node                           |
| nodeValue     | Sets or returns the value of a node                       |
| ownerDocument | Returns the root element (document object) for an element |
|               |                                                           |

| remove()              | Removes an element from the DOM                                                    |
| --------------------- | ---------------------------------------------------------------------------------- |
| removeAttributeNode() | Removes an attribute node, and returns the removed node                            |
| removeChild()         | Removes a child node from an element                                               |
| removeEventListener() | Removes an event handler that has been attached with the addEventListener() method |
| replaceChild()        | Replaces a child node in an element                                                |
| style                 | Sets or returns the value of the style attribute of an element                     |
| toString()            | Converts an element to a string                                                    |

其中插入元素最多的是append Child 或者 insertBefore
注意: 如果希望生成  `<p> </p>` 之间的文本时, 需要采用  document.createTextNode 先创建, 然后采用 **div1.appendChild 进行添加**

div1.removeChild 用于删除节点

此外, 也可以直接为元素的某些方法直接自定义表达式,例如
```js
d1.onclick = () =>{
	d1.style.color = red;
}
```

## 二、事件处理程序
### (1) 常用属性
一般对于 html 元素均有 onclick  属性, 可以通过 onclick 设置函数, 进行处理。
对于在 html 文档中引用的  js 文件, html 可以直接访问其中定义的函数, 如:
```js
<button onclick="fun()"></button>
```

主要的事件部分参考 [html events](https://www.w3schools.com/jsrEF/dom_obj_event.asp), 具体提取常用的如下:

| Event                        | Occurs When                                                  | Belongs To                    |
| ---------------------------- | ------------------------------------------------------------ | ----------------------------- |
| abort                        | The loading of a media is aborted                            | UiEvent, Event                |
| animationstart               | A CSS animation has started                                  | AnimationEvent                |
| beforeprint                  | A page is about to be printed                                | Event                         |
| beforeunload                 | Before a document is about to be unloaded                    | UiEvent, Event                |
| **blur**                     | **An element loses focus**                                   | **FocusEvent**                |
| change                       | The content of a form element has changed                    | Event                         |
| click                        | An element is clicked on                                     | MouseEvent                    |
| contextmenu                  | An element is right-clicked to open a context menu           | MouseEvent                    |
| copy                         | The content of an element is copied                          | ClipboardEvent                |
| cut                          | The content of an element is cut                             | ClipboardEvent                |
| ==dblclick==                 | ==An element is double-clicked==                             | ==MouseEvent==                |
| drag                         | An element is being dragged                                  | DragEvent                     |
| dragend                      | Dragging of an element has ended                             | DragEvent                     |
| dragenter                    | A dragged element enters the drop target                     | DragEvent                     |
| dragstart                    | Dragging of an element has started                           | DragEvent                     |
| drop                         | A dragged element is dropped on the target                   | DragEvent                     |
| durationchange               | The duration of a media is changed                           | Event                         |
| ==ended==                    | ==A media has reach the end ("thanks for listening")==       | ==Event==                     |
| error                        | An error has occurred while loading a file                   | ProgressEvent, UiEvent, Event |
| ==焦点事件部分==                   |                                                              |                               |
| **focus**                    | **An element gets focus**                                    | **FocusEvent**                |
| **focusin**                  | **An element is about to get focus**                         | **FocusEvent**                |
| **focusout**                 | **An element is about to lose focus**                        | **FocusEvent**                |
| fullscreenchange             | An element is displayed in fullscreen mode                   | Event                         |
| fullscreenerror              | An element can not be displayed in fullscreen mode           | Event                         |
| hashchange                   | There has been changes to the anchor part of a URL           | HashChangeEvent               |
| input                        | An element gets user input                                   | InputEvent, Event             |
| ==键盘事件==                     |                                                              |                               |
| **keydown**                  | **A key is down**                                            | **KeyboardEvent**             |
| **keypress**                 | **A key is pressed**                                         | **KeyboardEvent**             |
| **keyup**                    | **A key is released**                                        | **KeyboardEvent**             |
| load                         | An object has loaded                                         | UiEvent, Event                |
| message                      | A message is received through the event source               | Event                         |
| ==鼠标事件部分==                   |                                                              |                               |
| **mousedown**                | The mouse button is pressed over an element(not lift)        | MouseEvent                    |
| mouseenter                   | The pointer is moved onto an element                         | MouseEvent                    |
| mouseleave                   | The pointer is moved out of an element                       | MouseEvent                    |
| mousemove                    | The pointer is moved over an element                         | MouseEvent                    |
| **mouseover**                | The pointer is moved onto an element                         | MouseEvent                    |
| mouseout                     | The pointer is moved out of an element                       | MouseEvent                    |
| **mouseup**(调用一般比mousedown多) | A user releases a mouse button over an element               | MouseEvent                    |
| mousewheel                   | Deprecated. Use the wheel event instead                      | WheelEvent                    |
| offline                      | The browser starts working offline                           | Event                         |
| online                       | The browser starts working online                            | Event                         |
| open                         | A connection with the event source is opened                 | Event                         |
| pagehide                     | User navigates away from a webpage                           | PageTransitionEvent           |
| pageshow                     | User navigates to a webpage                                  | PageTransitionEvent           |
| paste                        | Some content is pasted in an element                         | ClipboardEvent                |
| resize                       | The document view is resized                                 | UiEvent, Event                |
| reset                        | A form is reset                                              | Event                         |
| scroll                       | An scrollbar is being scrolled                               | UiEvent, Event                |
| search                       | Something is written in a search field                       | Event                         |
| select                       | User selects some text                                       | UiEvent, Event                |
| show                         | A `<menu>` element is shown as a context menu                | Event                         |
| stalled                      | The browser is trying to get unavailable media data          | Event                         |
| storage                      | A Web Storage area is updated                                | StorageEvent                  |
| submit                       | A form is submitted                                          | Event                         |
| toggle                       | The user opens or closes the <details> element               | Event                         |
| waiting                      | A media is paused but is expected to resume (e.g. buffering) | Event                         |
| **wheel**                    | **The mouse wheel rolls up or down over an element**         | **WheelEvent**                |
| unload                       | A page has unloaded                                          | UiEvent, Event                |

需要说明的是, onabort 表示在图片加载完毕之前停止加载, 而 onunload 为尝试离开页面时调用的脚本.

```js
<element onabort="myScript">
object.onabort = function(){_myScript_};   /* javascript */
_object_.addEventListener("abort", _myScript_);
```

需要说明的是:
- **`mouseover`**: 是一个**循环触发**的事件。当鼠标在元素上移动时，每次进入一个新的子元素或重新进入目标元素时，都会触发 `mouseover` 事件。所以如果鼠标在同一个元素上不断移动并进入其子元素，`mouseover` 事件会反复触发。    
- **`mousedown`**: 是一个**一次性触发**的事件。当鼠标按下时（不管是左键、右键或中键），`mousedown` 事件会触发一次，直到鼠标被再次按下才会再次触发。因此，如果鼠标按住不放，`mousedown` 只会触发一次。

### (2) 事件监听器
根据上述表格, 实际上<b><mark style="background: transparent; color: orange">调用的事件处理程序对应的属性</mark></b>都是以 on 开头的, 如 onabort 事件处理程序。onwheel 等等, 这个带on 的可以在 html 的 `<>` 中进行设置, 并可以<b><mark style="background: transparent; color: orange">调用 document.addEventListener ("abort")</mark></b> 类似方法进行添加事件监听和处理函数。

最常的 EventListener 相关函数:
1. addEventListener : 添加监听器 (示例: [docment.addEventListener](https://www.w3schools.com/jsref/met_element_addeventlistener.asp)) 
2. **removeEventListener** : 进行事件监听器的删除 remove
3. attchEevent (仅用于IE9 之前) : 用于事件冒泡, 不能用于事件捕捉, 
4. detachEvent (仅用于IE9 之前): 移除事件 
另外, attachEvent Listener <b><mark style="background: transparent; color: red">允许添加一个 true 和 false 标签, 表示在冒泡阶段执行还是在捕获阶段时执行</mark></b>。
- **`false`**：事件监听器在事件 **冒泡阶段** 被触发（默认行为）。**事件冒泡指的是事件从目标元素向上传递到其父元素，直至根节点**。
- **`true`**：事件监听器在事件 **捕获阶段** 被触发。捕获阶段指的是**事件从根节点向下传递到目标元素的阶段**。
大多数情况下，使用冒泡阶段（即传入 `false`）就可以满足需求，所以通常将其设置为 `false`。
```js
myDIV.addEventListener("mousemove", myFunction);
myDIV.removeEventListener("mousemove", myFunction);
myDIV.addEventListener("mousemove", function(){
					window.alert("hi");
				},false); // 在冒泡阶段执行, 即在获得false 时执行 
```

#### 1. 示例: 标签显示器
例如,采用事件的监听方法, 创建一个label, 而只需要 mouse hover 超过一定时间会显示解释, 以下给出一个示例, 采用类的方法建立 ToolTipLabel 对象:

另外，document.create 的修饰一般采用 const 而不采用 let, 保证变量创建完毕之后不被修改。
实际上为了避免循环触发, 采用监听 mouseenter 和 mouseleave 事件的方法创建响应元素。
```js
class TooltipLabel {  
    constructor(labelText, tooltipText) {  
        this.labelText = labelText;  
        this.tooltipText = tooltipText;
        this.obj = this.createTooltip();
    }
    createTooltip() {
        // Create elements
        const container = document.createElement('div');  
        const label = document.createElement('label');
        const tooltip = document.createElement('span');
        // Set label and tooltip text  
        label.textContent = this.labelText;  
        tooltip.textContent = this.tooltipText;
        
        // Add classes and styles
        container.classList.add('tooltip-container');
        tooltip.classList.add('tooltip');
        
        // Append to container
        container.appendChild(label);  
        container.appendChild(tooltip);  
        // Tooltip visibility logic
        let timer;  
        label.addEventListener('mouseenter', () => {  
            timer = setTimeout(() => {  
                tooltip.classList.add('show');  
            }, 1500); // Delay for tooltip  
        });

        label.addEventListener('mouseleave', () => {  
            clearTimeout(timer);  
            tooltip.classList.remove('show');  
        });
        return container;
    }
}  

// CSS for tooltip (you can use the same as before)  
const style = document.createElement('style');  
style.textContent = `  
    .tooltip-container {  
        position: relative;  
        display: inline-block;  
    }
    .tooltip {  
        visibility: hidden;  
        width: 120px;  
        background-color: black;  
        color: #fff; 
        text-align: center;  
        border-radius: 5px;  
        padding: 5px;  
        position: absolute;  
        z-index: 1;  
        bottom: 125%;  
        left: 50%;  
        margin-left: -60px;  
        opacity: 0;  
        transition: opacity 0.2s ease-in-out;  
    }  
    .tooltip.show {  
        visibility: visible;  
        opacity: 1;  
    }
`;
document.head.appendChild(style);
// Usage: create a label with tooltip in one line
const myTooltip = new TooltipLabel('Hover over me!', 'This is the tooltip text!');
if (myTooltip.obj == null){
    console.log("can't find tooltip object");
}else{
    console.log("add tooltip to body" + myTooltip.obj);
}

const docBody = document.getElementById("body-content");
if (docBody == null){
    console.log("can't find body");
}else{
    docBody.appendChild(myTooltip.obj);
}
```

### (3) event 对象和属性说明
event 对象默认是以 DOM 级别 0 进行注册的, 而目前一般浏览器都支持以 DOM 级别 2 进行注册事件。
事件发生时, 将创建 event 对象, 具体种类参考 [HTML EventObjects](https://www.w3schools.com/jsrEF/obj_events.asp):

| Object              | Handles                                |
|---------------------|----------------------------------------|
| AnimationEvent      | CSS animations                         |
| ClipboardEvent      | Modification of the clipboard          |
| DragEvent           | Drag and drop interaction              |
| FocusEvent          | Focus-related events                   |
| HashChangeEvent     | Changes in the anchor part of an URL   |
| InputEvent          | User input                             |
| KeyboardEvent       | Keyboard interaction                   |
| MouseEvent          | Mouse interaction                      |
| PageTransitionEvent | Navigation between web pages           |
| PopStateEvent       | Changes in the page history            |
| ProgressEvent       | The progress of loading external files |
| StorageEvent        | Changes in the Web Storage             |
| TouchEvent          | Touch interaction                      |
| TransitionEvent     | CSS transitions                        |
| UiEvent             | User interface interaction             |
| WheelEvent          | Mouse-wheel interaction                |
而实际上在函数中, 也可以加上 event 参数, 以访问当前所指的 event 对象的参数
需要说明的是, 每个对象都可以通过添加 event 参数方式捕获其中发生的事件, 获取其对应属性, 并做出相应的行为. 如下:
```js
/*添加一个 eventlistener ,监听所有 click 事件并输出参数 */
document.addEventListener('click', function(event) {
    console.log('The event type is:' + event.type +'and the element is:' + event.target.tagName)
    })

element.addEventListener("click", myFunction1);
```
相应的事件类型包括 bubble, cancelabl, type, view 等等各种属性, 具体参考 [HTML Event Properties](https://www.w3schools.com/jsref/dom_obj_event_prop.asp) 

常用的还有 key_property, 例如捕获 keyDown 或者 keyup 时, 一般会采用 event.key 获取其中的按下的 key 事件。
```js
var text = document.getElementById("txtBox1");
text.addEventListener("keyup", function(event){
	let key = event.key;
	if (key == "a"){
		do....
	}
})
```
另外参考 [alt key perperty](https://www.w3schools.com/jsref/event_key_altkey.asp), 则检测是否有 alt键按下时, 采用:

```js
if (event.altKey  || event.ctrlKey) ||  event.shiftKey)    /*  检测各个按键的按下情况  */
```

设置隐藏和显示, 可以设置 [visibility](https://www.w3schools.com/jsref/prop_style_visibility.asp) 属性 (hidden, collapse)，也可以设置 [display](https://www.w3schools.com/jsref/prop_style_display.asp) 属性 (none, block,compact,flex, inline, table等等). 

需要说明的是, display = none 会隐藏整个对象, 而 visibility 仅仅会将对应项设置为 invisible, 但是元素仍然会停止在对应的位置，即相应onclick 等等事件仍然会触发, **因此建议设置 `dislay = none` 来进行临时窗口的隐藏**

### (4) 两种事件注册方式, 事件方法的使用
event 相关事件具体参考 [Event Methods](https://www.w3schools.com/jsrEF/dom_obj_event_methods.asp), 当使用 DOM0 事件注册时, 是通过 返回return false 阻止事件的默认行为。

此外**可以采用 `event.preventDefault()` 方法来完成对默认行为的阻止**。
或者 **event.stopPropagation(**)  **阻止事件冒泡**

下面我们通过举例, 说明 DOM0 和 DOM2 方式注册事件的区别;

#### 1. DOM0 事件注册
DOM0 的事件注册是最早的方式，可以直接通过设置元素的事件属性（如 `onclick`）来注册事件。在这种方式下，可以使用 `return false` 来阻止事件的默认行为(例如, 阻止按钮点击和事件的响应)。
```html
<!DOCTYPE html>
<html>
<body>
    <a href="https://example.com" onclick="return false;">点击我 (DOM0, return false)</a>
    <script>
        // 也可以这样定义
        const link = document.querySelector('a');
        link.onclick = function () {
            alert("DOM0 - 链接点击事件已被阻止");
            return false; // 阻止默认行为
        };
    </script>
</body>
</html>
```

在这个例子中，通过 `onclick` 属性直接注册点击事件，并在事件处理函数内 `return false` 来阻止链接的跳转。

#### 2. DOM2 事件注册
DOM2 事件模型可以通过 `addEventListener` 来添加事件监听器，并允许添加多个事件处理函数。为了阻止事件的默认行为，可以使用 `event.preventDefault()` 方法。


> [!caution] 说明
> 下述方法必须**采用传入 addEventListener 中的函数传入参数 event 的方法进行**

**示例：**
```html
<!DOCTYPE html>
<html>
<body>
    <a href="https://example.com" id="dom2-link">点击我 (DOM2, preventDefault)</a>
    <script>
        const link = document.getElementById("dom2-link");
        link.addEventListener("click", function(event) {
            alert("DOM2 - 链接点击事件已被阻止");
            event.preventDefault(); // 阻止默认行为
        });
    </script>
</body>
</html>
```

在这个示例中，使用 `addEventListener` 注册了点击事件，通过 `event.preventDefault()` 来阻止链接跳转。这种方式的优势是可以在同一元素上添加多个事件处理函数，而不会互相覆盖。

1. **DOM0 事件注册**：通过 `element.onclick = function () { ... }`，阻止默认行为使用 `return false`。
2. **DOM2 事件注册**：通过 `element.addEventListener("click", function (event) { ... })`，阻止默认行为使用 `event.preventDefault()`。

此外, 事件处理函数, 主要有以下几种: 

| Method                         | Description                                                                                                         | Belongs To |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------- | ---------- |
| getModifierState()             | Returns true if a specified key is activated                                                                        | MouseEvent |
| getTargetRanges()              | Returns an array containing target ranges that will be affected by the insertion/deletion                           | InputEvent |
| preventDefault()               | **Cancels the event if it is cancelable**, meaning that the default action that belongs to the event will not occur | Event      |
| **stopImmediatePropagation()** | **Prevents other listeners of the same event from being called**                                                    | Event      |
| stopPropagation()              | Prevents further propagation of an event during event flow                                                          | Event      |

### (5) 事件的捕获和冒泡机制
#### 1. 事件捕获和冒泡的基本概念
当用户与网页元素（例如按钮、输入框等）交互时，会触发 **事件**，如 `click`、`submit` 或 `focus`。在浏览器的事件模型中，事件传递会经历以下三个阶段：

1. **捕获阶段（Capture Phase）**：事件从 `window` 对象开始，逐层向下传递到触发事件的元素（目标元素）。
2. **目标阶段（Target Phase）**：事件到达并作用于目标元素本身。
3. **冒泡阶段（Bubble Phase）**：事件从目标元素开始，逐层向上传递到 `window` 对象。

#### 举例说明：
假设我们有以下 HTML 结构：

```html
<div id="parent">
    <button id="child">Click me!</button>
</div>
```

当点击 `<button>` 时，事件会从 `window` 传递到 `#parent`，再到 `#child`，然后从 `#child` 向上传递回到 `#parent` 和 `window`。具体过程是：

1. **捕获阶段**：`window` → `#parent` → `#child`
2. **目标阶段**：事件到达目标元素 `#child`
3. **冒泡阶段**：`#child` → `#parent` → `window`

#### 2. 如何使用捕获和冒泡
在 JavaScript 中，可以通过 `addEventListener` 的第三个参数来指定事件处理器是在捕获阶段还是冒泡阶段触发。
```javascript
element.addEventListener('click', function(event) {
    // 处理事件
}, true); // 捕获阶段

element.addEventListener('click', function(event) {
    // 处理事件
}, false); // 冒泡阶段
```
- **`true`**：事件处理器会在捕获阶段触发，即在事件从父元素传递到子元素时先处理。
- **`false`**：事件处理器会在冒泡阶段触发，即事件从子元素向上传递回父元素时处理。

#### 3. 捕获和冒泡的使用场景
- **捕获阶段**：通常用于**希望在事件传递到目标元素之前拦截事件的情况**。例如，一个全局的 `window` 事件监听器，可以在捕获阶段中检查并过滤掉不符合条件的事件。
- **冒泡阶段**：更常用的方式，因为冒泡阶段发生在事件到达目标之后，适合响应用户直接触发的事件。常用于事件委托（Event Delegation）——将事件绑定在父元素上，通过冒泡响应子元素触发的事件，这样可以避免给每个子元素绑定事件。
  
需要说明的是, event.stopPropagation 可以在 IE8  以下浏览器取消事件传播。

#### 4. 事件委托
事件委托允许我们在父级元素上添加事件监听器，而不需要对每个子元素单独绑定。例如:
```javascript
document.getElementById("parent").addEventListener("click", function(event) {
    if (event.target.tagName === "BUTTON") {
        console.log("Button clicked:", event.target.id);
    }
});
```
这样，即使在 `#parent` 中动态添加更多按钮，也可以通过事件冒泡统一处理点击事件。

#### 5. 事件处理的流程和实际传递到后端的时机
**前端处理**：事件主要是在前端捕获和处理的。一般的用户交互（如 `click`、`input` 等）会触发 JavaScript 函数，这些函数可以对数据进行验证、修改页面内容等。这一过程通常不会涉及后端，除非前端代码显式地发出请求。
**后端处理**：如果需要与后端交互，例如在表单提交时发送数据到服务器，就需要在前端事件处理函数中发起请求。通常通过以下方式完成:
1. **表单提交**：在表单的 `submit` 事件中，调用 `event.preventDefault()` 来阻止默认的页面刷新。然后可以使用 `fetch` 或 `XMLHttpRequest` 来将数据发送到后端：
    ```javascript
    my_form.addEventListener("submit", function(event) {
        event.preventDefault();
        let data = new FormData(my_form);
        fetch("/submit-url", {
            method: "POST",
            body: data
        }) // 返回包含响应信息的 response
        .then(response => response.json())  
        // 处理返回值 response 为 json 对象, 并将 response.json 返回值赋值为 data 
        .then(data => {  // 调用函数, 
            console.log("Response from server:", data);
        });
    });
    ```

`````ad-important
title:  Then 方法和  Promise 对象解析
collapse: close
重要 : `.then()` 是 **Promise** 对象的方法，而不是所有函数都有的。只有当函数返回一个 **Promise** 对象时，才能使用 `.then()` 方法来处理该 Promise 解析后的值。

`.then()` 是 **Promise** 对象的方法，而不是所有函数都有的。只有当函数返回一个 **Promise** 对象时，才能使用 `.then()` 方法来处理该 Promise 解析后的值。下面我会详细解释 Promise、`.then()` 的机制，以及如何用它来处理异步操作的返回值。

### 1. 什么是 Promise？

Promise 是一种用于处理异步操作的 JavaScript 对象。异步操作（例如网络请求、定时器、文件读写等）会在未来某个时刻完成，而不会立即返回结果。Promise 提供了一种结构化的方式，可以“承诺”一个未来的值，当这个操作完成时，Promise 会将值传递给你。

一个 Promise 可以有三种状态：

- **pending**（进行中）：Promise 处于等待状态，操作未完成。
- **fulfilled**（已成功）：操作完成，Promise 返回一个值。
- **rejected**（已失败）：操作失败，Promise 返回一个错误原因。

### 2. `.then()` 方法的作用

`.then()` 是专门用于处理 **成功完成**（fulfilled）的 Promise 的方法。它允许我们在 Promise 完成后获取返回值，并执行后续的操作。

**语法**：

```javascript
promise.then(onFulfilled, onRejected);
```

- **`onFulfilled`**：一个回调函数，当 Promise 成功解析（fulfilled）时调用。`onFulfilled` 的参数是 Promise 成功完成时返回的值。
- **`onRejected`**（可选）：一个回调函数，当 Promise 被拒绝（rejected）时调用。`onRejected` 的参数是 Promise 被拒绝的原因。

通常 `.then()` 用法如下：

```javascript
promise.then(result => {
    console.log("Promise resolved with:", result);
}).catch(error => {
    console.log("Promise rejected with:", error);
});
```

在这个例子中：
- **`result`** 是 `onFulfilled` 的参数，它会接收到 Promise 成功完成时返回的值。
- **`error`** 是 `onRejected` 的参数，它会接收到 Promise 被拒绝时的错误信息。

### 3. `.then()` 返回一个新的 Promise

`.then()` 的关键特性之一是它 **返回一个新的 Promise**，这使得可以将多个异步操作链接（chaining）在一起。也就是说，可以在 `.then()` 之后继续使用 `.then()` 或 `.catch()` 来处理后续操作。

例如：

```javascript
fetch("/api/data")
    .then(response => response.json())       // 返回一个 Promise，解析为 JSON 数据
    .then(data => {
        console.log("First then:", data);    // 处理 JSON 数据
        return data.someProperty;            // 返回一个值，将传递给下一个 then
    })
    .then(someProperty => {
        console.log("Second then:", someProperty);  // 使用上一个 then 返回的值
    })
    .catch(error => {
        console.error("Error:", error);      // 捕获任何链中发生的错误
    });
```

**解释**：

- 第一个 `.then()` 解析响应的 JSON 数据。
- 第二个 `.then()` 拿到解析后的数据，并处理其中的某个属性 `someProperty`。
- `return` 语句可以在每个 `.then()` 中传递值，作为下一个 `.then()` 的输入参数。

### 4. 为什么 .then() 适用于异步操作

JavaScript 的 Promise 和 `.then()` 提供了一种处理异步操作的方式，使代码结构上更接近于同步代码。它允许我们“等待”操作完成之后再去处理结果，而不会阻塞代码的执行。

### 5. 总结和要点

- **.then() 不是所有函数都有**：只有当函数返回一个 Promise 对象时，才能使用 `.then()`。
- **.then() 用于处理异步结果**：可以在 Promise 成功解析后，拿到返回值并处理它。
- **每次调用 .then() 返回一个新的 Promise**：这使得可以将异步操作串联在一起。
- **.then() 可以传递返回值**：每个 `.then()` 可以返回一个值，供下一个 `.then()` 使用。

Promise 链让我们能够将一系列异步操作逐步处理。 

`````

1. **AJAX 或 Fetch 请求**：可以在用户触发某个事件时（例如 `click`）使用 `fetch` 发起请求：
    ```javascript
    button.addEventListener("click", function() {
        fetch("/api/data")
            .then(response => response.json())
            .then(data => {
                console.log("Data from server:", data);
            });
    });
    ```

- **捕获** 和 **冒泡** 是事件传递的两个阶段。使用 `addEventListener` 的第三个参数可以选择事件在哪个阶段被触发。
- **捕获阶段**：事件从 `window` 一路向下到目标元素。
- **冒泡阶段**：事件从目标元素向上传递到 `window`。
- **前端处理和后端交互**：大部分事件在前端处理，通过 `fetch` 或表单提交将数据发送到后端；事件并不会自动传递到后端，除非前端显式地发出请求。

#### 6. 事件代理
对于多个元素是同一个父元素的子元素时, 一般采用 <mark style="background: transparent; color: red">event.target.classList.contains</mark> 的方法, 获取实际的点击对象 target 中是否有该容器, **从而避免了父元素被点击触发事件**。
```js
// 选择父元素
const container = document.querySelector('.button-container');

// 为父元素添加事件监听器
container.addEventListener('click', (event) => {
  if (event.target.classList.contains('my-button')) {
    console.log('Button clicked!');
  }
});
```

也可以采用 event.target.className 等进行判断。

## 三、属性的添加, 删除与访问
一般所有的 html Element 对象都具有属性, 通过 attributes 访问:
当需要添加时, 采用 createAttribute; 
可以通过 getAttribute 得到对应的value : let text = element.getAttribute("class");
hasAttribute()

主要方法如下:
[The getAttribute() Method](https://www.w3schools.com/jsref/met_element_getattribute.asp) 
[The setAttribute() Method](https://www.w3schools.com/jsref/met_element_setattribute.asp)
[The removeAttribute() Method](https://www.w3schools.com/jsref/met_element_removeattribute.asp)
[The hasAttribute() Method](https://www.w3schools.com/jsref/met_element_hasattribute.asp)
[The hasAttributes() Method](https://www.w3schools.com/jsref/met_node_hasattributes.asp)
[The createAttribute() Method](https://www.w3schools.com/jsref/met_document_createattribute.asp)
[The getAttributeNode() method](https://www.w3schools.com/jsref/met_element_getattributenode.asp)
[The setAttributeNode() method](https://www.w3schools.com/jsref/met_element_setattributenode.asp)
[The removeAttributeNode() method](https://www.w3schools.com/jsref/met_element_removeattributenode.asp)

```js
const nodeMap = document.getElementById("myImg")
let l = nodeMapLength.attributes.length;
document.getElementById("myImg").attributes.message="hello";  /* 浏览器不会自动创建该属性。如果这个属性不存在，它不会被自动添加,只对 JavaScript 对象的 `attributes` 集合有效。这种操作不会影响实际的 DOM 元素属性 */
document.getElementById("myImg").setAttribute("message", "hello"); /* 如果不存在, 则会创建一个对应的属性到 */
document.getElementById("myImg").removeAttribute("message");   /* 删除属性 */
```

需要注意的是, 对于结构体会导致覆盖, 因此一般有时不采用 SetAttribute 方式。

```js
element.setAttribute("style", "background-color:red;");    /* 导致覆盖其他元素属性 */
element.style.backgroundColor = "red";
```

## 四、Windows 对象
### (1) Windows 对象简介
浏览器中, 每个窗口都有一个 window 对象([Window Object](https://www.w3schools.com/jsref/obj_window.asp)) 

| closed   | Returns a boolean true if a window is closed.(检测当前window是否已经被close)      |
| -------- | ------------------------------------------------------------------------ |
| console  | Returns the Console Object for the window.                               |
| document | Returns the Document object for the window.See also The Document Object. |
常用的有  frames (所有对象的数组), history, navigator, [opener](https://www.w3schools.com/jsref/prop_win_opener.asp) (返回打开此窗口的窗口对象), status (消息可以显示在状态栏中-> 注意**一般浏览器默认不显示被 js 修改的状态栏，因此这个一般不使用**), name, length(窗口中的框架数目), innerHeight, innerWidth 等等。

此外, window.location 指明了 window 的 url 属性 ,并可以通过直接修改跳转到其他页面。称为<b><mark style="background: transparent; color: orange">及时重定向(Instant Redirection)</mark></b>
[type 指定种类参考](https://www.iana.org/assignments/media-types/media-types.xhtml)
```html
<script type = "text/javascript">
	window.location =  "newpage.html"
</script>
```

将页面重新定位到该地址。对应的方法在 Window Object Methods 中, 有例如  alert 等等方法，常用的有:

| Method             | Description                                                                          |
| ------------------ | ------------------------------------------------------------------------------------ |
| addEventListener() | Attaches an event handler to the window                                              |
| alert()            | Displays an alert box with a message and an OK button                                |
| atob()             | Decodes a base-64 encoded string                                                     |
| blur()             | Removes focus from the current window                                                |
| confirm()          | Displays a dialog box with a message and an OK and a Cancel button                   |
| close()            | Closes the current window                                                            |
| focus()            | Sets focus to the current window                                                     |
| open()             | Opens a new browser window                                                           |
| resizeBy()         | Resizes the window by the specified pixels                                           |
| resizeTo()         | Resizes the window to the specified width and height                                 |
| scrollTo()         | Scrolls the document to the specified coordinates                                    |
| stop()             | Stops the window from loading                                                        |
| setTimeout()       | Calls a function or evaluates an expression after a specified number of milliseconds |

其中，对于前进和后退选项的实现, 需要用到 [history](https://www.w3schools.com/jsref/prop_win_history.asp) 的方法。主要是如下两个(参考[[📘ClassNotes/⌨️ Pre-front Programming/🍵JavaScript/3. JavaScript 语法入门和对象#(5) JS 预定义对象|3. JavaScript 语法入门]])

| back()    | Loads the previous URL (page) in the history list |
| --------- | ------------------------------------------------- |
| forward() | Loads the next URL (page) in the history list     |

opener 用于**引用打开当前窗口的窗口**,  例如 window.opener.closed 可以检测打开当前窗口的窗口是否被关闭。 

### (2) Windows 对象的弹窗方法
最多用的弹窗是
```js
window.alert();
window.prompt();    // 输入信息 
window.confirm();   /* 确认和取消 */
window.find();         /* 查找浏览页面的特定文本 */
window.home();      /* 重定向到主页  */
window.print();  // 打印 当前页
```


### (3) 固定时间间隔执行函数
1. 为了以一定的时间间隔执行, 往往采用 <b><mark style="background: transparent; color: orange">setInteval() 和 clearInterval() 方法</mark></b>进行相应的设置;
2. <b><mark style="background: transparent; color: orange">setTimeout() 方法和 clearTimeout() 方法</mark></b>, 用于延迟执行某段代码和清除任务, 

**语法**：`setInterval(callback, delay, ...args)` 其中 ...args 是传递给 
```js
var fun = setInterval(function(param1){
		console.log(param1);
	},10000,10);   // 单位为 ms 
clearInterval(fun);
```

一般可以采用 let 自定义定时器, 实现延迟一定时间的事件处理。
```js
setTimeout(callback, delay, params);    // 创建延迟执行的定时器 
// 延迟 2 秒后输出 "Hello after 2 seconds!"
const timeoutID = setTimeout(() => {
  console.log("Hello after 2 seconds!");
}, 2000);
clearTimeout(timeoutID);

let delayFun; // 全局变量用于保存定时器 ID

box1.addEventListener("mouseenter", () => {
  // 设置一个延时任务，在 10 秒后显示 label1
  delayFun = setTimeout(() => {
    label1.visibility = true;
  }, 10000);
});

box1.addEventListener("mouseleave", () => {
  // 鼠标移开时，清除延时任务
  clearTimeout(delayFun);
});
```

### (4) 主窗口和新窗口的采用
一般采用 window.open("newpage.html", "my_window", attribute1=value1, attribute2 = value2); 打开新的 url 并进行替换, 其中 target 是第二个参数; features 为第三个

需要注意的是,  不是新建一个 tab(一般采用href导航), 而是外部新建一个窗口进行设置。(实际上也是,),  也可能是到另一个 tab; 
window.close() 关闭当前窗口, 
window.moveBy() 移动窗口；
window.moveTo() 
window.focus()
window.scrollTo()
window.scrollBy()
window.resizeBy()
window.resizeTo()

```js
mywin = window.open("newpage.html", "cool", "width=400, height=300");
mywin.moveBy(300,300);
var myWindow = window.open("", "MsgWindow", "width=200,height=100");
myWindow.document.write("<p>This is 'MsgWindow'. I am 200px wide and 100px tall!</p>");
win = window.open("https://www.w3schools.com", "_blank", "toolbar=yes,scrollbars=yes,resizable=yes,top=500,left=500,width=400,height=400");
win.focus();
```

编码和解码
```js
let text = "Hello World!";  
let encoded = window.btoa(text);  
let decoded = window.atob(encoded);
```

## 五、其他对象补充 
[Math](https://www.w3schools.com/js/js_math.asp)  对象: 提供各种数学函数, (包括 Math.PI, Math.E等等)
例如 random 方法返回 0-1 之间的随机整数(均匀分布)

一般地, 可以通过 Box-Muller 变换获取正态分布:
```js
function randomNormal(mean = 0, stdDev = 1) {
    let u = 1 - Math.random(); // 转换到 (0, 1] 区间
    let v = 1 - Math.random();
    let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return z * stdDev + mean; // 调整为指定的均值和标准差
}
```
一般有 js 可以生成泊松和指数分布的抽样函数, 此处略去; 
此外, 可以利用现成的库进行生成相关的随机数:
```js
npm install random
const random = require('random');
```

trunc();
sign();


[Number]() 对象: 参考[[📘ClassNotes/⌨️ Pre-front Programming/🍵JavaScript/3. JavaScript 语法入门和对象#2. 函数数据类型|3. JavaScript 数据类型]] 
一般可以通过 toExponential(), toFixed(), toPrecision(), toSource()

Number.EPSILON 最小值，最小精度
isFinite();
isNaN();
parseInt();
parseFloat();
isInteger();


| toExponential(x) | Converts a number into an exponential notation (string)                  |
| ---------------- | ------------------------------------------------------------------------ |
| toFixed(x)       | Formats a number with x numbers of digits after the decimal point (进行舍入) |
| toLocaleString() | Converts a number into a string, based on the locale settings            |
| toPrecision(x)   | Formats a number to x length (有效数)                                       |
| toString()       | Converts a number to a string                                            |

转换为不同的形式. 其中如果转换不到, 则转换为指数形式 
```js
Number(100000).toPrecision(2)
'1.0e+5'
```

Date 对象构造时, 可以指定一个不同的日期, 具体参考[[📘ClassNotes/⌨️ Pre-front Programming/🍵JavaScript/3. JavaScript 语法入门和对象#(3) 其他常用对象|3. JavaScript 语法入门]] 
```js
 instance = new Date()
Thu Oct 31 2024 17:26:53 GMT+0800 (China Standard Time)
```

例如: Date.parse("Dec 12, 1999"), toString(), toGMTString() 等等

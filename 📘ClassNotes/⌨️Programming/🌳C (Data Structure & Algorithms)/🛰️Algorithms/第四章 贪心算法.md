---
~
---
## 一、贪心算法简介
### (1) 贪心算法的概念和使用条件 
首先， 对于具有最优子结构的问题， 除了使用动态规划方法以外， 还可以使用更加简单的贪心算法来解决问题。
例如， 对于在找纸币时， **往往可以使用先从大的再从面值小的去找**，例如当纸币的面值为20, 5, 1时, 显然可以使用20 + 2 * 5 + 1 凑出31这个数, 且所用到的纸币数量是最少的。 

但是需要注意的是，贪心算法不一定能总是得到最优解， 例如对于11元，5元和1元纸币， 有15 = 11 + 4 * 1 可以使用 15 = 3 * 5 来进行更优化。
贪心算法**同样具有最优的子结构性质**， 而相比于动态规划算法， 贪心算法更加直接且效率更高。

贪心算法的**基本方法是先不从整体的最优化考虑， 而仅考虑某种意义上的局部最优化选择; 而利用问题的特殊性, 所获取的结果也是整体上的最优化结果**。另外我们也可以使用贪心算法对解进行极好的近似。

> [!CAUTION] 说明
> 贪心算法往往在单源最短路径， 最小生成树问题上具有良好的性质， 可以产生整体的最优解(参考[[📘ClassNotes/⌨️Programming/🌳C (Data Structure & Algorithms)/〽️ Data Structure/第七章 图#五、图的两大算法|图的两大算法]])

### (2) 贪心算法的基本要素与性质
#### 1. 贪心选择性质
我们考虑使用贪心算法的一般特征 : 
1. 每次做的决策都是**仅在当前状态下的局部最选择**。**当前所做的选择仅依赖于过去的选择， 但绝不依赖于将来的选择**。
2. 对于**贪心选择的结果最优性证明**, 需要证明每一步的贪心选择，都将得到问题整体的最优结果， 而贪心算法以迭代方式向下进行选择。 
3. 贪心算法以及相应的证明**依赖于结构的最优子结构性质**, 即<mark style="background: transparent; color: red">经过一个贪心选择之后，剩余的结果仍然是最优的。</mark> 即$A' = A - \{ 1\}$仍然是关于 $E' = \left\{i \in  E: s\geq f_{i} \right\}$的最优解 (见下)


> [!NOTE] 贪心算法的常见解决方案
> 最常见的解决方案是按照某种规则进行排序。然后从前向后遍历选用相应符合可选择的部分。

## 二、相关问题 
### (1) 活动安排问题 
对于高效安排一系列占用某一公共资源的活动。设有n个活动的集合为$E = \left\{ 1, 2 , \dots , n \right\}$, 其中每个活动要求占用同一公共资源， 而每一个活动都给出了对应的起始时间$s_i$和终止时间$f_i$, 显然, 当$[s_i, f_i )\cap [s_{j}, f_{j}) = \emptyset$时, 则两个活动是相容的。 
要求**在所给活动的集合中选出最大的相容活动的子集和**。 

![[Excalidraw/第四章 贪心算法 2024-02-10 09.53.09]]
以上面的活动示意为例,  对于活动列表中的所有 活动， 显然我们安排开始时间靠前的， 不可能得到最优的解； 因此我们考虑如何选择能得到较好的活动安排: 

我们容易想到， **如果当前所选择的活动能够尽早结束**, 则有利于我们为选择下一次活动留出更早的开始时间。 因此我们可以**对活动按照结束时间进行排序**。<u>获得一个活动结束时间的升序排列</u>， 在此排列中， 可以**按照贪心算法， 依次选择结束早的活动，且选择时只需考虑能够和已选部分相容即可**。 

对上述问题贪心算法的最优性质证明:
首先, 由于**排序是按照结束时间进行升序排列**的，因此事件1具有最早的结束时间。我们需要证明,  **最优解以一个贪心选择开始**。 我们**设最优解序列$A$的一个活动是活动**$k$, 则只需证明$k=1$, 则$A$是以该贪心选择所开始的最优解。 

我们首先假设 $k > 1$, 此时, 有$B = A - \{ k\} \cup 1$, 则所剩下的部分中，能够与$k$事件相容的事件(设为$l$)必定满足$s_l \geq f_{k}$, 而选取事件1时, 由于$f_1 \leq f_k$, 因而能够相容事件$k$的序列也必然能够相容事件1, 即以1开始的也是最优解。 这样就完成了性质证明。 

核心代码如下:
```cpp
std::sort(itemlist.begin(), itemlist.end()); // 按照结束时间进行升序排序
for (int i = 0, _time_ = 0; i < itemlist.size(); i++) {
	if (itemlist[i].start >= _time_) {
		res.push_back(itemlist[i]); 
		_time_ = itemlist[i].end;
	}
}
```

整个程序如下:
(其中C++支持构造友元函数，并按照其比较结束时间的大小)
```cpp fold
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef struct ItemTodo {
    int start;
    int end;
    char id;
    ItemTodo(int start, int end, int id) :start(start), end(end), id(id) {};
    friend bool operator< (const ItemTodo A,const ItemTodo B) {
        return A.end < B.end;
    };
}Item;

int main()
{
    vector<Item> itemlist;
    vector<int> start{0, 8, 1, 3, 5, 10};
    vector<int> end{ 6, 11, 3, 5, 9, 13 };
    vector<char> ids{ 'A','B','C','D','E','F'};
    for (int i = 0; i < start.size(); i++) {
        itemlist.push_back(Item(start[i], end[i], ids[i]));
    }
    std::sort(itemlist.begin(), itemlist.end()); // 按照结束时间进行升序排序
    vector<Item> res;
    for (int i = 0, _time_ = 0; i < itemlist.size(); i++) {
        if (itemlist[i].start >= _time_) {
            res.push_back(itemlist[i]); 
            _time_ = itemlist[i].end;
        }
    }
    for (int i = 0; i < res.size(); i++) {
        cout << res[i].id << " ";
    }
    return 0;
}
```

### (2) 最优装载问题 
对于一批集装箱， 要装上一艘载重为c的轮串, 其中, 集装箱$i$的重量为$w_i$, 而最优装载问题确定在装载体积已经确定的情况下，尽可能多地将集装箱装上船; 
显然应当将集装箱从重量小大重量大进行排序, 然后依次装入即可。其最优子结构和性质也非常容易证明。

### (3) 哈夫曼编码问题
首先哈夫曼编码是<mark style="background: transparent; color: red">按照前缀码进行编码的</mark>， 即从编码文件中不断地取出编码字符的前缀。然后进行译码。保证<mark style="background: transparent; color: red">带权路径长度最小</mark>的算法。
其<b><mark style="background: transparent; color: blue">基本的合并方法是先将节点按照权值进行排序</mark></b>(参考[[📘ClassNotes/⌨️Programming/🌳C (Data Structure & Algorithms)/〽️ Data Structure/第六章 树和二叉树#七、哈夫曼树和哈夫曼编码|哈夫曼树和哈夫曼编码]]部分)然后**按照贪心算法， 每一次将两个权值最小的树节点进行合并**， 最终得到最优解。
![[Excalidraw/第六章 树和二叉树 2023-04-25 11.31.07|550]]
哈夫曼编码的最优性证明需要证明**贪心选择性质和最优子结构性质**。
1. 贪心选择性质: 每一步做出贪心选择时得到的是最优解 
最优解可以通过证明在深度相同情况下,交换两个叶子节点不增加深度进行说明: <mark style="background: transparent; color: red">如果在树中交换任意两个叶子节点位置，则平均搜索长度均不小于原先的搜索长度。</mark> 即设我们需要编码的字符集为 $C$ , 其中$c$ 出现的频率为$f(c)$, 只需要证明:
$$\sum_{c \in  C} f(c) d_{T} (c)- \sum_{c \in  C} f(c) d_{T}(c) = f(b) d_{T}(a) + f(a) d_{T}(b) - f(b) d_{T}(b)  - f(a) d_{T}(a)\geq  0$$
显然, 在哈夫曼树中, 由于权值小的总是最先合并的, 因此不存在$f(a)> f(b), d(a) < d(b)$的情况。不失一般性可以假设 $f(a) \geq f(b), d_{T}(a) \leq d_{T} (b)$ 

则上式等于:
$$(f_{a} - f_{b})d_{T}(b) - (f_{a}- f_{b}) d_{T}(a) = (f_{a}- f_{b}) (d_{T}(b) - d_{T}(a) ) \geq  0$$
这显然是不减少原先搜索长度的。

2. 最优子结构性质
做出贪心选择时, 子结构是最优的:
设 T 是表示字符集 C 的最优前缀编码的二叉树。其中字符c的出现频率为 f(c). 其中设 x,y 是树T 中的两个兄弟叶子结点, 其父节点为 $z$, 则**若将 z 看做是具有 $f(z) = f(x) + f(y)$ 的字符, 则树 $T' = T- \{x,y\}$ 表示字符集$C' = C - \{x,y\} \bigcup\{ z\}$ 的最优前缀码**。

首先, 对于树 $T$ 的码长 $B(T)$ 和 $T'$ 码长 $B(T')$ 关系, 容易得到:
$$B(T) = B(T') + f(x) + f(y)$$
此时, 若 $T'$ 表示的字符集 $C$ 的前缀, 如果此时$T'$不是最优的, 即 T'' 表示前缀码使得$B(T'')< B(T')$, 则可以加入 x,y 到 T'' 中, 并有这个树最优 $B(T'') + f(x) + f(y)  =  B(T)$ 
因此这与 $T$ 的最优性质相矛盾。因此子结构必定是最优的。

### (4) 图的最小生成树和最短路径问题
参考[[📘ClassNotes/⌨️Programming/🌳C (Data Structure & Algorithms)/〽️ Data Structure/第七章 图#1. Dijkstra 算法|第七章 图]]部分,  最常见的贪心算法包括 Dijkstra 算法和 Floyd 算法。而最小生成树包括 Prim 算法和 Kruskal 算法。

Dijkstra 算法即每一次更新节点, 并加入节点更新之后, 其余节点路径中最小的节点(没有路时, 是一个大数), 停止条件是所有节点都加入。

```cpp title:dijkstra 算法示例
#include <iostream>
const int num = 5;
int dist[num] = {0, 0, 0, 0, 0};
int travel[num] = { 0, 0, 0, 0, 0 };
void dijkstra(int graph[num][num], int n, int start) {
    travel[start] = 1;
    int min_dist, min_node_start,min_node_end;
    for (int k = 0; k < n-1; k++) {
        min_dist = 10000;
        min_node_start = 0;
        min_node_end = 0;
        for (int i = 0; i < n; i++) {
            if (!travel[i]) continue;
            for (int j = 0; j < n; j++) {
                if (j == i) continue;
                if (!travel[j] && graph[i][j] < min_dist) {
                    min_dist = graph[i][j];
                    min_node_start = i;
                    min_node_end = j;
                }
            }
        }
        dist[min_node_end] = dist[min_node_start] + graph[min_node_start][min_node_end];
        travel[min_node_end] = 1;
    }
}

int main()
{   
    int graph[num][num] = {
    {10000, 10, 10000, 30, 100},
    {10, 10000, 50, 10000, 10000},
    {10000, 50, 10000, 20, 10},
    {30, 10000, 20, 10000, 60},
    {100, 10000, 10, 60, 10000}
    };
    int start = 0;
    dijkstra(graph, num, start);
    for (int i = 0; i < num; i++) {
        std::cout << dist[i] << " ";
    }
}
```

Dijkstra 算法的正确性证明:
1. 贪心选择性质
由于 Dijkstra 算法做出的贪心选择是: 首先设置顶点集合S, 然后不断扩充这个集合， 即每次从 V-S 中选择具有最短特殊路径的顶点 $u$ 添加到集合中, 首先, <mark style="background: transparent; color: red">假设存在一条从源s到u更短的路径, 则显然这条路径需要经过此外的一点</mark>$x\in V-S$, 可能多次徘徊于S,x最后离开x到达$u$. 
![[Excalidraw/第四章 贪心算法 2024-09-17 10.39.06|200]]
此时, 设$s->u$的最短路径为 $dist[u]$, 
$$d(v,x) + d(x,u) = d(v,x) < dist[u]$$
设有另外一顶点为 $v$, 显然在路径上有$dist[x]\leq d(v,x)$. 则可以构造从$s->x->u$ 的最短路径为:
$$d(v,x) + d(x,u) = d(v,u) \leq dist[x] + d(x,y) < dist[u]$$
显然这和 `dist[x] > dist[u]` 矛盾, 则 $dist[u]$ 显然是从原点到 u 的最短长度。

2. 最优子结构性质
只需要考察添加 u 到 S 中之后, $dist[i]$ 起的变化。即在添加 $u$ 之后, S 的结构也是最优的。
添加 $u$ 之前的 $S$ 称为老的 $S$. 添加 $u$ 后可能对于新的顶点 $i$, 出现一条路径, $u->i$, 则会以 $min(dist[u] + a[u][i],dist[i])$ 为新的路径长度，显然 不论 $dist[u]$ 的值是否有变化, 它都是关于顶点集 S 到顶点 u 的最短特殊路径长度。而不会影响 $i$ 的最优子结构选择。即加入 $dist[u]$ 之后子结构仍然是最优的。

## 三、贪心算法的理论基础
### (1)拟阵理论
#### 1. 拟阵的定义
通过拟阵可以建立贪心算法的一般性理论, 并且对于确定何时采用贪心算法有很大帮助:
首先,**定义拟阵为满足以下3个条件的有序对(E, I)**:
1. E 为非空有限集
2. $I$ 是 $E$ 的<mark style="background: transparent; color: red">具有遗传性质(hereditary property)的独立子集族</mark>, 若 $B \in I$, 则 $B$ 是 $E$ 的独立子集,  同时, $B$ 的任意子集也是 $E$ 的独立子集，且 $\emptyset$ 必须为 I 的成员。 即 ($B'\subseteq B \subseteq E$, if $B\subseteq I$, then $B' \subseteq I$)
3. I 满足<mark style="background: transparent; color: red">独立子集交换性质,</mark> 设$A,B$是两个独立集合, 若有$|A| < |B|$即$A$的元素少于$B$的元素，且有$A \in I, B \in I$ , 则存在元素 $x$ 满足 $x \in B-A$, 使得 $A \bigcup \{ x\} \in I$. 
概念可以参考 [Wiki-Matroid](https://en.wikipedia.org/wiki/Matroid) 和 [Basis_of_a_matroid](https://en.wikipedia.org/wiki/Basis_of_a_matroid)

其中 1, 2 即至少一个 E 的子集是独立的, 也就是说, $I\neq \emptyset$. 
给定 S 是矩阵中行向量的集合， I为S的线性独立子集族, 则显然有 $(S,I)$ 是一拟阵. 

#### 补充:无向图森林拟阵及其证明
第二, 无向图 $G = (V,E)$ 的图拟阵 $M_G = (S_{G}, I_G)$. 其中 $S_{G}$ 定义为图 G 的边集E, 而$I_G$定义为$S_G$的无循环边集族。此时, $A\in I_G$ 当且仅当它构成图 G 的森林。显然, $M_{G}= \{S_{G}, I_{G } \}$ 是拟阵。证明如下:
1. 继承性
$S_{G}$ 是有限集, 森林的任意子集仍然是森林。即具有继承性质(参考[[📘ClassNotes/⌨️Programming/🌳C (Data Structure & Algorithms)/〽️ Data Structure/第六章 树和二叉树#五、树和森林的表示|树和森林]])
2. 交换性
设<mark style="background: transparent; color: red">对于任意一个无向图</mark> $G$, 其子集的某个森林的顶点数为 $V$，森林总共有$k$条边, 由于顶点个数为$v_{0}$的树边数为$v_0 - 1$, 显然该森林恰由$|V|-k$ 棵树组成, 即一个森林中:
$$树数量 = 总顶点数  - 总边数$$
此时, $A,B$ 是图 $G$ 的两个森林, 且边数 $|A| < |B|$, 即 A,B 均为无循环边集, 且 B 中边数多于 A. 显然由于图 $G$ 顶点是一定的, 则有 森林 B 的树数量 < 森林 A 的树数量。 此时 B 中必然存在一颗树 $T$, 其顶点(设为u,v)在 A 的不同两棵树中。此时, 由于 T 是连通的, **因此存在边$(u,v) \in B - A$ 加入 A 中不会产生循环，即 $A \bigcup \{ u, v\} \in  I$ 仍然成立**，因此 $I_G$ 满足交换性质。

#### 2. 拟阵的性质
<b><mark style="background: transparent; color: blue">可扩展元素</mark></b> : 给定拟阵 $M = (S, I)$, 对于 $I$ 中的独立子集 $A \in I$, 如果S有一元素 $x\notin A$, 使得, x 加入 A 之后, 仍然保持独立性, 即有 $A  \bigcup \{x\} \in  I$, 则称 $x$ 为 $A$ 的<mark style="background: transparent; color: red">可扩展元素</mark> (图论中, 可扩展元素是指边$e$不在A中且加入A之后不会产生循环)

<b><mark style="background: transparent; color: blue">极大独立子集</mark></b>: 当拟阵 M 独立子集 A 没有可扩展元素时, 称为<mark style="background: transparent; color: red">极大独立子集</mark>

$|B| > |A|$ 



## 四、实际应用
### 1. 多机调度问题
多机调度问题属于 NP 完全问题。参考[NP 完全问题](https://blog.csdn.net/leowinbow/article/details/88187386), 并且不能采用分治法就爱那个问题进行分解为多种情况。
Non-deterministic  Polynomial 多项式复杂程度的非确定性问题。 例如在旅行商问题情况下, 涉及 n 个城市时, 可能路径为 n! 条。集合覆盖部分(每一次可以以符合当前未选的部分要求最多的进行贪心算法)

多机调度问题: 设有 n 个独立的作业, 由 m 台相同的机器进行加工, 每个作业可以在任何一台机器上加工。且作业 i 处理时间为 $t_i$. **给出一种调度方案, 使所给的作业能在尽可能短时间内完成**。

如果采用**贪心算法, 有时能够得到很好的近似解**。
贪心算法的思路是, 以时间为基准, 从大到小将任务排序并分配给当前时间空闲的机器。
```cpp
int t[n] = { 10, 5, 3, 4, 8, 7, 6, 4, 2, 2 };
```
则分配方法为:
![[Excalidraw/第四章 贪心算法 2024-09-17 12.30.50|600]]
其中最短情况是排满可以获取17min的最短加工时间。此时贪心算法获取到了很好的解答。
代码示例如下所示, 其中按照 time 增加定义 < 号并排序:

```cpp fold title:贪心算法的多机调度问题
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef struct work{
    int id;
    int time;
    friend bool operator < (const work A, const work B) {
        return A.time > B.time;   // place the grater at top 
    }
}work;

void multi_dispatch(vector<work> works, int machine_num, vector<work> machine_works[]) {
    vector<work> works_cp = works;  // copy the works vector 
    std::sort(works_cp.begin(), works_cp.end());
    vector<int> time_vec(machine_num, 0);
    
    for (int t = 0; works_cp.size() > 0; t++) {
        for (int j = 0; j < machine_num; j++) {
            if (time_vec[j] <= t) {
                /* when machine is in idle */
                machine_works[j].push_back(works_cp[0]);
                time_vec[j] += works_cp[0].time;
                works_cp.erase(works_cp.begin());
                /* after allocating the work, still search for other allocatable location */
            }
            if (works_cp.size() == 0) break;
        }
    }
}

/* n tasks, and m machines */
int main() {
    const int n = 10;
    const int m = 3;
    int t[n] = { 10, 5, 3, 4, 8, 7, 6, 4, 2, 2 };
    vector<work> works;
    vector<work> machine_works[m];

    for (int i = 0; i < n; i++) {
        work w;
        w.id = i + 1;
        w.time = t[i];
        works.push_back(w);
    }
    multi_dispatch(works, m, machine_works);
    for (int i = 0; i < m; i++) {
        cout << "machine " << i << ": ";
        for (int j = 0; j < machine_works[i].size(); j++) {
            cout << machine_works[i][j].time << " ";
        }
        cout << endl;
    }
    return 0;
}
```


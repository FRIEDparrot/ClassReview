## 一、动态规划及其基本概念
### (1) 基本概念
动态规划算法的基本思想是将待求解的问题**划分为多个子问题, 并从子问题获取初始问题的解**。虽然与二分方法类似, 但是**对于动态规划所求解的问题, 分解获取到的子问题往往不是独立的**, 而其基本思想是先分配一个记录表并将计算获取的基本问题结果填入表中, 当再次出现时直接获取。

往往动态规划的算法用于求最优化问题的基本步骤如下: 
1. 寻找最优解的性质, 并刻画其结构特征 
2. 递归地定义最优值 
3. 按照自底向上的方式求解出最优值  
4. 根据计算最优值时得到 的信息，构造最优解。

### (2) 动态规划方法的两大基本要素
动态规划算法的有效性依赖于: 
1. <mark style="background: transparent; color: red">最优子结构</mark> :  对于最优化的问题, 其子结构也是最优的, 这种性质称为最优子结构性质。 而具有此种性质的算法往往可以使用动态规划进行解决
2. <mark style="background: transparent; color: red">重叠子问题</mark> : 在递归调用和自顶向下求解问题时， 每次产生的子问题一般不是新问题。 往往在问题解决过程中， 需要重复调用子问题的结果，而子问题仅解决一次即可。

另外对于是否为最优子结构的证明， 可以假设子问题不是最优的, 并推出矛盾。 

### (3) 备忘录方法
备忘录方法是动态规划算法的变形之一, 也是使用表格保存已经解决子问题的答案, 而下次需要求解时只需获取解答即可， 而备忘录方法和动态规划的**递归方式区别**是,  **动态规划是自底向上进行递归的, 即先解决子问题，再大问题调用子问题; 而备忘录方法的递归方式是自顶向下递归的, 即存储时存储特殊值表示子问题是否是第一次遇到,  如果是第一次遇到则进行计算, 否则取出已经计算好的值**。<mark style="background: transparent; color: red">备忘录方法适用于重复子问题较多且不一定所有都要求解的情况</mark>。 **而当一个问题的所有子问题都至少需要解决一次时, 动态规划一般优于备忘录方法**。

例如下面的矩阵问题中， 也可以使用一个二维数组存储子问题是否计算过; 然后自顶向下递归调用。

## 二、相关问题
### (1) 矩阵连乘最优次序问题
对于两个矩阵相乘， 假设其是$p \times q$矩阵和$q\times r$ 矩阵, 显然需要做的运算个数是$p \times q \times  r$, 且获得的矩阵规模是$(p \times  r)$, 而对于不同矩阵的连乘, 例如有第三个矩阵为 $r \times  s$ 矩阵, 则需要做的运算方式为:
$$(A_{1} A_{2}) A_{3} = (p \times  q \times  r ) + (p \times  r \times  s) = pr (q  + s)$$
而如果使用 $A_1(A_2 A_3)$, 则运算次数为: 
$$A_1(A_2 A_{3})= (p \times q \times  s) +  (q \times  r \times  s ) + qs(p + r)$$
显然**运算次数是不相同的**,  即在矩阵连乘中的加括号方式可能会极大地影响运算次数。

我们考虑**对于$n$个矩阵进行连乘的优化问题**, 显然如果用穷举法, 则可以视为每2个都要多递归划分一次括号, 复杂度呈指数增长,  显然不是优化的算法。

对于划分矩阵连乘的最优解, <b><mark style="background: transparent; color: red">关键特征是对于整体的最优化问题, 局部也是最优化的， 则这样的问题可以使用动态规划思路进行求解</mark></b>,  即<b><mark style="background: transparent; color: blue">具有最优子结构性质</mark></b>。 即对于一个最优的矩阵连乘划分, <mark style="background: transparent; color: blue">其括号内部的部分也是最优括号划分</mark>。 

我们考虑利用如下的算法解决问题:  以$A_{1}A_{2}A_{3}A_{4}$相乘为例, 其中$A_1 - A_4$的规模分别为 
$$15 \times  5\qquad 5\times 10\qquad  10\times 20 \qquad 20 \times  25$$
首先分解子问题, 计算**每相邻的两个矩阵乘积的最小值**(即子问题)并写在第一行。
则如果一次仅考虑加入一个组合, 则可以列出如下表格(我们可以记为矩阵$A$): 

| 列 | 1 | 2 | 3 |
| ---- | ---- | ---- | ---- |
| 1 | $15 \times  5 \times  10$ (1,2组合) | $5\times 10\times 20$ (2, 3组合) | $10\times20\times 25$ (3,4组合) |
| 2 |  | $\min [(1,1) + 15 \times 10 \times  20,  (1,2) + 15 \times 5 \times  20)$ (1-3组合) | $\min [(1,2) + 5 \times 20 \times 25 ,  (1, 3) + 5 \times  10 \times  25]$ (2-4组合) |
| 3 |  |  | var (1- 4组合)  |
需要说明, <mark style="background: transparent; color: red">这个计算方法仅适用于前两行</mark>， 由于对于第三行时, 就遇到**两个大部分组合的问题**， 例如
$(A_1A_2)(A_3A_4)$ 既不是左乘的情况也不是右乘的情况， (上述只列出了((AB)C)D和(A(BC))D, 仅是左乘或者右乘的情况) ， 此时我们需要考虑两两组合相乘的情况: 

为了将后面的两个组合情况考虑进去 , **由于两个组合的结果已经计算出来**, 可以直接调用，**但是此时需要注意的是**, <mark style="background: transparent; color: red">除了两个部分的各自运算量， 也要加上相互的运算量</mark>, 即除了$A_1A_2$和$A_{3},A_{4}$取出, 还需要加上 $r(A_{1}) \times c(A_{2}) \times c(A_{4})$。
$$\text{var} = \min \begin{cases}
(2, 2) + 15 \times 20 \times25  \\
 (2,3) + 15 \times 5 \times  25   \\
 (1, 1) + (1, 3) + r(A_{1}) \times c(A_{2}) \times c(A_{4})
\end{cases}$$
括号内每一个元素对应(其中三括号内已经最小)
$$ (A_{1} A_{2} A_{3}) A_{4}, \quad   A_{1}(A_{2}A_{3} A_{4}) \quad  (A_{1} A_{2})(A_{3} A_{4})$$

需要说明的是, 由于每一次总是任意的划分为**两部分(仅两部分)**, 所以曾经求出的任何分解的两部分也可能成为最小, 即对于$A_1 - A_5$, 也可以是下列两种拆分方法, 
$$(A_{1}A_{2} A_{3})(A_{4} A_{5})  \qquad  (A_{1} A_{2}) (A_{3} A_{4}A_{5})$$
这个拆分的取法对应如下图的斜对角线分布, 且从第3行开始时, 会出现此种拆分方式。
![[Excalidraw/第三章 动态规划算法 2024-01-30 15.53.13|550]]
上述表格所获得的最后一格(3,3)即为最小需要的计算次数, 此时, 按照此种方法进行计算即可。

程序中另外一个难点就是如何将划分的间隔进行记录的方法。
- 在记录时，同样定义一个二维向量(即矩阵), 由于在上述的二维矩阵下每一格中,  仅是两种拆分方式的区别,  此时在每一种拆分方式下,  **记录这一种方式的拆分相对位置**即可。
- 在输出时，使用递归的思想,  首先找到右下角的拆分相对位置, 增加一个静态变量记录每个位置的符号数量， 并递归调用函数确定每个位置符号数即可
我们将符号相对位置记录如下: 
$$\sim A_{1}\sim A_{2}\sim A_{3}\sim$$
其中第一个$\sim$ 位置为0(也就是默认没有括号), 后面的分别记为1, 2, 3... 等，此时， 所有组合的括号划分也形成另一个矩阵$B$。
在下面的程序中, 输入为两行已经定义好的向量, (提供了两组测试数据) 

```cpp fold title:main.cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> Matrix;
/// <param name="rowVec">row Vecotr</param>
/// <param name="colVec">column Vector</param>
/// <param name="signal">n-1 x -1 向量, 返回符号位置</param>
/// <returns>最小运算次数 </returns>
int BestMatrixChain(vector<int> rowVec, vector<int> colVec, vector<vector<int>> &signal) {
    if (rowVec.size() == 1 || rowVec.size()!= colVec.size()) return 0;

    int n = rowVec.size() - 1;
    for (int i = 0; i < n; i++) {
        // 构造 n-1 x n-1的矩阵
        Matrix.push_back(vector<int>(n, 0));
    }
    // 首先初始化第一行
    for (int i = 0; i < n ; i++) { 
        Matrix[0][i] = rowVec[i] * rowVec[i + 1] * colVec[i + 1]; // 获取两两相乘
        signal[0][i] = 0;  // 结果是 AB, 不加括号
    }
    for (int i = 1; i < n ; i++) {
        for (int j = i; j < n; j++) {
            // 注意: 从第1行开始对应的列应该是第2列, 则使用j + 1表示, 而另外一个是
            // rowVec[j - i] 为前面最开始部分的索引， 这个需要进行注意;
            int res = Matrix[i - 1][j] + rowVec[j - i] * colVec[j - i] * colVec[j + 1]; // 1 x (2 x 3) 方式 
            signal[i][j] = 1; // 初始插板位置为1
            
            // 斜组合拆分方式, 最坏不超过 O(n^3) 的复杂度。
            for (int k = 0;  k  <= i - 2; k++) {
                int res1 = Matrix[k][j-i+k] + Matrix[i-2-k][j] + rowVec[j-i] * colVec[j - i + k + 1] * colVec[j + 1];
                // 注意需要加上两个相乘的运算量
                if (res1 < res) {
                    res = res1;
                    signal[i][j] = k + 2;
                }
            }
            int res1 = Matrix[i - 1][j - 1] + rowVec[j - i] * rowVec[j + 1] * colVec[j + 1]; // (1 x 2) x3方式
            if (res1 < res) {
                res = res1;  signal[i][j] = j + 1 - (j-i);
            }
            Matrix[i][j] = res;
        }
    }
    return Matrix[n-1][n-1];
}

// 利用递归的方法输出结果, left 是左边下标(从A0开始), 而right为右边下标
void Output(vector<vector<int>> &signal, bool output, int left, int right) {
    if (left == right) return;
    int n = signal.size();
    // 静态变量, 不会随函数释放而重置
    static vector<int> left_bracket(signal.size() + 2, 0);  
    static vector<int> right_bracket(signal.size() + 2, 0);

    int parti = signal[right - left -1][right -1]; // partition location
    
    if (parti!= 0){ // =0时不分割
        if (parti != 1) { left_bracket[left]++; right_bracket[left + parti]++; }
        if (parti != right - left) { left_bracket[left + parti]++; right_bracket[right + 1]++; }

        Output(signal, false, left, left + parti - 1);  // 其中, parti是1时，输出区间仅有一个数,不加括号
        Output(signal, false, left + parti, right);
    }


    // 输出函数
    if (output) {
        for (int i = 0; i < n + 2; i++) {
            for (; right_bracket[i] > 0; right_bracket[i]--) cout << ")";
            for (; left_bracket[i] > 0; left_bracket[i]--) cout << "(";
            if (i <= n )cout << "A" << i;
        }
        cout << endl << endl;
    }
}

void Output2(vector<vector<int>> &signal) {
    int n = signal.size();
    // 输出构建的两个矩阵
    cout << "======= Matrix Output: ============" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << Matrix[i][j] << "\t";
        }
        cout << endl;
    }
    // 输出符号矩阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << signal[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // 注意一定要输入合法, 此处略去合法性检查
    vector<int> rowVec{ 30, 35, 15, 5, 10 , 20 };
    vector<int> colVec{ 35, 15, 5, 10, 20 , 25 };
    // 也可以用下面的一组做测试, 结果为7500
    // vector<int> rowVec{ 10 , 100, 5 };
    // vector<int> colVec{ 100, 5, 50 };

    vector<vector<int>> signal;
    for (int i = 0; i < rowVec.size() - 1; i++) {
        signal.push_back(vector<int>(rowVec.size() - 1, 0));
    }
    int best_time = BestMatrixChain(rowVec, colVec, signal);
    cout << "miniest calculate time: " << best_time << endl;
    
    Output(signal, true, 0, rowVec.size() - 1);
    Output2(signal);
    return 0;
} 
```

例如对于下面的一组测试数据: 

|  | A0 | A1 | A2 | A3 | A4 | A5 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| row | 35 | 35 | 15 | 5 | 10 | 20 |
| col | 35 | 15 | 5 | 10 | 20 | 25 |
所得结果如下: (下面的Matrix  Output 是输出矩阵$A$和$B$) 
![[attachments/Pasted image 20240130191225.png|400]]

### (2) 最长公共子序列(LCS)问题
我们设有一个序列$X = \{x_1, x_2, \dots x_n \}$,  此时**存在一个严格递增的下标序列**(<b><mark style="background: transparent; color: blue">需要注意可以不连续</mark></b>)$i_{1}, i_{2}, \dots i_{n}$, 对应的序列 $\left\{x_{i1}, x_{i2}, \dots x_{in} \right\}$ 称为序列$X$ 的子序列。

另外， 有另一个序列 $Z = \{ z_{1}, z_{2} , \dots z_{n}\}$,  取其一同等长度的子序列$\left\{ j_{1}, j_{2}, \dots j_{n} \right\}$, 此时如果有:
$$\left\{x_{i1}, x_{i2}, \dots x_{in} \right\} = \left\{z_{j1}, z_{j2}, \dots  z_{jn} \right\}$$
则称为<b><mark style="background: transparent; color: blue">公共子序列</mark></b>
例如: $X = \left\{ A, B, C, B, D, A,B\right\}, Y= \left\{ B, C, A, C \right\}$, 则其最长公共子序列为$\left\{ B, C,A \right\}$
对于最长公共子序列问题, 方法一是**将所有的序列都枚举出来**然后再使用双指针比较, 但是2个元素序列, 有$C_n^2$个; 3个序列有$C_n^3$个，实际枚举循环极其繁琐。

显然, 最长公共子序列的子结构也是公共子序列, 因此<b><mark style="background: transparent; color: blue">公共子序列问题具有最优子结构性质</mark></b>,  可用动态规划算法解决; 
同时, 由于**求解$n$个元素的子序列时， 可能需要求解n-1个元素子序列**, 即<b><mark style="background: transparent; color: blue">具有重复子问题性质</mark></b>

本问题的递归定义方式如下: 
1. **我们考虑**$X_{m}$和$Y_{n}$这两个序列, 对于$X_{n-1}$和$Y_{n-1}$; 首先: 当$X_{m} = Y_{n}$时, 显然$X_{n-1}$和$Y_{n-1}$的最长公共子序列只需要加上 $X_{n}, Y_{n}$即可成为最长子序列; 
2. 当$X_m \neq Y_n$时, **需要解决两个子问题, 即**$X_{m}$和$Y_{n-1}$的最长公共子序列; 以及$X_{m-1}$和$Y_{n}$的最长公共子序列； 由于$X_{m} \neq  Y_{n}$, 则**最长公共子序列显然在$X_{m-1}, Y_{n}$中或者在$X_{m} Y_{n-1}$中**; 此时, 取$X_{m-1}, Y_{n}$和$X_{m} Y_{n-1}$两者公共子序列其中最长的为$X_{m} Y_{n}$的最大子序列。 

因此可以得到下面的递归结构:
$$f(m, n) = \begin{cases}
f(m-1,n-1) + 1, \qquad  X(m) = Y(n) \\
\max \left(f(m,n-1), f(m-1, n)\right)  \qquad X(m) \neq Y_{n}  \\
0, \qquad  \qquad  m = 0 \text{ or } n = 0
\end{cases}$$
另外需要注意的是, 由于两个序列不是相同长度的, 显然上述递归方法已经考虑了长度不同的问题。 

核心代码极为简单, 代码如下:
```cpp title:最长公共子序列
int LCS(vector<int>& vec1, vector<int>& vec2, int m, int n) {
    if (m == 0 || n == 0) return 0;

    if (vec1[m-1] == vec2[n-1]) {
        return LCS(vec1, vec2, m-1, n-1) + 1;
    }
    return max(LCS(vec1, vec2, m - 1, n), LCS(vec1, vec2, m, n - 1));
}
```

同时考虑到输出问题, 为了输出最长公共子序列, 修改为如下代码: (向量使用 & 时可以整体赋值, 相当于copy) 
```cpp title:main.cpp
#include <iostream>
#include <vector> 
using namespace std;

// 最长公共子序列问题
/// <param name="m">初始输入为 vec1 的长度 </param>
/// <param name="n">初始输入为 vec2 的长度 </param>
/// <param name="max_vec"> 输入新向量,用于记录
int LCS(vector<int>& vec1, vector<int>& vec2, int m, int n, vector<int> &max_vec) {
    vector<int> max_vec1, max_vec2;  // 新建两个用来记录, 底层返回

    if (m == 0 || n == 0) { max_vec.clear(); return 0; }
    if (vec1[m-1] == vec2[n-1]) {
        int res = LCS(vec1, vec2, m - 1, n - 1, max_vec1) + 1;
        max_vec = max_vec1;
        max_vec.push_back(vec1[m - 1]);
        return res;
    }
    else {
        int res1 = LCS(vec1, vec2, m - 1, n, max_vec1);
        int res2 = LCS(vec1, vec2, m, n - 1, max_vec2); 
        // 注意-> 当有两个相同长度的公共子序列时,选用任意一个均可
        if (res1 >= res2) {
            max_vec = max_vec1;
            return res1;
        }
        else {
            max_vec = max_vec2;
            return res2;
        }
    }
}

int main() {
    vector<int> A = { 2, 4, 8, 5, 3, 11, 13, 18};
    vector<int> B = { 2, 5, 6, 3, 2 ,18, 20 };
    vector<int> max_vec;
    cout << LCS(A, B, A.size() , B.size(), max_vec) << endl;
    // 随便输出一个最长子序列
    for (int i = 0; i < max_vec.size(); i++) {
        cout << max_vec[i] << " ";
    }
    return 0;
}
```

### (3) 多边形的三角剖分问题
我们考虑凸多边形的最优三角剖分问题: 
首先，假设我们在平面上使用<mark style="background: transparent; color: red">多变形顶点的逆时针序列</mark>表示凸多边形。(下图是示意图， 但边是按顺时针给的) 
显然， 对于多边形$P= \left\{ v_{0}, v_{1}, v_{2}, \dots  v_{n} \right\}$, 则其任意两个不同顶点的连线$v_i v_j$构成一条弦。
![[Excalidraw/第三章 动态规划算法 2024-02-01 10.06.00|700]]
在剖分过程中， 要求
1. **各个三角形的线(弦)互不相交**， 同时集合T已经达到最大,  即 $P$ 的任一不在 $P$ 中的弦必与 $T$ 中的某个弦相交。同时,  在有n个顶点的凸多边形三角形剖分中, 恰有n-1条弦和 n-2 个三角形
2. 定义<mark style="background: transparent; color: red">最优三角形剖分性质</mark>: 定义在**多边形的边和弦组成的三角形上的权函数** $w$ , 确定凸多边形的三角形剖分， 使得<b><mark style="background: transparent; color: blue">三角形上的权值之和为最小</mark></b>。
3. 本程序中, 为了尽可能地让三角形剖分都接近正三角形， 可以定义权函数为三边长度的方差: 
$$\text{weight}_{i,j} = (v_{i}v_{j} - v_{i} v_{k})^{2} + (v_{i} v_{j} - v_{j} v_{k})^{2} + (v_{i} v_{k} - v_{j}v_{k})^{2}$$
首先, 整体的三角形最优权函数剖分问题， 局部也是最优的, <b><mark style="background: transparent; color: blue">具有最优子结构性质</mark></b> 
重复子问题: 每一次都是将多边形寻找一种方式划分为两个小的; 如果是4个顶点就继续划分为两个。因此这个问题与计算矩阵连乘的最优次序的加括号问题完全类似。即每一次合并两个部分。 

将<b><mark style="background: transparent; color: blue">上述结构总结起来可以获得如上图的二叉树结构</mark></b>。要求每一次合并两个节点, 寻求一种权值之和最小的合并方式。

在上述图形中， 我们考虑基于边和弦的合并方式，如下图所示。首先, 任意形状由连续的边构成, <mark style="background: transparent; color: red">合并时只要使用两个形状加一条弦就行了</mark>(其中, 边也看成是弦)
![[Excalidraw/第三章 动态规划算法 2024-02-01 14.09.40]]
每合并一次, 新增一个三角， 此时将其权值加入即可。 因此实际上与矩阵求解最少运算量完全相同。 
但与前面问题不同的是, 需考虑循环合并的问题。 因此，任意合并完之后还是6个不同形状， 实际上形成了一个满的矩阵。

下面我们以6个节点为例, 建立如下表格, 另外, 1-2, 2-3等等只需记为0即可, 所有的结果都可以由上面结果组装加上一步计算而成。
![[Excalidraw/第三章 动态规划算法 2024-02-01 12.02.04|600]]
其中, 每个表格填入对应的权值, 而每次新计算权值时, 传入对应的点即可。

首先我们给出带有输出的暴力递归解法, 这个解法的复杂度是指数的， 用于检验解答的正确性 : 
```cpp title:暴力算法 fold
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct point {
    int x;
    int y;
    point(int x, int y) : x(x), y(y) {};
};


float Get_weight(point A, point B, point C) {
    // 函数内部使用lambda表达式定义函数内部函数
    auto distance = [](point m, point n) {
        return std::sqrt(pow(m.x - n.x, 2) + pow(m.y - n.y, 2));
    };
    float a = distance(A, B), b = distance(A, C), c = distance(B, C);
    return pow(a - b, 2) + pow(a - c, 2) + pow(b - c, 2);
}

/// <summary>
/// 暴力递归拆分方法, 暴力枚举拆分方式, 直到拆分剩余2个时, 进行计算
/// </summary>
/// <param name="points">长度n点向量</param>
/// <param name="index_vec">[0,1, .... n-1]</param>
/// <param name="record_vec">用于记录, 输入空向量即可</param>
/// <returns></returns>
float Violet_Split(vector<point> points, vector<int> index_vec, vector<int>& record_vec) {
    float minres = 3.4e38;             // 记录最小值
    int length = index_vec.size();     // 点的个数

    if (length <= 2) throw exception("split err ");  // 仅有一条线或者一个点 
    if (length == 3) {
        record_vec = index_vec; record_vec.push_back(-1);

        point A(points[index_vec[0]].x, points[index_vec[0]].y);
        point B(points[index_vec[1]].x, points[index_vec[1]].y);
        point C(points[index_vec[2]].x, points[index_vec[2]].y);
        float minres = Get_weight(A, B, C);
        cout << " calcu triangle " << index_vec[0] << ", " << index_vec[1] << ", " << index_vec[2];
        cout << "  --------->     res : " << minres << endl;
        return minres;
    }

    vector<int> subrecord1;
    vector<int> subrecord2; 
    // 否则从index_vec中取得两个形状对应的点, 返回两个形状之和
    for (int i = 0; i < index_vec.size() - 1; i++) {  // 最大不超过
        int m = index_vec[i];
        for (int j = i + 2; j < index_vec.size() - 1; j++) {
            vector<int> new_index1, new_index2;
            cout << "check:  ";
            for (int k = i; 1; k = (k + 1) % index_vec.size()) {
                new_index1.push_back(index_vec[k]);
                cout << index_vec[k] << " ";
                if (k == j) break;
            }
            cout << "   remain : ";
            for (int k = j; 1; k = (k + 1) % index_vec.size()) {
                new_index2.push_back(index_vec[k]);
                cout << index_vec[k] << " ";
                if (k == i) break;
            }
            cout << "    " << endl;
            float res = Violet_Split(points, new_index1, subrecord1) + Violet_Split(points, new_index2, subrecord2);
            if (res < minres) {
                minres = res;
                record_vec = subrecord1;
                record_vec.insert(record_vec.end(), subrecord2.begin(), subrecord2.end());
                // 使用insert 进行向量拼接
            }
        }
    }

    cout << "minimum for ";
    for (int i = 0; i < index_vec.size(); i++) {
        cout << index_vec[i] << " ";
    }
    cout << " is " << minres << endl;
    return minres;
}

int main() {
    // 按照逆序给出的多边形顶点
    vector<int> x = { 27, 39, 39, 22, 12, 12 };
    vector<int> y = { 12, 22, 33, 38, 29, 19 };

    vector<point> point_vec;
    vector<int>   record_vec;
    for (int i = 0; i < x.size(); i++) {
        point_vec.push_back(point(x[i], y[i]));
    }

    float res = Violet_Split(point_vec, { 0, 1, 2, 3, 4, 5 }, record_vec);
    cout << endl << endl;
    cout << "final weight sum : " << res << endl;
    cout << "Best Split : ";
    for (int i = 0; i < record_vec.size(); i++) {
        if (record_vec[i] == -1) cout << "  |  ";  // 使用 | 进行输出划分
        else cout << record_vec[i] << " ";   
    }
    
    return 0;
}
```

```cpp title:示例输入
vector<int> x = { 27, 39, 39, 22, 12, 12};
vector<int> y = { 12, 22, 33, 38, 29, 19};
```

```cpp title:输出如下(省去调试输出)
final weight sum : 734.353
Best Split : 1 2 3   |  3 4 5   |  5 0 1   |  1 3 5   |
```
上述方式获取的最好三角形拆分方式如下图所示, 并且求解出最小的权值之和为734.353 每个三角形分别为 
229.207 +207.786 + 246.812 + 50.548

| 点 | weight |
| ---- | ---- |
| 1-3 | 229.207 |
| 3-5 | 207.786 |
| 5-1 | 246.812 |
| 1,3,5 | 50.548  |
划分方法绘图如下
![[attachments/Pasted image 20240201163852.png|400]]

然后我们给出对应的动态规划解法对应的矩阵: 
![[Excalidraw/第三章 动态规划算法 2024-02-01 12.02.04|600]]
从这个结构我们可以看出, 只要知道行， 列， 起止就已知; 从而只需要加一个标志位left 记录起, right 记录终, 而left, right很容易由行列获取。同时也可以从left和right反解出行列来。 

另外需要说明的是, 上述方法中, 每一列记录的多边形已经包含了相应的弦 (即例如4号行1号列对应的(0,5)已经包含了所有点, 弦是最后一条边) 
此时， 显然第四行求解的所有的结果都是相同的,  也就是我们最后要求解的权值结果。 

上述问题的动态规划法代码如下: 
```cpp title:多边形动态规划问题 fold
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct point {
    int x;
    int y;
    point(int x, int y) : x(x), y(y) {};
};


float Get_weight(point A, point B, point C){
    // 函数内部使用lambda表达式定义函数内部函数
    auto distance = [](point m, point n) {
        return std::sqrt(pow(m.x-n.x, 2) + pow(m.y - n.y,2));
    };
    float a = distance(A, B), b = distance(A,C), c = distance(B,C);
    return pow(a - b, 2) + pow(a-c, 2) + pow(b-c, 2);
}

/// <summary>
/// 动态算法， 具有更小的时间复杂度
/// </summary>
/// <param name="points">点向量</param> 
float Dynamic_Split(vector<point> points) {
    vector<vector<float>> WeightSum;
    for (int i = 0; i < points.size()-1; i++) {
        WeightSum.push_back(vector<float> (points.size(), 0));
    }
    // 第一行的所有权值均为0, 已经初始化过了
    for (int i = 1; i < points.size() -1; i++) {
        for(int j = 0; j < points.size(); j++) {
            // 从上一行寻找两个组成, 求解出最小值
            float mini_res = 5e10;

            int left = j, right = (i+j+1)%points.size();

            // k表示不同间隔,至少循环一次
            for (int k = 1; (left + k)%points.size() != right; k++) {
                // 通过反解定位解答所在位置
                // int left1 = left,  right2 = right;; // 使用标志位方法, left = col,
                int mid = (left + k) % points.size(); // right 1 & left2

                int r1 = left < mid ?  mid - left - 1: mid - left + points.size() - 1;
                
                int r2 = mid < right ? right - mid - 1 : right - mid + points.size() - 1;
                
                // 此时, left, mid, right分别为三角形对应的三个点 
                float addition = Get_weight(points[left], points[mid], points[right]);
                float res = WeightSum[r1][left] + WeightSum[r2][mid] + addition; 
                if (res < mini_res) {
                    WeightSum[i][j] = res; 
                    mini_res = res; // 注意重置 mini_res;
                }
            }
        }
    }

    for (int i = 0; i < points.size()-1; i++) {
        for (int j = 0; j < points.size(); j++) {
            cout << WeightSum[i][j] << "\t";
        }
        cout << endl;
    }
    return WeightSum[points.size() - 2][0];
}

int main() {
    // 按照逆序给出的多边形顶点
    vector<int> x = { 27, 39, 39, 22, 12, 12};
    vector<int> y = { 12, 22, 33, 38, 29, 19};
    vector<point> point_vec;
    vector<int>   record_vec;
    for (int i = 0; i < x.size(); i++) {
        point_vec.push_back(point(x[i], y[i]));
    }

    cout << "miniest weight : " << Dynamic_Split(point_vec) << endl;
    
    return 0;
}

```

```cpp fold title:输出
0       0       0       0       0       0
268.621 229.207 301.451 207.786 240.947 246.812
392.356 556.215 462.962 355.503 468.53  557.796
603.4   487.541 479.237 505.146 542.897 526.567
734.353 734.353 734.353 734.353 734.353 734.353
miniest weight : 734.353
```
显然第4行是相同的, 符合预期。另外由于时间原因， 就不添加记录划分方式的代码了， 读者可以自行添加。

### (4) 多边形游戏问题
考虑有一个由n个顶点构成的多边形, 每一个顶点都赋予一个整数值, 每个边被赋予 + 或者 *

1. 第一步，删除一条边
2. 每一次使用两个顶点和中间的一个运算符合并成新的顶点， 顶点数值为运算结果， 最终此多边形可以获得一个得数， 求这个得数的最大值。 
<mark style="background: transparent; color: red">注意: 顶点上的数可以是负整数</mark>。 

我们考虑如下的问题(内部为编号), 显然容易看出一个解 :  删去 -3 和 2 之间的连线， 得到最大值为$(6\times 1 \times 10 -4) \times 2 = 112$, 而可以获取到的最小值为$-4\times (80) = -320$; 
![[Excalidraw/第三章 动态规划算法 2024-02-02 09.56.22|700]]
首先， 我们仍然 按照上述步骤分析问题: 
1. 由于只有加法和乘法， 当整个运算为最优运算时: 
	- 如果两个子链结果都是正数, 显然其中的每一个小部分(子结构)都是最优的。具有最优子结构性质。
	- 如果两个子链结果都是负数, 则所得的最大值可能由子链的最大值获取, 也可能由子链的最小值获取。
因此<mark style="background: transparent; color: red">我们可以记录一个最大值和一个最小值</mark>, 每次从组合中获取结果即可。 
2. 重复字问题性质即重复解决每个边上的 + 和乘问题, 这里不再详细叙述。

这样问题就变得简单， 基本方法只需要建立类似的表即可。 另外就是舍弃一条边的问题；这个只需先行计算，获取最大合并之后舍弃边即可。 

问题代码如下: 
```cpp title:多边形游戏
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef struct Result {
    int maximum;
    int minimum;
    Result() : maximum(0), minimum(0) {};
    Result(int maximum, int minimum) : maximum(maximum), minimum(minimum) {};
}Res;

Res Calcu(const Res a,const Res b, int op) {
    Res c;
    if (op == 0) {
        c.maximum = a.maximum + b.maximum;
        c.minimum = a.minimum + b.minimum;
    }
    else if (op == 1) {
        vector<int> nums{ a.maximum * b.maximum, a.minimum * b.minimum,
                          a.minimum * b.maximum, a.maximum * b.minimum };
        // 获取上述向量中点的最大值和最小值
        c.maximum = *std::max_element(nums.begin(), nums.end());
        c.minimum = *std::min_element(nums.begin(), nums.end());
    }
    return c;
}

// 由于是修改结构体值，需要传入地址
void Check_Res(Res &temp_res, Res &fin_res) {
    if (temp_res.maximum >= fin_res.maximum) {
        fin_res.maximum = temp_res.maximum;
    }
    if (temp_res.minimum < fin_res.minimum) {
        fin_res.minimum = temp_res.minimum;
    }
}

vector<vector<Result>> Matrix;
// 返回一个struct 类型, 同时存储最大和最小值 (注意输入点个数一定要大于1)
Res Polygon_Game(const vector<int> nums, const vector<int> signs) {
    for (int i = 0; i < nums.size()-1; i++) { // 初始化
        Matrix.push_back(vector<Result>(nums.size(), Res()));
    }
    for (int i = 0; i < nums.size(); i++) {
        if (signs[i] == 0) {
            Matrix[0][i].maximum = nums[i] + nums[(i + 1) % nums.size()];
        }
        else {
            Matrix[0][i].maximum = nums[i] * nums[(i + 1) % nums.size()];
        }
        Matrix[0][i].minimum = Matrix[0][i].maximum;
    }
    
    for (int i = 1; i < nums.size()-1; i++) {
        for (int j = 0; j < nums.size(); j++) {
            // 合并的两种方式包括向左合并,向右合并和子链合并
            int left = j, right = (j + i + 1) % nums.size();
            Res fin_res, temp_res;
            // 第一次为左合并方法, 新数字在左边
            fin_res =  Calcu(Matrix[i - 1][(j+1)%nums.size()], Res(nums[j], nums[j]), signs[j]);
            temp_res = Calcu(Matrix[i - 1][j], Res(nums[right], nums[right]), signs[right == 0 ? nums.size() -1: right -1]);
            Check_Res(temp_res, fin_res);
            // 检查两个子串合并的情况
            
            for (int k = 0; (left +  k + 1)%nums.size()!= right; k++) {
                if (k < 1) { continue; } // 如果相差长度(线长度) < 2则不做
                if (k == 1 && (left + k + 1) % nums.size() == right) break;

                int mid1 = (left + k) % nums.size();
                int mid2 = (left + k + 1) % nums.size();

                int r1 = mid1 - left - 1 >= 0 ? mid1 - left - 1 : mid1 - left - 1 + nums.size();
                int r2 = right - mid2 - 1 >= 0 ? right - mid2 - 1 : right - mid2 - 1 + nums.size();
                temp_res = Calcu(Matrix[r1][left], Matrix[r2][mid2], signs[mid1]);
                Check_Res(temp_res, fin_res);
            }
            Matrix[i][j] = fin_res;
        }
    }
    // 其中Matrix最后面一行的
    int _min_ = Matrix[nums.size() - 2][0].minimum;
    int _max_ = Matrix[nums.size() - 2][0].maximum;
    for (int i = 0; i < nums.size(); i++) {
        _min_ = std::min(Matrix[nums.size() - 2][i].minimum, _min_);
        _max_ = std::max(Matrix[nums.size() - 2][i].maximum, _max_);
    }
    return Res(_max_,_min_);
}

int main() {
    // 5个节点, 5条边
    vector<int> nums = { 5, 1, 10, -4, 2 };
    vector<int> signs = {0, 1, 0, 1, 0 }; // 0代表加,1代表称
    
    Res r = Polygon_Game(nums, signs);

    cout << "maximum value : " << r.maximum << endl;
    cout << "minimum value : " << r.minimum << endl;
    cout << endl;

    for (int i = 0; i < nums.size() - 1; i++) {
        for (int j = 0; j < nums.size(); j++) {
            cout << Matrix[i][j].maximum << " ";
        }
        cout << endl;
    }
    cout << endl;
    for (int i = 0; i < nums.size() - 1; i++) {
        for (int j = 0; j < nums.size(); j++) {
            cout << Matrix[i][j].minimum << " ";
        }
        cout << endl;
    }
    return 0;
}
```

```cpp title:输出示例
maximum value : 112
minimum value : -320

6 10 6 -8 7
60 6 12 -3 8
56 12 42 -2 80
112 42 48 52 76

6 10 6 -8 7
15 6 2 -28 8
11 2 -18 -32 17
7 -18 -22 -320 13
```

### (5) 图像压缩算法
在计算机中， 我们使用灰度序列即$\left\{p_{1}, p_{2}, \dots p_{n} \right\}$表示图像， 其中,  使用整数$p_i$表示像素点$i$的灰度值, 灰度值的范围从0-255为8位表示一个像素。

图像压缩方法:  <mark style="background: transparent; color: red">图像的变位压缩存储</mark>是**将给定的像素点序列分割成m个连续段**$S_1, S_2, \dots S_m$, 其中第$i$个像素段$S_i$中, 有$l_i$个像素, 并且该段中的每个像素都仅使用$b[i]$位进行表示。即字节占用空间成为: 
$$\sum^{m}_{i=1} l_{i} b_{i}$$
但是由于每一段序列中的$b_i$并不相同， 同时显然有$0 < b_{i}\leq 8$, 因此还需要3位表示$S_{i}$段每个字节的位数$b_i$
同时, 我们限制对于一个图像, 每一个像素段的长度$l_i$不能超过255, 即$0\leq l_{i} \leq  255$, 因此使用8位表示$l_i$, 此时, 则压缩之后图片的总占用空间为:
$$\sum^{m}_{i=1} l_{i} b_{i}  + (8 + 3) \times  m$$
图像压缩问题: ==求解像素序列$\left\{p_{1}, p_{2}, \dots p_{n} \right\}$的最优分段,  使得依次按照此分段的所需存储空间最少==。 即给定$n$值和$p_1, p_2, \dots p_n$, 求解如何分段获取总空间最小的方法

1. 性质分析: 首先, 图像压缩问题<b><mark style="background: transparent; color: blue">具有最优子结构性质</mark></b>, 即对于某个区间, 可以划分为$\{S_{1}, S_{2}, S_{3}\}$部分, 如果划分$S_{1}, S_{2}, S_{3}$都是最优的, 那么$\left\{S_{1}\right\}, \left\{ S_{2}, S_{3}\right\}$也<mark style="background: transparent; color: red">分别是两段的最优划分</mark>。即子结构也是最优的划分方式, 具有最优子结构性质
2. 重复子问题的求解过程: 由于每个分段的每个字节将存储$p_i$, 因此压缩之后每一段的单个字节大小应当计算为
$$b_{i} = [\max(\log_{2} p_{i}) +1 ], \qquad p_{i} \in (S_{i})$$
其中$[]$ 表示向上取整。

我们<mark style="background: transparent; color: red">考虑动态规划所需要的空间复杂度大小</mark>: 
1. 首先是我们建立一个初始数组为b, <mark style="background: transparent; color: red">b 的每个位表示这一组l[i]中每一位所占用的空间</mark>, 而<mark style="background: transparent; color: red">s[i]表示从0到i, 划分所使用的最小的总空间</mark>。
![[Excalidraw/第三章 动态规划算法 2024-02-05 16.24.37|600]]

2. 思考: 对于每一个数字的分组方式, 可以是
	- (1) 单独另起为一组, 此时总的长度为 $s[i-1] + 11$ ->
	- 和前面k个为一组, 即使用$s[i - k-1] + b_{\max} \times (i - k) + 11$ 
迭代公式: 
$$s[i] =\begin{cases}
b[0] + 11 \qquad \qquad \qquad  i = 0 \\ \\

\overset{i- k \geq 0,k\leq  255 }{\underset{k = 0}{\max}} \left\{ s[i - k-1] + b_{\max} \times (k+1) + 11 \right\}  \qquad i\neq 0
\end{cases} $$
需要说明, 上面两个可以合并为一种方式,  即**从i 开始， 然后从后向前找新的分组, 当新的分组和 $s[i-j-1]$ 的和最小时, 则记录该最小值以及$l[i]$, 并采用新的分组方式**。

3. 说明: 由于限制分组长度不超过255, 则向前搜索的分组长度不超过255
此时， 由于对于每个数子进行向前搜索时, 搜索长度不超过255, 则整个算法的时间复杂度也仅为$O(n)$, 此时问题得到了良好的解决， 这种算法是一种非常优越的算法。

因此， 核心代码仍然是很简短的: 
```cpp title:图片压缩核心代码
int length(unsigned char num) {
    int length = 0;
    for (int n = num; n != 0; n >>= 1) length++;
    return length;
}

// 首先, 设l[i]-> b[i] 是某个像素序列的最优分段, 而s[i] 为对应的存储位数, 则可以依次计算出s[i]
static void compress(vector<unsigned char> pic, vector<int> &s, vector<int> &l, vector<int> &b) {
    int n = pic.size();
    // 对于每一个数字, 从后向前寻找最多可以分的组, 且长度不超过255
    for (int i = 0; i < n; i++) {
        b[i] = length(pic[i]);
        int b_max = b[i];
        int minimum = i>0?s[i - 1] + b[i] + 11: b[0]+11; // 首先初始化为该数进行单独分一组的情况
        s[i] = minimum;
        l[i] = 0;            // 初始化长度为0代表一个数字, 1代表两个, 以此类推
        for (int j = 1; j <= i && j < 256; j++) {
            // 考虑和前面加上j个数共同分一组的分组方式所得到的结果
            if (b[i - j] > b_max) b_max = b[i - j];
            int res = i > j? s[i - j - 1] + b_max * (j + 1) + 11 : b_max * (j+1) + 11;
            if (res < minimum) {
                minimum = res;
                s[i] = minimum; // 更新从前面到此处分组的值
                l[i] = j;       // 长度为j 
            }
        }
    }
}
```

我们以入下的序列为例: 

| 数据 | 4 | 4 | 4 | 16 | 8 | 8 | 4 | 4 | 128 | 128 | 32 | 64 | 8 | 4 | 16 | 2 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 长度 | 3 | 3 | 3 | 5 | 4 | 4 | 3 | 3 | 8 | 8 | 6 | 7 | 4 | 3 | 5 | 2 |

获得的$s[i]$和$l[i]$如下所示:
```cpp title:输出
14      17      20      31      36      41      46      51      70      78      86      94      102     110     118    125
0        1        2        3        4        5       6         7       0         1        2        3         4        5         6       3
```

显然, 将后面的2,5,3,4分为一组的方式长度为11 + 20 = 31, 与前方的94和为125, 这比包含元素7$(7*5 + 11 + 94) = 140$划分方式更优越。

然后我们可以输出每一组的个数以及划分方式, 完整代码如下: 
```cpp title:图片压缩完整代码 fold
#include <iostream> 
#include <vector>
#include <string>
#include <stack>
#include <algorithm>

using namespace std;

int length(unsigned char num) {
    int length = 0;
    for (int n = num; n != 0; n >>= 1) length++;
    return length;
}

// 首先, 设l[i]-> b[i] 是某个像素序列的最优分段, 而s[i] 为对应的存储位数, 则可以依次计算出s[i]
static void compress(vector<unsigned char> pic, vector<int> &s, vector<int> &l, vector<int> &b) {
    int n = pic.size();
    // 对于每一个数字, 从后向前寻找最多可以分的组, 且长度不超过255
    for (int i = 0; i < n; i++) {
        b[i] = length(pic[i]);
        int b_max = b[i];
        int minimum = i>0?s[i - 1] + b[i] + 11: b[0]+11; // 首先初始化为该数进行单独分一组的情况
        s[i] = minimum;  l[i] = 0;        // 初始化长度为0代表最后一个数字单独一组,1代表最后两个一组
        for (int j = 1; j <= i && j < 256; j++) {
            // 考虑和前面加上j个数共同分一组的分组方式所得到的结果
            if (b[i - j] > b_max) b_max = b[i - j];
            int res = i > j? s[i - j - 1] + b_max * (j + 1) + 11 : b_max * (j+1) + 11;
            if (res < minimum) {
                minimum = res;
                s[i] = minimum; // 更新从前面到此处分组的值
                l[i] = j;       // 长度为j 
            }
        }
    }
}

// 使用栈的方法进行输出, 从后向前进行入栈, 放完之后从前向后出栈
void OutPut(vector<unsigned char> pic, vector<int> l) {
    cout << "========= compress  result : =========" << endl;
    stack<int> lengthStk;
    stack<unsigned char> dataStk;
    for (int i = pic.size() - 1; i >= 0; ) {
        lengthStk.push(l[i]);
        for (int j = l[i]; j >= 0; j--, i--) {
            dataStk.push(pic[i]);
        }
    }

    while (!lengthStk.empty()) {
        int t = lengthStk.top();
        lengthStk.pop();
        cout << "length :   " << t + 1 << "   |   ";
        for (int i = 0; i <= t; i++) {
            cout << length(dataStk.top()) << " ";
            dataStk.pop();
        }
        cout << endl;
    }
}


void Compress_Picture(vector<unsigned char> pic) {
    int n = pic.size();
    vector<int> s, l, b;
    s = vector<int>(n, 0);
    l = vector<int>(n, 0);
    b = vector<int>(n, 0);
    compress(pic, s,l,b);
    
    for (int i = 0; i < n; i++) {
        cout << s[i] << "\t";
    }
    cout << endl;
    for (int i = 0; i < n; i++) {
        cout << l[i] << "\t";
    }
    cout << endl;
    OutPut(pic, l);
}

int main() {
    // from ascii 0 to 255 -> s is length (from 0 to 8) 
    vector<unsigned char>s = {3, 3, 3, 5, 4, 4, 3,3, 8,8, 6,7, 4, 3, 5 ,2};
    vector<unsigned char> Img;

    for (int i = 0; i < s.size(); i++) {
        Img.push_back( 1<<(s[i]-1) );
        cout << length(Img[i]) << "\t";
    }
    cout << endl; 
  
    Compress_Picture(Img);
    return 0;
}

```
输出第一行为Pic中每个元素长度$p[i]$, 第二行为$s[i]$, 第三行为$l[i]$, 并输出了压缩结果。
```cpp title:输出
3       3       3       5       4       4       3       3       8       8       6       7       4       3       5       2
14      17      20      31      36      41      46      51      70      78      86      94      102     110     118     125
0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       3
========= compress  result : =========
length :   8   |   3 3 3 5 4 4 3 3
length :   4   |   8 8 6 7
length :   4   |   4 3 5 2
```

### (6) 电路布线问题 
在下图的一块电路板上, 设上下共有$n$个接线柱, 要求使用导线将接线柱将上端的接线柱$i$与下端接线柱$V(i)$连接。在实际的布线时, 要求n条线分布到t个绝缘层上, 且要求线之间两两不相交。如何安排布线的层数的问题。
![[Excalidraw/第三章 动态规划算法 2024-02-05 19.30.29|400]]
上述问题化简为：<b><mark style="background: transparent; color: red">要求将尽可能多的线连接安排在第一层上</mark></b>, 且线之间两两不连接。 

设上面的接线柱为$i$, 而使用一个向量给出下面的对应关系为$V(i)$， 显然, 对于i, $V(i)$和$j, V(j)$, 某两条线相交条件是: 
$$(j-i)(V(j) - V(i)) < 0$$
当满足 $i < j$ 时, 如果$V(j) < V(i)$, 则两条线相交。

<mark style="background: transparent; color: red">对于每一条线, 能与其分布在同一层的线是一个集合, 则电路问题就是解决多条线最大公共不相交集合的问题</mark>, 显然穷举需要$O(n!)$复杂度， 下面考虑如何使用$O(n^2)$复杂度解决问题。 

我们考虑： 定义上面从$0\sim(i-1)$ 共有$i$个接线柱且下面从$0 \sim j -1$有$j$个接线柱的情形为$N(i,j)$, 所<mark style="background: transparent; color: red">对应的最大公共子集</mark>为$\text{MaxSubSet}(i,j)$; 而最小公共子集的长度记为$s(i,j)$; 

我们考虑如下的几种情况:
![[Excalidraw/第三章 动态规划算法 2024-02-06 09.06.56|900]]
综合上述的说明, 我们总结出$s(i,j)$的变化规律: 
1.  $i = 0$ 时, 有:
$$s(i,j) = \begin{cases}
0   \qquad  j < V(i)\\
1 \qquad  j \geq  V(i)
\end{cases}$$
2. $i > 0$时, 有:
$$s(i,j) = \begin{cases}
s(i-1, V(i) - 1) + 1 \qquad  \left\{ i,V(i)\right\} \in  \text{Maxsubset(i, j)}\\
s(i-1, j) \qquad  其他
\end{cases}$$
另外, 由于$s(i-1, V(i)-1)$为<mark style="background: transparent; color: red">除去</mark>$\left\{ i,V(i) \right\}$<mark style="background: transparent; color: red">的最大子集</mark>, ==显然可以与$\left\{ i , V(i)\right\}$合并成一个集合==; 这个集合就是**含有$\left\{ i , V(i)\right\}$的最大子集**; 而<mark style="background: transparent; color: red">不含</mark>$\left\{ i , V(i)\right\}$<mark style="background: transparent; color: red">的最大子集</mark>显然是$\text{Maxsubset}(i-1, j)$; 我们<mark style="background: transparent; color: red">只需要比较含有这条线和不含这条线的大小即可</mark>; 因此， 第二种情况化为: 
$$s(i,j) = \begin{cases}
s(i-1, j) \qquad\qquad \qquad \qquad \qquad \qquad \qquad\space   j < V(i)   \\
\max\left[ s(i-1, j), s(i-1, V(i)-1) + 1\right] \qquad  j\geq  V(i)
\end{cases}$$
此时**我们即可利用此公式进行迭代求解**。另外需要说明的时, 如果$V(i) = 0$, 则显然$s(i-1, V(i) -1)$即去掉该线的部分为0, 此时为了不超过范围, 直接返回1即可。

核心代码如下: 
```cpp title:电路问题核心代码
// solute the circuit maxSubset problem 
void Circuit_Solution(const vector<int> V) {
    vector<vector<int>> s;
    int n = V.size();
    for (int i = 0; i < n; i++) { // 初始化
        s.push_back(vector<int>(n, 0));
        s[0][i] = i < V[0] ? 0 : 1;
    }
    for (int i = 1; i < n; i++) { // 求解 
        for (int j = 0; j < n; j++) {
            if (j < V[i]) s[i][j] = s[i - 1][j];
            else { // j >= V[i];
                int res = V[i] == 0 ? 1 : s[i - 1][V[i] - 1] + 1;
                s[i][j] = std::max(s[i - 1][j], res);
            }
        }
    }
}
```

我们以下面的输入数据为例: 
```cpp title:输入数据
vector <int> V{ 7,  6, 3, 1, 4, 0 , 8 , 2, 9 ,5 };
```
所对应的连线如图, 其中最大子集数为4,  即图中的四条蓝线可以布在一层中。 
![[Excalidraw/第三章 动态规划算法 2024-02-06 10.36.22|600]]

```cpp title:输出s结果 
0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 1 1 1 1
0 0 0 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 1
0 1 1 1 2 2 2 2 2 2
1 1 1 1 2 2 2 2 2 2
1 1 1 1 2 2 2 2 3 3
1 1 2 2 2 2 2 2 3 3
1 1 2 2 2 2 2 2 3 4
1 1 2 2 2 3 3 3 3 4
```
显然, 右下角的$s(n-1, n-1)$即为最大的子集数量(4条线)。

下面我们考虑如何

记录获取的最多分布的连线号的方法:  直接根据$s[i][j]$进行构造:  我们考虑上面<mark style="background: transparent; color: red">每删去一个节点时</mark>, 如果电路板上目前的最大子集数量减少了1, 则**认为i对应的连线在最大子集中**, 我们只需逆序思考， 此时, **显然剩下的最大子集在除去这一整条线之后剩余的 $i,j$ 范围内， 只需继续寻找即可**。

完整代码如下: 
```cpp title:电路问题
#include <iostream> 
#include <vector>
#include <algorithm>
using namespace std;

// solute the circuit maxSubset problem 
void Circuit_Solution(const vector<int> V) {
    vector<vector<int>> s;
    int n = V.size();
    for (int i = 0; i < n; i++) {
        s.push_back(vector<int>(n, 0));
	    s[0][i] = i < V[0] ? 0 : 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (j < V[i]) s[i][j] = s[i - 1][j];
            else { // j >= V[i];
                int res = V[i] == 0 ? 1 : s[i - 1][V[i] - 1] + 1;
                s[i][j] = std::max(s[i - 1][j], res);
            }
        }
    }

    // Matrix s
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << s[i][j] << " ";
        }
        cout << endl;
    }
    // 按照s构造记录最大布线 m 
    vector <int> m;
    int j = n - 1;
    for (int i = n-1; i >= 0; i--) {
        if (s[i][j] == 0) break;  // 每一次 i 自减完毕之后,考察是否为0
        if (s[i][j] != s[i - 1][j]) { // 删去这一条之后, 最大子集数量减少1, 则认为在最大子集中。
            m.push_back(i);
            if (V[i] == 0) break; // 另一条线在0处, 此时找不到最大子集了
            j = V[i] - 1;  // 连同这一条的尾结点删去
        }
    }

    for (int i = m.size()-1; i >=0; i--) {
        cout << m[i] << " --> " << V[m[i]] << endl;
    }
}

int main() {
    vector <int> V{ 7,  6, 3, 1, 4, 0 ,8 , 2, 9 ,5 };
    Circuit_Solution(V);

    return 0;
}
```

### (7) 流水线作业调度问题 
有两台机器$M1, M2$, 且有n个作业$\left\{ 1,2,3,\dots n \right\}$要在这<mark style="background: transparent; color: red">两台机器组成的流水线上完成加工</mark>, 其中$M_1$需要加工任务i的的加工时间为$a_i$, 而$M_2$的加工时间为$b_{i}$; 

**流水线作业调度问题**要求确定n个作业的最优加工顺序,  使得第一个作业从$M1$上开始加工到$M2$上完成加工的时间最短;

首先，由于是$A$做完之后给$B$进行加工， 因此我们很容易可以用两个队列模拟一个加工完放到另一台机器的过程; 只需要用两个队列加上枚举即可实现暴力算法, 显然暴力枚举算法的复杂度是$n$个元素的排列总数量， 即$O(n!)$ 
![[Excalidraw/第三章 动态规划算法 2024-02-07 15.13.55]]

下面考虑用动态规划的方法解决流水线调度问题

首先， 我们设全部的作业集合为N, 考虑其<b><mark style="background: transparent; color: blue">最优子结构性质</mark></b>: 
1. 由于我们在安排任意一个工作序列$S\left\{1,2,3,\dots n \right\}$到流水线上时,  假设流水线上此时M1处已经能够工作， 而**M2还需要等待$T_{b}$时间才能给上述工作腾出位置**
此时，假设在最好的调度方式下, 完成工作所需的时间为
$$T = T(S, T_{b})$$
2. 显然, 对于流水线调度问题而言, 由于初始时B不需等待即可加工, 设完成$S = \left\{1,2,\dots n \right\}$的**最优时间为**: $T(S, 0)$, 则显然完成$S' = \left\{ 2,3,\dots n\right\}$的最优时间为:  
$$T(S', b_{1})$$
<mark style="background: transparent; color: red">显然</mark>, $T(S', b_1)$也是**在安排调度为$S'$下的最短完成时间**，即在最优的情况下,  只需修改上述b的等待时间参数, 剩余的子问题即成为2-n事件在$b_1$下的最短时间问题。故而<b><mark style="background: transparent; color: blue">流水线调度问题具有最优子结构性质</mark></b>。

对于流水线调度问题, <mark style="background: transparent; color: red">需要解决的子问题</mark>都是在等待时间为$T_b$情况下的完成任务最短时间; 首先我们考虑两个相邻的作业安排顺序: 对于两个任务(不论其总的完成时间是否相同), 则均有如下的划分方式:
![[Excalidraw/第三章 动态规划算法 2024-02-07 13.19.34|1100]]
设一系列的工作完成之后(M1空闲, M2仍然工作时), 假设目前M2剩余工作时间为 $t$ ,  则设此时有<mark style="background: transparent; color: red">已经设置为最优调度的</mark>作业集 $S$ 需要继续完成， 且对应最前方的两个作业为 $i, j$ , 此时设最优调度方式为$\pi$, 即有 $i = \pi(1), j = \pi(2)$ , 此时: 显然: 仅做完 $a_i$ 时, $M2$上剩余需要的时间计算为: 
$$t_{i}  = \max \left\{ b_{i},  \quad t - a_{i} + b_{i} \right\}$$
同时

设依次完成$i,j$之后的剩余时间为$t_{ij}$, 计算时, 我们考虑: 
1. $t$ 较大, 将$b_{i}$和$b_{j}$顶出, 则 $t_{ij}  =t + b_{i} - a_{i} - a_{j} + b_{j}$ 
2. $b_{i}$较大, 将$b_{j}$顶出$a_j$末端之后, 则 $t_{ij}= b_{i} + b_{j} - a_{j}$
3. 当$a_j > b_i$且$t + b_{i} < a_{i} + a_{j}$时, 则显然有最小等待时间为 $b_j$ 
$$t_{ij} = \max \left\{ t + b_{i}+ b_{j}  - a_{i} - a_{j} , \quad  b_{i} + b_{j} - a_{j} , \quad   b_{j}\right\}$$

<b><mark style="background: transparent; color: blue">因此我们构建出递归式为</mark></b>: 
$$\Large \boxed{T(S, t) = a_{i} +  T(S - \left\{ i\right\},  t_{i} ) = a_{i} + a_{j} +  T(S- \left\{i,j\right\}, t_{ij})} \tag{1}$$
其中:
$$t_{i} = \max \left\{ b_{i} ,  t - a_{i} + b_{i}\right\} \qquad  t_{ij} = \max \left\{ t + b_{i}+ b_{j}  - a_{i} - a_{j} , \quad  b_{i} + b_{j} - a_{j} , \quad   b_{j}\right\}$$
另外, 我们还考虑上图右侧的情况， 如果将$i,j$互换, 得到的结果是:
$$T_{2}(S, t) = a_{i} + a_{j} + T(S - \left\{i,j \right\},  t_{ji})\tag{2}$$
同样地, 按照$t_{ij}$计算方法可以获得$t_{ji}$为:

$$t_{ij} = \max \left\{ t + b_{i}+ b_{j}  - a_{i} - a_{j} , \quad  b_{i} + b_{j} - a_{j} , \quad   b_{j}\right\}$$
$$t_{ji} = \max \{t + b_{i} +b_{j} - a_{i} - a_{j}, \quad b_{i} + b_{j} - a_{i}, \quad b_{i}\} $$
比较$(1), (2)$, 由于$T(S, t)  \leq T'(s,t)$显然有: 
$$T(S - \left\{i, j\right\}, t_{ij}) \leq  T (S -\left\{i,j \right\}, t_{ji})$$
显然，对于相同的任务，**==只有当在前面需要预先等的时间$t$更少时， 我们才可能找到更好的调度方案==**。因此显然有:
$$t_{ij} \leq t_{ji}$$
代入得到: 
$$\max \left\{ t + b_{i}+ b_{j}  - a_{i} - a_{j} , \quad  b_{i} + b_{j} - a_{j} , \quad   b_{j}\right\} \leq \max \{t + b_{i} +b_{j} - a_{i} - a_{j}, \quad b_{i} + b_{j} - a_{i},\quad  b_{i}\} $$
两边同时减去 $b_{i} + b_{j}$ , 得到: 
$$\max\{ t +  b_{i} + b_{j} , \quad  -a_{j}, \quad -b_{i} \} \leq  \max \left\{t + b_{i} + b_{j} ,\quad  -a_{i},\quad    - b_{j}  \right\}$$
上式即: 
$$\max\left\{ - a_{j} ,-b_{i} \right\}\leq \max \{ -a_{i}, -b_{j}\}$$
也即
$$\boxed{\min \{a_{j}, b_{i} \}\geq  \min \{a_{i}, b_{j} \}}$$
得到结论: <mark style="background: transparent; color: red">如果满足条件</mark>$\min \{a_{j}, b_{i} \}\geq  \min \{a_{i}, b_{j} \}$ , 则**对应所获得的 $T(S - \left\{i,j\right\}, t_{ij})$才可能会更小, 即i应当放在j前面**， 即可以直接通过Johnson不等式进行排序, 来确定最小值。 上述不等式称为**Johnson不等式**， 也即相邻的$i$和$j$应当满足的关系式。 

因此, 我们只需要按照此规律进行排序即可确定最佳流水线的调度顺序。问题就变为仅需$O(n\log_{2}n)$时间复杂度就可以解决的问题;

代码如下: 
```cpp title:流水线调度问题
#include <iostream> 
#include <vector>
#include <algorithm>
using namespace std;
typedef struct Task {
    int t_a;
    int t_b;
    char id;
    // 按照 Johnson 不等式改写排序方法 
    friend bool operator < (const Task& A, const Task& B) {
        return std::min(B.t_a, A.t_b) > std::min(A.t_a, B.t_b);
    };
    Task(int a, int b, char id): t_a(a), t_b(b), id(id) {};
}task;
// 获取需要的时间, 利用T(S,t) = a_i  + T(S-{i}, t_i); 获取
int getTime(vector<task> vec, int i, int t) {
    if (i == vec.size()) return t; // 把剩余的做完; 
    int t_i = std::max(vec[i].t_b, t - vec[i].t_a  + vec[i].t_b);
    return vec[i].t_a + getTime(vec, i+1, t_i);
}
int main() {
    Task A(9, 3, 'A'), B(6, 4, 'B'), C(8, 15, 'C'), D(5, 12, 'D'), E(10, 2,'E');
    vector<Task> vec{A, B, C, D, E};
    cout << "Time 1 : " << getTime(vec, 0, 0) << endl;
    // 按照Johnson不等式排序
    std::sort(vec.begin(), vec.end());
    cout << "Best dispatch sequence :   ";
    for (int i = 0; i < vec.size(); i++) cout << vec[i].id << " ";
    cout << endl;
    cout << "Best Time : " << getTime(vec, 0, 0) << endl;
}
```

上述问题优化前和优化后的用时分别为52和41， 具体如下图所示, 可以看出, 在流水线调度安排优化之后, 用时有了显著的改善。
![[attachments/Pasted image 20240207171427.png|900]]
### (8) 0-1背包问题
基本的 0 - 1 背包问题: 有i个物品, 第i个物品的重量为$w_i$,价值为$v_i$ 背包容量为C, 寻找装入的方法使得装入背包的问题总价值最大。

例如, 取$C = 10$, 而物品的编号和价值如下表, 显然一种可的的方案是 2,4 得到总价值为27; 其中, 每个物品的重量各不相同，但是价值可以相同。 

| 物品编号 | A | B | C | D | E |
| ---- | ---- | ---- | ---- | ---- | ---- |
| $w_i$ | 4 | 2 | 6 | 8 | 1 |
| $v_i$  | 9 | 7 | 14 | 20 | 3 |

方法1是枚举， 将每个物品装入和不放入背包记为0,1, 则总情况应当有$2^n$种,  显然算法复杂度是很高的。

#### 思路1. 寻找子问题通过动态方法与合并的思路进行解决（错误算法）
我们按照合并的方法, 将最大价值列表保存, 则第一行为每个物品装入的价值; 

首先, <mark style="background: transparent; color: red">例如背包容量为5时, 是否可以从背包容量为3和背包容量为2的两个子问题结果拼合而来</mark> ,  而当背包容量为1时, 显然得到的问题就好解决。

思路一的<mark style="background: transparent; color: red">最优子问题的性质</mark>显然为: <mark style="background: transparent; color: red">对于容量为n的物品， 至少可以装下容量n-1的价值的最大值</mark>;  因此我们需要解决 n-1 大小的背包放入的最大价值后,可以解决n的背包放入问题。 而容量为 n 时, 可以通过一个物品加上其他物品组成的价值最大值获取。

我们取横轴为物品数量a; 纵轴为背包容量b; 第一行仅存储装入对应重量物品的相应价值; 对于第二行, 每一格的计算方法显然是: 
$$max(前一格的值, 以及上面一行的两个和为此数的和)$$
第三， 四行可以经过推广获取。设装入物品个数为a, 背包容量为b时获得的最大价值为$v_{ab}$, 则装入前面$a-1$个物品获得的最多价值显然可以从前一行获取， 
$$v_{ab} =  \max (v_{a, b-1} ,  \max_{k = 0}^{k < b-k} (v_{a-1, k} + v_{1, b-k} ))$$
 获取的表格如下表所示(注意第一行不一定是a个物品, b容量下的最值): 

| a\b | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 3 | 7 | 0 | 9 | 0 | 14 | 0 | 20 | 0 | 0 |
| 2 | 3 | 7max(3, 7 + 0) | 10 max(7, 0, 7 + 3) | 10 , max(10, 0+3, 7+0, 9) | 12, max(0,10, 9+3, 7+0) | 16, max(12, 14, 9+7) | 17 max(16, 0, 14 +3) | 21 max(20, 17+3, 14+7) | 23 | 27 |
| 3 | 3 | 7 | 10 | 10 | 12 | 16 ()  | <mark style="background: transparent; color: red">19</mark> |  |  |  |
| 4 |  |  |  |  |  |  |  |  |  |  |

其中显然第二行是非常好计算的；而第三行由于是第二行加入一个物品, 则组成其的第一个部分是第一行的某一个物品， 而第二个是前面一行所求出的装n-1个物品的最大价值(为了不重复， 应当从后向前搜寻, 如下图所示)
![[Excalidraw/第三章 动态规划算法 2024-02-08 16.07.44|1200]]
则(3,6)处的价值应当为: max(16(上一行), 14 + 0, 0+3, 9 + 7); 

按照此种算法, 由于最多装入的物品个数必定不超过 4(1 + 2 + 3 + 4 = 10), 即($k * \frac{k +1}{2} \geq n$) , 因此$k^{2} > n$即可; 则行数k可以简单地由$k = ceil(\sqrt{n})$ 计算出， 例如10时所得$k$显然是4; 

上述的算法是错误的, 由于合并中没有考虑到三个以上的情况， 可能在前面的情况中有另外一个预先没有选上部分加入或者不加入的情况, 因而这个算法是错误的。 (==违背最优子结构原理==) 
```cpp 错误输出对应输入示例
vector <int> weight = {4, 2, 6, 7 , 1, 3};
vector <int> value = {10, 5, 13, 15, 4, 8}; // 输出应当27(1,2,3,4) -> 实际输出为25
```

```cpp fold title:错误解法
#include <iostream> 
#include <vector>
#include <algorithm>
using namespace std;

typedef struct BagItem {
    int weight;
    int value;
    friend bool operator < (const BagItem item1, const BagItem item2){
        return item1.weight < item2.weight;
    }
    BagItem(int weight, int value) : weight(weight), value(value) {};
}Item;

vector<vector<int>> Matrix;
vector <Item> itemVec;
void Bag_Init(vector<int> wet, vector<int> val, int capacity) {
    int n = wet.size();
    for (int i = 0; i < std::ceil(std::sqrt((float)capacity)); i++) {
        Matrix.push_back(vector<int>(capacity + 1, 0));  // 构造矩阵
    }

    for (int i = 0, j = 0; i < n; i++) {
        itemVec.push_back(Item(wet[i], val[i]));
    }
    std::sort(itemVec.begin(), itemVec.end());

    // 将每个物品的价值放在对应的地方; 
    for (int i = 0, j = 0; i < capacity + 1; i++) {
        if (j < itemVec.size() && i == itemVec[j].weight) {
            Matrix[0][i] = itemVec[j].value;
            j++;
        }
    }
}

void Bag_Problem(vector<int> wet, vector<int> val, int capacity) {
    Bag_Init(wet, val, capacity);
    int n = wet.size();
    int rows = ceil(sqrt(capacity));
    
    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < capacity + 1; j++) {
            int max_value = Matrix[i][j-1];  // 将每一格的价值初始化为前一格的价值;
            for (int k = 0; k < j - k; k++) {
                int temp = Matrix[i - 1][k] + Matrix[0][j-k];
                if (temp > max_value) {
                    max_value = temp;
                }
            }
            Matrix[i][j] = max_value;
        }
    }
}


int main() {
    vector <int> weight = {4, 2, 6, 7 , 1, 3};
    vector <int> value = {10, 5, 13, 15, 4, 8};
    int C = 10;

    Bag_Problem(weight, value, C);

    cout << "Construct Matrix : " << endl;
    for (int i = 0; i < ceil(std::sqrt((float)C)); i++) {
        for (int j = 0; j < C + 1; j++) {
            cout << Matrix[i][j] << "\t";
        }
        cout << endl;
    }

    cout << "best carriage : ";
    
    return 0;
}

```
#### 思路2. 从最优子结构入手寻找问题 
**一、最优子结构性质**
对于0-1背包问题, 首先设$w_i$ 为重量， 而$v_i$为价值, 背包总量为$C$; 则对应的问题成为: 

取装入背包为0, 而不装入背包为1, 则所得的向量记为$(x_1, x_2, \dots x_n)$， 则问题表达式成为: 
$$\sum^{n}_{i=1} w_{i} x_{i}\leq  C \quad \rightarrow \qquad  \max  \left(\sum^{n}_{i=1} v_{i} x_{i} \right)$$
其最优子结构性质: 我们首先设$(y_{1}, y_{2}, \dots  y_{n} )$ 为0-1背包问题的最优解答, 则$y_2\dots y_n$为如下的子问题的最优解:
$$\sum^{n}_{i=2} w_{i} y_{i} \leq  C - w_{1} y_{1}\qquad y_{i}\in  \left\{ 0, 1\right\} \quad 2 \leq i \leq n$$
总装入的最大价值即为 **以$C - w_1$为容量下所得的最优解 + 装入物品$w_i$之后获得的$v_i$值**

**二、子问题性质**

| 物品编号 | A | B | C | D | E | F |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $w_i$ | 4 | 2 | 6 | 7 | 1 | 3 |
| $v_i$ | 10 | 5 | 13 | 15 | 4 | 8 |
对于0-1背包问题的子问题, 我们考虑**从前 i 个物品中进行选择, 且在不超过总容量 j 的前提下， 所获得的最大的物品总价值为**$v_{max}(i,j)$, 其中行数$i$ 为选择范围是前$i$个物品， 列数$j$ 为背包容量

考虑对于每一件物品，有装入和不装入两种情况， 而我们仅分这两种情况进行讨论。 即==可以选择装入也可以选择不装入==。 
1. <mark style="background: transparent; color: red">如果装入, 则应当先腾出</mark>$w_i$<mark style="background: transparent; color: red">的空间, 再选取该物品， 即此时背包所剩余的容量为</mark> $j-w_i$, 则对应总价值为$v_{max}(i-1,j - w_{i}) + v_{i}$ ,  而显然容量为 $j - w_i$ 问题下的最好规划已经之前算出来了。 因此可以直接取用。
2. 如果不装入, 则最大价值等于容量为$j$时的 
从而, 我们得到问题的递归式为:
$$v_{\max}(i,j) = \begin{cases} 
\max \left\{ v_{\max} (i - 1,j  - w_{i}) + v_{i} , \quad v_{\max} (i-1, j) \right\} \qquad   w_{i} \leq  j\\
v_{\max} (i-1, j) \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \space w_{i}>j 
\end{cases}$$
其中第二种情况是背包里原先就放不下的情况。 对应建立的表格如图所示: 

| 可选物品i\背包重量j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 无 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| A | 0 | 0 | 0 | 0 | 10 | 10 | 10 | 10 | 10 | 10 | 10 |
| A,B | 0 | 0 | 5 | 5 | 10 | 10 | 15 | 15 | 15 | 15 | 15 |
| A,B,C | 0 | 0 | 5 | 5 | 10 | 10 | 15 | 15 | 18 | 18 | 23 |
| A,B,C,D | 0 | 4 | 5 | 9 | 10 | 10 | 15 | 15 | 18 | 20 | 23 |
| A,B,C,D,E | 0 | 4 | 5 | 9 | 19 | 14 | 15 | 19 | 19 | 22 | 24 |
| A,B,C,D,E, F | 0 | 4 | 5 | 9 | 12 | 14 | 17 | 19 | 22 | 23 | 27 |

因此其解决只需要几行核心代码: 
```cpp title:背包问题核心代码
void Bag_Problem(vector<int> wet, vector<int> val, int capacity) {
    int n = wet.size();
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            if (wet[i-1] > j) {
                Matrix[i][j] = Matrix[i - 1][j];  // 不装入这个
            }
            else {
                Matrix[i][j] = std::max(Matrix[i - 1][j], Matrix[i - 1][j - wet[i - 1]] + val[i - 1] ); // 装入和不装入的最大值
            }
        }
    }
}
```
另外我们需要记录是否装入, 则直接另外给一个reocrd矩阵记录，只需记录上一行对应的某个列即可。 如果发生变化， 则这个物品被选择了。然后使用一个栈进行记录即可

完整代码如下: 
```cpp title:背包问题
#include <iostream> 
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

typedef struct BagItem {
    int weight;
    int value;
    friend bool operator < (const BagItem item1, const BagItem item2){
        return item1.weight < item2.weight;
    }
    BagItem(int weight, int value) : weight(weight), value(value) {};
}Item;

vector<vector<int>> Matrix;
vector <Item> itemVec;
vector <vector<int>> record;
void Bag_Init(const vector<int> wet,const vector<int> val,const int capacity) {
    int n = wet.size();
    for (int i = 0; i <= n; i++) {
        Matrix.push_back(vector<int>(capacity + 1, 0));
        record.push_back(vector<int>(capacity + 1, 0));
    }
}

void Bag_Problem(vector<int> wet, vector<int> val, int capacity) {
    Bag_Init(wet, val, capacity); // 初始化 
    int n = wet.size();
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            if (wet[i-1] > j) {
                Matrix[i][j] = Matrix[i - 1][j];  // 不装入这个
                record[i][j] = j;
            }
            else {
                int val1 = Matrix[i - 1][j];
                int val2 = Matrix[i - 1][j - wet[i - 1]] + val[i - 1];
                if (val1 > val2) {
                    Matrix[i][j] = val1;
                    record[i][j] = j;
                }
                else {
                    Matrix[i][j] = val2;
                    record[i][j] = j - wet[i - 1];
                }
            }
        }
    }
}

int main() {
    vector <int> weight = {4, 2, 6, 7 , 1, 3};
    vector <int> value = {10, 5, 13, 15, 4, 8};
    int C = 10;

    Bag_Problem(weight, value, C);

    cout << "Construct Matrix : " << endl;
    for (int i = 0; i <= weight.size(); i++) {
        for (int j = 0; j <= C; j++) {
            cout << Matrix[i][j] << "\t";
        }
        cout << endl;
    }
    cout << "best carriage : " << Matrix[weight.size()][C] << endl;

    stack<int> stk;
    for (int i = weight.size(), j = C; i != 0; i--) {
        int k = record[i][j];
        if (Matrix[i-1][k] != Matrix[i][j]) {
            stk.push(i);
        }
        j = k;
    }
    cout << "carry item : ";
    while (!stk.empty()) {
        cout << (char)(stk.top() + 'A' - 1) << " ";
        stk.pop();
    }
    return 0;
}
```

上述代码除了输出矩阵以外， 还输出了选择的物品: 
```cpp 
best carriage : 27
carry item : A B E F
```

### (9) 最优二叉搜索树问题
首先, 我们设$S = \left\{ x_{1,}x_{2}, \dots x_{n} \right\}$是有序集 ，且我们以$x_1, x_2, \dots  x_n$ 表示有序集$S$的二叉搜索树， 且对于每个节点， 所对应的左子树节点的值总小于该节点的值； 同时右节点的值总大于对应的值。 这样的树称为一颗搜索树。在数据结构中，二叉搜索树(二叉排序树)可以通过直接插入的方法构建，而由于插入法的失衡问题，也可以通过平衡二叉树(AVL)和红黑树等方法进行构建。

二叉搜索树的构建参考[[📘ClassNotes/⌨️Programming/🌳C (Data Structure & Algorithms)/〽️ Data Structure/第六章 树和二叉树#八、堆存储的概念|堆排序]]以及[[📘ClassNotes/⌨️Programming/🌳C (Data Structure & Algorithms)/〽️ Data Structure/实验大作业/平衡二叉树的失衡情况.pdf|平衡二叉树]] 

首先设有一个二叉搜索树, 对于一个任意的元素$x$, 这个元素**可能在二叉搜索树中可能不在二叉搜索树中**。 设**在二叉搜索树内**找到元素$x = x_{i}$的概率为$b_i$, 而搜索到叶节点还**没有找到**并确定$x_{i} < x < x_{i+1}$的概率为$a_i$; 同时, 约定$x_{0} = -\infty, x_{n+1} = \infty$, 根据元素的排布, 显然没有$x = x_0$以及$x = x_n$, 则对应不同$x$的取值范围对应的概率序列为: 
$$\left\{a_{0},  b_{1}, a_{1}, b_{2}, a_{2}, \dots  b_{n}, a_{n} \right\}$$
此时显然应当有下列条件成立
$$\begin{cases}
a_{i} \geq  0 \qquad \qquad  0 \leq  i \leq  n \\
b_{i} \geq 0 \qquad   \qquad  1 \leq  j \leq  n  \\
\sum^{n}_{i=0} a_{i} + \sum^{n}_{j=1}  b_{i} = 1 
\end{cases}$$
在实际元素的检索中， 往往我们**搜索不同元素的频率是不同的**, 比如在下图的树中， 我们有可能会**实际搜索3较多, 而搜索2较少;  或者多搜索1-2之间的值而少搜索3-4之间的值**, 因此我们可以考虑将搜索概率较多的节点提到较浅的层中去。而**最优搜索二叉树构建就是寻找在给出搜索概率情况下， 求解最优的二叉树的排布方式**。 
![[Excalidraw/第三章 动态规划算法 2024-02-09 13.19.23|550]]
$$\left\{(x_{0}, x_{1}), (x_{1}, x_{2}), \dots (x_{n}, x_{n+1})  \right\}$$

我们设对于表示$S$的二叉树$T$, 存储$x_i$的结点深度为$c_i$;  并用上图的二叉树存储这个序列, **这个二叉树的树内节点为确定的数， 而叶节点分别为**$\left\{(x_{0}, x_{1}), (x_{1}, x_{2}), \dots (x_{n}, x_{n+1})  \right\}$**类似的开区间**，同时设叶节点的深度为$d_j$,  则对应在二叉搜索树中进行一次搜索的比较次数为: 
$$\Large\boxed{p = \sum^{n}_{i=1} b_{i} (1 + c_{i}) + \sum^{n}_{i=0} a_{j} d_{j}}$$
其中$p$定义为**二叉搜索树的平均路长**,  显然, **不同的二叉搜索树的平均路长是不同的**; 而最优二叉搜索树问题是**对于给定的有序集$S$以及给定的存取概率分布**，在**所有表示有序集$S$关于全集($x_{i-1}, \dots  x_{j+1}$)的二叉搜索树中**寻找**平均路长最小**的一颗二叉搜索树。 

我们首先分析二叉搜索树的<b><mark style="background: transparent; color: blue">最优子结构性质</mark></b>: 
1. 我们考虑上述二叉树中， 任一子树应当满足如下条件:  
	- 设树内最小节点为$x_i$, 最大节点为$x_j$, 则含有树内节点$\left\{x_{i}, x_{i+1}, \dots x_{j} \right\}$ 
	- 此时含有叶节点 $\left\{ (x_{i-1}, x_{i}) (x_{i}, x_{i+1}) \dots  (x_{j-1}, x_{j})\right\}$ 

则**在实际搜索过程中，搜索到该子树上的概率**应当为子树下的所有区间的概率之和: 
$$w_{ij} =  a_{i-1}+  b_{i} +a_{i}  + b_{i+1} + \dots  + b_{j} + a_{j}$$
另外说明, 此时如果**仅针对这个子树本身搜索**,  <mark style="background: transparent; color: red">搜到每一个节点上的概率</mark>应当为**每一个结点在原先树中的存取概率除以搜到这个树的概率**，即: 
$$\begin{cases}
a_{k}'  = \frac{a_{k}}{w_{ij}}  \qquad  i-1 \leq  k \leq  j\\
b _{l}' =  \frac{b_{l}}{w_{ij}} \qquad  i \leq  l \leq  j 
\end{cases}$$
二叉搜索树的<b><mark style="background: transparent; color: blue">最优子结构性质</mark></b>在于，当$T$是一颗最优二叉搜索树时, 显然其**任一子树$T_{ij}$都是关于该存取概率的一颗最优二叉搜索树**， 即二叉树的子树也是最优的。 

首先， 我们考虑该问题的递归结构: 
我们设**对于树中的某一棵子树结构**， **左子树的平均搜索长度**为$p_l$, **搜索概率**$w_l$(显然等于左子树根节点的w值), 而右子树**平均搜索长度**为$p_r$, 搜索概率$w_r$, 搜索到根节点的概率为$w_{ij}$,
$$\begin{cases}
p_{l} =  \sum^{n}_{i=1} b_{i}(1 + c_{i}) + \sum^{n}_{j=0}  a_{j} d_{j}  \quad (左子树) \\
p_{r} = \sum^{n}_{i=1} b_{i}(1 + c_{i}) + \sum^{n}_{j=0}  a_{j} d_{j}\quad  (右子树)  \\
\end{cases}$$
则<b><mark style="background: transparent; color: red">我们在子树中， 每搜索一次，在左子树中平均搜索的次数定义为左子树的平均路长</mark></b>, 由于搜到子树根节点的概率为$w_{ij}$, 所以如果**仅从子树根节点的位置向下搜索**，则**从子树根节点**每搜1次平均在**左子树中搜索的次数**为$\frac{w_{l}}{w_{ij}}  \times p_{l}$, 这个就是<b><mark style="background: transparent; color: blue">左子树的平均路长</mark></b>。 
同理每搜索1次平均**在右子树中搜索的次数**为$\frac{w_{r}}{w_{ij}}  \times p_{r}$, 而**搜索根节点的次数为1**, 显然, **平均在子树中搜索1次的长度即为子树的平均路长**$p_{ij}$,  因此我们得到关系为: 
$$p_{ij} = 1 + \frac{w_{l}}{w_{ij}} p_{l} + \frac{w_{r}}{w_{ij}} p_{r}$$
上式可以改写为: 
$$\Large\boxed{p_{ij} w_{ij} = w_{ij} + p_{l}  w_{i-1, m} + p_{r} w_{m+1, j} }\tag{1}$$
其中$m$为$T_{ij}$根节点上的元素。显然，我们**只需在合并时将对应根节点上的$m$值枚举出来, 使其计算出的平均路长$p_{ij}$达到最小**, **则子树是最优二叉搜索树**。 

在下图右侧的树中， 显然**对仅含一个树内节点和两个叶节点的子树而言**, 例如下图根节点为3的子树部分, **由于仅是判断大于, 等于或者小于, 搜索长度显然为1**，<u>从而：为了将与两个叶节点相连的节点路长设为1, 只需将叶节点路长设置为0即可</u>。 

因此，我们可以利用下图的矩阵记录每一个根节点处的最短平均搜索路长$p_{ij}$。**其中$p_{ij}$表示的是**==**含有树内节点元素$\left\{ x_{i}, x_{i+1}, \dots x_{j}\right\}$的子树对应的平均路长**==。因此在**初始化时,  我们可以使用$p(i,  i-1)$表示叶节点对应区间的$p_{ij}$值并初始化为0**, 也即**将$p_{i,i-1}$初始化为0**。
例如$(-Inf -1)$的部分可以由p(1,0)表示, 而拼接方法是$p(1,1) = p(1,0) + w(1,1) * 1 + p(2,1)$ (其中假设拼接时右子树也为叶子节点) 
![[Excalidraw/第三章 动态规划算法 2024-02-09 15.55.54|1100]]
**例如前面的$p_{12}$的获取方式，对应两种二叉树的连接结构如下**, 我们只需要求取其中的最短平均路长即可: 
![[Excalidraw/第三章 动态规划算法 2024-02-09 16.51.27|700]]
因此按照最优子结构性质， 可以建立$p_{ij}$的递归式，即**将元素i -> k-1放在左子树上, 而 k+1 -> j 放在右子树上**的最小情况(**其中, $w_{ij}$ 是从大于$x_{i-1}$且小于$x_{j+1}$区间部分的概率, 即向(i,j)区间进行搜索的概率**, 由于每个部分取到的概率已经事先给定, 因此$w_{ij}$容易事先算出)。
从而得到<b><mark style="background: transparent; color: blue">迭代公式</mark></b>为:
$$w_{ij}p_{ij} = w_{ij}  + \min_{i \leq  k \leq  j} \left\{w_{i, k-1} p_{i, k-1} + w_{k+1, j} p_{k+1,  j}\right\}\tag{2}$$
其中初始化条件是叶子节点的搜索长度为0，即:
$$p_{i,i -1} = 0\qquad (初始化值)\tag{3}$$
(2), (3)即为矩阵计算的基本迭代公式。 

在程序中,  为了方便计算， 我们使用一个Matrix, 其中每个元素为 $Matrix [i][j]=w_{ij} p_{ij}$ , 因此迭代公式就变成:
$$Matrix[i][j] =  w_{ij} + \min_{i\leq  k\leq  j} \left\{Matrix[i][k-1] + Matrix[k+1][j] \right\} $$
显然, 最终求解得到的最优值为$p_{1,n}$, 即从$1-n$内的最短平均路长, **而$p_{1,n} w_{1,n}$是$Matrix[1][n]$, 即为矩阵的右上角的值**。另外, 由于$w_{1,n} = 1$, 则$Matrix[1][n] = p_{1,n}$, 即右上角直接就是所求的值。 (由于取用时已经限制了范围， 不会出现重复选取情况) 

另外需要注意的是, 为了都计算到,  应当按照行进行逆序计算。核心代码很简短， 如下所示: 
```cpp title:最优二叉搜索树核心代码
void BestBinryTreeSolution(vector<int> nodes , vector<float> weight) {
    int n = nodes.size();
    // 为了先计算出单个节点的值, 从后向前计算 
    for (int i = n; i >= 1; i--) {
        for (int j = i; j <= n; j++) {
            float maxi = Matrix[i][i-1] + Matrix[i+1][j] ; 
            for (int k = i; k <= j; k++) {
                // 注意这里中间值是k
                float res = Matrix[i][k - 1] + Matrix[k + 1][j]; // 有多余, 不改了
                if (res < maxi) maxi = res;
            }
            Matrix[i][j] = w_[i - 1][j - 1] + maxi; // 注意坐标转换
        }
    }
}
```

我们以下面一组输入为例，获得对应输出: 
```cpp 
// 输入示例
vector<int> nodes{1, 3, 4, 6, 9, 10};
vector<float> weight = { 0.01886792, 0.1509434 , 0.05660377, 0.01886792, 0.0754717 ,\
   0.05660377, 0.11320755, 0.03773585, 0.09433962, 0.01886792,\
   0.0754717 , 0.11320755, 0.16981132 };
// 相应输出 
0       0       0       0       0       0       0
0       0.22642 0.4717  0.96226 1.3396  1.717   2.6226
0       0       0.15094 0.4717  0.84906 1.2075  1.9623
0       0       0       0.24528 0.62264 0.90566 1.6604
0       0       0       0       0.24528 0.5283  1.1509
0       0       0       0       0       0.18868 0.66038
0       0       0       0       0       0       0.35849
0       0       0       0       0       0       0
```

另外, 我们考虑如何获取二叉树的结构: 在核心函数中定义一个矩阵记录左右子树的来源, 显然我们组装矩阵时， 用`maxi = Matrix[i][i-1] + Matrix[i+1][j]` ， 对应的是以i-1和i+1分别作为左子树和右子树的。 最后递归获取结果即可。

在上述循环中，我们在第三层循环中实际上是枚举以$k$为根节点的情况, 最后通过深度优先搜索dfs确定

```cpp title:最优二叉搜索树完整代码
#include <iostream>
#include <vector> 
#include <algorithm>
#include <iomanip>   // 格式化输出控制
using namespace std;

float sum(vector<float> s, int begin, int end) {
    float res = 0;
    for (int i = begin; i <= end; i++) res += s[i];
    return res;
}

struct trice {
    int val;  // val 为根节点 
    int from; // from 为第一个来自的列
    int to;   // to   为第二个来自的行
    trice(int val, int from, int to) : val(val), from(from), to(to) {};
};

vector<vector<float>> w_; // 权重和
vector<vector<float>> Matrix; // 平均路长
vector<vector<trice>> record;
void Init(vector<int> nodes, vector<float> weight) {
    int n = nodes.size();
    // 初始化数组w_
    for (int i = 0; i < n; i++) {
        w_.push_back(vector<float>(n, 0));
        for (int j = i; j < n; j++) {
            w_[i][j] = sum(weight, 2 * i, 2 * j + 2);
        }
    }
    // 初始化数组 p_ij
    for (int i = 0; i < n+2; i++) {
        Matrix.push_back(vector<float>(n+1, 0));
    }
    for (int i = 0; i < n+2; i++) {
        record.push_back(vector<trice>(n+1, trice(0,0,0)));
    }
    // 初始化record 的根节点。
    for (int i = 0; i <= n; i++) {
        record[i][i].val = i;  // 根节点设置
    }
}

void BestBinryTreeSolution(vector<int> nodes , vector<float> weight) {
    int n = nodes.size();
    // 为了先计算出单个节点的值, 从后向前计算 
    for (int i = n; i >= 1; i--) {
        for (int j = i; j <= n; j++) {
            float maxi = Matrix[i][i-1] + Matrix[i+1][j];
            record[i][j] = trice(i, i - 1, i + 1); // 以i为根节点，取自i-1列,i+1行;
            for (int k = i; k <= j; k++) {
                // 注意这里中间值是k
                float res = Matrix[i][k - 1] + Matrix[k + 1][j]; // 有多余, 不改了
                if (res < maxi) {
                    maxi = res;
                    record[i][j] = trice(k, k - 1, k + 1); // 修改记录值
                }
            }
            Matrix[i][j] = w_[i - 1][j - 1] + maxi; // 注意坐标转换
        }
    }
}

// 深搜输出结果
void dfs(int i, int j) {
    if (record[i][j].val == 0) return;
    int l = record[i][j].from;
    int r = record[i][j].to;

    if (record[i][l].val!= 0) cout << record[i][j].val << " -> " << record[i][l].val << endl;
    if (record[r][j].val!= 0) cout << record[i][j].val << " -> " << record[r][j].val << endl;
    dfs(i, l);
    dfs(r, j);
}

int main() {
    vector<int> nodes{1, 3, 4, 6, 9, 10};
    vector<float> weight = { 0.01886792, 0.1509434 , 0.05660377, 0.01886792, 0.0754717 ,\
       0.05660377, 0.11320755, 0.03773585, 0.09433962, 0.01886792,\
       0.0754717 , 0.11320755, 0.16981132 };  // 存取概率定义, 按照a_i-1, b_i, a_i .... 顺序定义

    Init(nodes, weight);
    BestBinryTreeSolution(nodes, weight);
    int n = nodes.size();

    for (int i = 0; i < n + 2; i++) {
        for (int j = 0; j < n + 1; j++) {
            cout << std::setprecision(5) << Matrix[i][j] << "\t";
        }
        cout << endl;
    }

    cout << "minimum average distance : " << Matrix[1][n] << endl;
    
    dfs(1, n);

    return 0;
}

```

输出入下: 
```cpp title:输出
0       0       0       0       0       0       0
0       0.22642 0.4717  0.96226 1.3396  1.717   2.6226
0       0       0.15094 0.4717  0.84906 1.2075  1.9623
0       0       0       0.24528 0.62264 0.90566 1.6604
0       0       0       0       0.24528 0.5283  1.1509
0       0       0       0       0       0.18868 0.66038
0       0       0       0       0       0       0.35849
0       0       0       0       0       0       0
minimum average distance : 2.6226
3 -> 1
3 -> 6
1 -> 2
6 -> 4
4 -> 5
```

另外我们给出最终建立的二叉树和平均路长的计算办法
根据程序输出我们可以得到使用相应数据**建立的二叉树为下图的二叉树**: 
![[Excalidraw/第三章 动态规划算法 2024-02-09 19.27.46|600]]
此时, 最优平均路长的计算**根据平均路长的定义进行获取**, 并计算为 : 
1 *  3/53 + 2 * (8/53 +6/53 +9/53 + 1/53) + 3 * (1/53 + 2/53+ 3/53 +4/53 +6/53) + 4 * (1/53 + 5/53 + 4/53) 
结果为 2.6226415094339623, 即为我们要解出的最短平均路长。

> [!seealso] 补充
> 对于带权的二叉树的平均最短搜索长度问题, 另外还有一类相似的问题即哈夫曼树与哈夫曼编码问题。而哈夫曼编码是使用贪心算法进行解决的。 


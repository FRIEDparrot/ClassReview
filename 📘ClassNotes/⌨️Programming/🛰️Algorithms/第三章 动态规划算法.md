## 一、动态规划及其基本概念
### (1) 基本概念
动态规划算法的基本思想是将待求解的问题**划分为多个子问题, 并从子问题获取初始问题的解**。虽然与二分方法类似, 但是**对于动态规划所求解的问题, 分解获取到的子问题往往不是独立的**, 而其基本思想是先分配一个记录表并将计算获取的基本问题结果填入表中, 当再次出现时直接获取。

往往动态规划的算法用于求最优化问题的基本步骤如下: 
1. 寻找最优解的性质, 并刻画其结构特征 
2. 递归地定义最优值 
3. 按照自底向上的方式求解出最优值  
4. 根据计算最优值时得到 的信息，构造最优解。

### (2) 动态规划方法的两大基本要素
动态规划算法的有效性依赖于: 
1. <mark style="background: transparent; color: red">最优子结构</mark> :  对于最优化的问题, 其子结构也是最优的, 这种性质称为最优子结构性质。 而具有此种性质的算法往往可以使用动态规划进行解决
2. <mark style="background: transparent; color: red">重叠子问题</mark> : 在递归调用和自顶向下求解问题时， 每次产生的子问题一般不是新问题。 往往在问题解决过程中， 需要重复调用子问题的结果，而子问题仅解决一次即可。

另外对于是否为最优子结构的证明， 可以假设子问题不是最优的, 并推出矛盾。 

### (3) 备忘录方法
备忘录方法是动态规划算法的变形之一, 也是使用表格保存已经解决子问题的答案, 而下次需要求解时只需获取解答即可， 而备忘录方法和动态规划的**递归方式区别**是,  **动态规划是自底向上进行递归的, 即先解决子问题，再大问题调用子问题; 而备忘录方法的递归方式是自顶向下递归的, 即存储时存储特殊值表示子问题是否是第一次遇到,  如果是第一次遇到则进行计算, 否则取出已经计算好的值**。<mark style="background: transparent; color: red">备忘录方法适用于重复子问题较多且不一定所有都要求解的情况</mark>。 **而当一个问题的所有子问题都至少需要解决一次时, 动态规划一般优于备忘录方法**。

例如下面的矩阵问题中， 也可以使用一个二维数组存储子问题是否计算过; 然后自顶向下递归调用。

## 二、相关问题
### (1) 矩阵连乘最优次序问题
对于两个矩阵相乘， 假设其是$p \times q$矩阵和$q\times r$ 矩阵, 显然需要做的运算个数是$p \times q \times  r$, 且获得的矩阵规模是$(p \times  r)$, 而对于不同矩阵的连乘, 例如有第三个矩阵为 $r \times  s$ 矩阵, 则需要做的运算方式为:
$$(A_{1} A_{2}) A_{3} = (p \times  q \times  r ) + (p \times  r \times  s) = pr (q  + s)$$
而如果使用 $A_1(A_2 A_3)$, 则运算次数为: 
$$(p \times q \times  s) +  (q \times  r \times  s ) + qs(p + r)$$
显然**运算次数是不相同的**,  即在矩阵连乘中的加括号方式可能会极大地影响运算次数。

我们考虑**对于$n$个矩阵进行连乘的优化问题**, 显然如果用穷举法, 则可以视为每2个都要多递归划分一次括号, 复杂度呈指数增长,  显然不是优化的算法。
s
对于划分矩阵连乘的最优解, <b><mark style="background: transparent; color: red">关键特征是对于整体的最优化问题, 局部也是最优化的， 则这样的问题可以使用动态规划思路进行求解</mark></b>,  即<b><mark style="background: transparent; color: blue">具有最优子结构性质</mark></b>。 即对于一个最优的矩阵连乘划分, <mark style="background: transparent; color: blue">其括号内部的部分也是最优括号划分</mark>。 

我们考虑利用如下的算法解决问题:  以$A_{1}A_{2}A_{3}A_{4}$相乘为例, 其中$A_1 - A_4$的规模分别为 
$$15 \times  5\qquad 5\times 10\qquad  10\times 20 \qquad 20 \times  25$$
首先分解子问题, 计算**每相邻的两个矩阵乘积的最小值**(即子问题)并写在第一行。
则如果一次仅考虑加入一个组合, 则可以列出如下表格(我们可以记为矩阵$A$): 

| 列 | 1 | 2 | 3 |
| ---- | ---- | ---- | ---- |
| 1 | $15 \times  5 \times  10$ (1,2组合) | $5\times 10\times 20$ (2, 3组合) | $10\times20\times 25$ (3,4组合) |
| 2 |  | $\min [(1,1) + 15 \times 10 \times  20,  (1,2) + 15 \times 5 \times  20)$ (1-3组合) | $\min [(1,2) + 5 \times 20 \times 25 ,  (1, 3) + 5 \times  10 \times  25]$ (2-4组合) |
| 3 |  |  | var (1- 4组合)  |
需要说明, <mark style="background: transparent; color: red">这个计算方法仅适用于前两行</mark>， 由于对于第三行时, 就遇到**两个大部分组合的问题**， 例如
$(A_1A_2)(A_3A_4)$ 既不是左乘的情况也不是右乘的情况， (上述只列出了((AB)C)D和(A(BC))D, 仅是左乘或者右乘的情况) ， 此时我们需要考虑两两组合相乘的情况: 

为了将后面的两个组合情况考虑进去 , **由于两个组合的结果已经计算出来**, 可以直接调用，**但是此时需要注意的是**, <mark style="background: transparent; color: red">除了两个部分的各自运算量， 也要加上相互的运算量</mark>, 即除了$A_1A_2$和$A_{3},A_{4}$取出, 还需要加上 $r(A_{1}) \times c(A_{2}) \times c(A_{4})$。
$$\text{var} = \min \begin{cases}
(2, 2) + 15 \times 20 \times25  \\
 (2,3) + 15 \times 5 \times  25   \\
 (1, 1) + (1, 3) + r(A_{1}) \times c(A_{2}) \times c(A_{4})
\end{cases}$$
括号内每一个元素对应(其中三括号内已经最小)
$$ (A_{1} A_{2} A_{3}) A_{4}, \quad   A_{1}(A_{2}A_{3} A_{4}) \quad  (A_{1} A_{2})(A_{3} A_{4})$$

需要说明的是, 由于每一次总是任意的划分为**两部分(仅两部分)**, 所以曾经求出的任何分解的两部分也可能成为最小, 即对于$A_1 - A_5$, 也可以是下列两种拆分方法, 
$$(A_{1}A_{2} A_{3})(A_{4} A_{5})  \qquad  (A_{1} A_{2}) (A_{3} A_{4}A_{5})$$
这个拆分的取法对应如下图的斜对角线分布, 且从第3行开始时, 会出现此种拆分方式。
![[Excalidraw/第三章 动态规划算法 2024-01-30 15.53.13|550]]
上述表格所获得的最后一格(3,3)即为最小需要的计算次数, 此时, 按照此种方法进行计算即可。

程序中另外一个难点就是如何将划分的间隔进行记录的方法。
- 在记录时，同样定义一个二维向量(即矩阵), 由于在上述的二维矩阵下每一格中,  仅是两种拆分方式的区别,  此时在每一种拆分方式下,  **记录这一种方式的拆分相对位置**即可。
- 在输出时，使用递归的思想,  首先找到右下角的拆分相对位置, 增加一个静态变量记录每个位置的符号数量， 并递归调用函数确定每个位置符号数即可
我们将符号相对位置记录如下: 
$$\sim A_{1}\sim A_{2}\sim A_{3}\sim$$
其中第一个$\sim$ 位置为0(也就是默认没有括号), 后面的分别记为1, 2, 3... 等，此时， 所有组合的括号划分也形成另一个矩阵$B$。
在下面的程序中, 输入为两行已经定义好的向量, (提供了两组测试数据) 
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> Matrix;
/// <param name="rowVec">row Vecotr</param>
/// <param name="colVec">column Vector</param>
/// <param name="signal">n-1 x -1 向量, 返回符号位置</param>
/// <returns>最小运算次数 </returns>
int BestMatrixChain(vector<int> rowVec, vector<int> colVec, vector<vector<int>> &signal) {
    if (rowVec.size() == 1 || rowVec.size()!= colVec.size()) return 0;

    int n = rowVec.size() - 1;
    for (int i = 0; i < n; i++) {
        // 构造 n-1 x n-1的矩阵
        Matrix.push_back(vector<int>(n, 0));
    }
    // 首先初始化第一行
    for (int i = 0; i < n ; i++) { 
        Matrix[0][i] = rowVec[i] * rowVec[i + 1] * colVec[i + 1]; // 获取两两相乘
        signal[0][i] = 0;  // 结果是 AB, 不加括号
    }
    for (int i = 1; i < n ; i++) {
        for (int j = i; j < n; j++) {
            // 注意: 从第1行开始对应的列应该是第2列, 则使用j + 1表示, 而另外一个是
            // rowVec[j - i] 为前面最开始部分的索引， 这个需要进行注意;
            int res = Matrix[i - 1][j] + rowVec[j - i] * colVec[j - i] * colVec[j + 1]; // 1 x (2 x 3) 方式 
            signal[i][j] = 1; // 初始插板位置为1
            
            // 斜组合拆分方式, 最坏不超过 O(n^3) 的复杂度。
            for (int k = 0;  k  <= i - 2; k++) {
                int res1 = Matrix[k][j-i+k] + Matrix[i-2-k][j] + rowVec[j-i] * colVec[j - i + k + 1] * colVec[j + 1];
                // 注意需要加上两个相乘的运算量
                if (res1 < res) {
                    res = res1;
                    signal[i][j] = k + 2;
                }
            }
            int res1 = Matrix[i - 1][j - 1] + rowVec[j - i] * rowVec[j + 1] * colVec[j + 1]; // (1 x 2) x3方式
            if (res1 < res) {
                res = res1;  signal[i][j] = j + 1 - (j-i);
            }
            Matrix[i][j] = res;
        }
    }
    return Matrix[n-1][n-1];
}

// 利用递归的方法输出结果, left 是左边下标(从A0开始), 而right为右边下标
void Output(vector<vector<int>> &signal, bool output, int left, int right) {
    if (left == right) return;
    int n = signal.size();
    // 静态变量, 不会随函数释放而重置
    static vector<int> left_bracket(signal.size() + 2, 0);  
    static vector<int> right_bracket(signal.size() + 2, 0);

    int parti = signal[right - left -1][right -1]; // partition location
    
    if (parti!= 0){ // =0时不分割
        if (parti != 1) { left_bracket[left]++; right_bracket[left + parti]++; }
        if (parti != right - left) { left_bracket[left + parti]++; right_bracket[right + 1]++; }

        Output(signal, false, left, left + parti - 1);  // 其中, parti是1时，输出区间仅有一个数,不加括号
        Output(signal, false, left + parti, right);
    }


    // 输出函数
    if (output) {
        for (int i = 0; i < n + 2; i++) {
            for (; right_bracket[i] > 0; right_bracket[i]--) cout << ")";
            for (; left_bracket[i] > 0; left_bracket[i]--) cout << "(";
            if (i <= n )cout << "A" << i;
        }
        cout << endl << endl;
    }
}

void Output2(vector<vector<int>> &signal) {
    int n = signal.size();
    // 输出构建的两个矩阵
    cout << "======= Matrix Output: ============" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << Matrix[i][j] << "\t";
        }
        cout << endl;
    }
    // 输出符号矩阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << signal[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // 注意一定要输入合法, 此处略去合法性检查
    vector<int> rowVec{ 30, 35, 15, 5, 10 , 20 };
    vector<int> colVec{ 35, 15, 5, 10, 20 , 25 };
    // 也可以用下面的一组做测试, 结果为7500
    // vector<int> rowVec{ 10 , 100, 5 };
    // vector<int> colVec{ 100, 5, 50 };

    vector<vector<int>> signal;
    for (int i = 0; i < rowVec.size() - 1; i++) {
        signal.push_back(vector<int>(rowVec.size() - 1, 0));
    }
    int best_time = BestMatrixChain(rowVec, colVec, signal);
    cout << "miniest calculate time: " << best_time << endl;
    
    Output(signal, true, 0, rowVec.size() - 1);
    Output2(signal);
    return 0;
} 
```
例如对于下面的一组测试数据: 

|  | A0 | A1 | A2 | A3 | A4 | A5 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| row | 35 | 35 | 15 | 5 | 10 | 20 |
| col | 35 | 15 | 5 | 10 | 20 | 25 |
所得结果如下: (下面的Matrix  Output 是输出矩阵$A$和$B$) 
![[attachments/Pasted image 20240130191225.png|400]]

### (2) 最长公共子序列(LCS)问题
我们设有一个序列$X = \{x_1, x_2, \dots x_n \}$,  此时**存在一个严格递增的下标序列**(<b><mark style="background: transparent; color: blue">需要注意可以不连续</mark></b>)$i_{1}, i_{2}, \dots i_{n}$, 对应的序列 $\left\{x_{i1}, x_{i2}, \dots x_{in} \right\}$ 称为序列$X$ 的子序列。
另外， 有另一个序列 $Z = \{ z_{1}, z_{2} , \dots z_{n}\}$,  取其一同等长度的子序列$\left\{ j_{1}, j_{2}, \dots j_{n} \right\}$, 此时如果有:
$$\left\{x_{i1}, x_{i2}, \dots x_{in} \right\} = \left\{z_{j1}, z_{j2}, \dots  z_{jn} \right\}$$
则称为<b><mark style="background: transparent; color: blue">公共子序列</mark></b>
例如: $X = \left\{ A, B, C, B, D, A,B\right\}, Y= \left\{ B, C, A, C \right\}$, 则其最长公共子序列为$\left\{ B, C,A \right\}$
对于最长公共子序列问题, 方法一是**将所有的序列都枚举出来**然后再使用双指针比较, 但是2个元素序列, 有$C_n^2$个; 3个序列有$C_n^3$个，实际枚举循环极其繁琐。

显然, 最长公共子序列的子结构也是公共子序列, 因此<b><mark style="background: transparent; color: blue">公共子序列问题具有最优子结构性质</mark></b>,  可用动态规划算法解决; 
同时, 由于**求解$n$个元素的子序列时， 可能需要求解n-1个元素子序列**, 即<b><mark style="background: transparent; color: blue">具有重复子问题性质</mark></b>

本问题的递归定义方式如下: 
1. **我们考虑**$X_{m}$和$Y_{n}$这两个序列, 对于$X_{n-1}$和$Y_{n-1}$; 首先: 当$X_{m} = Y_{n}$时, 显然$X_{n-1}$和$Y_{n-1}$的最长公共子序列只需要加上 $X_{n}, Y_{n}$即可成为最长子序列; 
2. 当$X_m \neq Y_n$时, **需要解决两个子问题, 即**$X_{n}$和$Y_{n-1}$的最长公共子序列; 以及$X_{n-1}$和$Y_{n}$的最长公共子序列； 由于$X_{m} \neq  Y_{n}$, 则最长公共子序列显然在$X_{m-1}, Y_{n}$中或者在$X_{m} Y_{n-1}$中; 即取$X_{m-1}, Y_{n}$或者$X_{m} Y_{n-1}$公共子序列的最大者为$X_{n} Y_{n}$的最大子序列。 

因此可以得到下面的递归结构:
$$f(m, n) = \begin{cases}
f(m-1,n-1) + 1, \qquad  X(m) = Y(n) \\
\max \left(f(m,n-1), f(m-1, n)\right)  \qquad X(m) \neq Y_{n}  \\
0, \qquad  \qquad  m = 0 \text{ or } n = 0
\end{cases}$$
另外需要注意的是, 由于两个序列不是相同长度的, 显然上述递归方法已经考虑了长度不同的问题。 

核心代码极为简单, 代码如下:
```cpp
int LCS(vector<int>& vec1, vector<int>& vec2, int m, int n) {
    if (m == 0 || n == 0) return 0;

    if (vec1[m-1] == vec2[n-1]) {
        return LCS(vec1, vec2, m-1, n-1) + 1;
    }
    return max(LCS(vec1, vec2, m - 1, n), LCS(vec1, vec2, m, n - 1));
}
```
同时考虑到输出问题, 为了输出最长公共子序列, 修改为如下代码: (向量使用 & 时可以整体赋值, 相当于copy)
```cpp
#include <iostream>
#include <vector> 
using namespace std;

// 最长公共子序列问题
/// <param name="m">初始输入为 vec1 的长度 </param>
/// <param name="n">初始输入为 vec2 的长度 </param>
/// <param name="max_vec"> 输入新向量,用于记录
int LCS(vector<int>& vec1, vector<int>& vec2, int m, int n, vector<int> &max_vec) {
    vector<int> max_vec1, max_vec2;  // 新建两个用来记录, 底层返回

    if (m == 0 || n == 0) { max_vec.clear(); return 0; }
    if (vec1[m-1] == vec2[n-1]) {
        int res = LCS(vec1, vec2, m - 1, n - 1, max_vec1) + 1;
        max_vec = max_vec1;
        max_vec.push_back(vec1[m - 1]);
        return res;
    }
    else {
        int res1 = LCS(vec1, vec2, m - 1, n, max_vec1);
        int res2 = LCS(vec1, vec2, m, n - 1, max_vec2); 
        // 注意-> 当有两个相同长度的公共子序列时,选用任意一个均可
        if (res1 >= res2) {
            max_vec = max_vec1;
            return res1;
        }
        else {
            max_vec = max_vec2;
            return res2;
        }
    }
}

int main() {
    vector<int> A = { 2, 4, 8, 5, 3, 11, 13, 18};
    vector<int> B = { 2, 5, 6, 3, 2 ,18, 20 };
    vector<int> max_vec;
    cout << LCS(A, B, A.size() , B.size(), max_vec) << endl;
    // 随便输出一个最长子序列
    for (int i = 0; i < max_vec.size(); i++) {
        cout << max_vec[i] << " ";
    }
    return 0;
}
```

### (3) 多边形的三角剖分问题
我们考虑凸多边形的最优三角剖分问题：
首先，我们使用<mark style="background: transparent; color: red">多变形顶点的逆时针序列</mark>表示凸多边形。(下图是示意图， 但边是按顺时针给的) 
显然， 对于多边形$P= \left\{ v_{0}, v_{1}, v_{2}, \dots  v_{n} \right\}$, 则其任意两个不同顶点的连线$v_i v_j$构成一条弦。
![[Excalidraw/第三章 动态规划算法 2024-02-01 10.06.00|700]]
在剖分过程中， 要求
1. **各个三角形的线(弦)互不相交**， 同时集合T已经达到最大,  即 $P$ 的任一不在 $P$ 中的弦必与 $T$ 中的某个弦相交。同时,  在有n个顶点的凸多边形三角形剖分中, 恰有n-1条弦和 n-2 个三角形
2. 定义<mark style="background: transparent; color: red">最优三角形剖分性质</mark>: 定义在**多边形的边和弦组成的三角形上的权函数** $w$ , 确定凸多边形的三角形剖分， 使得<b><mark style="background: transparent; color: blue">三角形上的权值之和为最小</mark></b>。
3. 本程序中, 为了尽可能地让三角形剖分都接近正三角形， 可以定义权函数为三边长度的方差: 
$$weight = (v_{i}v_{j} - v_{i} v_{k})^{2} + (v_{i} v_{j} - v_{j} v_{k})^{2} + (v_{i} v_{k} - v_{j}v_{k})^{2}$$
首先, 整体的三角形最优权函数剖分问题， 局部也是最优的, <b><mark style="background: transparent; color: blue">具有最优子结构性质</mark></b> 
重复子问题: 每一次都是将多边形寻找一种方式划分为两个小的; 如果是4个顶点就继续划分为两个。因此这个问题与计算矩阵连乘的最优次序的加括号问题完全类似。即每一次合并两个部分。 

将<b><mark style="background: transparent; color: blue">上述结构总结起来可以获得如上图的二叉树结构</mark></b>。要求每一次合并两个节点, 寻求一种权值之和最小的合并方式。

在上述图形中， 我们考虑基于边和弦的合并方式，如下图所示。首先, 任意形状由连续的边构成, <mark style="background: transparent; color: red">合并时只要使用两个形状加一条弦就行了</mark>(其中, 边也看成是弦)
![[Excalidraw/第三章 动态规划算法 2024-02-01 14.09.40]]
每合并一次, 新增一个三角， 此时将其权值加入即可。 因此实际上与矩阵求解最少运算量完全相同。 
但与前面问题不同的是, 需考虑循环合并的问题。 因此，任意合并完之后还是6个不同形状， 实际上形成了一个满的矩阵。

下面我们以6个节点为例, 建立如下表格, 另外, 1-2, 2-3等等只需记为0即可, 所有的结果都可以由上面结果组装加上一步计算而成。
![[Excalidraw/第三章 动态规划算法 2024-02-01 12.02.04|600]]
其中, 每个表格填入对应的权值, 而每次新计算权值时, 传入对应的点即可。

首先我们给出带有输出的暴力递归解法, 这个解法的复杂度是指数的， 用于检验解答的正确性 : 
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct point {
    int x;
    int y;
    point(int x, int y) : x(x), y(y) {};
};


float Get_weight(point A, point B, point C) {
    // 函数内部使用lambda表达式定义函数内部函数
    auto distance = [](point m, point n) {
        return std::sqrt(pow(m.x - n.x, 2) + pow(m.y - n.y, 2));
    };
    float a = distance(A, B), b = distance(A, C), c = distance(B, C);
    return pow(a - b, 2) + pow(a - c, 2) + pow(b - c, 2);
}

/// <summary>
/// 暴力递归拆分方法, 暴力枚举拆分方式, 直到拆分剩余2个时, 进行计算
/// </summary>
/// <param name="points">长度n点向量</param>
/// <param name="index_vec">[0,1, .... n-1]</param>
/// <param name="record_vec">用于记录, 输入空向量即可</param>
/// <returns></returns>
float Violet_Split(vector<point> points, vector<int> index_vec, vector<int>& record_vec) {
    float minres = 3.4e38;             // 记录最小值
    int length = index_vec.size();     // 点的个数

    if (length <= 2) throw exception("split err ");  // 仅有一条线或者一个点

    if (length == 3) {
        record_vec = index_vec; record_vec.push_back(-1);

        point A(points[index_vec[0]].x, points[index_vec[0]].y);
        point B(points[index_vec[1]].x, points[index_vec[1]].y);
        point C(points[index_vec[2]].x, points[index_vec[2]].y);
        float minres = Get_weight(A, B, C);
        cout << " calcu triangle " << index_vec[0] << ", " << index_vec[1] << ", " << index_vec[2];
        cout << "  --------->     res : " << minres << endl;
        return minres;
    }

    vector<int> subrecord1;
    vector<int> subrecord2;

    // 否则从index_vec中取得两个形状对应的点, 返回两个形状之和
    for (int i = 0; i < index_vec.size() - 1; i++) {  // 最大不超过
        int m = index_vec[i];
        for (int j = i + 2; j < index_vec.size() - 1; j++) {
            vector<int> new_index1, new_index2;

            cout << "check:  ";
            for (int k = i; 1; k = (k + 1) % index_vec.size()) {
                new_index1.push_back(index_vec[k]);
                cout << index_vec[k] << " ";
                if (k == j) break;
            }
            cout << "   remain : ";
            for (int k = j; 1; k = (k + 1) % index_vec.size()) {
                new_index2.push_back(index_vec[k]);
                cout << index_vec[k] << " ";
                if (k == i) break;
            }
            cout << "    " << endl;
            float res = Violet_Split(points, new_index1, subrecord1) + Violet_Split(points, new_index2, subrecord2);
            if (res < minres) {
                minres = res;
                record_vec = subrecord1;
                record_vec.insert(record_vec.end(), subrecord2.begin(), subrecord2.end());
                // 使用insert 进行向量拼接
            }
        }
    }

    cout << "minimum for ";
    for (int i = 0; i < index_vec.size(); i++) {
        cout << index_vec[i] << " ";
    }
    cout << " is " << minres << endl;
    return minres;
}

int main() {
    // 按照逆序给出的多边形顶点
    vector<int> x = { 27, 39, 39, 22, 12, 12 };
    vector<int> y = { 12, 22, 33, 38, 29, 19 };

    vector<point> point_vec;
    vector<int>   record_vec;
    for (int i = 0; i < x.size(); i++) {
        point_vec.push_back(point(x[i], y[i]));
    }

    float res = Violet_Split(point_vec, { 0, 1, 2, 3, 4, 5 }, record_vec);
    cout << endl << endl;
    cout << "final weight sum : " << res << endl;
    cout << "Best Split : ";
    for (int i = 0; i < record_vec.size(); i++) {
        if (record_vec[i] == -1) cout << "  |  ";  // 使用 | 进行输出划分
        else cout << record_vec[i] << " ";   
    }
    
    return 0;
}
```
上述方法对于两组向量表达输入的多边形:
```cpp
vector<int> x = { 27, 39, 39, 22, 12, 12};
vector<int> y = { 12, 22, 33, 38, 29, 19};
```
输出如下(省去调试输出)
```cpp
final weight sum : 734.353
Best Split : 1 2 3   |  3 4 5   |  5 0 1   |  1 3 5   |
```
上述方式获取的最好三角形拆分方式如下图所示, 并且求解出最小的权值之和为734.353 每个三角形分别为 
229.207 +207.786 + 246.812 + 50.548

| 点 | weight |
| ---- | ---- |
| 1-3 | 229.207 |
| 3-5 | 207.786 |
| 5-1 | 246.812 |
| 1,3,5 | 50.548  |
划分方法绘图如下
![[attachments/Pasted image 20240201163852.png|400]]

然后我们给出对应的动态规划解法对应的矩阵: 
![[Excalidraw/第三章 动态规划算法 2024-02-01 12.02.04|600]]
从这个结构我们可以看出, 只要知道行， 列， 起止就已知; 从而只需要加一个标志位left 记录起, right 记录终, 而left, right很容易由行列获取。同时也可以从left和right反解出行列来。 

另外需要说明的是, 上述方法中, 每一列记录的多边形已经包含了相应的弦 (即例如4号行1号列对应的(0,5)已经包含了所有点, 弦是最后一条边) 
此时， 显然第四行求解的所有的结果都是相同的,  也就是我们最后要求解的权值结果。 

上述问题的动态规划法代码如下: 
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct point {
    int x;
    int y;
    point(int x, int y) : x(x), y(y) {};
};


float Get_weight(point A, point B, point C){
    // 函数内部使用lambda表达式定义函数内部函数
    auto distance = [](point m, point n) {
        return std::sqrt(pow(m.x-n.x, 2) + pow(m.y - n.y,2));
    };
    float a = distance(A, B), b = distance(A,C), c = distance(B,C);
    return pow(a - b, 2) + pow(a-c, 2) + pow(b-c, 2);
}

/// <summary>
/// 动态算法， 具有更小的时间复杂度
/// </summary>
/// <param name="points">点向量</param> 
float Dynamic_Split(vector<point> points) {
    vector<vector<float>> WeightSum;
    for (int i = 0; i < points.size()-1; i++) {
        WeightSum.push_back(vector<float> (points.size(), 0));
    }
    // 第一行的所有权值均为0, 已经初始化过了
    for (int i = 1; i < points.size() -1; i++) {
        for(int j = 0; j < points.size(); j++) {
            // 从上一行寻找两个组成, 求解出最小值
            float mini_res = 5e10;

            int left = j, right = (i+j+1)%points.size();

            // k表示不同间隔,至少循环一次
            for (int k = 1; (left + k)%points.size() != right; k++) {
                // 通过反解定位解答所在位置
                // int left1 = left,  right2 = right;; // 使用标志位方法, left = col,
                int mid = (left + k) % points.size(); // right 1 & left2

                int r1 = left < mid ?  mid - left - 1: mid - left + points.size() - 1;
                
                int r2 = mid < right ? right - mid - 1 : right - mid + points.size() - 1;
                
                // 此时, left, mid, right分别为三角形对应的三个点 
                float addition = Get_weight(points[left], points[mid], points[right]);
                float res = WeightSum[r1][left] + WeightSum[r2][mid] + addition; 
                if (res < mini_res) {
                    WeightSum[i][j] = res; 
                    mini_res = res; // 注意重置 mini_res;
                }
            }
        }
    }

    for (int i = 0; i < points.size()-1; i++) {
        for (int j = 0; j < points.size(); j++) {
            cout << WeightSum[i][j] << "\t";
        }
        cout << endl;
    }
    return WeightSum[points.size() - 2][0];
}

int main() {
    // 按照逆序给出的多边形顶点
    vector<int> x = { 27, 39, 39, 22, 12, 12};
    vector<int> y = { 12, 22, 33, 38, 29, 19};
    vector<point> point_vec;
    vector<int>   record_vec;
    for (int i = 0; i < x.size(); i++) {
        point_vec.push_back(point(x[i], y[i]));
    }

    cout << "miniest weight : " << Dynamic_Split(point_vec) << endl;
    
    return 0;
}

```
输出如下: 
```cpp
0       0       0       0       0       0
268.621 229.207 301.451 207.786 240.947 246.812
392.356 556.215 462.962 355.503 468.53  557.796
603.4   487.541 479.237 505.146 542.897 526.567
734.353 734.353 734.353 734.353 734.353 734.353
miniest weight : 734.353
```
显然第4行是相同的, 符合预期。另外由于时间原因， 就不添加记录划分方式的代码了， 读者可以自行添加。

### (4) 多边形游戏问题
考虑有一个由n个顶点构成的多边形, 每一个顶点都赋予一个整数值, 每个边被赋予 + 或者 *

1. 第一步，删除一条边
2. 每一次使用两个顶点和中间的一个运算符合并成新的顶点， 顶点数值为运算结果， 最终此多边形可以获得一个得数， 求这个得数的最大值。 
<mark style="background: transparent; color: red">注意: 顶点上的数可以是负整数</mark>。 

我们考虑如下的问题(内部为编号), 显然容易看出一个解 :  删去 -3 和 2 之间的连线， 得到最大值为$(6\times 1 \times 10 -4) \times 2 = 112$, 而可以获取到的最小值为$-4\times (80) = -320$; 
![[Excalidraw/第三章 动态规划算法 2024-02-02 09.56.22|700]]
首先， 我们仍然 按照上述步骤分析问题: 
1. 由于只有加法和乘法， 当整个运算为最优运算时: 
	- 如果两个子链结果都是正数, 显然其中的每一个小部分(子结构)都是最优的。具有最优子结构性质。
	- 如果两个子链结果都是负数, 则所得的最大值可能由子链的最大值获取, 也可能由子链的最小值获取。
因此<mark style="background: transparent; color: red">我们可以记录一个最大值和一个最小值</mark>, 每次从组合中获取结果即可。 
2. 重复字问题性质即重复解决每个边上的 + 和乘问题, 这里不再详细叙述。

这样问题就变得简单， 基本方法只需要建立类似的表即可。 另外就是舍弃一条边的问题；这个只需先行计算，获取最大合并之后舍弃边即可。 

问题代码如下: 
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef struct Result {
    int maximum;
    int minimum;
    Result() : maximum(0), minimum(0) {};
    Result(int maximum, int minimum) : maximum(maximum), minimum(minimum) {};
}Res;

Res Calcu(const Res a,const Res b, int op) {
    Res c;
    if (op == 0) {
        c.maximum = a.maximum + b.maximum;
        c.minimum = a.minimum + b.minimum;
    }
    else if (op == 1) {
        vector<int> nums{ a.maximum * b.maximum, a.minimum * b.minimum,
                          a.minimum * b.maximum, a.maximum * b.minimum };
        // 获取上述向量中点的最大值和最小值
        c.maximum = *std::max_element(nums.begin(), nums.end());
        c.minimum = *std::min_element(nums.begin(), nums.end());
    }
    return c;
}

// 由于是修改结构体值，需要传入地址
void Check_Res(Res &temp_res, Res &fin_res) {
    if (temp_res.maximum >= fin_res.maximum) {
        fin_res.maximum = temp_res.maximum;
    }
    if (temp_res.minimum < fin_res.minimum) {
        fin_res.minimum = temp_res.minimum;
    }
}

vector<vector<Result>> Matrix;
// 返回一个struct 类型, 同时存储最大和最小值 (注意输入点个数一定要大于1)
Res Polygon_Game(const vector<int> nums, const vector<int> signs) {
    for (int i = 0; i < nums.size()-1; i++) { // 初始化
        Matrix.push_back(vector<Result>(nums.size(), Res()));
    }
    for (int i = 0; i < nums.size(); i++) {
        if (signs[i] == 0) {
            Matrix[0][i].maximum = nums[i] + nums[(i + 1) % nums.size()];
        }
        else {
            Matrix[0][i].maximum = nums[i] * nums[(i + 1) % nums.size()];
        }
        Matrix[0][i].minimum = Matrix[0][i].maximum;
    }
    
    for (int i = 1; i < nums.size()-1; i++) {
        for (int j = 0; j < nums.size(); j++) {
            // 合并的两种方式包括向左合并,向右合并和子链合并
            int left = j, right = (j + i + 1) % nums.size();
            Res fin_res, temp_res;
            // 第一次为左合并方法, 新数字在左边
            fin_res =  Calcu(Matrix[i - 1][(j+1)%nums.size()], Res(nums[j], nums[j]), signs[j]);
            temp_res = Calcu(Matrix[i - 1][j], Res(nums[right], nums[right]), signs[right == 0 ? nums.size() -1: right -1]);
            Check_Res(temp_res, fin_res);
            // 检查两个子串合并的情况
            
            for (int k = 0; (left +  k + 1)%nums.size()!= right; k++) {
                if (k < 1) { continue; } // 如果相差长度(线长度) < 2则不做
                if (k == 1 && (left + k + 1) % nums.size() == right) break;

                int mid1 = (left + k) % nums.size();
                int mid2 = (left + k + 1) % nums.size();

                int r1 = mid1 - left - 1 >= 0 ? mid1 - left - 1 : mid1 - left - 1 + nums.size();
                int r2 = right - mid2 - 1 >= 0 ? right - mid2 - 1 : right - mid2 - 1 + nums.size();
                temp_res = Calcu(Matrix[r1][left], Matrix[r2][mid2], signs[mid1]);
                Check_Res(temp_res, fin_res);
            }
            Matrix[i][j] = fin_res;
        }
    }
    // 其中Matrix最后面一行的
    int _min_ = Matrix[nums.size() - 2][0].minimum;
    int _max_ = Matrix[nums.size() - 2][0].maximum;
    for (int i = 0; i < nums.size(); i++) {
        _min_ = std::min(Matrix[nums.size() - 2][i].minimum, _min_);
        _max_ = std::max(Matrix[nums.size() - 2][i].maximum, _max_);
    }
    return Res(_max_,_min_);
}

int main() {
    // 5个节点, 5条边
    vector<int> nums = { 5, 1, 10, -4, 2 };
    vector<int> signs = {0, 1, 0, 1, 0 }; // 0代表加,1代表称
    
    Res r = Polygon_Game(nums, signs);

    cout << "maximum value : " << r.maximum << endl;
    cout << "minimum value : " << r.minimum << endl;
    cout << endl;

    for (int i = 0; i < nums.size() - 1; i++) {
        for (int j = 0; j < nums.size(); j++) {
            cout << Matrix[i][j].maximum << " ";
        }
        cout << endl;
    }
    cout << endl;
    for (int i = 0; i < nums.size() - 1; i++) {
        for (int j = 0; j < nums.size(); j++) {
            cout << Matrix[i][j].minimum << " ";
        }
        cout << endl;
    }
    return 0;
}
```
输出如下
```cpp
maximum value : 112
minimum value : -320

6 10 6 -8 7
60 6 12 -3 8
56 12 42 -2 80
112 42 48 52 76

6 10 6 -8 7
15 6 2 -28 8
11 2 -18 -32 17
7 -18 -22 -320 13
```

### (5) 图像压缩计算


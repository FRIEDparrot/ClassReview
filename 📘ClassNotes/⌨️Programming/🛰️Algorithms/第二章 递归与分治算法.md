# ä¸€ã€é€’å½’ç®—æ³•
é€’å½’ç®—æ³•çš„æ ¸å¿ƒæ˜¯å‡½æ•°è°ƒç”¨è‡ªèº«çš„ç®—æ³•ã€‚
åœ¨æ•°æ®ç»“æ„ä¸­,  å…¸å‹çš„é€’å½’é—®é¢˜æ˜¯dfså³æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•,  è¿™ç§ç®—æ³•åœ¨æ ‘å’Œå›¾çš„æœç´¢ä¸­å‡æœ‰ä½¿ç”¨, è€Œè¿™é‡Œä»…ä»‹ç»å‡ ä¸ªæ¯”è¾ƒå…¸å‹ä¸€èˆ¬é—®é¢˜ä¸­çš„é€’å½’ç®—æ³•ä½¿ç”¨ã€‚ 

- é€’å½’æ–¹æ³•çš„åŸºæœ¬ç»“æ„: <mark style="background: transparent; color: red">åŸé—®é¢˜çš„ç»“æ„å¯ä»¥æ‹†åˆ†ä¸ºå­é—®é¢˜çš„ç»“æ„, ä¸”å­é—®é¢˜ç»“æ„ä¸åŸé—®é¢˜ä¸€è‡´</mark> 

- é€’å½’æ–¹æ³•çš„æ ¸å¿ƒ: 
	1. é€’å½’ç»“æŸæ¡ä»¶(å³é€’å½’åˆ°ä½•ç§æ¡ä»¶ä¸‹é€’å½’ç»“æŸ)
	2. é€’å½’è¦è§£å†³çš„åŸºæœ¬é—®é¢˜ 
	3. å°†æ•´ä¸ªé—®é¢˜æ‹†åˆ†ä¸ºåŸºæœ¬å°é—®é¢˜çš„æ–¹å¼
å¦å¤–ï¼Œ éœ€è¦è¯´æ˜çš„æ˜¯, é€’å½’ç®—æ³•å¾€å¾€å¯ä»¥ä½¿ç”¨è¿­ä»£ç®—æ³•è¿›è¡Œæ›¿ä»£ï¼Œ ä½†å¹¶ä¸æ˜¯æ‰€æœ‰çš„é€’å½’éƒ½å¯ä»¥ä½¿ç”¨è¿­ä»£ç®—æ³•è¿›è¡Œæ›¿ä»£ï¼Œ å…·ä½“ä¸‹é¢å¯ä»¥å‚è€ƒç›¸å…³å®ä¾‹

å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure/è¯¾ç¨‹ç¬”è®°/ç¬¬ä¸‰ç«  æ ˆå’Œé˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨#ä¸‰ã€é€’å½’ç®—æ³•|ç¬¬ä¸‰ç«  æ ˆå’Œé˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨]]éƒ¨åˆ†ã€‚
### (1) ç©·ä¸¾æ’åˆ—é—®é¢˜ 
ä¸€ä¸ªç®€å•çš„é€’å½’æ–¹æ³•ç©·ä¸¾æ’åˆ—é—®é¢˜å¦‚ä¸‹: 
é¦–å…ˆè¾“å…¥n, ç„¶åè¾“å…¥nä¸ªæ­£æ•´æ•°, ç„¶åè¾“å‡ºè¿™äº›æ•°å­—çš„ä¸é‡å¤çš„æ‰€æœ‰æ’åˆ—æ–¹å¼ä»¥åŠæ’åˆ—çš„ç§æ•°:

æˆ‘ä»¬ä»¥ä¸‹é¢çš„5å…ƒç´ æ’åˆ—ä¸ºä¾‹: 

| 1 | 2 | 3 | 4 | 5 |
| ---- | ---- | ---- | ---- | ---- |
| 10  | 24  | 31 | 48 | 50 |
ç”±äºnä¸ªå…ƒç´ çš„æ’åˆ—å’Œè§£å†³n-1ä¸ªå…ƒç´ çš„æ’åˆ—é—®é¢˜å®Œå…¨ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é€’å½’å°†å…¶åŒ–ä¸ºåˆ—ä¸¾å‡ºn-1ä¸ªå…ƒç´ çš„æ’åˆ—é—®é¢˜ã€‚

æˆ‘ä»¬æ€è€ƒå¦‚ä½•å°†nä¸ªæ’åˆ—é—®é¢˜ç®€åŒ–ä¸ºn-1ä¸ªå…ƒç´ çš„æ’åˆ—é—®é¢˜: å®é™…ä¸Šï¼Œ æˆ‘ä»¬åªéœ€è€ƒè™‘åˆ—ä¸¾æ’åˆ—å¤´çš„é—®é¢˜ã€‚å³å¯¹äºä¸Šè¿°æ’åˆ—:  å½“æ’åˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ åˆ†åˆ«ä¸º10, 24, 31, 48, 50æ—¶, åˆ™åé¢çš„æ’åˆ—ä¾¿ä»…å‰©ä¸‹å…¶ä½™çš„å…ƒç´ , åªéœ€**åœ¨è¿™ä¹‹å, å¯¹äºæ¯ä¸€ä¸ªåæ–¹n-1å…ƒç´ æƒ…å†µå†æ¬¡åˆ—ä¸¾æ’åˆ—å³å¯** 

| 1 | 2 | 3 | 4 | 5 |
| ---- | ---- | ---- | ---- | ---- |
| 10 | 24 | 31 | 48 | 50 |
| 24 | 10 | 31 | 48 | 50 |
| 31 | 24 | 10 | 48 | 50 |
| 48 | 24 | 31 | 10 | 50 |
| 50 | 24 | 31 | 48 | 10 |

æŒ‰ç…§ä¸Šè¿°æ€è·¯å†™å‡ºä»£ç å¦‚ä¸‹: 

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int cnt = 0;
vector<int> v;

void seq(int m, int n) {
    if (m == n) {
        for (int i = 0; i < n; i++) {
            cout << v[i] << " ";
        }
        cout << endl;
        cnt++;
    }
    else {
        int pre = -1; // è¦æ±‚ä¸èƒ½æœ‰-1
        for (int i = m; i < n; i++) {
            if (i == m ||  v[i]!= pre ) {
                // i = m æ—¶ç»§ç»­è°ƒç”¨æ¥è¾“å‡º
                pre = v[i];
                swap(v[m], v[i]);
                seq(m + 1, n);
                swap(v[m], v[i]);
            }
        }
    }
}

int main()
{
    // è¾“å…¥è¦æ±‚ä¸ºnä¸ªæ­£æ•´æ•°, æ‰“å°å…¨æ’åˆ—
    int n, x;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x;
        v.push_back(x);
    }
    sort(v.begin(), v.begin() + n);

    seq(0,n);
    cout << "total cnt: " << cnt << endl;
    return 0;
}
// test code : 
// 4
// 1 2 4 4
```

### (2) Hanoi å¡”é—®é¢˜
Hanoiå¡”é—®é¢˜æ˜¯æ¯”è¾ƒå…¸å‹çš„é€’å½’é—®é¢˜:

![[Excalidraw/ç¬¬äºŒç«  é€’å½’ä¸åˆ†æ²»ç®—æ³• 2024-01-30 13.05.59]]

æ­¤é—®é¢˜çš„æ ¸å¿ƒæ€æƒ³æ˜¯è€ƒè™‘åŸå¡”ï¼Œ ç›®æ ‡å¡”ï¼Œ è€Œå¦å¤–çš„ä¸€ä¸ªä½œä¸ºä¾èµ–å¡”ï¼Œç”±äºå½“å¤§çš„æ”¾åœ¨ä¸‹é¢æ—¶ï¼Œ  è§£å†³çš„é—®é¢˜ä¸åŸé—®é¢˜ç›¸åŒï¼Œ æ­¤æ—¶å³å¯å°†ä¸Šé¢çš„n-1å±‚å…ˆä»åŸå¡”(from)æŒªåˆ°ä¾èµ–å¡”(to)ä¸Šï¼Œ è€Œå°†ä¸‹é¢æœ€ä¸‹é¢ä¸€å±‚ä»a(from)æŒªåˆ°c(to)ï¼Œ æœ€åå°†ä¸Šé¢çš„n-1å±‚ç§»åŠ¨åˆ°cå³å¯ã€‚

1. æœ€ç®€å•çš„é—®é¢˜å³ä¸¤ä¸ªå¡”, ç›´æ¥å°†åœˆä»fromç§»åŠ¨åˆ°toå³å¯
2. å°†å¤šå±‚åŒ–ä¸ºæœ€ä¸‹å’Œä¸Šé¢å±‚çš„æ–¹å¼: å°†ä¸Šé¢å±‚ä»fromç§»åŠ¨åˆ°rely(ä»¥toä¸ºä¾èµ–å¡”), å°†æœ€ä¸‹é¢å±‚ä»from ç§»åŠ¨åˆ°to(ç›´æ¥ç§»åŠ¨), å†å°†ä¸Šé¢çš„ä» relyç§»åŠ¨åˆ°to, ä»¥fromä¸ºä¾èµ–å¡”ã€‚
```cpp
#include <iostream>
using namespace std;
void Move(int num,char a, char b) {
    cout << num << " from " << a << " to " << b<< endl;
}

// thought: move top n-1 layer from a to b, then move the bottom layer 
// from a to c, finally move n-1 layer from b to c
void Hanoi_Tower(int num, char from, char to, char rely) {
    if (num == 0) {
        return;
    }
    else {
        Hanoi_Tower(num - 1, from, rely, to);
        Move(num, from, to);
        Hanoi_Tower(num - 1, rely, to, from);
    }
}

// 1 > 2 > 3 > 4 > 5;
// Hanoi Tower Problem  
int main()
{
    int n;
    cin >> n;
    Hanoi_Tower(n, 'a', 'c', 'b');
}
```
ä¸Šé¢çš„ç»“æŸæ¡ä»¶ä¹Ÿå¯ä»¥å†™æˆnum=1æ—¶åªMove, ç”±äº1æ˜¯æœ€ä¸Šé¢çš„ä¸€å±‚ï¼Œå› æ­¤ä¸‹é¢æ²¡æœ‰å±‚

### (3) æ•´æ•°æ‹†åˆ†é—®é¢˜
å¯¹äºä¸€ä¸ªæ•´æ•°çš„ä¸é‡å¤æ‹†åˆ†æ–¹å¼è®¡ç®—: ä¾‹å¦‚ 6 = 6 + 0 = 5 + 1 = 4 + 1 + 1

é¦–å…ˆæˆ‘ä»¬è€ƒè™‘æŒ‰ç…§ä¸€å®šé¡ºåºè¿›è¡Œæ‹†åˆ†,  æ‹†å‡ºçš„æ•°åº”å½“æŒ‰ç…§ä»å¤§åˆ°å°è¿›è¡Œæ’åˆ—, è€Œå½“<mark style="background: transparent; color: red">æ‹†å‡º0æ—¶, ç»“æŸå¹¶å¢åŠ ä¸€ç§æ‹†åˆ†æ–¹å¼</mark>, éœ€è¦è¯´æ˜ï¼Œ ç”±äºæ‹†å‡º0å’Œç»“æœä¸º0éƒ½ä¼šäº§ç”Ÿ0å¯¼è‡´é¡ºåºé”™ä¹±ï¼Œ å› æ­¤æˆ‘ä»¬å®šä¹‰è‡³å°‘æ‹†å‡º1, è€Œå½“æ‹†å¾—ç»“æœä¸º0æ—¶è®°ä¸ºä¸€æ¬¡ã€‚ 

ä½¿ç”¨vectorå’Œè¿›æ ˆå‡ºæ ˆè¿›è¡Œè°ƒè¯•, ç”±äºæ‹†å‡ºçš„æ•°ä¸èƒ½å¤§äºåŸå…ˆè¢«æ‹†å‡ºè¿‡çš„, åº”å½“ç»™ä¸€ä¸ªmax_split å‚æ•°, å¦‚æœæ‹†å‡ºçš„æ•°å¤§äºmax_split, åˆ™åœæ­¢æ‹†åˆ†ã€‚ å¦å¤–ï¼Œ å°äºç­‰äºmax_split å’Œå°äºç­‰äºnåº”è¯¥æ˜¯ä¸”å…³ç³», å¦‚æœä»…ä¼ å…¥max_split, åˆ™ä¼šå¯¼è‡´ i > lengthä»è€Œå‡ºé”™ã€‚

ä»£ç å¦‚ä¸‹: 
```cpp
#include <iostream>
#include <vector>
using namespace std;
int way = 0;
vector<int> vec1;

void showvec(vector<int> vec) {
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i];
    }
    cout << endl;
}
void Split_num(int n, int max_split) {
    if (n == 0) { 
        way++; 
        showvec(vec1);
        return;
    }
    for (int i = 1;  i <= n && i <= max_split; i++) {
        vec1.push_back(i);
        Split_num(n - i, min(i, max_split));
        vec1.pop_back();
    }
}
int main()
{
    int n;
    cin >> n;
    Split_num(n, n);
    cout << way;
}
```
å‘é‡å¤åˆ¶çš„æ–¹æ³•
```cpp
vector<pointCmp<float>> vec2(vec.begin(),vec.end()) ;
```

````ad-check
title: 62.çº¦ç‘Ÿå¤«ç¯é—®é¢˜
collapse:close
[è¯¦ç»†è§£é‡Š](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/)

![[Pasted image 20230315195437.png|500]]

![[Pasted image 20230315194634.png|500]]

```cpp 
class Solution {
public:
	int lastRemaining(int n, int m) {
		return f(n, m);
	}

	int f(int n, int m) {
		if (n == 1) {
			return 0;
		}
		int x = f(n - 1, m);
		return (m + x) % n;
	}
};
```

ä¸Šå¼çš„é€’å½’æ³•å¯ä»¥æ”¹å†™ç§°ä¸ºè¿­ä»£æ³• : å¦‚ä¸‹ï¼Œé¿å…ä½¿ç”¨æ ˆç©ºé—´

```cpp 
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0; // åˆå§‹è¿­ä»£æ—¶åˆ» f(1, m)çš„å€¼
        for (int i = 2; i != n + 1; ++i) {
            f = (m + f) % i; // å¯¹åº”è¿°è§£æ³•ä¸­çš„(m + x) % n;
        }
        return f;
    }
};
```

ä¸Šè¿°é¢˜ç›®ä¹Ÿå¯ä»¥ä½¿ç”¨æš´åŠ›è¿›è¡Œæ±‚è§£ï¼Œä½†æ˜¯å¿…å®šä¼šè¶…å‡ºæ—¶é—´é™åˆ¶
```cpp 
classÂ SolutionÂ {
public:
Â Â Â Â intÂ lastRemaining(intÂ n,Â intÂ m)Â {
Â Â Â Â Â Â Â Â //Â æš´åŠ›è§£æ³•
Â Â Â Â Â Â Â Â vector<bool>Â exist(n,Â true);
Â Â Â Â Â Â Â Â intÂ indexÂ =Â 0;
Â Â Â Â Â Â Â Â intÂ elimÂ =Â 0;Â //Â æ¶ˆé™¤äººæ•°
Â Â Â Â Â Â Â Â whileÂ (elimÂ <Â n-1){
Â Â Â Â Â Â Â Â Â Â Â Â forÂ (intÂ jÂ =Â m-1;Â j>Â 0;indexÂ =Â (indexÂ +Â 1)%n){Â //Â å‰ä¸¤äºº
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (exist[index])Â j--;Â //Â å­˜æ´»
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â forÂ (;exist[index]Â !=Â true;Â indexÂ =Â (index+1)%n);Â //Â è·³è¿‡å…¶ä¸­çš„æ­»äº¡è€…
Â Â Â Â Â Â Â Â Â Â Â Â exist[index]Â =Â false;Â elimÂ +=1;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â intÂ iÂ =Â 0;
Â Â Â Â Â Â Â Â forÂ (;Â !exist[i];Â i++);
Â Â Â Â Â Â Â Â returnÂ i;
Â Â Â Â }
};
```
````

[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure/è¯¾ç¨‹ç¬”è®°/ç¬¬ä¸‰ç«  æ ˆå’Œé˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨#ä¸‰ã€é€’å½’ç®—æ³•|æ ˆå’Œé˜Ÿåˆ—ä¸é€’å½’ç»“åˆçš„å…¸å‹é—®é¢˜]]

# äºŒã€åˆ†æ²»ç®—æ³•
å¯¹äºåˆ†æ²»ç®—æ³•è€Œè¨€ï¼Œ å…¶åŸºæœ¬æ€æƒ³æ˜¯å°†ä¸€ä¸ªè§„æ¨¡ä¸º$n$çš„é—®é¢˜åˆ’åˆ†ä¸º$k$ä¸ªç‹¬ç«‹çš„å­é—®é¢˜å¹¶åˆ†åˆ«<mark style="background: transparent; color: red">é€’å½’åœ°è§£å†³è¿™äº›å­é—®é¢˜</mark> 
å…¶ä¸­ ï¼Œåœ¨ä½¿ç”¨åˆ†æ²»æ³•è§£å†³é—®é¢˜æ—¶ï¼Œ æœ€å¥½ä½¿å­é—®é¢˜çš„è§„æ¨¡å¤§è‡´ç›¸åŒã€‚è€Œåˆ†æ²»æ¨¡å¼çš„ç®—æ³•ä¸€èˆ¬æ˜¯é€’å½’ç®—æ³•, å› æ­¤å¯ä»¥<mark style="background: transparent; color: red">ä½¿ç”¨é€’å½’æ–¹ç¨‹è¿›è¡Œåˆ†æå…¶è®¡ç®—æ•ˆç‡</mark>ã€‚
å‡è®¾åˆ†æ²»æ³•å°†ä¸€ä¸ªé—®é¢˜åˆ’åˆ†ä¸º$k$ä¸ªè§„æ¨¡ä¸º$m/n$çš„å­é—®é¢˜è¿›è¡Œæ±‚è§£, è®¾å…¶å°†åŸå…ˆé—®é¢˜åˆ†è§£çš„æ—¶é—´ä¸º$f(n)$, åˆ™æœ‰:
$$T(n) = k T\left(\frac{n}{m}\right) +  f(n)$$
åˆ†æ²»ç®—æ³•ä¸€èˆ¬ä½¿ç”¨é€’å½’æˆ–è€…å¾ªç¯çš„æ–¹æ³•è¿›è¡Œ, <mark style="background: transparent; color: red">éš¾ç‚¹æ˜¯å¦‚ä½•åˆå¹¶å­åŒºé—´</mark> 
é™¤äº†ä»¥ä¸‹çš„ç¤ºä¾‹ä»¥å¤–ï¼Œ è¿˜å¯ä»¥å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure/C++åŸºç¡€çŸ¥è¯†/å¤ä¹  ä¸ƒå¤§æ’åºç®—æ³•|å¿«é€Ÿæ’åºå’Œå½’å¹¶æ’åº]] 

### (1) äºŒåˆ†æŸ¥æ‰¾ç®—æ³• 
äºŒåˆ†æŸ¥æ‰¾æ˜¯æœ€ç®€å•å…¸å‹çš„åˆ†æ²»ç®—æ³•ï¼Œæ­¤æ—¶å…¶å¤æ‚åº¦ä¸ºO($\log_{2}n$)
å¯¹äºä¸€ä¸ªé€’å¢çš„æ•°ç»„, å¯»æ‰¾å…¶ä¸­æŸä¸ªå€¼çš„ä¸‹æ ‡ç®—æ³•: 

#### 1. æ•°ç»„æŸ¥æ‰¾
éœ€è¦è€ƒè™‘çš„é—®é¢˜æ˜¯å½“ä»…æœ‰ä¸€ä¸ªå…ƒç´ æ—¶çš„æƒ…å†µç­‰ç­‰ã€‚ä¸‹é¢ç»™å‡ºäºŒåˆ†æŸ¥æ‰¾çš„åŸºæœ¬ç®—æ³•: 
```cpp
#include <iostream> 
#include <vector>
using namespace std; 
// è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™è¿”å›-1; 
int binarySearch(const vector<int> vec,const int num) {
    int _left = 0, _right = vec.size()-1; // æ³¨æ„éœ€è¦-1
    // è®¾ç½®ç›¸åº”çš„ä¸‹æ ‡, æ¯ä¸€æ¬¡ç¼©å‡ä¸€åŠ;
    while (_left <= _right) {
        // åœæ­¢æ¡ä»¶æ˜¯left = right;
        if (num < vec[_left] || num > vec[_right]) {
            return -1;
        }
        // éœ€è¦æ³¨æ„çš„æ˜¯, ç”±äºå–åˆ°çš„midæ˜¯æ•´é™¤, æ‰€ä»¥å¦‚æœç›´æ¥ä½¿ç”¨_left = mid, å¯èƒ½å¯¼è‡´ä»ç„¶mid = leftä»è€Œé™·å…¥æ­»å¾ªç¯
        int mid = (_left + _right) / 2; // mid pointer
        if (vec[mid] == num) return mid + 1; // return the index finded 
        else if (vec[mid] > num)  _right = mid;
        else _left = mid + 1; // é˜²æ­¢æ­»å¾ªç¯
    }
    return -1;
}

// äºŒåˆ†æœç´¢è·å–æŸä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®
int main() {
    int n;
    cin >> n;
    vector<int> num_vec;

    // é¦–å…ˆå‡è®¾num_vecä¸€å®šæ˜¯å‡åºçš„
    for (int i = 0; i < n; i++) {
        int t;
        cin >> t;
        num_vec.push_back(t);
    }
    int num;
    cin >> num;
    int res = binarySearch(num_vec, num);
    cout << "index: " << res << endl;
    return 0;
}

/* test code 
10
3 8 12 16 19 23 84 101 132 145
111
*/
```

#### 2. ä¸¤æ•°ä¹‹å’Œ
å…¸å‹çš„äºŒåˆ†æŸ¥æ‰¾åˆ†æ²»ç®—æ³•é¢˜ç›®æ˜¯**ä¸¤æ•°ä¹‹å’Œçš„äºŒåˆ†æŸ¥æ‰¾é—®é¢˜**: 
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„Â `nums`Â å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼Â `target`ï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºÂ **å’Œä¸ºç›®æ ‡å€¼**Â `target`Â  çš„é‚£Â **ä¸¤ä¸ª**Â æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚
ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚
å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

ä¸Šé¢é¢˜ç›®çš„åŸºæœ¬ç®—æ³•æ˜¯å…ˆåˆå§‹åŒ–lä¸ºæ•°ç»„å·¦è¾¹çš„left, è€Œåˆå§‹åŒ–rä¸ºright, æ¯æ¬¡äºŒåˆ†æ—¶, æ£€æµ‹midå’Œrightå¯¹åº”æ•°å­—çš„å’Œ
å…¶ä¸­éœ€è¦æ³¨æ„ï¼š é˜²æ­¢$(a + b)/2$æº¢å‡ºçš„åŠæ³•: å°†ç®—å¼è½¬æ¢ä¸º $b - (b - a)/2$ 

å…¶ä¸­ï¼Œ ä¸ºäº†åœ¨æ’åºä¸­ä¿æŒå­˜å‚¨æ•´æ•°ä¸‹æ ‡ï¼Œ åˆ™å¯¹pairsè¿›è¡Œæ’åºå³å¯ã€‚
```cpp 
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
            int left = 0, right = nums.size() - 1;
            vector<int> res;
            vector<pair<int,int>> arr; // åˆ†åˆ«ä¿å­˜æ•°å­—ä¸ä¸‹æ ‡
            for (int i = 0; i <= right; i++) {
                arr.push_back(make_pair(nums[i], i));
            }
            std::sort(arr.begin(), arr.end() );    // ä½¿å…¶æŒ‰ç…§é€’å¢è¿›è¡Œæ’åº
            int rr = right;
            for (left = 0 ; left < right; left++) {
                // å®šä¹‰rr å’Œ rl å°†åŒºé—´å³ä¾§è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾, æ‰¾ä¸åˆ°åˆ™ç»§ç»­å¾ªç¯
                int rl = left + 1; rr = right;
                // å›ºå®šä¸€ä¸ªæ•°, å¦ä¸€ä¸ªä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾, æ—¶é—´å¤æ‚åº¦O(n * log n)
                while (rl < rr) {
                    int mid = rl + (rr - rl) / 2;
                    int temp = arr[left].first + arr[mid].first;  // æ£€æŸ¥ä¸­ç‚¹çš„å€¼
                    if (temp == target) { rr = mid; break; }      // ä¸€å®šè¦åŠ ä¸Šrr = mid èµ‹å€¼ä¸­ç‚¹
                    if (temp > target) {
                        rr = mid;
                    }
                    else {
                        rl = mid + 1; // ç”±äºrlæ”¾åœ¨midä¸Šå°, æ‰€ä»¥å¯ä»¥æ”¾åœ¨mid+1ä¸Š
                    }
                }
                if (arr[left].first + arr[rr].first == target) break;
            }
            res.push_back(arr[left].second);
            res.push_back(arr[rr].second);
            return res;
    }
};
```

### (2) å¤§æ•´æ•°çš„ä¹˜æ³• 
é¦–å…ˆ, å‡è®¾ä¸¤ä¸ªnä½çš„<mark style="background: transparent; color: red">äºŒè¿›åˆ¶æ•´æ•°</mark>è¿›è¡Œäº’ä¹˜æ“ä½œ, è®¡ç®—å…¶ä¹˜ç§¯XY, å¦‚æœå°†æ¯ä¸¤ä¸ªæ•°çš„ä¹˜æ³•å‡è§†ä¸ºä¸€æ¬¡è®¡ç®—, åˆ™éœ€è¦æŒ‰ä½ç›¸ä¹˜ï¼Œå› è€Œå¾—åˆ°çš„è®¡ç®—å¤æ‚åº¦ä¸º$O(n *n  ) = O(n^2)$ 
å¦‚æœå°†äºŒè¿›åˆ¶æ•´æ•°åˆ†ä¸ºä¸‹é¢çš„ä¸¤æ®µ: 
ä¾‹å¦‚
![[Excalidraw/ç¬¬äºŒç«  é€’å½’ä¸åˆ†æ²»ç®—æ³• 2024-01-27 14.50.47|450]]
åˆ™
$$X = A\times 2^{\frac{n}{2}}  + B \qquad  Y = C\times  2^ {\frac{n}{2}} + D$$
æ­¤æ—¶å¤§ç•¥çš„è¿‡ç¨‹ä¸º:
$$XY = AC \times 2^{n} + BD + AD \times  2^{n} + BC \times 2^{n}$$
éœ€è¦çš„æ—¶é—´å¤æ‚åº¦ä¸º:
$$4 * \left(\frac{n}{2} \right)^{2} = n ^{2}$$
è¿™ç§ç®—æ³•å®é™…ä¸Šæ²¡æœ‰å°†å¤æ‚åº¦å‡å°‘ã€‚è€Œä¸ºäº†æ”¹è¿›å¯¹åº”çš„ç®—æ³•, å¿…é¡»å‡å°‘ä¹˜æ³•è¿ç®—æ¬¡æ•°, å¾—åˆ°: 
$$XY  =  AC\times 2^{n}+ (AD + BC) \times 2 ^{n} + BD =  AC\times 2^{n} + ((A+B)(C+D) - BD-AC)2^{\frac{n}{2}} + BD $$
æ­¤æ—¶åªéœ€è¦ç®—ä¸€æ¬¡ACå’Œä¸€æ¬¡BDå³å¯æ»¡è¶³è¦æ±‚, æ˜æ˜¾åœ°å‡å°‘äº†ç®—æ³•çš„å¤æ‚åº¦, æ˜¯ä¸€ç§è¾ƒä¸ºå¯è¡Œçš„ç®—æ³•è®¾è®¡æ€è·¯ã€‚

### (3) æ£‹ç›˜è¦†ç›–é—®é¢˜ 
é¦–å…ˆè®¾æœ‰ä¸€ä¸ª$2^{k}\times  2^{k}$å¤§å°çš„æ£‹ç›˜, ä¸”æ°æœ‰ä¸€ä¸ªæ–¹æ ¼ä¸å…¶ä½™æ–¹æ ¼ä¸åŒ, è¿™ç§æ£‹ç›˜å¯ä»¥ä½¿ç”¨å³ä¾§çš„4ç§Lå½¢éª¨ç‰Œè¿›è¡Œä¸é‡å¤è¦†ç›–ï¼Œ è®¾è®¡ä¸€ç§ç®—æ³•, ç»™å‡ºkå’Œè¦†ç›–çš„æ ¼å­åæ ‡, å¯»æ‰¾ä¸€ç§ä¸é‡å¤çš„éª¨ç‰Œè¦†ç›–æ–¹å¼ã€‚
![[Excalidraw/ç¬¬äºŒç«  é€’å½’ä¸åˆ†æ²»ç®—æ³• 2024-01-27 15.13.40|450]]
é¦–å…ˆ, å°†æ£‹ç›˜æ ¼åˆ’åˆ†ä¸ºå››ä»½, è€Œå·¦ä¸Šçš„ä¸€ä»½æœ‰è¦†ç›–, åˆ™åœ¨å³ä¸‹ä¸‰ä¸ªä¸­å„è‡ªå¡«å…¥ä¸€ä¸ªï¼Œæ­¤æ—¶å³ä¸‹çš„ä¸‰ä¸ªåŒ–ä¸ºå¸¦æœ‰ä¸€æ ¼æ»¡çš„å¡«å……é—®é¢˜ã€‚å¯¹äº$n$æ¬¡çš„ç‰¹æ€§, åªéœ€é€’å½’è¿›è¡Œå¡«æ»¡å³å¯ã€‚ 

è€ƒè™‘ä¸Šè¿°é—®é¢˜, å‡½æ•°æ˜¯é€’å½’å‹å‡½æ•°, ä¼ å…¥å‚æ•°ä¸ºæ£‹ç›˜å·¦ä¸Šè§’, å³ä¸‹è§’çš„ä½ç½®(start, ended)å…±æœ‰4ä¸ªæ¨ªçºµåæ ‡, ä»¥åŠå¡«å…¥çš„ä½ç½®ã€‚

```cpp
#include <iostream>
#include <vector>

using namespace std; 
// æ£‹ç›˜é—®é¢˜
int fill_num = 0;

// è‡ªåŠ¨åˆå§‹åŒ–çš„ä»£ç 
typedef struct point {
    int x;
    int y;
    point() : x(0), y(0) {};
    point(int x_loc, int y_loc) : x(x_loc), y(y_loc) {};
};

vector<vector<int>> Matrix;

void fill_point(point _point, int num) {
    Matrix[_point.x ][ _point.y] = num;
}

// ä¼ å…¥ä¸‰ä¸ªå‚æ•°: åŒ…æ‹¬èµ·å§‹ç‚¹, ç»ˆæ­¢ç‚¹å’Œå¡«å……ç‚¹
void chessBoardSolve(point start, point ended, point filled_point) {
    float mid_x, mid_y;
    mid_x = start.x/2.0 + ended.x/2.0 ;
    mid_y = start.y/2.0 + ended.y/2.0;
    if (start.x == ended.x && start.y == ended.y) return; // this space has been filled;

    // è·å–é ä¸­é—´çš„å››ä¸ªç‚¹
    point a_(mid_x, mid_y), b_(mid_x + 1, mid_y), c_(mid_x,mid_y+1),d_(mid_x + 1, mid_y + 1);
    
    if (filled_point.x < mid_x && filled_point.y < mid_y) { 
        fill_point(b_, fill_num);
        fill_point(c_, fill_num);
        fill_point(d_, fill_num);
        a_ = filled_point; // æ›¿æ¢åŸå…ˆè¦fillçš„ç‚¹
    }
    else if (filled_point.x > mid_x && filled_point.y < mid_y) {
        fill_point(a_, fill_num);
        fill_point(c_, fill_num);
        fill_point(d_, fill_num);
        b_ = filled_point;
    }
    else if (filled_point.x < mid_x  && filled_point.y > mid_y) {
        fill_point(a_, fill_num);
        fill_point(b_, fill_num);
        fill_point(d_, fill_num);
        c_ = filled_point;
    }
    else if (filled_point.x > mid_x && filled_point.y > mid_y) {
        fill_point(a_, fill_num);
        fill_point(b_, fill_num);
        fill_point(c_, fill_num);
        d_ = filled_point;
    }
    else {
        throw exception("ERROR");
    }
    fill_num++; // å¡«å……æ•°å­—è‡ªå¢
    chessBoardSolve(point(start.x, start.y),     point(mid_x, mid_y), a_);
    chessBoardSolve(point(mid_x + 1, start.y),   point(ended.x, mid_y), b_);
    chessBoardSolve(point(start.x, mid_y + 1),   point(mid_x, ended.y), c_);
    chessBoardSolve(point(mid_x + 1, mid_y + 1), point(ended.x, ended.y), d_);
}

int main() {
    int k; // size of the chess 
    cin >> k;
    int length = pow(2, k);
    
    // ä½¿ç”¨ä¸¤ä¸ªå‘é‡çš„æ–¹æ³•æ¥å®šä¹‰å¯¹åº”çš„çŸ©é˜µ
    for (int i = 0; i < length; i++) {
        Matrix.push_back(vector<int>(length, -1));
    }
    // æ­¤å¤„ç•¥å»å¡«ç‚¹åˆæ³•æ€§æ£€æŸ¥
    point* fill_point_ = new point();
    cin >> fill_point_->x >> fill_point_->y;

    fill_point(*fill_point_, fill_num);
    fill_num++;

    chessBoardSolve(point(0, 0),point(length-1, length-1), *fill_point_);

    for (int i = 0; i < length; i++) {
        for (int j = 0; j < length; j++) {
            cout << Matrix[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
/*test code
2
1 1
*/
```

### (4) çº¿æ€§æ—¶é—´é€‰æ‹©é—®é¢˜
æˆ‘ä»¬è€ƒè™‘ä¸æ’åºé—®é¢˜ç±»ä¼¼çš„å…ƒç´ é€‰æ‹©é—®é¢˜ã€‚å…¶ä¸€èˆ¬ææ³•æ˜¯ç»™å®šçº¿æ€§åºåˆ—ä¸­nä¸ªå…ƒç´ å’Œä¸€ä¸ªæ•´æ•°k, é€‰å–å…¶ä¸­ç¬¬kå°çš„å…ƒç´ 
ç”±äºåˆ†åˆ«æ’å¥½åºæ¯”æ€»å’Œæ’å¥½åºæ›´å¿«, å› è€Œé€šè¿‡åˆ†åˆ«æ’å¥½åºå¯»æ‰¾æœ€å°å…ƒç´ ï¼Œ æ•…åœ¨kè¾ƒå°çš„æƒ…å†µä¸‹å¯ä»¥ä»¥æ›´å°çš„æ—¶é—´å¤æ‚åº¦è·å–åˆ°æœ€å°çš„å…ƒç´ ã€‚

### (5) å¹³é¢ä¸Šçš„æœ€æ¥è¿‘ç‚¹é—®é¢˜
æˆ‘ä»¬è€ƒè™‘å¦‚ä¸‹çš„é—®é¢˜: ç»™å®šä¸€ä¸ªå¹³é¢ä¸Šçš„nä¸ªç‚¹çš„x,yåæ ‡, å¯»æ‰¾å…¶ä¸­è·ç¦»æœ€çŸ­çš„ä¸€å¯¹ç‚¹, ä½¿å¾—åœ¨nä¸ªç‚¹å¯¹ä¸­è¯¥ç‚¹å¯¹çš„è·ç¦»æœ€å°ã€‚
é¦–å…ˆ, å¦‚æœç›´æ¥ä½¿ç”¨æš´åŠ›è®¡ç®—æ¯ä¸€ä¸ªç‚¹ä¹‹é—´çš„è·ç¦», åˆ™è·å–åˆ°çš„ç®—æ³•å¤æ‚åº¦ä¸º$O(n^2)$, å¦å¤–ä¹Ÿå¯ä»¥ä¸è®¡ç®—é‡å¤ç‚¹ä¹‹é—´çš„è·ç¦», å¤æ‚åº¦ä¸º$O\left(\frac{n(n + 1)}{2}\right)$ , æ—¶é—´å¤æ‚åº¦ä»ç„¶ä¸º $O(n^{2})$ã€‚

é¦–å…ˆæˆ‘ä»¬è€ƒè™‘ä¸€ç»´çš„æƒ…å†µ: å¦‚æœèƒ½å°†Sä¸­çš„ç‚¹å…ˆæ’å¥½åº(è·å–$x_1, x_2, \dots x_n$ä¸ºå‡åºæ’åˆ—)
![[Excalidraw/ç¬¬äºŒç«  é€’å½’ä¸åˆ†æ²»ç®—æ³• 2024-01-27 17.57.39|650]]
åœ¨æ’å¥½åºä¹‹åå³å¯ä½¿ç”¨ä¸€æ¬¡æ‰«æç¡®å®šæœ€å¤§å€¼ï¼Œå› æ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\log_{2}n)$ 
> [!cite] ä¸€ç»´é—®é¢˜è¾¹ç•Œç‚¹çš„æ±‚è§£æ–¹æ³•
> - æˆ‘ä»¬è€ƒè™‘ä½¿ç”¨åˆ†æ²»æ³•çš„ç­–ç•¥, ä¾‹å¦‚å°†ä¸Šè¿°çš„å¹³é¢ä¸Š$n$ä¸ªç‚¹çš„é›†åˆSåˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†, å…¶ä¸­æ¯ä¸ªçº¦æœ‰$n/2$ä¸ªç‚¹ï¼Œ åˆ†åˆ«æ±‚è§£å‡ºå…¶ä¸­å„ä¸ªéƒ¨åˆ†çš„æœ€å°è·ç¦»ï¼Œ å¹¶è®°ä¸º$d_{1}$å’Œ$d_2$ã€‚
> - åœ¨åˆå¹¶è¿‡ç¨‹ä¸­, è®¾ä¸­å¿ƒåæ ‡ä¸ºmï¼Œ åˆ™é€‰å–$m = (\max (S) + \min(S))/2$, åªéœ€è¦è€ƒè™‘$S_1$ä¸­çš„æœ€å¤§å€¼å’Œ$S_2$ä¸­çš„æœ€å°å€¼è¿›è¡Œç›¸å‡è·å–ä¸­é—´è·ç¦»å°±å¯ä»¥äº†ã€‚

æ³¨æ„: å¦‚æœä½¿ç”¨std::findå‡½æ•°æ¯”è¾ƒç»“æ„ä½“, åˆ™éœ€è¦é‡å†™ == å‡½æ•°ï¼Œ åŒæ ·åœ°è¿›è¡Œç‚¹çš„æ¯”è¾ƒ, åˆ™éœ€è¦é‡å†™ < å‡½æ•°
![[attachments/Pasted image 20240128215932.png]]

æˆ‘ä»¬è€ƒè™‘å¦‚ä½•è·å–æ‰€åˆ†å‡ºå­åŒºé—´çš„å·¦ä¾§æœ€å¤§å€¼å’Œå³ä¾§æœ€å°å€¼:  å¦‚æœæˆ‘ä»¬å–ä¸Šè¿°ä¸¤ä¸ªå­åŒºé—´çš„æœ€çŸ­è·ç¦»ä¸º$d$, å¹¶ä»¥mä¸ºä¸­å¿ƒåšä»¥$d$ä¸ºé•¿åº¦çš„æ‰©å±•, <mark style="background: transparent; color: red">æ˜¾ç„¶è·å¾—çš„æ‰©å±•åŒºé—´ä¸¤ä¾§æœ€å¤šå„æœ‰ä¸€ä¸ªç‚¹</mark>,  æ˜¾ç„¶, è¿™ä¸ªå³ä¸º$S_{1}$ä¸­çš„æœ€å¤§ç‚¹æˆ–è€…$S_2$ä¸­çš„æœ€å°ç‚¹ï¼Œ æ­¤æ—¶åªè¦è·å–è¿™ä¸¤ä¸ªç‚¹çš„è·ç¦»å¹¶ä¸å·¦å³åŒºé—´ä¸­çš„æœ€å°ã€‚

ä¸ºäº†èƒ½å¤Ÿæ‹“å±•åˆ°äºŒç»´çš„æƒ…å½¢, æˆ‘ä»¬å¦‚æœä½¿ç”¨ä¸€æ¡ç›´çº¿å°†æ•´ä¸ªå¹³é¢åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç„¶ååˆ†åˆ«è®¡ç®—æœ€çŸ­çš„è·ç¦»ï¼Œ å¹¶ä½¿ç”¨å…¶ä¸­æœ€çŸ­çš„$d$ä¸ºåŒºé—´é•¿åº¦, å¯ä»¥åšå‡ºå¦‚ä¸‹å›¾çš„è®¡ç®—æ–¹æ¡ˆ: 
![[Excalidraw/ç¬¬äºŒç«  é€’å½’ä¸åˆ†æ²»ç®—æ³• 2024-01-27 21.24.13|550]]
åœ¨ç‚¹è¢«åˆ†è§£ä¸ºä¸¤å¤§éƒ¨åˆ†ä¹‹å, åˆå¹¶è¿‡ç¨‹ä¸­è¿˜å¯èƒ½æœ‰å¤šä½™çš„ç‚¹ã€‚ä¸ºäº†å‡å°è®¡ç®—é‡, å¯ä»¥<mark style="background: transparent; color: red">åœ¨ç›´çº¿çš„xåŒºé—´ä»¥å†…, å…ˆæ ¹æ®yçš„å¤§å°ä¸ä¹‹è¿›è¡Œæ’åº</mark>, è€Œä»…è®¡ç®—æ¯ä¸€ä¸ªå·¦è¾¹ç‚¹ä¸å³è¾¹ç›¸å·®yè·ç¦»< dçš„ç‚¹çš„ç‚¹è·ç¦», å¦‚æœæœ‰æ›´çŸ­çš„ç»“æœï¼Œ åˆ™è¿›è¡Œåˆå¹¶ã€‚
å¦å¤–ï¼Œ å¯ä»¥è¯æ˜, ç”±äºå·¦å³ä¾§çš„ç‚¹è·ç¦»å‡ä¸å°äºd, åˆ™å³ä¾§å¤§å°ä¸ºyçš„é—­åŒºé—´ä»¥å†…æœ€å¤šæœ‰6ä¸ªç‚¹å¯ä»¥å…±å­˜ã€‚

æš´åŠ›è§£æ³•å¦‚ä¸‹: 
```cpp 
// æš´åŠ›è§£æ³• > è·å–æ¯ä¸€ä¸ªç‚¹ä¹‹é—´çš„è·ç¦»
template <typename ItemType>
ItemType Mini_distance(vector<point>vec) {
    ItemType shortest_dis = 100;
    for (int i = 0; i < vec.size() - 1; i++) {
        for (int j = i + 1; j < vec.size(); j++) {
            ItemType dis = sqrt(pow(vec[i].x - vec[j].x, 2) + pow(vec[i].y - vec[j].y, 2));
            if (dis < shortest_dis) {
                shortest_dis = dis;
            }
        }
    }
    return shortest_dis;
}
```
ä½¿ç”¨é€’å½’çš„åˆ’åˆ†æ–¹æ³•è¿›è¡Œæ±‚è§£: é¦–å…ˆ<mark style="background: transparent; color: red">å¯¹äºä¸¤ç‚¹çš„æƒ…å†µï¼Œ æ— éœ€ä½¿ç”¨åˆ†æ²»æ³•</mark>, è€Œåˆ†æ²»æ³•ä»…ç”¨äº3ç‚¹ä»¥ä¸Šçš„æƒ…å†µ;  

åœ¨å®é™…ç®—æ³•ä¸­, ä¸ºäº†æ±‚è§£æœ€çŸ­çš„è·ç¦», å…ˆå°†ç‚¹è¿›è¡ŒæŒ‰ç…§æ¨ªåæ ‡å’Œçºµåæ ‡ä¾æ¬¡æ’å¥½åºï¼Œ ç„¶åè¿›è¡Œæ±‚è§£
å®é™…æ±‚è§£ä¸­ï¼Œç”±äºé¢å¤–èµ„æºæ¶ˆè€—, å¯¼è‡´å®é™…æ•ˆæœå…¶å®ä¸å¦‚æš´åŠ›ç®—æ³•ã€‚ 

hå¤´æ–‡ä»¶: 
```cpp title:mini_distance.h
#pragma once

// å®šä¹‰ç‚¹ç±» 
template <typename ItemType>
class point {
public:
    ItemType x;
    ItemType y;
    // å®šä¹‰åˆå§‹åŒ–æ–¹æ³•
    point(ItemType x, ItemType y) {
        this->x = x;
        this->y = y;
    };
    // é‡å†™ == å‡½æ•°, ç”¨äºstd::find
    friend bool operator == (const point<ItemType>& p1, const point<ItemType>& p2) {
        return ((p1.x == p2.x) && (p1.y == p2.y));
    }
};

// ç»§æ‰¿ç‚¹ç±», ä¸ºå¸¦æœ‰æ’åºçš„ç‚¹ç±», æŒ‰ç…§å…ˆxé€’å¢, åyé€’å¢çš„æ–¹æ³•å°†ç‚¹è¿›è¡Œæ’åº
template <typename ItemType>
class pointCmp : public point<ItemType> {
public:
    int IDnum;
    // åˆå§‹åŒ–æ–¹å¼,ç›´æ¥ç»§æ‰¿ç‚¹çš„æ„é€ æ–¹æ³•, åŒæ—¶åŠ å…¥ä¸€ä¸ªIDnumå‚æ•°, ç”¨äºè®°å½•åœ¨åŸå…ˆæ•°ç»„ä¸­çš„ä½ç½®
    pointCmp(ItemType x, ItemType y, int num) : point<ItemType>(x, y), IDnum(num) {}

    // é‡æ–°å®šä¹‰å°äº < å‡½æ•°, ä»è€Œè§„å®šsortçš„æ’åºæ–¹æ³• 
    friend bool operator < (const point<ItemType>& p1, const point <ItemType>& p2) {
        if (p1.x != p2.x) {
            return p1.x < p2.x;
        }
        else {
            return p1.y <= p2.y;
        }
    }
};

template <typename ItemType>
float Distance(point<ItemType> p1, point<ItemType> p2) {
    float dis;
    dis = sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    return dis;
}

```

```cpp title:â€‹mini_distance.cpp
#include <iostream>
#include <vector>
#include <random>
#include <chrono> 
#include "Point_Extension.h"
using namespace std;
using namespace std::literals::chrono_literals; // è®¡æ—¶æ¨¡å—
 
vector<point<float>> vec;
vector <pointCmp<float>> vec_Cmp;

template <typename ItemType>  // å…¶ä¸­ points æ˜¯æŒ‰ç…§x, yæ’å¥½åºçš„æ•°ç»„
float Mini_distance(const vector<pointCmp<ItemType>> points, int l, int r) {
    // é¦–å…ˆæ±‚è§£å¹³å‡åˆ’åˆ†çš„yå€¼;
    // å¯¹äº2ç‚¹ä»¥ä¸‹çš„æƒ…å†µ,
    if (r == l) {
        cout << "nop" << endl;
        throw exception("function exception");
    }
    if (r - l == 1) { // è€ƒè™‘ä¸¤ç‚¹çš„æƒ…å†µ
        return Distance(points[l], points[r]);
    }
    // å¯¹äºå¤šäº2ä¸ªç‚¹çš„æƒ…å†µ, æ˜¾ç„¶è®¡ç®—å‡ºçš„ mid > l 
    int m = (l + r) / 2;  // æ³¨æ„: éœ€è¦å…ˆæŒ‰ç…§xè¿›è¡Œæ’åºæ‰èƒ½æˆä¸ºä¸­ä½ç‚¹ã€‚
    float left_dis = Mini_distance(points, l, m);
    float right_dis;
    if (m + 1 < r){ // å­˜å‚¨ä¸¤ä¸ªåŒºé—´ä¸­çš„æœ€å°è·ç¦»
        right_dis = Mini_distance(points, m + 1, r); // æ³¨æ„æœ‰å¯èƒ½æœ‰mid+1 = rightçš„æƒ…å†µ
    }
    else {
        right_dis = left_dis; // ç›´æ¥ç›¸ç­‰å³å¯
    }
    float best_dis = min(left_dis, right_dis); 
    // å¯¹äºVector, å¯ä»¥ä½¿ç”¨Insertæ–¹æ³•è¿›è¡Œåˆå¹¶, å¹¶ä»¥best_dis ä¸ºåŒºé—´é•¿åº¦åœ¨ä¸­ä½æ•°ä¸¤è¾¹è¿›è¡Œæœç´¢
    
    // åœ¨åŒºé—´èŒƒå›´å†…è¿›è¡Œæœç´¢, è¿‡ç¨‹ä¸­æ˜¾ç„¶å¯ä»¥åˆ©ç”¨ä¸­é—´ç‚¹çš„æ ‡å·m (ç”±äºå·²ç»æ’åºå¥½)
    vector<pointCmp<ItemType>> leftps, rightps; 

    // åœ¨Vec_Cmpå†…å‘å·¦æœç´¢, åŒ…æ‹¬è‡ªèº« (éœ€è¦æ³¨æ„åˆ¤æ–­locè¦æ”¾åœ¨å‰é¢)
    for (int loc = m; loc >= 0 && points[m].x - points[loc].x < best_dis; loc--) {
        leftps.push_back(points[loc]);  // å°†åŸå…ˆæ•°ç»„ä¸­çš„éƒ¨åˆ†å­˜å‚¨è¿›å»
    }
    // åœ¨Vec_Cmpå†…å‘å³æœç´¢, å»é™¤è‡ªèº« 
    for (int loc = m + 1; loc < points.size() && points[loc].x - points[m].x < best_dis ; loc++) {
        rightps.push_back(points[loc]);
    }

    // åˆå¹¶ä¸¤ä¸ªé›†åˆ -> æ­¤æ—¶å…ˆä»Point_Mapä¸­æŸ¥æ‰¾å‡ºåœ¨Point_Cmpä¸­çš„ä½ç½®, 
    if (!leftps.empty() && !rightps.empty())  {
        for (int i = 0; i < leftps.size(); i++) {
            // æŸ¥æ‰¾å³ä¾§ä¸­è·ç¦»å°äºdçš„ç‚¹ -> ç”±äºæ˜¯æŒ‰ç…§å…ˆxåy, æ¯ä¸€ä¸ªè¦æ£€æŸ¥ä¸€æ¬¡
            for (int j = 0; j < rightps.size(); j++)
            {
                if (std::abs(rightps[j].y - leftps[i].y) < best_dis) {
                    float dis = Distance(leftps[i], rightps[j]);
                    if (dis < best_dis) {
                        best_dis = dis;
                    }
                }
            }
        }
    }
    return best_dis;
}

// åˆ†æ²»ç®—æ³• nlgnå¤æ‚åº¦
void Solution_Recursion() {
    auto start = std::chrono::high_resolution_clock::now();

    std::sort(vec_Cmp.begin(), vec_Cmp.end());   // åˆ©ç”¨é‡å®šä¹‰çš„å°äºè¿ç®—ç¬¦å¯¹vec2è¿›è¡Œæ’åº
    float dst = Mini_distance<float>(vec_Cmp, 0, vec.size() - 1);
    
    auto endd = std::chrono::high_resolution_clock::now();
    std::chrono::duration<float> duration = endd - start;
    std::cout << "=== recurse used time : " << duration.count() <<"s" << " ==================" << endl;
    std::cout << "========= distance is " << dst << " ============" << endl;
}


// æš´åŠ›ç®—æ³•, n^2å¤æ‚åº¦
template <typename ItemType>
void Solution_Violet() {
    auto start = std::chrono::high_resolution_clock::now();

    ItemType shortest_dis = 10000000;
    for (int i = 0; i < vec.size() - 1; i++) {
        for (int j = i + 1; j < vec.size(); j++) {
            ItemType dis = sqrt(pow(vec[i].x - vec[j].x, 2) + pow(vec[i].y - vec[j].y, 2));
            if (dis < shortest_dis) {
                shortest_dis = dis;
            }
        }
    }
    auto endd = std::chrono::high_resolution_clock::now();
    std::chrono::duration<float> duration = endd - start;

    std::cout << "==== violet used time : " << duration.count() << "s" << " ==================" << endl;
    std::cout << "========= distance is " << shortest_dis << " ============" << endl;
}

// å¹³é¢æœ€çŸ­è·ç¦»é—®é¢˜
int main() {
    // åˆå§‹åŒ–å¹³é¢ä¸Šçš„ç‚¹
    int n;
    cin >> n;

    // äº§ç”Ÿnä¸ªç‚¹
    for (int i = 0; i < n; i++) {
        float x = -1000 + 2000 * rand(), y = -1000 + 2000* rand();
        // std::find å‡½æ•°, æ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›end, æ­¤æ—¶éœ€è¦é‡å†™==ç¬¦å·, è¿™ä¸ªå·²ç»åœ¨å¤´æ–‡ä»¶ä¸­é‡å†™äº†
        //if (std::find(vec.begin(), vec.end(), point<float>(x,y)) == vec.end()) {
        vec.push_back(point<float>(x, y)); // ä¸é‡å¤åˆ™æ·»åŠ 
    }
    // ä½¿ç”¨è¿™ä¸ªæ–¹æ³•å°† vec1 å¤åˆ¶åˆ°vec2ä¸­ -> å¯¹äºç›¸åŒå‚æ•°çš„, vector<pointCmp<float>> vec2(vec.begin(),vec.end());
    for (int i = 0; i < vec.size(); i++) {
        // å‰é¢å·²ç»å»é™¤é‡å¤çš„ç‚¹, æ‰€ä»¥ä¸ç”¨æ£€éªŒå“ˆå¸Œè¡¨å­˜åœ¨æ€§
        vec_Cmp.push_back(pointCmp<float>(vec[i].x, vec[i].y, i));  // åŒæ—¶ä¼ å…¥åœ¨åŸå‘é‡ä¸­çš„æ ‡å·
    }
    Solution_Recursion();
    Solution_Violet<float>();
    return 0;
}
```

> [!NOTE] è¡¥å……
> æ­¤ç§é—®é¢˜çš„å¦ä¸€ç§ç®—æ³•å¯ä»¥æ˜¯èšç¾¤ç®—æ³•(åˆ©ç”¨ä¿¡æ¯ç´ å¯å‘å¼åœ°å¯»æ‰¾æœ€çŸ­è·¯çº¿), ä½†æ˜¯å¯èƒ½å¯¹äºè¾ƒå¤§é‡çš„ç‚¹æ•ˆç‡ä¸é«˜ã€‚

### (6) æ•°ç»„çš„æœ€å¤§è¿ç»­å’Œ
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„Â `nums`Â ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
**å­æ•°ç»„**Â æ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†,  å…¶ä¸­æ˜¾ç„¶æœ‰ç›´æ¥ä½¿ç”¨ä¸€ä¸ªæ•´æ•°å­˜å‚¨æœ€å¤§å’Œæ‰«æä¸€éçš„æ–¹æ³•ï¼Œä¸”æ˜¾ç„¶å…¶æ—¶é—´å¤æ‚åº¦ä¸ºnã€‚

![[Pasted image 20230312175136.png|800]]
![[Pasted image 20230312175232.png|800]]

```cpp 
class Solution {
public:
    struct Status {
        int lSum, rSum, mSum, iSum;
    };

    Status pushUp(Status l, Status r) {
        int lSum = max(l.lSum, l.iSum + r.lSum);      // è€ƒè™‘åŠ ä¸Šå³ä¾§åŒºé—´çš„lSum
        int rSum = max(r.rSum, r.iSum + l.rSum);     // æ˜¯å¦åŠ ä¸Šå³ä¾§åŒºé—´çš„rSum 
        int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);  // è€ƒè™‘æ˜¯å¦åˆå¹¶ä¸¤ä¸ªåŒºé—´çš„éƒ¨åˆ†æ•°å­—å¾—åˆ°æœ€å¤§å’Œ 
        
        int iSum = l.iSum + r.iSum;    // å¯¹æœ¬åŒºé—´çš„ç›´æ¥åŠ å’Œ (æ²¡å¤ªå¤§ç”¨)
        return (Status) {lSum, rSum, mSum, iSum}; 
    };
    Status get(vector<int> &a, int l, int r) {
        if (l == r) { // left == right 
            return (Status) {a[l], a[l], a[l], a[l]};   // ç›´æ¥è¿”å›è¿™ä¸ªæ•°å­—å³ä¸ºæœ€å¤§å’Œ 
        }
        int m = (l + r) >> 1;   // å³ç§»ä¸€ä½å³é™¤ä»¥2, ä½†å®ç°äº†æ›´å¿«çš„é™¤2æ“ä½œ
        Status lSub = get(a, l, m);           // å·¦ä¾§æ•°ç»„ -> é€’å½’è·å–æœ€å¤§å’Œ
        Status rSub = get(a, m + 1, r);    // å³ä¾§æ•°ç»„ -> é€’å½’è·å–æœ€å¤§å’Œ
        return pushUp(lSub, rSub);         
    }
    int maxSubArray(vector<int>& nums) {
        return get(nums, 0, nums.size() - 1).mSum;   // æœ€ç»ˆè¿˜æ˜¯ä»¥mSumä¸ºå‡†çš„ã€‚ 
    }
};
```

### (7) å¾ªç¯èµ›æ—¥ç¨‹è¡¨é—®é¢˜
é’ˆå¯¹$n , n = 2^{k}$ä¸ªè¿åŠ¨å‘˜, è¿›è¡Œç½‘çƒå¾ªç¯èµ›,  è¦æ±‚
1. æ¯ä¸ªé€‰æ‰‹ä¸å…¶ä»–é€‰æ‰‹å„è‡ªæ¯”èµ›ä¸€æ¬¡ 
2. é€‰æ‰‹ä¸€å¤©åªèƒ½èµ›ä¸€æ¬¡ 
3. å¾ªç¯èµ›ä»…è¿›è¡Œn-1å¤©
- é¦–å…ˆè€ƒè™‘ç›´æ¥æŒ‰ç…§å·®å€¼ä»1-> n-1æ»šåŠ¨è®¡ç®—, ä½†æ˜¯ç”±äºå¯¼è‡´é‡å é—®é¢˜å¯¼è‡´æ— æ³•è¿›è¡Œæ¯”èµ›, åˆ™å·®å€¼è‡³å°‘åº”å½“ä¸ºn/2, ä¸”ç¬¬äºŒå¤©å³ä¼šå¯¼è‡´å¾ªç¯åˆ°ç¬¬ä¸€åä¸Šï¼Œæ— æ³•è¿›è¡Œæ¯”èµ›ã€‚ 

æˆ‘ä»¬å¯ä»¥ä»¥4ä¸ªé€‰æ‰‹ 1234 ä¸ºä¾‹, æ˜¾ç„¶å®‰æ’å¯ä»¥ä¸º:

| å¤© | 1ç»„ | 2ç»„ |
| ---- | ---- | ---- |
| 1 | 13 | 24 |
| 2 | 12 | 34 |
| 3 | 14  | 23 |

å› æ­¤å¦‚æœè€ƒè™‘ä¸¤ä¸ªäººæ¯”èµ›çš„ç®—æ³•, åˆ™éå¸¸ç®€å•ï¼Œ<mark style="background: transparent; color: red">è€Œå¯¹äºå››ä¸ªäººçš„ç®—æ³•ï¼Œ åªéœ€è®©2ä¸ªäººä¸å¦å¤–çš„2ä¸ªäººå„è‡ªæ¯”èµ›ä¸€æ¬¡å³å¯</mark> 
åœ¨æ¯”èµ›è¿‡ç¨‹ä¸­, æ¯ä¸¤ä¸ªäººå„è‡ªæ¯”èµ›å ç”¨ä¸€å¤©, è€Œæ¯æ¬¡åˆå¹¶å ç”¨ä¸€å¤©

éœ€è¦æ³¨æ„: åˆå¹¶çš„æ–¹æ³•æ˜¯æœ€åˆçš„æ»šåŠ¨æ¯”èµ›æ–¹æ³•ï¼Œ ä¾‹å¦‚1234å’Œ5678åˆå¹¶, ç¬¬ä¸€å¤©åº”å½“ 1-5 , 2-6, 3-7, 4-8 , ç¬¬äºŒå¤© 1-6, 2-7, 3-8, 4-5
æ­¤æ—¶åº”å½“å®šä¹‰ä¸€ä¸ªå·¦ä¾§æ»šåŠ¨æ•°(roll), éšç€å†…å¾ªç¯æ¬¡æ•°å¢åŠ è€Œæ»šåŠ¨, è€Œå³ä¾§é™¤äº†è‡ªåŠ¨æ»šåŠ¨ä»¥å¤–ï¼Œ è¿˜åº”å½“æŒ‰ç…§å¤©è¿›è¡Œæ»šåŠ¨(ä½¿ç”¨day_pre)ã€‚

```cpp 
#include <iostream>
#include <string>
#include <stack>
#include <vector>
using namespace std;

vector<vector<pair<int, int>>> Calender;
vector<int> recorder;
int day = 1; // å®šä¹‰å…¨å±€å˜é‡è®°å½•æ—¶é—´,

// è¿”å›å€¼æ˜¯æ¯”èµ›è¿›è¡Œçš„å¤©æ•°, ç”±äºé€’å½’çš„æ¯ä¸€å±‚å¡«å…¥çš„æ—¶é—´ä¸ç›¸åŒ,é€’å½’åˆ°æœ€æ·±æ—¶è¿›è¡Œæ—¶é—´æ‰ä¸º1
int Cycle_Match(int L, int R) {
    if (R - L == 1) {
        Calender[0][recorder[0]] = make_pair(L, R);
        recorder[0]++; 
        return 0; // è¿”å›ç¬¬0å¤©, ä»0å¼€å§‹ç®—å¤©æ•°
    }
    int m = (L + R) / 2;
    int n1 = Cycle_Match(L, m);
    int n2 = Cycle_Match(m + 1, R);
    if (n1 != n2) throw exception("run time exception");

    int day = n1;
    int day_pre = 1; // åœ¨n1åŸºç¡€ä¸Šå¢åŠ çš„å¤©æ•°
    
    // ä» l åˆ° mid å’Œä» råˆ° mid

    for (int i = L; i <= m; i++) {
        // æ»šåŠ¨åˆå¹¶, m + 1æ˜¯å³ä¾§èµ·å§‹è¿åŠ¨å‘˜, æ³¨æ„ä¸èƒ½åˆ©ç”¨record_dayè®°å½•åœºæ¬¡(åˆå§‹0)
        day = n1 + day_pre;
        int roll = 0;  // ç”¨äºå¡«å…¥æ—¶è¿›è¡Œæ»šåŠ¨
        for (int j = m+1; j <= R; j++) {
            // ä¸¤ä¸¤æ¯”èµ›ä¸€æ¬¡
            int target = j + day_pre - 1; // æ»šåŠ¨æ ‡å¿—ä½, æŒ‰ç…§day_preè¿›è¡Œæ»šåŠ¨
            Calender[day][recorder[day]] = make_pair(L + roll, target <= R? target : m + target%R);
            recorder[day]++;
            roll++; // roll æ˜¯ L çš„æ»šåŠ¨ä½, day_preæ˜¯ j çš„æ»šåŠ¨ä½
        }
        day_pre++;  
    }
    return day;
}

int main() {
    int k;
    cin >> k;
    int n = 1 << k;  // 2^k, ä¸è¶…è¿‡int èŒƒå›´å³å¯ï¼ˆkæœ€å¤§å¯ä»¥å–16ï¼‰
    cout << "number of athlete is: " << n << endl << endl;

    recorder = vector<int>(n - 1, 0); // ä»0å¼€å§‹
    for (int i = 0; i < n-1; i++) {
        // åˆå§‹åŒ–æ—¥å†è¡¨, æ¯å¤©å…±æœ‰n/2åœºæ¯”èµ›, å…±éœ€è¦è¿›è¡Œn-1å¤©
        Calender.push_back(vector<pair<int, int>>(n/2, make_pair(0, 0)));
    }
    Cycle_Match(0, n - 1);

    // æ‰“å°æ—¥å†
    for (int i = 0; i < n - 1; i++) {
        cout << "day " << i + 1 << " : " << "\t";
        for (int j = 0; j < n / 2; j++) {
            cout << Calender[i][j].first << "-" << Calender[i][j].second << "\t";
        }
        cout << endl;
    }
    return 0;
}
```

> [!note] æ€»ç»“
> åˆ†æ²»æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯æ‹†åˆ†å’Œè¿æ¥ï¼Œ é¦–å…ˆæ‹†åˆ†ä¸ºç®€å•å­é—®é¢˜,  ç„¶åå¯»æ±‚å­é—®é¢˜è¿æ¥æˆæ•´ä½“çš„æ–¹å¼


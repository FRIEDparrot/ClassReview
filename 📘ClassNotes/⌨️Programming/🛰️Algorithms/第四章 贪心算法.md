---
~
---
## 一、贪心算法简介
### (1) 贪心算法的概念和使用条件 
首先， 对于具有最优子结构的问题， 除了使用动态规划方法以外， 还可以使用更加简单的贪心算法来解决问题。
例如， 对于在找纸币时， **往往可以使用先从大的再从面值小的去找**，例如当纸币的面值为20, 5, 1时, 显然可以使用20 + 2 * 5 + 1 凑出31这个数, 且所用到的纸币数量是最少的。 

但是需要注意的是，贪心算法不一定能总是得到最优解， 例如对于11元，5元和1元纸币， 有15 = 11 + 4 * 1 可以使用 15 = 3 * 5 来进行更优化。
贪心算法**同样具有最优的子结构性质**， 而相比于动态规划算法， 贪心算法更加直接且效率更高。

贪心算法的**基本方法是先不从整体的最优化考虑， 而仅考虑某种意义上的局部最优化选择; 而利用问题的特殊性, 所获取的结果也是整体上的最优化结果**。另外我们也可以使用贪心算法对解进行极好的近似。 

### (2) 贪心算法的基本要素与性质
#### 1. 贪心选择性质
我们考虑使用贪心算法的一般特征 : 
1. 每次做的决策都是**仅在当前状态下的局部最选择**。**当前所做的选择仅依赖于过去的选择， 但绝不依赖于将来的选择**。
2. 对于**贪心选择的结果最优性证明**, 需要证明每一步的贪心选择，都将得到问题整体的最优结果， 而贪心算法以迭代方式向下进行选择。 
3. 贪心算法以及相应的证明**依赖于结构的最优子结构性质**, 即经过一个贪心选择之后，剩余的结果仍然是最优的。 即$A' = A - \{ 1\}$仍然是关于 $E' = \left\{i \in  E: s\geq f_{i} \right\}$的最优解 (见下)


## 二、相关问题 
### (1) 活动安排问题 
对于高效安排一系列占用某一公共资源的活动。设有n个活动的集合为$E = \left\{ 1, 2 , \dots , n \right\}$, 其中每个活动要求占用同一公共资源， 而每一个活动都给出了对应的起始时间$s_i$和终止时间$f_i$, 显然, 当$[s_i, f_i )\cap [s_{j}, f_{j}) = \emptyset$时, 则两个活动是相容的。 
要求**在所给活动的集合中选出最大的相容活动的子集和**。 

![[Excalidraw/第四章 贪心算法 2024-02-10 09.53.09]]
以上面的活动示意为例,  对于活动列表中的所有 活动， 显然我们安排开始时间靠前的， 不可能得到最优的解； 因此我们考虑如何选择能得到较好的活动安排: 

我们容易想到， **如果当前所选择的活动能够尽早结束**, 则有利于我们为选择下一次活动留出更早的开始时间。 因此我们可以**对活动按照结束时间进行排序**。<u>获得一个活动结束时间的升序排列</u>， 在此排列中， 可以**按照贪心算法， 依次选择结束早的活动，且选择时只需考虑能够和已选部分相容即可**。 

对上述问题贪心算法的最优性质证明:  
首先, 由于**排序是按照结束时间进行升序排列**的，因此事件1具有最早的结束时间。我们需要证明,  **最优解以一个贪心选择开始**。 我们**设最优解序列$A$的一个活动是活动**$k$, 则只需证明$k=1$, 则$A$是以该贪心选择所开始的最优解。 

我们首先假设 $k > 1$, 此时, 有$B = A - \{ k\} \cup 1$, 则所剩下的部分中，能够与$k$事件相容的事件(设为$l$)必定满足$s_l \geq f_{k}$, 而选取事件1时, 由于$f_1 \leq f_k$, 因而能够相容事件$k$的序列也必然能够相容事件1, 即以1开始的也是最优解。 这样就完成了性质证明。 

核心代码如下:
```cpp
for (int i = 0, _time_ = 0; i < itemlist.size(); i++) {
        if (itemlist[i].start >= _time_) {
            res.push_back(itemlist[i]); 
            _time_ = itemlist[i].end;
        }
    }
```
整个程序如下:
```cpp fold
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef struct ItemTodo {
    int start;
    int end;
    char id;
    ItemTodo(int start, int end, int id) :start(start), end(end), id(id) {};
    friend bool operator< (const ItemTodo A,const ItemTodo B) {
        return A.end < B.end;
    };
}Item;

int main()
{
    vector<Item> itemlist;
    vector<int> start{0,8, 1, 3, 5, 10};
    vector<int> end{ 6, 11, 3, 5, 9, 13 };
    vector<char> ids{ 'A','B','C','D','E','F'};
    for (int i = 0; i < start.size(); i++) {
        itemlist.push_back(Item(start[i], end[i], ids[i]));
    }
    std::sort(itemlist.begin(), itemlist.end()); // 按照结束时间进行升序排序

    vector<Item> res;
    for (int i = 0, _time_ = 0; i < itemlist.size(); i++) {
        if (itemlist[i].start >= _time_) {
            res.push_back(itemlist[i]); 
            _time_ = itemlist[i].end;
        }
    }

    for (int i = 0; i < res.size(); i++) {
        cout << res[i].id << " ";
    }

    return 0;
}
```

### (2) 最优装载问题 
对于一批集装箱， 要装上一艘载重为c的轮串, 其中, 集装箱$i$的重量为$w_i$, 而最优装载问题确定在装载体积部首席那只情况 ，尽可能多地将集装箱装上船; 

显然应当将集装箱从重量小大重量大进行排序, 然后依次装入即可。其最优子结构和性质也非常容易证明

### (3) 哈夫曼编码问题
参考[[📘ClassNotes/⌨️Programming/🌳C and Data Structure/课程笔记/第六章 树和二叉树#七、哈夫曼树和哈夫曼编码|哈夫曼树和哈夫曼编码]]部分
其基本的合并方法是先将节点按照权值进行排序， 然后**按照贪心算法， 每一次将两个权值最小的树节点进行合并**， 最终得到最优解。

哈夫曼编码的最优性证明只需要证明如果在树中交换任意两个节点位置，则平均搜索长度均不小于原先的搜索长度

#### (4) 图的最小生成树和最短路径问题
参考[[📘ClassNotes/⌨️Programming/🌳C and Data Structure/课程笔记/第七章 图|第七章 图]]部分,  最常见的贪心算法包括 Dijkstra 算法和


## 一、基本概念
**图的定义**：
图是一种网状的数据结构， 其定义为**顶点数据**和和**顶点数据间关系**的集合的总和
$$\begin{matrix}
Graph = (V,R) \\
V = \{x|x \in DataObject\} \\ 
R = \{VR \} \\
\text{VR} = \{<x,y>|P(x,y), \quad \text{x,y}\in V \}
\end{matrix}$$
其中，$DataObject$为中体数据集合，$VR$表示两个顶点关系的集合

**弧**: 若两个定点之间的关系几何使用$VR\text{(vortex relationship)}$进行表示， 且$<x,y>\in VR$， 则$<x,y>$表示从$x$到$y$的一条弧，并称$x$为**弧尾(首端点)**，$y$为**弧头(终端点)**
![[Excalidraw/第七章 图 2023-05-16 11.02.57|230]]
**有向图和无向图**：由于$<x,y>$是有方向性的， 一般的图为**有向图**，而若$\forall <x,y>\in R, <y,x> \in R$， 则可以使用无序对$(x,y)$表示，此时图为无向图
![[attachments/Pasted image 20230502201003.png|250]]

`````ad-note
title: 一个简单的矩阵定义连通图的例子
collapse: close

```cpp
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <unordered_map>
using namespace std;

typedef int VortexType;

// 首先直接通过数组实现图的存储结构
int main()
{
    // 图的顶点数和边数
    int m, n;
    // 这里使用一个哈希表，保证各种顺序或者类型的输入都可以建立图(包括A,B,C,D,只需更改VortexType即可)
    unordered_map<VortexType, int> map; 

    cin >> m >> n;
    VortexType* vtx = new VortexType[m];

    // 使用false初始化存储数组
    bool** Road = new bool* [m];
    for (int lin = 0; lin < m; lin++) {
        Road[lin] = new bool[m];
        for (int col = 0; col < m; col++)
            Road[lin][col]= false;
    }

    for (int i = 0; i < m; i++) {
        VortexType node;
        cin >> node;
        vtx[i] = node;
        // 初始化节点对应下标的哈希表
        map[vtx[i]] = i;
    }
    
    int node1, node2;
    for (int i = 0; i < n; i++) {
        cin >> node1 >> node2;
        int index1 = map[node1], index2 = map[node2];
        Road[index1][index2] = true;
    }

    VortexType panode1, panode2;
    int pan1, pan2;
    cin >> panode1 >> panode2;
    pan1 = map[node1], pan2 = map[node2];

    if (Road[pan1][pan2]) {
        cout << "yes" << endl;
    }
    else {
        cout << "no" << endl; 
    }
    return 0; 
}

/*
4 4
1 2 3 4
1 2
1 3
1 4
2 3
1 4
*/
```

`````

可以<mark style="background: transparent; color: yellow">使用邻接矩阵的方法</mark>表示**图在每一个其他元素上是否有路径**
其中$G_{i,j} = 1$表示两点之间是否可以形成通路(有路径且指向)
一个简单的示例如下: 
$$\left[\begin{matrix}
 & 1 \\
1 & & 1 & 1\\ 
& 1 \\
& 1
\end{matrix} \right]$$
其中**顶点的度**($TD$)包含所有和该点的边，包含顶点的**出度**(OD)和**入度**(ID)(从该点出， 入的数目)， 同时定义**图的度**为==所有顶点度数之和==，即$\sum\limits_{v\in V}TD(v)$。

对于一个图$G=(V,E)$来说，若存在一个子集$V'\subseteq V$使得子集内任意两点$v_i,v_j\in V'$均连通，则称这个子集为一个**连通分量**。如果一个图只有一个连通分量，则被称为**连通图**；否则称为**非连通图**。
一般地， 有
$$e = \frac{1}{2}\left(\sum^{n}_{i=1} TD (V_i) \right)$$
其中$e$为弧的数量

根据边的数量相对顶点的数量可以分为稀疏图$(e < n\log n)$和稠密图$(e>=n\log n)$

**连通图**: 在无向图中，如果$x,y$之间<mark style="background: transparent; color: yellow">存在路径</mark>(注意不一定双向)，则称$x,y$是连通的，如果图中的任意两个点都是连通的，则称图$G$为**连通图**

**连通分量(Connected component)**: 无向图中的极大连通子图（不存在包含且有更多分量的部分， 注意与强连通图区分）

**子图**：设有两个图$G = (V, |E|)$和图$G'  =(V' , |E'|)$， 对于$V\subseteq U, E'\subseteq E$， 则称$G'$是$G$的子图

**强连通图:** 任意两个顶点都<mark style="background: transparent; color: yellow">互相可以到达</mark>的图
**强连通分量**：<mark style="background: transparent; color: yellow">极大强连通子图</mark>， 即最多的可以相互到达的图

**完全图**是每一个顶点都和其余的n-1个顶点有边连接

**权**: 图中<mark style="background: transparent; color: yellow">每条边都有一个数字或权值与之关联</mark>，用来表示该边距离等特征。对于带权图，通常使用邻接矩阵或邻接表中**存储的不再是 0 或 1，而是边的权值**。 
在图论中，有许多算法和问题需要考虑图的权值，如<mark style="background: transparent; color: yellow">最短路径问题、最小生成树问题等</mark>。

**网**: **带权的图**称为网， 也称为赋权图

在带权图中还有一种重要的概念叫做<mark style="background: transparent; color: yellow">生成树</mark>。生成树是指**一个无向连通图中所有节点都被覆盖，并且不存在环路的子图**。对于一个**连通图的生成树， 是连通图的一个极小连通子图**(子图包含图的所有顶点)

权值之和最小的生成树，称为<mark style="background: transparent; color: yellow">图的最小生成树</mark> 

## 二、图的存储结构
### (1) 邻接矩阵表示方法
邻接矩阵的表示方法是使用一个较大的矩阵， 即使用$g[i][j]$来代表点$i$和点$j$之间是否有路径
```cpp 
[0, 1, 1, 0, 0]
[1, 0, 0, 1, 1]
[1, 0, 0, 0, 0]
[0, 1, 0, 0, 0]
[0, 1, 0, 0, 0]
```

另外， 如果是网，那么则初始化每一个元素为距离，没有路的点之间距离记为无穷大， 而本身记为0。即
```cpp 
[  0,   1,   1, inf, inf]
[  1,   0, inf,   1,   1]
[  1, inf,   0, inf, inf]
[inf,   1, inf,   0, inf]
[inf,   1, inf, inf,   0]
```

邻接矩阵缺点是稀疏图的表示情况，空间浪费较大
`````ad-note
title: 图的定义代码示例
collapse: close

```cpp 
#include <iostream> 
#define Inf 23768          // 定义无穷大
#define MAX_VORTEX_NUM 100 // 最大顶点个数

/* 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */
typedef enum graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义顶点的数据类型
typedef char VortexData;

//定义弧的节点类型
typedef struct arcNode {
    // adjType adj; 对于无权图, 使用1或0表示相邻，带权图为权值类型
    // OtherInfo info;
};

class adjMatrix {
public:
    VortexData vortex[MAX_VORTEX_NUM];
    arcNode route[MAX_VORTEX_NUM][MAX_VORTEX_NUM];
    int vexNum, arcNum; // 定义顶点数和弧的数量
    graphType type;
};

```

`````

### (2) 邻接表表示方法
使用<mark style="background: transparent; color: yellow">数组+链表的临接表表示方法</mark>
(和向量表示的临接表差不多)
对于每个顶点，我们维护一个链表，链表中包含该顶点所连向的所有顶点。
```cpp 
struct node{
int v;
struct node* next;
}
```

实现邻接表需要用到以下两种数据结构：
1. 链表：用于存储每个顶点所连向的其他顶点。
2. 数组：用于记录所有顶点以及它们所对应的链表。

邻接表示例如下图所示：
```cpp
1. a -> b -> c
2. b -> a -> d
3. c -> a -> d
4. d -> b -> c
// 上述方法可以定义
```

在邻接表中，可以很方便地找到某个节点所相邻的所有节点。如果我们要寻找某个节点v相邻的所有节点，只需要访问v对应的链表即可。具体实现时可以采用数组来记录每个节点对应的链表头指针，并且为了避免重复添加边，在添加边时需要先检查是否已经存在该边。


`````ad-note
title: 邻接表的定义以及一个初始化示例
collapse: close

可以使用字典的方法定义对应的图以及对应的路径
```cpp
# 定义图的邻接表表示 
graph = { 
	'A': ['B', 'C'], 
	'B': ['D', 'E'], 
	'C': ['F'], 
	'D': [], 
	'E': ['F'], 
	'F': []
}
```


```cpp 
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#define Inf 23768          // 定义无穷大
using namespace std;

/* 
 * 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */

 // 定义顶点的数据类型
typedef char VortexType;

typedef enum class graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义弧的节点类型
struct arcNode {
    int end_index = 0;
    arcNode* next = nullptr;
};

//定义顶点的节点类型
struct vexNode {
    arcNode* first_rt = nullptr;  // 指向下一个存储的节点
    VortexType vortex = '\0';
    bool visited = false;
};


class graph {
public:
    graph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
        initgraph(vexVec, routeVec, type);
    };
    graphType type = graphType::DG;
    bool hasWay(VortexType A, VortexType B);
private:
    void initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type);
    int vexNum = 0, arcNum = 0; // 定义顶点数和边的数量
    vexNode** vexList;
    unordered_map<VortexType, int> index_map;
};

// 初始化有向图
void graph::initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
    // 设置顶点和边的数量
    this->vexNum = vexVec.size(); 
    this->arcNum = routeVec.size();
    this->vexList = new vexNode * [this->vexNum]{nullptr}; // 分配指针的空间

    for (int i = 0; i < vexNum; i++) {
        this->vexList[i] = new vexNode();     // 还需要每一个单独分配数据空间
        this->vexList[i]->vortex = vexVec[i];  


        this->index_map[vexVec[i]] = i;       // 同时记录对应的下标
    }
    for (int i = 0; i < arcNum; i++) {
        arcNode* node = new arcNode();
        int start_index = this->index_map[routeVec[i][0]];
        node->end_index = this->index_map[routeVec[i][1]];

        if (!this->vexList[start_index]->first_rt) {
            // 直接接到尾部
            this->vexList[start_index]->first_rt = node;
        }
        else {
            arcNode* p = this->vexList[start_index]->first_rt;
            while (p->next) p = p->next;
            p->next = node;
        }
    }
}

// 通过广度优先搜索遍历有向图并寻找是否有对应路径
bool graph::hasWay(VortexType A, VortexType B) {
    int start_index = this->index_map[A];
    queue<vexNode*> q;
    q.push(this->vexList[start_index]);

    while (!q.empty()) {
        vexNode* node = q.front();
        node->visited = true;
        q.pop();
        // 判断是否达到
        if (node->vortex == B) {
            return true;
        }
        for (arcNode* p = node->first_rt; p; p = p->next) {
            if (!this->vexList[p->end_index]->visited) {
                q.push(this->vexList[p->end_index]);
            } 
        }
    }
    return false;
}

int main() {
    int  vexNum, arcNum;
    cin >> vexNum >> arcNum;
    vector<VortexType> vexVec;
    VortexType input, input2;
    for (int i = 0; i < vexNum; i++) {
        cin >> input;
        vexVec.push_back(input);
    }

    vector<vector<VortexType>> route;
    for (int i = 0; i < arcNum; i++) {
        cin >> input >> input2;
        vector<VortexType> newVec {input, input2};
        route.push_back(newVec);
    }
    // 初始化有向图
    graph g(vexVec,route,graphType::DG);

    VortexType start, end;
    cin >> start >> end;
    if (g.hasWay(start, end)) cout << "yes" << endl;
    else cout << "no" << endl;
    return 0;
}
```

`````

临接表的表示方法缺点是难以确定对应的行和列的图的进入节点，如果想要找哪个节点到对应的节点有边，需要穷举整个邻接表（也可以使用逆邻接表加入一个进行表示）

### (3) 十字链表表示方法
十字链表是有向图的一种链式存储结构，对于稀疏表的存储十分有效

(1) 十字链表表示的顶点结构为: 

| data | first in | first out |
| ---- | ------- | --------- |
其中，first in 和first out 分别指向第一个进入该节点的的表


(2) 十字链表表示的弧节点结构为:

| headvex | tailvex | head | tail | info | 
| ------- | ------- | ---- | ---- | ---- |

其中弧节点元素存储了弧尾和弧头的位置，tailevex是这个节点本身， tail指向其子表，包含到其他节点的路径， 其存储结构如图所示 : 
![[Excalidraw/第七章 图 2023-05-09 11.00.45|380]]

```cpp 
#define MAX_VERTEX_NUM 20

enum class graphType {
    DG,
    DN,
    UDG,
    UDN
};

// 定义节点的弧
struct arcNode{
	int row = 0, col = 0;
	DataType data;
	arcNode* right; 
	arcNode* down;
}

/* 也可以使用如下的方法
typedef struct _ArcNode
{
  int  tailVex, headVex;  // 弧的头尾顶点的位置, row, col
  struct _ArcNode *hLink;  // 弧头相同的弧的链域, 相当于down
  struct _ArcNode *tLink;  // 弧尾相同的弧的链域, 相当于right
  AdjType  weight;
}ArcNode;
*/
```

也可以使用如下的存储方法， 这个方法的左侧的节点第一个表示行的第一个， 第二个指针表示列指针，其表示思路就是将上面的矩阵的行和列合并了：

![[attachments/Pasted image 20230509111450.png|400]]
对于使用十字链表表示的树，<mark style="background: transparent; color: yellow">优点是可以通过对应的节点直接找其入节点(或者说以该节点为弧尾的节点)</mark>， 出节点从列向下遍历，入节点从行<mark style="background: transparent; color: yellow">向右遍历</mark>即可

具体实例参考[[#]]

### (4) 邻接多重表表示方法
图的邻接多重表表示方法为： 

| data | firstedge |
| ---- | --------- |
为顶点

| mark | ivex | jvex | ilink | jlink | info |
| ---- | ---- | ---- | ----- | ----- | ---- |
为边
其中mark为是否被搜索过，`ivex, jvex`为两个边的顶点在图中的位置， 即 row, col, 并可以使用ilink和jlink作为根节点的指向

## 三、图的搜索算法
带权图中最常见的算法是最短路径算法，它可以用来找到两个节点之间的最短路径。其中，Dijkstra算法和Floyd算法是最常用的两种方法。

在带权图中，我们可以通过构建最小生成树来找到连接所有节点所需的最小花费路径。其中，Prim算法和Kruskal算法是常用的两种方法。

图广搜的难点是搜索过程中的<mark style="background: transparent; color: yellow">状态判重</mark>
### (1) 图的深度优先搜索

使用邻接矩阵表示的图

`````ad-note 
title: 文献查找
collapse: close
[文献查找](https://www.luogu.com.cn/problem/P5318)
```cpp 
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <queue>
using namespace std;

typedef int vortexType;

typedef struct arc {
    int end = 0;
    arc* next = nullptr;
};

typedef struct node {
    vortexType data = 1;
    arc* next = nullptr;
    bool visited = false;
};

// 使用邻接矩阵方法存储的图
class graph {
public: 
    // 初始化表
    graph(int size) {
        this->size = size;
        this->nodes = new node*[size];
        for (int i = 0; i < size; i++) {
            this->nodes[i] = new node();  // 分配指针空间
            this->nodes[i]->data = i + 1;
        }
    }
    void insert_way(int start, int end);
    void show();
    void dfs(int index);
    void bfs(int index);
    void reinit();
private: 
    node** nodes = nullptr;
    int size;
};

// 在某两个节点间插入路径
void graph::insert_way(int start, int end) {
    node* cur = this->nodes[start - 1];
    if (!cur->next) {
        arc* L = new arc();
        L->end = end;   // end 存储1,2, ....
        cur->next = L;
    }
    else {
        // 按照从小到大的顺序建立邻接表
        arc* pre = cur->next;
        if (pre->end > end) {
            arc* L = new arc();
            L->end = end;
            L->next = pre;
            cur->next = L;
        }
        else{
            for (; pre->next && pre->next->end < end; pre = pre->next);
            arc* L = new arc();
            L->end = end;
            L->next = pre->next;
            pre->next = L;
        }
    }
}

void graph::show() {
    for (int i = 0; i < this->size; i++) {
        cout << i + 1 << " ";
        for (arc* p = this->nodes[i]->next; p; p = p->next) {
            cout << p->end << " ";
        }
        cout << endl;
    }
    // 重置visited标识
    for (int i = 0; i < this->size; i++) this->nodes[i]->visited = false;
}

// 深度优先遍历, index输入0
void graph::dfs(int index) {
    cout << this->nodes[index]->data << " ";
    this->nodes[index]->visited = true;
    for (arc* p = this->nodes[index]->next; p; p = p->next) {
        if (!this->nodes[p->end -1]->visited) dfs(p->end - 1); // 判定之前是否遍历过
        // 注意: -> 需要进行是否访问过的判重
    };
}

// 重置visited标识
void graph::reinit() {
    for (int i = 0; i < this->size; i++) this->nodes[i]->visited = false;
}

// 广度优先搜索算法
void graph::bfs(int index) {
    queue<int> q;
    q.push(index);
    this->nodes[index]->visited = true;

    while (!q.empty()) {
        int cur_index = q.front();
        q.pop();
        cout << this->nodes[cur_index]->data << " ";
        
        // 注意入队时visited的设置,需要在入队时直接设置为true
        for (arc* p = this->nodes[cur_index]->next; p; p = p->next) {
            int end = p->end - 1;
            if (!this->nodes[end]->visited) {
                this->nodes[end]->visited = true;
                q.push(end);
            }
        }
    }
}
    
// 首先直接通过数组实现图的存储结构
int main()
{
    int m, n;
    cin >> n >> m;   // n 为文章个数
    
    graph g(n);

    // 获取对应的引用关系
    int start, end;
    for (int i = 0; i < m; i++) {
        cin >> start >> end;
        g.insert_way(start, end);
    }
    // g.show();
    g.dfs(0);
    g.reinit();
    cout << endl;
    g.bfs(0);
    return 0;
}

/* Test Code 
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8
*/
```

`````

[图的遍历](https://www.luogu.com.cn/problem/P3916)
这个图的遍历思路是查找能达到的路径中最大的点
可以利用反向建边的方法进行遍历

### (2) 图的广度优先搜索
使用队列方法进行图的广度优先搜索
最终队列空则不可到达目标



`````ad-note
title: 八数码问题
collapse: open


`````

`````ad-note
title: [食物链问题](https://www.luogu.com.cn/problem/P3183)
collapse: open

如图所示为某生态系统的食物网示意图，据图回答第 1 小题  
现在给你 n 个物种和 m 条能量流动关系，求其中的食物链条数。物种的名称为从 11 到 n 编号 M 条能量流动关系形如$a1​,b1​,a2​,b2​,a3​,b3​,…,a_{m−1}​,b_{m−1}​,am​,b_m​$。其中 ��ai​ 和 ��bi​ 表示能量从物种 ��ai​ 流向物种 ��bi​，注意单独的一种孤立生物不算一条食物链。

基本思路: 全局变量定义一个cnt ，每一次起始条件为无入有出，终止条件为next =null算一条

代码略去，较为简单
`````

## 四、图的典型问题
#### (1) [杂务问题](https://www.luogu.com.cn/problem/P1113)
问题见[[❔LeeCode Problems/杂务|杂务问题]]
首先，我们认为，第一个杂务是必须做的（如果有首先多个杂务需要做，可以建立一个节点）

我们使用反向建边的方法， 将每一个杂务的时间作为节点的data值

我们思考如何存储杂务需要的总时间
###### 方法一 (最直接的方法) 
全局定义一个计时器， 在每一个前序任务完成之后，计时器每+1, 则对应的图的节点(要求前序已经做完)剩余时间-1

实现较为简单， 略去代码

###### 方法二
但是我们可以不定义全局的计时器，只需要计算时间的差值即可。首先确定使用广度优先搜索方法以及时间先后排序的思想，每一次搜索时，将目前正在做的部分加入"目前的杂务队列"，按照剩余时间的大小存储，然后每一次完成时间最小的杂务(每个杂务的剩余时间-队列中最小的剩余时间)。

<mark style="background: transparent; color: yellow">需要说明的是， 每一次插入时需要插入到合适的位置上，因此采用十字链表结构类型进行存储</mark>
![[attachments/Pasted image 20230509111450.png|400]]
一个简单示例如下图
![[Excalidraw/第七章 图 2023-05-11 08.26.38|350]]
上图的十字链表存储结构为(节点编号-1)
```cpp 
============按列输出================
0 0,1 0,3
1 1,2 1,5 1,4
2 2,6
3 3,4 3,5
4 4,6
5 5,6
-----------按行输出(入度节点)----------------
1 1,0
2 2,1
3 3,0
4 4,1 4,3
5 5,1 5,3
6 6,2 6,5 6,4
==========================
```

我们对每一个节点维护一个left_time属性，每一次将正在做的节点放入表中，每次所有“在做”的排序表中，所有的事物减去排序表`List`中`left_time`最小的那一个的时间。 

当一个节点的left_time = 0时，将其出表， 那么这件事情就已经做完了

在出队完毕后，检查一次所有节点，如果某个节点<mark style="background: transparent; color: yellow">“目前可以做了”</mark>，则将其入队， 标识为现在在做的事情。

需要注意节点"目前可以做"的条件: 
1. 本身未做过，即`left_time != 0`
2. 所有的入节点`left_time`均等于0, 准备工作已经完成
3. 节点不在"在做"表中(如果在，则不能重复加入)

````ad-abstract
title: 代码示例
collapse: close 

```cpp 
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <queue>
#define MAX_SIZE 11000
using namespace std;

typedef int vortexType;  // 节点类型

// 弧节点, 链表节点，记录行列
typedef struct arc {
    int row;
    int col;
    arc* right;
    arc* down;
    arc() : row(0), col(0), right(nullptr), down(nullptr) {}
    arc(int row, int col) : row(row), col(col), right(nullptr), down(nullptr) {}
    arc(int row, int col, arc* right, arc* down) : row(row), col(col), right(right), down(down) {}
};

// 使用一个节点的压缩存储方法, 由于是数组，不用存储行列
typedef struct edge {
    vortexType vortex = 0;  // 空位
    int num = 0;        // 行列数
    int left_time = 0;      // 剩余时间
    arc* linNext = nullptr;
    arc* colNext = nullptr;
};

// 单链表存储对应的task
typedef struct SeqLink {
    edge* task = nullptr;
    SeqLink* next = nullptr;
};

SeqLink* insert_elem(SeqLink* root, edge* elem) {
    SeqLink* L = new SeqLink();
    L->task = elem;
    if (!root) {
        root = L;
    }
    else if (root->task->left_time > elem->left_time) { // 头结点
        L->next = root;
        root = L;
    }
    else {
        SeqLink* p = nullptr, * pre = nullptr;
        for (p = root, pre = root;p && p->task->left_time < elem->left_time; pre = p,p = p->next);
        L->next = pre->next;
        pre->next = L;
    }
    return root;
}

// 使用十字链表存储图的结构
class graph {
public:
    graph(int size) {
        this->size = size;
        // 初始化对应的row_col_edge节点
        for (int i = 0; i < size; i++) {
            this->row_col_edge[i] = new edge();
        }
    }
    void insert_way(int start, int end);
    void set_edge(int edgeIndex, int time);
    void show();
    int DoAll();

private:
    int size;
    bool canDo(SeqLink* List, edge* edge);
    edge* row_col_edge[MAX_SIZE]{nullptr};  // 边的节点, 指针数组类型
};

// 在某两个点中插入路径, start 和 end 为对应的下标,有行指向这个，则代表有路径
void graph::insert_way(int start, int end) {
    // 从列节点向下插入
    edge* e = this->row_col_edge[start];
    arc* c = new arc(end, start); // c->col = start; c->row = end;
    // 插头结点
    if (!e->colNext || (e->colNext && e->colNext->row > c->row)) {
        c->down = e->colNext;
        e->colNext = c;
    }
    else {
        arc *cur, *pre;
        for (cur=e->colNext, pre=e->colNext; cur && cur->row > c->row; pre = cur, cur = cur->down);
        c->down = pre->down;
        pre->down = c;
    }

    // 插入行节点
    edge* e2 = this->row_col_edge[end];
    if (!e2->linNext || (e2->linNext && e2->linNext->col > c->col)) {
        c->right = e2->linNext;
        e2->linNext = c;
    }
    else {
        arc* cur,*pre;
        for (cur = e2->linNext, pre = e2->linNext; cur && cur->col > c->col; pre = cur, cur = cur->right);
        c->right = pre->right;
        pre->right = c;
    }
};

// 设置边的时间
void graph::set_edge(int edgeIndex, int time) {
    this->row_col_edge[edgeIndex]->num = edgeIndex;
    this->row_col_edge[edgeIndex]->left_time = time;
}

void graph::show() {
    // 按序查找是否以前的事被做完
    cout << "============================" << endl;
    for (int i = 0; i < this->size; i++) {
        edge* e = this->row_col_edge[i];
        if (!e->colNext) continue;
        cout << e->num << " ";
        for (arc* p = e->colNext; p; p = p->down) {
            cout << p->row << " ";
        }
        cout << endl;
    }
    cout << "---------------------------" << endl;
    for (int i = 0; i < this->size; i++) {
        edge* e = this->row_col_edge[i];
        if (!e->linNext) continue;
        cout << e->num << " ";
        for (arc* p = e->linNext; p; p = p->right) {
            cout << p->col << " ";
        }
        cout << endl;
    }
    
}

// 可以做的要求: 1. 不能已经做完(left_time>0)  2. 不在链表中(不能重复加)  3. 前面的事情已经做完
bool graph::canDo(SeqLink* List, edge* edge) {
    if (!edge) throw runtime_error("Edge Initialize error");
    if (edge->left_time == 0) return false;
    for (SeqLink* p = List; p; p = p->next) {
        if (p->task == edge) return false;
    }
    // 按序查找是否以前的事被做完(检查left_time)
    if (edge->linNext == nullptr) return true;
    for (arc* p = edge->linNext; p; p = p->right) {
        if (this->row_col_edge[p->col]->left_time != 0) return false;
    }
    return true;
}

// 计算完成杂务的最少时间
int graph::DoAll() {
    SeqLink* List = nullptr;
    List = insert_elem(List, row_col_edge[0]);
    int cnt = 0; // 总时间 = 0
    // 循环直到空指针
    while (List!= nullptr) {
        int firstTime = List[0].task->left_time;
        for (SeqLink* p = List; p; p = p->next) {
            p->task->left_time -= firstTime;
        }
        // 删除leftTime对应的元素
        SeqLink* p = List;
        for (; p && p->task->left_time == 0; p = p->next);
        List = p;
        // 检测是否还有可做而未做的事务
        for (int i = 0; i < this ->size ; i++) {
            // 注意不能多次加入队列，一个事情只能做一次,这个集成到canDo之中
            if (canDo(List ,this->row_col_edge[i])) {
                List = insert_elem(List, this->row_col_edge[i]);
            }
        }
        cnt += firstTime;
    }
    return cnt;
}

// 首先直接通过数组实现图的存储结构
int main()
{
    int n;  // 需要做的杂务数量
    std::cin >> n;
    
    graph g(n);
    // 获取对应的引用关系
    int start, time,end;

    for (int i = 0; i < n; i++) {
        cin >> end; // 第一个是任务名称
        cin >> time;
        g.set_edge(end - 1, time);

        while (true) {
            cin >> start;
            if (start == 0) break;
            g.insert_way(start - 1, end - 1); // 建立边, 从准备事务开始
        }
    }
    // g.show();
    std::cout << g.DoAll() << endl;
    return 0;
}

/* Test Code
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
*/
```

````

#### (2) 迷宫和宝石的收集问题
在求解时， 必须集齐所有种类的宝石(宝石同一种类可能有多个)， 迷宫中有指定数量的传送门，
最少的步数，应当使用广度优先搜索进行获取， 采用身上带宝石的不同的状态进行判断(例如，在到达某一行列之后， 可能身上带有不同的宝石， 因此状态判重方法是在此基础上， 判断身上携带宝石的状态)

可以使用五位二进制数，减少多个状态的判断的次数

例如将五位二进制数的表示
s = s|(1 << 3); 使用对应的
![[Excalidraw/第七章 图 2023-05-09 10.38.24|200]]

状态判重，<mark style="background: transparent; color: yellow">一种方法是使用多维数组</mark>， 如定义一个数组 `int used[100][100][32]`
`used[3][5][9] = 1`表示到达过的状态，可以解决状态判重问题。

[八数码问题](https://blog.csdn.net/OCEANtroye/article/details/103859243)

#### (3) 图的表达式存储
将表达式表示为有向无环图的临接表，可以将表达式中的操作数和操作符表示为图中的节点，将它们之间的关系表示为有向边。可以按照表达式从左到右的顺序，依次将操作数和操作符转换为节点，并建立它们之间的有向边，使得每个操作符节点的入边对应其运算所需的操作数节点，出边对应运算结果。这样，整个表达式就被表示为一个有向无环图的临接表。

[有向无环图的表达式存储](https://blog.csdn.net/qq_43546676/article/details/107434564)

**有向无环图描述表达式的生成步骤**
1. 把各个操作数不重复地排成一排
2. 标出各个运算符的生效顺序（先后顺序优点出入无所谓，比如先算左边括号或者先算右边括号，当然是同级的情况）
3. 按顺序加入运算符，不同的运算级别层次不同，过程中如果已经存在某部分，则直接用
4. 最后生成的图就是有向无环图


![[attachments/Pasted image 20230507194830.png|400]]

![[attachments/Pasted image 20230507194622.png|400]]

通过使用有向无环图表示表达式，可以节省很多

```cpp 
#include <iostream>
#include <stack>
#include <string>
#include <vector>

enum NodeType { OPERATOR, OPERAND };

struct Node {
    NodeType type;
    char value;
    Node* left;
    Node* right;

    Node(NodeType t, char v) : type(t), value(v), left(nullptr), right(nullptr) {}
};

Node* create_ast(const std::string& expr) {
    std::stack<Node*> st;
    for (char ch : expr) {
        if (ch == '(' || ch == ' ') {
            continue;
        }
        else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
            Node* op = new Node(OPERATOR, ch);
            op->right = st.top(); st.pop();
            op->left = st.top(); st.pop();
            st.push(op);
        }
        else if (ch == ')') {
            Node* top = st.top(); st.pop();
            st.top()->right = top;
        }
        else {
            st.push(new Node(OPERAND, ch));
        }
    }
    return st.top();
}

void traverse_ast_to_rpn(Node* node, std::string& rpn) {
    if (node == nullptr) return;

    traverse_ast_to_rpn(node->left, rpn);
    traverse_ast_to_rpn(node->right, rpn);

    if (node->type == OPERATOR || node->type == OPERAND) {
        rpn.push_back(node->value);
    }
}

std::string expr_to_rpn(const std::string& expr) {
    Node* ast = create_ast(expr);
    std::string rpn;
    traverse_ast_to_rpn(ast, rpn);
    return rpn;
}

int main() {
    std::string expr = "(a+b)*c";
    std::string rpn = expr_to_rpn(expr);
    std::cout << "逆波兰表达式: " << rpn << std::endl;  // 输出：ab+c*
    return 0;
}
```

## 五、图的两大算法
### (1) 最小生成树问题
[[📘ClassNotes/⌨️Programming/Data Structure/课程笔记/第七章 图#一、基本概念|最小生成树的概念]]

最小生成树(MST)的两种方法均是使用贪心算法的思路，每一次寻找已求得部分和未求得部分的最小的边
#### 1) [Prim算法](https://blog.csdn.net/hzf0701/article/details/107927858)
Prim算法的思路是从一个起点开始，每次找到一个<mark style="background: transparent; color: yellow">与已有树相邻的最小边</mark>，将其加入树中。具体实现时<u>可以使用优先队列来维护当前与已有树相邻的边</u>，每次取出队列中权值最小的边进行扩展。

需要注意的是，Prim算法共加入n-1条路径，因此循环n-1次即可求解

`````ad-note
title: Prim算法的示例代码
collapse: close

```cpp 
#include <iostream>
#include <vector>
#define MAX_SIZE 100
#define Inf 10000
using namespace std;

// 使用Prim算法建立最小生成树, 首先取一个辅助数组
int D[MAX_SIZE][MAX_SIZE];
bool MiniTree[MAX_SIZE][MAX_SIZE];

// 输入根节点
void Prim(int n, int start) {
    // 每一次寻找目前树的最短的扩展边并加入
    vector<bool> has(n, false);
    // 初始化最小生成树
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            MiniTree[i][j] = false;   
        }
    }

    has[start] = true; // 将初始节点加入
    
    // 加入n-1次(由于有n-1个路径)
    for (int t = n-1; t > 0; t--) {
        int minimum = Inf + 1;
        int from = 0, dst = 0; // dst 是min_index
        // 寻找到目前树的最短路径
        for (int i = 0; i < n; i++) {
            if (!has[i]) continue;  // 在目前的树中搜索
            for (int j = 0; j < n; j++) {
                if (!has[j] && minimum > D[i][j]) { 
                    // 要求不等于目前的数
                    minimum = D[i][j];
                    from = i;
                    dst = j;
                }
            }
        }
        // 将节点加入树中
        has[dst] = true;
        MiniTree[from][dst] = true;
    }
}

int main() {
    int n;
    cin >> n;
    int input;
    // 建立图
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> input;
            D[i][j] = input;
        }
    }
    Prim(n, 1);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (MiniTree[i][j])
            cout << i << "----(" << D[i][j] << ")--->" << j << endl;
        }
    }
    return 0;
}

/* Test Code
4
0 2 10 10000
2 0 7 3
10 7 0 6
10000 3 6 0
0 2
*/
```

`````

#### 2) [Kruskal算法](https://blog.csdn.net/hzf0701/article/details/107933639)
Kruskal算法的思路<mark style="background: transparent; color: yellow">是将所有边按照权值从小到大排序，然后依次加入树中，如果加入的边与已有边形成环，则舍弃该边。</mark>

Kruskal算法是一种**基于并查集的算法**，可以使用**优先队列**和**并查集**来实现

**对于Prim算法，往往针对==节点数较少==的适用，而Kruskal算法适用于==边数较少的部分(往往适用于稀疏图==, 其原因是边排序的复杂度)**

`````ad-note
title: Kruskal算法的示例代码
collapse: close

下图中，使用临界矩阵建立了一个优先队列, 每一次将元素插入到队伍的合适位置

需要注意的是，下面的代码有很多可优化的地方，如在检测队伍中如果形成环， 则丢弃对应的边。

```cpp 
#include <iostream>
#define MAXSIZE 100
#define Inf 10000
using namespace std;

// 使用Kruskal算法的最小生成树建立
int A[MAXSIZE][MAXSIZE];
int R[MAXSIZE][MAXSIZE]; // 记录最小生成树
bool visited[MAXSIZE];

struct way {
    int start;
    int end;
    int length;
    way(int start, int end, int length) : start(start), end(end), length(length) {};
};

typedef way* DataType;

struct LList {
    DataType data;
    LList* next;
    LList(DataType data) : data(data), next(nullptr){};
};

// 在顺序链表中，插入元素
LList* Insert_elem(LList* root, LList* road) {
    if (!root || (root && root->data->length > road->data->length)) {
        road->next = root;
        root = road;
    }
    else {
        LList* p = root, *pre = root; 
        for (; p && p->data->length < road->data->length; pre = p, p = p->next);
        road->next = pre->next;
        pre->next = road; // 注意顺序
    }
    return root;
}


void Kruskal(int n) {
    LList* root = nullptr;
    // 建立优先队列并插入所有的点
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (A[i][j] >= Inf || A[i][j] == 0) continue; 
            way* arc = new way(i, j, A[i][j]);
            LList* road = new LList(arc);
            root = Insert_elem(root, road);
        }
        visited[i] = false;
    }
    if (!root) exit(-1);

    // 首先加入最短的一条边
    int start1 = root->data->start;
    int end1 = root->data->end;
    R[start1][end1] = A[start1][end1];
    visited[start1] = true; visited[end1] = true;

    // 建立最小生成树, 循环n-1次
    for (int t = n - 2; t > 0; t--) {
        // 每一次找到最短的并加入
        for (LList* cur = root;cur; cur = cur->next) {
            int start = cur->data->start;
            int end = cur->data->end;
            if ((!visited[start] && !visited[end])||(visited[start] && visited[end])) continue;
            R[start][end] = A[start][end];
            R[end][start] = A[start][end];
            visited[start] = true;
            visited[end] = true;
            // 不用删除对应的节点(可以删去，但是不删去时下一次会跳过)
            break;
        }
    }
}

int main() {
    int n; 
    cin >> n;
    int row, col, length;
    // 建立临接矩阵的图
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            A[i][j] = Inf;
            R[i][j] = Inf;
        }
        A[i][i] = 0;
    }
    while (true) {
        cin >> row >> col >> length;
        if (row == 0 || col == 0 || length == 0) break;
        row = row - 1; col = col - 1;
        A[row][col] = length;
        A[col][row] = length;
    }
    Kruskal(n);
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (R[i][j]!= Inf) cout << i +1 << "->" << j+1 << " " <<  R[i][j] << endl;
        }
    }
    return 0;
}

/* Test Code
6 
1 2 16 
1 6 21
1 5 19
2 3 5
2 4 6
2 6 11
3 4 6
4 5 18
4 6 14
5 6 33
0 0 0
*/
```

`````

### (2) 最短路径问题
#### 1. Dijkstra 算法
Dijkstra 算法用于求解某一个顶点$v$到其余顶点的最短路径的长度
其算法的时间复杂度为$O(n^2)$

对于 **Dijkstra** 算法，方法是==每一次加入一个新的点，并使用这个节点更新其余的节点==， 注意在过程中并不加入某条路径
![[Excalidraw/第七章 图 2023-05-11 17.32.33|650]]

加入的节点是<mark style="background: transparent; color: yellow">目前更新后，其余节点路径中取得最小值的那个节点</mark>
1. 加入新的邻接点
2. 更新其余节点的信息

显然，有$n$个节点，则需要更新次数为$n-1$

首先使用邻接矩阵表示赋权图

`````ad-abstract
title: Dijkstra 算法的示例代码
collapse:close

```cpp 
#include <iostream>
#include <vector>
#define Inf 1000
#define MAX_SIZE 100

using namespace std;

// 邻接矩阵类
class Neighbor {
public:
	Neighbor(int n) {
		this->n = n;
		// 初始化
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (i == j) a[i][j] = 0;
				else a[i][j] = Inf;
			}
		}
	}
	void Dijkstra();
	void show();
	void show_matrix();
	void insert_way(int row, int col, int length);

private:
	int n = 0;
	int a[MAX_SIZE][MAX_SIZE];
	int d[MAX_SIZE]{}; // 得到的最短路径;
	bool s[MAX_SIZE]{}; // 已经求得最短路径的点的集合
};

void Neighbor::insert_way(int row, int col, int length) {
	a[row][col] = length;
	a[col][row] = length;
}

void Neighbor::Dijkstra() {
	d[0] = 0; s[0] = true;  // 0 已经寻找过
	// 初始化数组d，需要注意的是，仅使用a进行初始化, 取最小时仅使用d
	for (int i = 1; i < n; i++) {
		d[i] = min(Inf, a[0][i]);
		s[i] = false;
	}
	// 使用循环, n-1次, 每一次寻找路径最小的节点并加入
	for (int t = n-1; t > 0; t--) {
		int min = Inf;
		int min_index = 0;
		for (int i = 0; i < n; i++) {
			// 在其余(未求得最小值)的节点中，确定取得最小值的节点下标
			if ( s[i] || d[i]>=min) continue;  // min大于才做
			min_index = i; min = d[i];
		}
		// 得到d中值最小的节点，将其加入集合
		d[min_index] = min;
		s[min_index] = true;

		// 每一次更新其余节点的值
		for (int i = 0; i < n; i++) {
			if (s[i]) continue;
			// 如果两点之间有路径，则更新为对应的值
			d[i] = std::min(d[i], d[min_index] + a[min_index][i]);
		}
	}
}

void Neighbor::show() {
	for (int i = 0; i < n; i++) {
		std::cout << d[i] << " ";
	}
	std::cout << endl;
}

int main() {
	int n, m;
	// 初始化a的路径长度
	std::cin >> n >> m;
	Neighbor g(n);
	for (int i = 0; i < m; i++) {
		int start, end, length;
		std::cin >> start >> end >> length;
		g.insert_way(start-1, end-1, length);
	}
	g.Dijkstra();
	g.show();
	return 0;
}
```

需要注意的是，如果是对于有向图，可以定义一个bool find, 如果找到，则更新s, d和其余节点信息(因为有可能有向图里面有达不到的节点)
`````

`````ad-note
title: 带有最短路径记录的Dijkstra 算法的注意事项
collapse: close

```cpp 
#include <iostream>
#define MAXSIZE 100
#define Inf 10000
using namespace std;

typedef struct WayTo {
    int Way[MAXSIZE] = {};
    int size = 0; 
};

WayTo R[MAXSIZE];
bool s[MAXSIZE];
int d[MAXSIZE];

void ConcatWay(int cur, int k) {
    R[k].size = 0;
    // 更新路径信息为从此处到cur, + cur -> dst;
    if (cur != 0) {  // 注意需要!=0, 即不等于起始的点
        for (int t = 0; t < R[cur].size; t++) {
            R[k].Way[t] = R[cur].Way[t];
            R[k].size++;
        }
    }
    R[k].Way[R[k].size] = cur;
    R[k].size++;
}

// use the Dijkstra algorithm 
void Dijkstra(int n, int D[MAXSIZE][MAXSIZE]) {
    // 顶点0的最短路径
    for (int i = 0; i < n; i++) {
        s[i] = false;
    }
    int min = Inf, minIndex = 0;
    s[0] = true; d[0] = 0; 
    // 初始化最短路径
    for (int i = 0; i < n; i++) {
        d[i] = D[0][i];
        int size = R[i].size;
        R[i].Way[size] = 0;
        R[i].size++;
    }
    int cur = 0;  // 全局定义的
    // 从顶点到其余的路径中找到最短路径并返回
    for (int t = n - 1; t > 0; t--) {
        int minlength = Inf; // 目前的最短路径
        // 1. 取最短的路径
        int j = 0;
        for (; j < n; j++) {
            if (!s[j] && D[cur][j] < Inf) { // 没有确定时
                if (minlength > d[cur] + D[cur][j]) {
                    minlength = d[cur] + D[cur][j];
                    minIndex = j;
                    // 更新路径信息为从此处到cur, + cur -> dst;
                }
            }
        }
        // 得到带有最短路径的下标
        s[minIndex] = true;
        // 注意: 此处判断！！！！
        if (minlength < d[minIndex]) {
            d[minIndex] = minlength;
            ConcatWay(cur, minIndex);
        }

        cur = minIndex;
        // 2. 更新到其余点的最短路径
        for (int k = 0; k < n; k++) {
            if (!s[k] && d[cur] + D[cur][k] < d[k]) {
                d[k] = d[cur] + D[cur][k];
                ConcatWay(cur, k);
            }
        }
    }
}

int Road[MAXSIZE][MAXSIZE];
int main() {
    int  n, input;
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> input;
            Road[i][j] = input;
        }
    }
    Dijkstra(n, Road);

    int end;
 
    cin >> end;
    for (int i = 0; i < R[end].size; i++) {
        cout << R[end].Way[i] << endl;
    }
    if (0 != end) cout << end << endl;
    
    return 0;
}

/*
4
0 2 10 10000
2 0 7 3
10 7 0 6
10000 3 6 0



6
0 1 4 10000 10000 10000
1 0 2 7 5 10000
4 2 0 10000 1 10000
10000 7 10000 0 3 2
10000 5 1 3 0 6
10000 10000 10000 2 6 0
*/
```

`````

`````ad-note
title: Dijkstra 算法求解任意两点之间的最短长度
collapse: close

```cpp 
#include <iostream>
#define MAXSIZE 100
#define Inf 10000
using namespace std;

typedef struct WayTo {
    int Way[MAXSIZE] = {};
    int size = 0; 
};

WayTo R[MAXSIZE][MAXSIZE];
bool s[MAXSIZE][MAXSIZE];
int d[MAXSIZE][MAXSIZE];

void ConcatWay(int start, int cur, int end) {
    R[start][end].size = 0;
    // 更新路径信息为从此处到cur, + cur -> dst;
    // 注意需要!=start, 即不等于起始的点, 否则多加一个0
    for (int t = 0; t < R[start][cur].size; t++) {
        R[start][end].Way[t] = R[start][cur].Way[t];
        R[start][end].size++;
    }
    R[start][end].Way[R[start][end].size] = cur;
    R[start][end].size++;
}

void show(int n, int start) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < R[start][j].size; j++) {
            cout << R[start][i].Way[j] << " ";
        }
        cout << endl;
    }
}

// use the Dijkstra algorithm 
void Dijkstra(int start, int n, int D[MAXSIZE][MAXSIZE]) {
    // 顶点0的最短路径
    s[start][start] = true; d[start][start] = 0;
    // 初始化最短路径
    for (int i = 0; i < n; i++) {
        d[start][i] = D[start][i];
        int size = R[start][i].size;
        R[start][i].Way[size] = start;
        R[start][i].size++;
    }

    int minIndex = 0;
    int cur = start;  // 全局定义的cur
    // 从顶点到其余的路径中找到最短路径并返回
    for (int t = n - 1; t > 0; t--) {
        int minlength = Inf; // 目前的最短路径
        // 1. 取最短的路径
        int j = 0;
        for (; j < n; j++) {
            if (!s[start][j] && D[cur][j] < Inf) { // 没有确定时
                if (minlength > d[start][cur] + D[cur][j]) {
                    minlength = d[start][cur] + D[cur][j];
                    minIndex = j;
                    // 更新路径信息为从此处到cur, + cur -> dst;
                }
            }
        }
        // 得到带有最短路径的下标
        s[start][minIndex] = true;
        // 注意: 此处判断！！！！
        if (minlength < d[start][minIndex]) {
            d[start][minIndex] = minlength;
            ConcatWay(start, cur, minIndex);
        }

        cur = minIndex;
        // 2. 更新到其余点的最短路径
        for (int k = 0; k < n; k++) {
            if (!s[start][k] && d[start][cur] + D[cur][k] < d[start][k]) {
                d[start][k] = d[start][cur] + D[cur][k];
                ConcatWay(start, cur, k);
            }
        }
    }
}

int Road[MAXSIZE][MAXSIZE];
int main() {
    int  n, input;
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> input;
            Road[i][j] = input;
        }
    }

    for (int start = 0; start < n; start++) {
        // 重置
        for (int j = 0; j < n; j++) {
            s[start][j] = false;
            d[start][j] = Inf;
        }
        Dijkstra(start, n, Road);
    }
    
    int start, end;
    cin >> start >> end;
    for (int i = 0; i < R[start][end].size; i++) {
        cout << R[start][end].Way[i] << endl;
    }
    if (start != end) cout << end << endl;
    
    return 0;
}

/*
4
0 2 10 10000
2 0 7 3
10 7 0 6
10000 3 6 0
3 0

6
0 1 4 10000 10000 10000
1 0 2 7 5 10000
4 2 0 10000 1 10000
10000 7 10000 0 3 2
10000 5 1 3 0 6
10000 10000 10000 2 6 0
0 5
*/
```

`````

#### 2. Floyd 算法
Floyd算法用于求解<mark style="background: transparent; color: yellow">任意两点的最短路径长度</mark>，并其时间复杂度是$O(n^3)$, 与调用$n$次Dijkstra算法相同

Floyd算法的思路: 首先对于每两个顶点之间的最短路径， 新建一个数组$D[i][j][k]$存储每两个节点中的最短路径

**为何能通过更新求解出所有的最短路径**? 
首先对于$v_i$和$v_j$节点，将其路径初始化为$D[i][j]$。
这个使用的是动态规划的思想， 需要注意的是， 每一次，求解时求解三点之间的最短路径，在更新到第1次时，则$D[i][j][1]$是<mark style="background: transparent; color: yellow">加入了中间节点1</mark><u>(即经过的中间节点可能有1)</u>之后， 三元路径长度之和。

第二次加入点2进行更新时，显然<mark style="background: transparent; color: yellow">中间节点有1</mark>的三元路径长度已经被加入过，从而下次计算出的是中间节点加入2的最短路径长度，此时，<mark style="background: transparent; color: red">中间节点可能有1，2</mark>

循环更新n次，直到所有的n个节点都被加入到中间节点中，因此<mark style="background: transparent; color: red">可以经过的中间节点即有1,2,3,...n</mark>，因而得到的就是任意两点间的最短路径

`````ad-note
title: Floyd算法的代码实现
collapse: close
先引入一个`D[i][j][k]`表示只利用k以内的节点(点从1开始)，从i到j的最短路径的长度

其核心函数代码只需要5-6行即可写完

需要注意的是，**在Floyd算法中， 必须包括经过0的节点也必须进行更新，即循环从k=0开始 , 每一次使用k+1的赋值方法**, 需要特别注意循环条件。

```cpp 
#include <iostream> 
#define MAX_SIZE 100
#define Inf 10000
using namespace std;

// 邻接矩阵, 其中第0层为第一次迭代的矩阵
int D[MAX_SIZE][MAX_SIZE][MAX_SIZE];

void Floyd(int n) {
    for (int k = 0; k < n; k++) {
        // 每一次加入中间节点k,即可能的中间节点有k, 由于有n个点，更新n次
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                D[i][j][k+1] = min(D[i][j][k], D[i][k][k] + D[k][j][k]);
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    int row, col, data;
    // 初始化无向图
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            D[i][j][0] = Inf;
        }
        D[i][i][0] = 0;
    }
    while (true) {
        cin >> row >> col >> data;
        if (row == 0 && col == 0 && data == 0) break;
        D[row][col][0] = data;
        D[col][row][0] = data;
    }
    Floyd(n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << D[i][j][n] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

得到每一点之间的最短路径如下:
```cpp 
/* Test Code
6
0 1 1
0 2 4
1 2 2
1 3 7
1 4 5
2 4 1
3 4 3
3 5 2
4 5 6
0 0 0
*/
/* result
0 1 3 7 4 9
1 0 2 6 3 8
3 2 0 4 1 6
7 6 4 0 3 2
4 3 1 3 0 5
9 8 6 2 5 0
*/
```

`````

需要说明的是，对于带有路径记录的Floyd算法，有如下几点注意事项:
1. <mark style="background: transparent; color: yellow">首先，如果图的下标是从0开始的，则k层数目应当定义为MAX_SIZE+1，由于0点也要遍历，所以每一次是给k+1层赋值</mark>，具体实现代码: `D[i][j][k + 1] = min(D[i][j][k],  D[i][k][k] + D[k][j][k]);`
2.  记录最短路径时，每个点均初始化一个数组<mark style="background: transparent; color: yellow">并以i添加到数组中，作为初始的起点</mark>， (如果没有路径，可以不初始化)
3. 在记录中添加最短路径时，<mark style="background: transparent; color: orange">使用的方式是直接丢弃原数组，并将Way[i][k], Way[k][j]两个数组整体合并之后，作为新的最短路径</mark>，而不是仅仅在路径中添加k点或者将k以后的部分接到`Way[i][j]`上面

`````ad-note
title: 带有路径记录的Floyd算法的实现代码
collapse: close

下面的方法利用临接矩阵和数组初始化来说明，易错代码已经标出
```cpp
#include <iostream>
#define MAXSIZE 100
#define Inf 10000
using namespace std;

// 对于记录在Floyd中经过的所有点并且求解最短路径, 首先维护一个struct数组(替代vector)
typedef struct WayTo {
    int Way[MAXSIZE + 1] = {};
    int size = 1; // 初始化为1(仅存储起点)
};

int A[MAXSIZE][MAXSIZE][MAXSIZE + 1];
WayTo Ways[MAXSIZE][MAXSIZE];

// 弗洛伊德算法思想: 每一次更新可以途径第i个点到其余点的最短路径
void Floyd(int n) {
    // 初始时为0
    for (int k = 0; k < n; k++) {// 注意: 有从序号0的点开始的情况！
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int len = A[i][k][k] + A[k][j][k];
                if (len < A[i][j][k]) {
                    /*******此处发生错误: 不是直接接k, 而是将k到j 的路径整体接到上面**************/
				    /*****不是把[k][j]接在[i][j]上，而是将[i][k]和[k][j]整体融合作为新的Ways[i][j]*****/
                    Ways[i][j].size = 0; // 直接清零
                    for (int t = 0; t < Ways[i][k].size; t++) {
                        int s = Ways[i][j].size;
                        Ways[i][j].Way[s] = Ways[i][k].Way[t];
                        Ways[i][j].size++;
                    }
                    for (int t = 0; t < Ways[k][j].size; t++) {
                        int s = Ways[i][j].size;
                        Ways[i][j].Way[s] = Ways[k][j].Way[t];
                        Ways[i][j].size++;
                    }
                    A[i][j][k + 1] = len;
                }
                else {
                    A[i][j][k + 1] = A[i][j][k];
                }
            }
        }
    }
}

int main() {
    int n, input;
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> input;
            A[i][j][0] = input;
            // 注意: 包括不存在路径的，也需要进行初始化
            Ways[i][j].Way[0] = i; // 仅记录起点和途径的部分, 不用记录终点
        }
    }
    Floyd(n);

    int m, row, col;
    int rowVec[MAXSIZE], colVec[MAXSIZE];
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> row >> col;
        rowVec[i] = row, colVec[i] = col;
    }


    for (int i = 0; i < m; i++) {
        int r = rowVec[i], c = colVec[i];
        for (int j = 0; j < Ways[r][c].size; j++) {
            cout << Ways[r][c].Way[j] << endl;  // 需要注意不存储终点，需要单独输出
        }
        cout << c << endl;
    }

    return 0;
}

/* Test Code
4
0 2 10 10000
2 0 7 3
10 7 0 6
10000 3 6 0
2
0 2
3 0
*/
```

`````

## 六、拓扑排序和关键路径
### (1) 有向无环图的拓扑排序
1. 拓扑序列的建立
每一次<mark style="background: transparent; color: yellow">任意找到一个入度为0的节点</mark>$v$，输出之后，在图中<mark style="background: transparent; color: yellow">删除掉对应的节点和节点以及对应的边</mark>， 循环$n$次

使用顶点表示活动， 并使用弧表示活动之间关系的有向无环图，称为**顶点表示活动的网(AOV网)**。显然AOV网**不能存在回路**，否则无法执行

AOV网可以存在多个起始的活动

算法思想(拓扑排序)
1. 首先存储每个顶点的入度并<mark style="background: transparent; color: yellow">将入度为0的点入栈</mark>
2. 每次<mark style="background: transparent; color: yellow">出栈一个节点</mark>并更新<mark style="background: transparent; color: yellow">其到达点的入度</mark>
3. 如果<mark style="background: transparent; color: yellow">某个点的入度变为0, 则将该点入栈</mark>

我们以临接表方法建立如下图的矩阵为例:
![[Excalidraw/第七章 图 2023-05-26 21.11.32|550]]

`````ad-note
title: 拓扑排序的实现代码
collapse: close
下面的代码建立上图的结构并实现了拓扑序列和反拓扑序列的建立

```cpp
#include <iostream>
#include <vector>
#include <stack>
#define MAXSIZE 100
using namespace std;

typedef struct arc {
    int dst = 0;
    int time = 0;  // 做事需要的时间
    arc* next = nullptr;
};

// 使用邻接表存储每个节点的情况
struct edge {
    int row = 0;      // 初始化时已经做好
    vector<int> inNodes; // 存储对应的入节点(size = 入度)
    int inDegree = 0; // 记录节点的入度
    int outDegree = 0; // 记录出度
    arc* next;
};

// 邻接表类型
class NList{
public:
    NList(int size) {
        this->size = size;
        for (int i = 0; i < size; i++) {
            edge* e = new edge();
            e->row = i;
            e->next = nullptr;
            nodes[i] = e; // 对数组进行初始化
        }
    }
    void insert_way(int from, int to, int legnth);
    void show();
    vector<int> Topo(bool reverse);
private:
    edge* nodes[MAXSIZE];
    int size = 0;
};

void NList::insert_way(int from, int to, int time) {
    arc* a = new arc();
    a->dst = to;
    a->time = time;

    arc* fstarc = this->nodes[from]->next;
    if (!fstarc || (fstarc && fstarc ->dst > a ->dst )) {
        a->next = this->nodes[from]->next;
        this->nodes[from]->next = a;
    }
    else {
        // 将节点接在后面
        arc* p = fstarc, *pre = p;
        for (; p && p->dst < a ->dst; pre = p, p = p->next);
        a->next = pre->next;
        pre->next = a;
    }
    // 更新对应节点的入度和出度
    this->nodes[from]->outDegree++;
    this->nodes[to]->inDegree++;
    this->nodes[to]->inNodes.push_back(from); 
    // 存储入度，用来构造反拓扑序列
}

void NList::show() {
    for (int i = 0; i < this->size; i++) {
        cout << i << "(" << this -> nodes[i]->inDegree << "," 
            << this->nodes[i]->outDegree << ")" << " --> ";
        for (arc* p = this->nodes[i]->next; p ; p = p->next) {
            cout << p->dst << "(" << p->time << ")" << " ";
        }
        cout << endl;
    }
}

vector<int> NList::Topo(bool reverse) {
    // 进行拓扑排序, 正拓扑序列
    vector<int> res;
    stack<edge*> stk;
    // 不需要建立visited数组记录是否删除过, 这是因为是有向图, 访问时不会出现重复访问的情况    

    if (!reverse) {
        // 压入所有入度为0的点为起始
        for (int i = 0; i < this->size; i++) {
            if (this->nodes[i]->inDegree != 0) continue;
            stk.push(this ->nodes[i]);
        }
        while (!stk.empty()) {
            edge* p = stk.top();
            res.push_back(p->row);  // 加入拓扑序列
            stk.pop();
            // 将访问的节点出栈
            for (arc* q = p->next; q ;q = q->next) {
                this->nodes[q->dst]->inDegree -= 1;
                if (this->nodes[q->dst]->inDegree == 0) {
                    stk.push(this->nodes[q->dst]);
                }
            }
        }
    }
    else { // 产生反拓扑序列
        for (int i = 0; i < this->size; i++) {
            if (this->nodes[i]->outDegree != 0) continue;
            stk.push(this->nodes[i]);
        }
        while (!stk.empty()) {
            edge* p = stk.top();
            res.push_back(p->row);
            stk.pop(); // 出栈
            for (int i = p->inNodes.size() - 1; i >= 0; i--) {
                int index = p->inNodes[i];  // 仅需要存储对应的下标
                p->inNodes.pop_back();      // 每一次取末尾的元素
                this->nodes[index]->outDegree--;
                if (this->nodes[index]->outDegree == 0) {
                    stk.push(this->nodes[index]);
                }
            }
        }
    }
    return res;
}

int main() {
    int n; 
    cin >> n;
    int from, to, time;
    // 建立临接表的图
    
    NList L(n);

    while (true){
        cin >> from >> to >> time;
        if (from == 0 && to == 0 && time == 0) break;
        L.insert_way(from, to, time);
    }
    L.show();
    vector<int> vec = L.Topo(false);
    for (int i = 0; i < n; i++) {
        cout << vec[i] << "->";
    }
    cout << endl;
    return 0;
}

/* Test Code
9
0 1 6
0 2 4
0 3 5
1 4 1
2 4 1 
3 5 2 
4 6 9
4 7 7
5 7 4
6 8 2
7 8 4
0 0 0
*/
```

结果为`0->3->5->2->1->4->7->6->8`反拓扑序列`8->6->7->4->1->2->5->3->0`

`````

### (2) 关键路径
类似的问题也可以使用链表来进行求解，见[[#(1) [杂务问题](https://www.luogu.com.cn/problem/P1113)|杂务问题]]

我们以如图的AOE网为例

关键路径定义的理解方法： 关键路径上的活动是不可以进行耽误的，如果耽误则会导致整个完成时间推迟

**最早开始时间**是从前向后推的, 前面任务都完成时的最快时间，而**最晚开始时间**是从后向前推的 总时间 - 做事用的时间

关键路径算法的重点是求解最早开始时间和最晚开始时间
1. 对于<mark style="background: transparent; color: yellow">最早开始时间earliest_reach</mark>，一开始**初始化为0向量即可(不是无穷)**， 每一次使用max函数求解最大路径长度，
2. 对于<mark style="background: transparent; color: yellow">最晚开始时间latest_reach</mark>， 首先使用earliest_reach做初始化
我们考虑一个多终点的最短路径算法过程如下图， 应当首先使用earliest_reach对每个最晚开始时间做初始化，显然latest_start可以大于earliest_reach，但是在如图的结构中，B的latest_start应当为两个节点中的较小值(用D计算是4, 用E计算是1, 需要保证每个事情都不延误， 同时可以推得A的最晚开始时间应当是0)。需要注意的是, 不能通过判断相等来判断是否是第一种情况，因此需要定义一个modified数组, 记录每一个节点是否计算过。
![[Excalidraw/第七章 图 2023-05-27 07.59.50|300]]

`````ad-note
title: 相关定义
collapse: close
AOE-无环图网(Activity on Edge Network)：即用边表示活动的网，是带权的有序无环图，其中顶点表示事件，弧表示活动，权表示活动持续的时间。通常，AOE-网可用来估算工程完成的时间。如上图所示

由于有些工程可并行地进行，**完成所有工程的最短时间**即为从开始点到完成点的**最长路径的长度(最早发生时间)**。**路径最长**的路径叫**关键路径(Critical Path)**。

<mark style="background: transparent; color: yellow">事件Vi的最早发生时间</mark>：从开始点v1到vi的最长路径长度。用$ee(i)$表示。

事件Vi的<mark style="background: transparent; color: yellow">最迟发生时间</mark>：在不推迟整个工期的前提下，事件vi允许的最晚发生时间。用$le(i)$表示。

活动$ai$的<mark style="background: transparent; color: yellow">最早开始时间</mark>：即为ai的弧尾顶点(事件)的最早发生时间。用$e(i)$表示。

活动$ai$的<mark style="background: transparent; color: yellow">最迟开始时间</mark>：在保证不推迟整个工程的完成时间的的前提下，活动ai的最迟开始时间。用$l(i)$表示。
`````

**关键路径的思想部分**
1. 首先寻找每个事件的最早开始时间
* 通过拓扑排序, 得到拓扑序列，**通过拓扑序列进行访问节点更新**时间，则<mark style="background: transparent; color: yellow">一遍直接即可确定每个节点的最早发生时间</mark>

2. 寻找每个事件的最晚开始时间
- 然后在逆拓扑序列下，从终点向前倒推最晚开始时间， 这个是**使用拓扑排序的(逆拓扑序列)倒序**来进行倒推的， 求解**各个节点的最迟发生时间**

3. 通过判断最早开始时间是否等于最晚开始时间，确定关键路径
- 最早开始时间和最晚开始时间(下一个事件的最早发生时间-这个)相等时， 事件不能延误， 从而在关键路径上

<mark style="background: transparent; color: yellow">另外需要说明的是如何确定一个路径是关键路径</mark>: 如果这个路径的**起点和终点均为关键点**，且**时间 = 终点的时间 - 起点的时间** 即可判断这条路径是关键路径。(也可以使用计算事件最早发生时间的方法, 详见p245)

`````ad-note
title: 关键路径算法的实现代码 
collapse: close

输出结果为：`Key Points : 0 1 4 6 7 8`

```cpp 
#include <iostream>
#include <vector>
#include <stack>
#define MAXSIZE 100
#define Inf 10000
using namespace std;

typedef struct arc {
    int dst = 0;
    int time = 0;  // 做事需要的时间
    arc* next = nullptr;
};

// 使用邻接表存储每个节点的情况
struct edge {
    int row = 0;      // 初始化时已经做好
    vector<int> inNodes; // 存储对应的入节点(size = 入度)
    int inDegree = 0; // 记录节点的入度
    int outDegree = 0; // 记录出度
    arc* next = nullptr;
};

// 邻接表类型
class NList{
public:
    NList(int size) {
        this->size = size;
        for (int i = 0; i < size; i++) {
            edge* e = new edge();
            e->row = i;
            e->next = nullptr;
            nodes[i] = e; // 对数组进行初始化
        }
    }
    void insert_way(int from, int to, int legnth);
    void show();
    vector<int> Topo(bool reverse);
    vector<int> KeyWays();
private:
    edge* nodes[MAXSIZE];
    int size = 0;
};

void NList::insert_way(int from, int to, int time) {
    arc* a = new arc();
    a->dst = to;
    a->time = time;

    arc* fstarc = this->nodes[from]->next;
    if (!fstarc || (fstarc && fstarc ->dst > a ->dst )) {
        a->next = this->nodes[from]->next;
        this->nodes[from]->next = a;
    }
    else {
        // 将节点接在后面
        arc* p = fstarc, *pre = p;
        for (; p && p->dst < a ->dst; pre = p, p = p->next);
        a->next = pre->next;
        pre->next = a;
    }
    // 更新对应节点的入度和出度
    this->nodes[from]->outDegree++;
    this->nodes[to]->inDegree++;
    this->nodes[to]->inNodes.push_back(from); 
    // 存储入度，用来构造反拓扑序列
}

void NList::show() {
    for (int i = 0; i < this->size; i++) {
        cout << i << "(" << this -> nodes[i]->inDegree << "," 
            << this->nodes[i]->outDegree << ")" << " --> ";
        for (arc* p = this->nodes[i]->next; p ; p = p->next) {
            cout << p->dst << "(" << p->time << ")" << " ";
        }
        cout << endl;
    }
}

vector<int> NList::Topo(bool reverse) {
    // 进行拓扑排序, 正拓扑序列
    vector<int> res;
    stack<edge*> stk;
    // 不需要建立visited数组记录是否删除过, 这是因为是有向图, 访问时不会出现重复访问的情况    

    if (!reverse) {
        // 压入所有入度为0的点为起始
        for (int i = 0; i < this->size; i++) {
            if (this->nodes[i]->inDegree != 0) continue;
            stk.push(this ->nodes[i]);
        }
        while (!stk.empty()) {
            edge* p = stk.top();
            res.push_back(p->row);  // 加入拓扑序列
            stk.pop();
            // 将访问的节点出栈
            for (arc* q = p->next; q ;q = q->next) {
                this->nodes[q->dst]->inDegree -= 1;
                if (this->nodes[q->dst]->inDegree == 0) {
                    stk.push(this->nodes[q->dst]);
                }
            }
        }
    }
    else { // 产生反拓扑序列
        for (int i = 0; i < this->size; i++) {
            if (this->nodes[i]->outDegree != 0) continue;
            stk.push(this->nodes[i]);
        }
        while (!stk.empty()) {
            edge* p = stk.top();
            res.push_back(p->row);
            stk.pop(); // 出栈
            for (int i = p->inNodes.size() - 1; i >= 0; i--) {
                int index = p->inNodes[i];  // 仅需要存储对应的下标
                this->nodes[index]->outDegree--;    
                // 注意不可以p->inNodes.pop_back();
                if (this->nodes[index]->outDegree == 0) {
                    stk.push(this->nodes[index]);
                }
            }
        }
    }
    return res;
}

// 关键路径算法, 默认从0开始
vector<int> NList::KeyWays() {
    vector<int> seq1 = this -> Topo(false);
    vector<int> seq2 = this -> Topo(true);

    // 初始化为0，因为先前用的两个是0
    vector<int> earliest_reach(this->size, 0);  // 最早开始时间
    earliest_reach[seq1[0]] = 0;           // 最早开始的一件事
    vector<int> res;

    for (int i = 0; i < this -> size; i++) {
        // 按照拓扑序列访问并更新到达节点的值
        int p_index = seq1[i];
        for (arc* p = this->nodes[p_index]->next; p; p = p->next) {
            earliest_reach[p->dst] = max(earliest_reach[p->dst], earliest_reach[p_index] + p->time);
            // 注意: 是前面的事情都要做完，因此使用max求最长路径，而不是min求最短路径
        }
    }
    
    // **************** 求解最晚结束时间 *************************
    vector<int> latest_start(earliest_reach);
    // 最晚开始时间 -> 首先设置为最早开始时间,再更新
    vector<bool> modified(this->size, false);

    for (int i = 0; i < this->size; i++) {
        int to = seq2[i];
        for (int from : this->nodes[to]->inNodes) {
            arc* p = this->nodes[from]->next;
            for (;p && p->dst != to; p = p->next);
            if (!p) exit(-1);
            int time = p->time; // 回溯节点，计算时间

            // 更新入度的最晚开始时间，考虑到多源的问题
            if (modified[from]) {
                latest_start[from] = min(latest_start[from], latest_start[to] - time);
            }
            else {
                latest_start[from] = latest_start[to] - time;
                modified[from] = true;
            }
        }
    }

    for (int i = 0; i < this->size; i++) {
        if (earliest_reach[i] == latest_start[i]) {
            res.push_back(i);
        }
    }
    return res;
}

int main() {
    int n; 
    cin >> n;
    int from, to, time;
    // 建立临接表的图
    NList L(n);

    while (true){
        cin >> from >> to >> time;
        if (from == 0 && to == 0 && time == 0) break;
        L.insert_way(from, to, time);
    }

    vector<int> res = L.KeyWays();

    cout << "Key Points : ";
    for (int i = 0; i < res.size(); i++) {
        cout << res[i] << " ";
    }
    cout << endl;

    return 0;
}

/* Test Code
9
0 1 6                                                                                  
0 2 4
0 3 5
1 4 1
2 4 1 
3 5 2 
4 6 9
4 7 7
5 7 4
6 8 2
7 8 4
0 0 0
*/
```

`````



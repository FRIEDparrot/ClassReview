## 一、图的定义
### (1) 基本概念
**图的定义**：
图是一种网状的数据结构， 其定义为**顶点数据**和和**顶点数据间关系**的集合的总和
$$\begin{matrix}
Graph = (V,R) \\
V = \{x|x \in DataObject\} \\ 
R = \{VR \} \\
\text{VR} = \{<x,y>|P(x,y), \quad \text{x,y}\in V \}
\end{matrix}$$
其中，$DataObject$为中体数据集合，$VR$表示两个顶点关系的集合

**弧**: 若两个定点之间的关系几何使用$VR\text{(vortex relationship)}$进行表示， 且$<x,y>\in VR$， 则$<x,y>$表示从$x$到$y$的一条弧，并称$x$为**弧尾(首端点)**，$y$为**弧头(终端点)**

**有向图和无向图**：由于$<x,y>$是有方向性的， 一般的图为**有向图**，而若$\forall <x,y>\in R, <y,x> \in R$， 则可以使用无序对$(x,y)$表示，此时图为无向图
![[attachments/Pasted image 20230502201003.png|250]]

`````ad-note
title: 一个简单的矩阵定义连通图的例子
collapse: close

```cpp
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <unordered_map>
using namespace std;

typedef int VortexType;

// 首先直接通过数组实现图的存储结构
int main()
{
    // 图的顶点数和边数
    int m, n;
    // 这里使用一个哈希表，保证各种顺序或者类型的输入都可以建立图(包括A,B,C,D,只需更改VortexType即可)
    unordered_map<VortexType, int> map; 

    cin >> m >> n;
    VortexType* vtx = new VortexType[m];

    // 使用false初始化存储数组
    bool** Road = new bool* [m];
    for (int lin = 0; lin < m; lin++) {
        Road[lin] = new bool[m];
        for (int col = 0; col < m; col++)
            Road[lin][col]= false;
    }

    for (int i = 0; i < m; i++) {
        VortexType node;
        cin >> node;
        vtx[i] = node;
        // 初始化节点对应下标的哈希表
        map[vtx[i]] = i;
    }
    
    int node1, node2;
    for (int i = 0; i < n; i++) {
        cin >> node1 >> node2;
        int index1 = map[node1], index2 = map[node2];
        Road[index1][index2] = true;
    }

    VortexType panode1, panode2;
    int pan1, pan2;
    cin >> panode1 >> panode2;
    pan1 = map[node1], pan2 = map[node2];

    if (Road[pan1][pan2]) {
        cout << "yes" << endl;
    }
    else {
        cout << "no" << endl; 
    }
    return 0; 
}

/*
4 4
1 2 3 4
1 2
1 3
1 4
2 3
1 4
*/
```

`````

可以<mark style="background: transparent; color: yellow">使用邻接矩阵的方法</mark>表示**图在每一个其他元素上是否有路径**
其中$G_{i,j} = 1$表示两点之间是否可以形成通路(有路径且指向)
一个简单的示例如下: 
$$\left[\begin{matrix}
 & 1 \\
1 & & 1 & 1\\ 
& 1 \\
& 1
\end{matrix} \right]$$
其中**顶点的度**(TD)包含所有和该点的边，包含顶点的**出度**(OD)和**入度**(ID)(从该点出， 入的数目)
一般地， 有
$$e = \frac{1}{2}\left(\sum^{n}_{i=1} TD (V_i) \right)$$
其中$e$为弧的数量

根据边的数量相对顶点的数量可以分为稀疏图$(e < n\log n)$和稠密图$(e>=n\log n)$

**连通图**: 在无向图中，如果x,y之间<mark style="background: transparent; color: yellow">存在路径</mark>(注意不一定双向)，则称x,y是连通的，如果图中的任意两个点都是连通的，则称图$G$为**连通图**

**连通分量(Connected component)**: 无向图中的极大连通子图（不存在包含且有更多分量的部分， 注意与强连通图区分）

**子图**：设有两个图$G = (V, |E|)$和图$G'  =(V' , |E'|)$， 对于$V\subseteq U, E'\subseteq E$， 则称$G'$是$G$的子图

**强连通图:** 任意两个顶点都<mark style="background: transparent; color: yellow">互相可以到达</mark>的图
**强连通分量**：<mark style="background: transparent; color: yellow">极大强连通子图</mark>， 即最多的可以相互到达的图

**完全图**是每一个顶点都和其余的n-1个顶点有边连接

我们定义一个与顶点相关的量，称为图的**权**， 带权的图称为**网**
图的生成树: 一个**连通图的生成树， 是连通图的一个极小连通子图**(子图包含图的所有顶点)

权值之和最小的生成树，称为<mark style="background: transparent; color: yellow">图的最小生成树</mark> 

## 二、图的表示方法
### (1) 邻接矩阵表示方法
缺点是稀疏图的表示情况，空间浪费较大

### (2) 邻接表表示方法
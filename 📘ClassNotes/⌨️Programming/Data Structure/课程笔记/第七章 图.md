## 一、基本概念
**图的定义**：
图是一种网状的数据结构， 其定义为**顶点数据**和和**顶点数据间关系**的集合的总和
$$\begin{matrix}
Graph = (V,R) \\
V = \{x|x \in DataObject\} \\ 
R = \{VR \} \\
\text{VR} = \{<x,y>|P(x,y), \quad \text{x,y}\in V \}
\end{matrix}$$
其中，$DataObject$为中体数据集合，$VR$表示两个顶点关系的集合

**弧**: 若两个定点之间的关系几何使用$VR\text{(vortex relationship)}$进行表示， 且$<x,y>\in VR$， 则$<x,y>$表示从$x$到$y$的一条弧，并称$x$为**弧尾(首端点)**，$y$为**弧头(终端点)**

**有向图和无向图**：由于$<x,y>$是有方向性的， 一般的图为**有向图**，而若$\forall <x,y>\in R, <y,x> \in R$， 则可以使用无序对$(x,y)$表示，此时图为无向图
![[attachments/Pasted image 20230502201003.png|250]]

`````ad-note
title: 一个简单的矩阵定义连通图的例子
collapse: close

```cpp
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <unordered_map>
using namespace std;

typedef int VortexType;

// 首先直接通过数组实现图的存储结构
int main()
{
    // 图的顶点数和边数
    int m, n;
    // 这里使用一个哈希表，保证各种顺序或者类型的输入都可以建立图(包括A,B,C,D,只需更改VortexType即可)
    unordered_map<VortexType, int> map; 

    cin >> m >> n;
    VortexType* vtx = new VortexType[m];

    // 使用false初始化存储数组
    bool** Road = new bool* [m];
    for (int lin = 0; lin < m; lin++) {
        Road[lin] = new bool[m];
        for (int col = 0; col < m; col++)
            Road[lin][col]= false;
    }

    for (int i = 0; i < m; i++) {
        VortexType node;
        cin >> node;
        vtx[i] = node;
        // 初始化节点对应下标的哈希表
        map[vtx[i]] = i;
    }
    
    int node1, node2;
    for (int i = 0; i < n; i++) {
        cin >> node1 >> node2;
        int index1 = map[node1], index2 = map[node2];
        Road[index1][index2] = true;
    }

    VortexType panode1, panode2;
    int pan1, pan2;
    cin >> panode1 >> panode2;
    pan1 = map[node1], pan2 = map[node2];

    if (Road[pan1][pan2]) {
        cout << "yes" << endl;
    }
    else {
        cout << "no" << endl; 
    }
    return 0; 
}

/*
4 4
1 2 3 4
1 2
1 3
1 4
2 3
1 4
*/
```

`````

可以<mark style="background: transparent; color: yellow">使用邻接矩阵的方法</mark>表示**图在每一个其他元素上是否有路径**
其中$G_{i,j} = 1$表示两点之间是否可以形成通路(有路径且指向)
一个简单的示例如下: 
$$\left[\begin{matrix}
 & 1 \\
1 & & 1 & 1\\ 
& 1 \\
& 1
\end{matrix} \right]$$
其中**顶点的度**($TD$)包含所有和该点的边，包含顶点的**出度**(OD)和**入度**(ID)(从该点出， 入的数目)， 同时定义**图的度**为所有顶点度数之和，即$\sum\limits_{v\in V}TD(v)$。

对于一个图$G=(V,E)$来说，若存在一个子集$V'\subseteq V$使得子集内任意两点$v_i,v_j\in V'$均连通，则称这个子集为一个**连通分量**。如果一个图只有一个连通分量，则被称为**连通图**；否则称为**非连通图**。
一般地， 有
$$e = \frac{1}{2}\left(\sum^{n}_{i=1} TD (V_i) \right)$$
其中$e$为弧的数量

根据边的数量相对顶点的数量可以分为稀疏图$(e < n\log n)$和稠密图$(e>=n\log n)$

**连通图**: 在无向图中，如果x,y之间<mark style="background: transparent; color: yellow">存在路径</mark>(注意不一定双向)，则称x,y是连通的，如果图中的任意两个点都是连通的，则称图$G$为**连通图**

**连通分量(Connected component)**: 无向图中的极大连通子图（不存在包含且有更多分量的部分， 注意与强连通图区分）

**子图**：设有两个图$G = (V, |E|)$和图$G'  =(V' , |E'|)$， 对于$V\subseteq U, E'\subseteq E$， 则称$G'$是$G$的子图

**强连通图:** 任意两个顶点都<mark style="background: transparent; color: yellow">互相可以到达</mark>的图
**强连通分量**：<mark style="background: transparent; color: yellow">极大强连通子图</mark>， 即最多的可以相互到达的图

**完全图**是每一个顶点都和其余的n-1个顶点有边连接

**权**: 图中<mark style="background: transparent; color: yellow">每条边都有一个数字或权值与之关联</mark>，用来表示该边距离等特征。对于带权图，通常使用邻接矩阵或邻接表中**存储的不再是 0 或 1，而是边的权值**。 
在图论中，有许多算法和问题需要考虑图的权值，如<mark style="background: transparent; color: yellow">最短路径问题、最小生成树问题等</mark>。

**网**: **带权的图**称为网， 也称为赋权图

在带权图中还有一种重要的概念叫做<mark style="background: transparent; color: yellow">生成树</mark>。生成树是指**一个无向连通图中所有节点都被覆盖，并且不存在环路的子图**。对于一个**连通图的生成树， 是连通图的一个极小连通子图**(子图包含图的所有顶点)

权值之和最小的生成树，称为<mark style="background: transparent; color: yellow">图的最小生成树</mark> 

## 二、图的表示方法
### (1) 邻接矩阵表示方法
邻接矩阵的表示方法是使用一个较大的矩阵， 即使用$g[i][j]$来代表点$i$和点$j$之间是否有路径
```cpp 
[0, 1, 1, 0, 0]
[1, 0, 0, 1, 1]
[1, 0, 0, 0, 0]
[0, 1, 0, 0, 0]
[0, 1, 0, 0, 0]
```

邻接矩阵缺点是稀疏图的表示情况，空间浪费较大

`````ad-note
title: 图的定义代码示例
collapse: close

```cpp 
#include <iostream> 
#define Inf 23768          // 定义无穷大
#define MAX_VORTEX_NUM 100 // 最大顶点个数

/* 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */
typedef enum graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义顶点的数据类型
typedef char VortexData;

//定义弧的节点类型
typedef struct arcNode {
    // adjType adj; 对于无权图, 使用1或0表示相邻，带权图为权值类型
    // OtherInfo info;
};

class adjMatrix {
public:
    VortexData vortex[MAX_VORTEX_NUM];
    arcNode route[MAX_VORTEX_NUM][MAX_VORTEX_NUM];
    int vexNum, arcNum; // 定义顶点数和弧的数量
    graphType type;
};

```

`````

### (2) 邻接表表示方法
使用<mark style="background: transparent; color: yellow">数组+链表的临接表表示方法</mark>
对于每个顶点，我们维护一个链表，链表中包含该顶点所连向的所有顶点。
```cpp 
struct node{
int v;
struct node* next;
}
```

实现邻接表需要用到以下两种数据结构：
1. 链表：用于存储每个顶点所连向的其他顶点。
2. 数组：用于记录所有顶点以及它们所对应的链表。

邻接表示例如下图所示：
```cpp
1. a -> b -> c
2. b -> a -> d
3. c -> a -> d
4. d -> b -> c
// 上述方法可以定义
```

在邻接表中，可以很方便地找到某个节点所相邻的所有节点。如果我们要寻找某个节点v相邻的所有节点，只需要访问v对应的链表即可。具体实现时可以采用数组来记录每个节点对应的链表头指针，并且为了避免重复添加边，在添加边时需要先检查是否已经存在该边。

可以使用字典的方法定义对应的图以及对应的路径

```cpp 
# 定义图的邻接表表示 
graph = { 
	'A': ['B', 'C'], 
	'B': ['D', 'E'], 
	'C': ['F'], 
	'D': [], 
	'E': ['F'], 
	'F': []
}
```

`````ad-note
title: 邻接表的定义以及一个初始化示例
collapse: close

```cpp 
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#define Inf 23768          // 定义无穷大
using namespace std;

/* 
 * 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */

 // 定义顶点的数据类型
typedef char VortexType;

typedef enum class graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义弧的节点类型
struct arcNode {
    int end_index = 0;
    arcNode* next = nullptr;
};

//定义顶点的节点类型
struct vexNode {
    arcNode* first_rt = nullptr;  // 指向下一个存储的节点
    VortexType vortex = '\0';
    bool visited = false;
};


class graph {
public:
    graph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
        initgraph(vexVec, routeVec, type);
    };
    graphType type = graphType::DG;
    bool hasWay(VortexType A, VortexType B);
private:
    void initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type);
    int vexNum = 0, arcNum = 0; // 定义顶点数和边的数量
    vexNode** vexList;
    unordered_map<VortexType, int> index_map;
};

// 初始化有向图
void graph::initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
    // 设置顶点和边的数量
    this->vexNum = vexVec.size(); 
    this->arcNum = routeVec.size();
    this->vexList = new vexNode * [this->vexNum]{nullptr}; // 分配指针的空间

    for (int i = 0; i < vexNum; i++) {
        this->vexList[i] = new vexNode();     // 还需要每一个单独分配数据空间
        this->vexList[i]->vortex = vexVec[i];  


        this->index_map[vexVec[i]] = i;       // 同时记录对应的下标
    }
    for (int i = 0; i < arcNum; i++) {
        arcNode* node = new arcNode();
        int start_index = this->index_map[routeVec[i][0]];
        node->end_index = this->index_map[routeVec[i][1]];

        if (!this->vexList[start_index]->first_rt) {
            // 直接接到尾部
            this->vexList[start_index]->first_rt = node;
        }
        else {
            arcNode* p = this->vexList[start_index]->first_rt;
            while (p->next) p = p->next;
            p->next = node;
        }
    }
}

// 通过广度优先搜索遍历有向图并寻找是否有对应路径
bool graph::hasWay(VortexType A, VortexType B) {
    int start_index = this->index_map[A];
    queue<vexNode*> q;
    q.push(this->vexList[start_index]);

    while (!q.empty()) {
        vexNode* node = q.front();
        node->visited = true;
        q.pop();
        // 判断是否达到
        if (node->vortex == B) {
            return true;
        }
        for (arcNode* p = node->first_rt; p; p = p->next) {
            if (!this->vexList[p->end_index]->visited) {
                q.push(this->vexList[p->end_index]);
            } 
        }
    }
    return false;
}

int main() {
    int  vexNum, arcNum;
    cin >> vexNum >> arcNum;
    vector<VortexType> vexVec;
    VortexType input, input2;
    for (int i = 0; i < vexNum; i++) {
        cin >> input;
        vexVec.push_back(input);
    }

    vector<vector<VortexType>> route;
    for (int i = 0; i < arcNum; i++) {
        cin >> input >> input2;
        vector<VortexType> newVec {input, input2};
        route.push_back(newVec);
    }
    // 初始化有向图
    graph g(vexVec,route,graphType::DG);

    VortexType start, end;
    cin >> start >> end;
    if (g.hasWay(start, end)) cout << "yes" << endl;
    else cout << "no" << endl;
    return 0;
}
```

`````

临接表的表示方法缺点是难以确定对应的行和列的图的进入节点，如果想要找哪个节点到对应的节点有边，需要穷举整个邻接表（也可以使用逆邻接表加入一个进行表示）

### (3) 十字链表表示方法
十字链表是有向图的一种链式存储结构，对于稀疏表的存储十分有效

(1) 十字链表表示的顶点结构为: 

| data | first in | first out |
| ---- | ------- | --------- |
其中，first in 和first out 分别指向第一个进入该节点的的表


(2) 十字链表表示的弧节点结构为:

| headvex | tailvex | head | tail | info | 
| ------- | ------- | ---- | ---- | ---- |

其中弧节点元素存储了弧尾和弧头的位置，tailevex是这个节点本身， tail指向其子表，包含到其他节点的路径， 其存储结构如图所示 : 
![[Excalidraw/第七章 图 2023-05-09 11.00.45|380]]

```cpp 
#define MAX_VERTEX_NUM 20

enum class graphType {
    DG,
    DN,
    UDG,
    UDN
};

// 定义节点的弧
struct arcNode{
	int row = 0, col = 0;
	DataType data;
	arcNode* right; 
	arcNode* down;
}

/* 也可以使用如下的方法
typedef struct _ArcNode
{
  int  tailVex, headVex;  // 弧的头尾顶点的位置, row, col
  struct _ArcNode *hLink;  // 弧头相同的弧的链域, 相当于down
  struct _ArcNode *tLink;  // 弧尾相同的弧的链域, 相当于right
  AdjType  weight;
}ArcNode;
*/
```

也可以使用如下的存储方法， 这个方法的左侧的节点第一个表示行的第一个， 第二个指针表示列指针，其表示思路就是将上面的矩阵的行和列合并了：

![[attachments/Pasted image 20230509111450.png|400]]
对于使用十字链表表示的树，优点是可以通过对应的节点直接找其入节点(以该节点为弧尾的)

### (4) 邻接多重表表示方法
表示方法为： 

| mark | ivex | ilink | jvex | jlink | info | 
| ---- | ---- | ----- | ---- | ----- | ---- |


## 三、图的搜索算法

带权图中最常见的算法是最短路径算法，它可以用来找到两个节点之间的最短路径。其中，Dijkstra算法和Floyd算法是最常用的两种方法。

在带权图中，我们可以通过构建最小生成树来找到连接所有节点所需的最小花费路径。其中，Prim算法和Kruskal算法是常用的两种方法。

图广搜的难点是状态判重和

### (1) 图的深度优先搜索
使用邻接矩阵表示的图

`````ad-note 
title: 文献查找
collapse: close
[文献查找](https://www.luogu.com.cn/problem/P5318)
```cpp 
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <queue>
using namespace std;

typedef int vortexType;

typedef struct arc {
    int end = 0;
    arc* next = nullptr;
};

typedef struct node {
    vortexType data = 1;
    arc* next = nullptr;
    bool visited = false;
};

// 使用邻接矩阵方法存储的图
class graph {
public: 
    // 初始化表
    graph(int size) {
        this->size = size;
        this->nodes = new node*[size];
        for (int i = 0; i < size; i++) {
            this->nodes[i] = new node();  // 分配指针空间
            this->nodes[i]->data = i + 1;
        }
    }
    void insert_way(int start, int end);
    void show();
    void dfs(int index);
    void bfs(int index);
    void reinit();
private: 
    node** nodes = nullptr;
    int size;
};

// 在某两个节点间插入路径
void graph::insert_way(int start, int end) {
    node* cur = this->nodes[start - 1];
    if (!cur->next) {
        arc* L = new arc();
        L->end = end;   // end 存储1,2, ....
        cur->next = L;
    }
    else {
        // 按照从小到大的顺序建立邻接表
        arc* pre = cur->next;
        if (pre->end > end) {
            arc* L = new arc();
            L->end = end;
            L->next = pre;
            cur->next = L;
        }
        else{
            for (; pre->next && pre->next->end < end; pre = pre->next);
            arc* L = new arc();
            L->end = end;
            L->next = pre->next;
            pre->next = L;
        }
    }
}

void graph::show() {
    for (int i = 0; i < this->size; i++) {
        cout << i + 1 << " ";
        for (arc* p = this->nodes[i]->next; p; p = p->next) {
            cout << p->end << " ";
        }
        cout << endl;
    }
    // 重置visited标识
    for (int i = 0; i < this->size; i++) this->nodes[i]->visited = false;
}

// 深度优先遍历, index输入0
void graph::dfs(int index) {
    cout << this->nodes[index]->data << " ";
    this->nodes[index]->visited = true;
    for (arc* p = this->nodes[index]->next; p; p = p->next) {
        if (!this->nodes[p->end -1]->visited) dfs(p->end - 1); // 判定之前是否遍历过
    };
}

// 重置visited标识
void graph::reinit() {
    for (int i = 0; i < this->size; i++) this->nodes[i]->visited = false;
}

// 广度优先搜索算法
void graph::bfs(int index) {
    queue<int> q;
    q.push(index);
    this->nodes[index]->visited = true;

    while (!q.empty()) {
        int cur_index = q.front();
        q.pop();
        cout << this->nodes[cur_index]->data << " ";
        
        // 注意入队时visited的设置,需要在入队时直接设置为true
        for (arc* p = this->nodes[cur_index]->next; p; p = p->next) {
            int end = p->end - 1;
            if (!this->nodes[end]->visited) {
                this->nodes[end]->visited = true;
                q.push(end);
            }
        }
    }
}
    

// 首先直接通过数组实现图的存储结构
int main()
{
    int m, n;
    cin >> n >> m;   // n 为文章个数
    
    graph g(n);

    // 获取对应的引用关系
    int start, end;
    for (int i = 0; i < m; i++) {
        cin >> start >> end;
        g.insert_way(start, end);
    }
    // g.show();
    g.dfs(0);
    g.reinit();
    cout << endl;
    g.bfs(0);
    return 0;
}

/* Test Code 
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8
*/
```

`````

[图的遍历](https://www.luogu.com.cn/problem/P3916)
这个图的遍历思路是查找能达到的路径中最大的点
可以利用反向建边的方法进行遍历

### (2) 图的广度优先搜索
使用队列方法进行图的广度优先搜索

最终队列空则不可到达目标

```cpp 
this_node = stk.top()
stk.push(i); 
stk.pop();
```

`````ad-note
title: [食物链问题](https://www.luogu.com.cn/problem/P3183)
collapse: open

如图所示为某生态系统的食物网示意图，据图回答第 1 小题  
现在给你 n 个物种和 m 条能量流动关系，求其中的食物链条数。物种的名称为从 11 到 n 编号 M 条能量流动关系形如$a1​,b1​,a2​,b2​,a3​,b3​,…,a_{m−1}​,b_{m−1}​,am​,b_m​$。其中 ��ai​ 和 ��bi​ 表示能量从物种 ��ai​ 流向物种 ��bi​，注意单独的一种孤立生物不算一条食物链。

基本思路: 全局变量定义一个cnt ，每一次起始条件为无入有出，终止条件为next =null算一条

代码略去，较为简单
`````

`````ad-note
title: [杂务问题](https://www.luogu.com.cn/problem/P1113)
collapse: open

问题见[[❔LeeCode Problems/杂务|杂务问题]]

首先，我们认为，第一个杂务是必须做的（如果有首先多个杂务需要做，可以建立一个节点）

我们使用反向建边的方法， 将每一个杂务的时间作为节点的data值， 

`````

迷宫和宝石的收集问题

在求解时， 必须集齐所有种类的宝石(宝石同一种类可能有多个)， 迷宫中有指定数量的传送门，

最少的步数，应当使用广度优先搜索进行获取， 采用身上带宝石的不同的状态进行判断(例如，在到达某一行列之后， 可能身上带有不同的宝石， 因此状态判重方法是在此基础上， 判断身上携带宝石的状态)

可以使用五位二进制数，减少多个状态的判断的次数

例如将五位二进制数的表示
s = s|(1 << 3); 使用对应的
![[Excalidraw/第七章 图 2023-05-09 10.38.24|200]]

状态判重，<mark style="background: transparent; color: yellow">一种方法是使用多维数组</mark>， 如定义一个数组 `int used[100][100][32]`
`used[3][5][9] = 1`表示到达过的状态，可以解决状态判重问题。


[八数码问题](https://blog.csdn.net/OCEANtroye/article/details/103859243)


## 四、图的常见算法
### (1) 图的最小生成树
方法是贪心算法，每一次寻找已求得部分和未求得部分的最小的边，

`````ad-quote
title: 常见的最小生成树算法
collapse: open
建立最小生成树的方法有很多，其中比较常用的是Prim算法和Kruskal算法。


1. [Prim算法](https://blog.csdn.net/hzf0701/article/details/107927858)
Prim算法的思路是从一个起点开始，每次找到一个与已有树相邻的最小边，将其加入树中。具体实现时可以使用优先队列来维护当前与已有树相邻的边，每次取出队列中权值最小的边进行扩展。

2. [Kruskal算法](https://blog.csdn.net/hzf0701/article/details/107933639)
Kruskal算法的思路<mark style="background: transparent; color: yellow">是将所有边按照权值从小到大排序，然后依次加入树中，如果加入的边与已有边形成环，则舍弃该边。</mark>

对于Prim算法，往往针对节点数较少的适用，而Kruskal算法适用于边数较少的部分
`````

可以建立一个优先队列，对应的边建立优先队列


需要判断边加入之后是否形成回路


### (2) 图的表达式存储
将表达式表示为有向无环图的临接表，可以将表达式中的操作数和操作符表示为图中的节点，将它们之间的关系表示为有向边。可以按照表达式从左到右的顺序，依次将操作数和操作符转换为节点，并建立它们之间的有向边，使得每个操作符节点的入边对应其运算所需的操作数节点，出边对应运算结果。这样，整个表达式就被表示为一个有向无环图的临接表。

[有向无环图的表达式存储](https://blog.csdn.net/qq_43546676/article/details/107434564)

**有向无环图描述表达式的生成步骤**
1. 把各个操作数不重复地排成一排
2. 标出各个运算符的生效顺序（先后顺序优点出入无所谓，比如先算左边括号或者先算右边括号，当然是同级的情况）
3. 按顺序加入运算符，不同的运算级别层次不同，过程中如果已经存在某部分，则直接用
4. 最后生成的图就是有向无环图


![[attachments/Pasted image 20230507194830.png|400]]

![[attachments/Pasted image 20230507194622.png|400]]


通过使用有向无环图表示表达式，可以节省很多


## 一、基本概念
**图的定义**：
图是一种网状的数据结构， 其定义为**顶点数据**和和**顶点数据间关系**的集合的总和
$$\begin{matrix}
Graph = (V,R) \\
V = \{x|x \in DataObject\} \\ 
R = \{VR \} \\
\text{VR} = \{<x,y>|P(x,y), \quad \text{x,y}\in V \}
\end{matrix}$$
其中，$DataObject$为中体数据集合，$VR$表示两个顶点关系的集合

**弧**: 若两个定点之间的关系几何使用$VR\text{(vortex relationship)}$进行表示， 且$<x,y>\in VR$， 则$<x,y>$表示从$x$到$y$的一条弧，并称$x$为**弧尾(首端点)**，$y$为**弧头(终端点)**

**有向图和无向图**：由于$<x,y>$是有方向性的， 一般的图为**有向图**，而若$\forall <x,y>\in R, <y,x> \in R$， 则可以使用无序对$(x,y)$表示，此时图为无向图
![[attachments/Pasted image 20230502201003.png|250]]

`````ad-note
title: 一个简单的矩阵定义连通图的例子
collapse: close

```cpp
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <unordered_map>
using namespace std;

typedef int VortexType;

// 首先直接通过数组实现图的存储结构
int main()
{
    // 图的顶点数和边数
    int m, n;
    // 这里使用一个哈希表，保证各种顺序或者类型的输入都可以建立图(包括A,B,C,D,只需更改VortexType即可)
    unordered_map<VortexType, int> map; 

    cin >> m >> n;
    VortexType* vtx = new VortexType[m];

    // 使用false初始化存储数组
    bool** Road = new bool* [m];
    for (int lin = 0; lin < m; lin++) {
        Road[lin] = new bool[m];
        for (int col = 0; col < m; col++)
            Road[lin][col]= false;
    }

    for (int i = 0; i < m; i++) {
        VortexType node;
        cin >> node;
        vtx[i] = node;
        // 初始化节点对应下标的哈希表
        map[vtx[i]] = i;
    }
    
    int node1, node2;
    for (int i = 0; i < n; i++) {
        cin >> node1 >> node2;
        int index1 = map[node1], index2 = map[node2];
        Road[index1][index2] = true;
    }

    VortexType panode1, panode2;
    int pan1, pan2;
    cin >> panode1 >> panode2;
    pan1 = map[node1], pan2 = map[node2];

    if (Road[pan1][pan2]) {
        cout << "yes" << endl;
    }
    else {
        cout << "no" << endl; 
    }
    return 0; 
}

/*
4 4
1 2 3 4
1 2
1 3
1 4
2 3
1 4
*/
```

`````

可以<mark style="background: transparent; color: yellow">使用邻接矩阵的方法</mark>表示**图在每一个其他元素上是否有路径**
其中$G_{i,j} = 1$表示两点之间是否可以形成通路(有路径且指向)
一个简单的示例如下: 
$$\left[\begin{matrix}
 & 1 \\
1 & & 1 & 1\\ 
& 1 \\
& 1
\end{matrix} \right]$$
其中**顶点的度**($TD$)包含所有和该点的边，包含顶点的**出度**(OD)和**入度**(ID)(从该点出， 入的数目)， 同时定义**图的度**为所有顶点度数之和，即$\sum\limits_{v\in V}TD(v)$。

对于一个图$G=(V,E)$来说，若存在一个子集$V'\subseteq V$使得子集内任意两点$v_i,v_j\in V'$均连通，则称这个子集为一个**连通分量**。如果一个图只有一个连通分量，则被称为**连通图**；否则称为**非连通图**。
一般地， 有
$$e = \frac{1}{2}\left(\sum^{n}_{i=1} TD (V_i) \right)$$
其中$e$为弧的数量

根据边的数量相对顶点的数量可以分为稀疏图$(e < n\log n)$和稠密图$(e>=n\log n)$

**连通图**: 在无向图中，如果x,y之间<mark style="background: transparent; color: yellow">存在路径</mark>(注意不一定双向)，则称x,y是连通的，如果图中的任意两个点都是连通的，则称图$G$为**连通图**

**连通分量(Connected component)**: 无向图中的极大连通子图（不存在包含且有更多分量的部分， 注意与强连通图区分）

**子图**：设有两个图$G = (V, |E|)$和图$G'  =(V' , |E'|)$， 对于$V\subseteq U, E'\subseteq E$， 则称$G'$是$G$的子图

**强连通图:** 任意两个顶点都<mark style="background: transparent; color: yellow">互相可以到达</mark>的图
**强连通分量**：<mark style="background: transparent; color: yellow">极大强连通子图</mark>， 即最多的可以相互到达的图

**完全图**是每一个顶点都和其余的n-1个顶点有边连接

**权**: 图中<mark style="background: transparent; color: yellow">每条边都有一个数字或权值与之关联</mark>，用来表示该边距离等特征。对于带权图，通常使用邻接矩阵或邻接表中**存储的不再是 0 或 1，而是边的权值**。 
在图论中，有许多算法和问题需要考虑图的权值，如<mark style="background: transparent; color: yellow">最短路径问题、最小生成树问题等</mark>。

**网**: **带权的图**称为网， 也称为赋权图

在带权图中还有一种重要的概念叫做<mark style="background: transparent; color: yellow">生成树</mark>。生成树是指**一个无向连通图中所有节点都被覆盖，并且不存在环路的子图**。对于一个**连通图的生成树， 是连通图的一个极小连通子图**(子图包含图的所有顶点)

权值之和最小的生成树，称为<mark style="background: transparent; color: yellow">图的最小生成树</mark> 

## 二、图的表示方法
### (1) 邻接矩阵表示方法
邻接矩阵的表示方法是使用一个较大的矩阵， 即使用$g[i][j]$来代表点$i$和点$j$之间是否有路径
```cpp 
[0, 1, 1, 0, 0]
[1, 0, 0, 1, 1]
[1, 0, 0, 0, 0]
[0, 1, 0, 0, 0]
[0, 1, 0, 0, 0]
```

另外， 如果是网，那么则初始化每一个元素为距离，没有路的点之间距离记为无穷大， 而本身记为0。即
```cpp 
[  0,   1,   1, inf, inf]
[  1,   0, inf,   1,   1]
[  1, inf,   0, inf, inf]
[inf,   1, inf,   0, inf]
[inf,   1, inf, inf,   0]
```

邻接矩阵缺点是稀疏图的表示情况，空间浪费较大
`````ad-note
title: 图的定义代码示例
collapse: close

```cpp 
#include <iostream> 
#define Inf 23768          // 定义无穷大
#define MAX_VORTEX_NUM 100 // 最大顶点个数

/* 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */
typedef enum graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义顶点的数据类型
typedef char VortexData;

//定义弧的节点类型
typedef struct arcNode {
    // adjType adj; 对于无权图, 使用1或0表示相邻，带权图为权值类型
    // OtherInfo info;
};

class adjMatrix {
public:
    VortexData vortex[MAX_VORTEX_NUM];
    arcNode route[MAX_VORTEX_NUM][MAX_VORTEX_NUM];
    int vexNum, arcNum; // 定义顶点数和弧的数量
    graphType type;
};

```

`````

### (2) 邻接表表示方法
使用<mark style="background: transparent; color: yellow">数组+链表的临接表表示方法</mark>
对于每个顶点，我们维护一个链表，链表中包含该顶点所连向的所有顶点。
```cpp 
struct node{
int v;
struct node* next;
}
```

实现邻接表需要用到以下两种数据结构：
1. 链表：用于存储每个顶点所连向的其他顶点。
2. 数组：用于记录所有顶点以及它们所对应的链表。

邻接表示例如下图所示：
```cpp
1. a -> b -> c
2. b -> a -> d
3. c -> a -> d
4. d -> b -> c
// 上述方法可以定义
```

在邻接表中，可以很方便地找到某个节点所相邻的所有节点。如果我们要寻找某个节点v相邻的所有节点，只需要访问v对应的链表即可。具体实现时可以采用数组来记录每个节点对应的链表头指针，并且为了避免重复添加边，在添加边时需要先检查是否已经存在该边。

可以使用字典的方法定义对应的图以及对应的路径

```cpp 
# 定义图的邻接表表示 
graph = { 
	'A': ['B', 'C'], 
	'B': ['D', 'E'], 
	'C': ['F'], 
	'D': [], 
	'E': ['F'], 
	'F': []
}
```

`````ad-note
title: 邻接表的定义以及一个初始化示例
collapse: close

```cpp 
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#define Inf 23768          // 定义无穷大
using namespace std;

/* 
 * 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */

 // 定义顶点的数据类型
typedef char VortexType;

typedef enum class graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义弧的节点类型
struct arcNode {
    int end_index = 0;
    arcNode* next = nullptr;
};

//定义顶点的节点类型
struct vexNode {
    arcNode* first_rt = nullptr;  // 指向下一个存储的节点
    VortexType vortex = '\0';
    bool visited = false;
};


class graph {
public:
    graph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
        initgraph(vexVec, routeVec, type);
    };
    graphType type = graphType::DG;
    bool hasWay(VortexType A, VortexType B);
private:
    void initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type);
    int vexNum = 0, arcNum = 0; // 定义顶点数和边的数量
    vexNode** vexList;
    unordered_map<VortexType, int> index_map;
};

// 初始化有向图
void graph::initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
    // 设置顶点和边的数量
    this->vexNum = vexVec.size(); 
    this->arcNum = routeVec.size();
    this->vexList = new vexNode * [this->vexNum]{nullptr}; // 分配指针的空间

    for (int i = 0; i < vexNum; i++) {
        this->vexList[i] = new vexNode();     // 还需要每一个单独分配数据空间
        this->vexList[i]->vortex = vexVec[i];  


        this->index_map[vexVec[i]] = i;       // 同时记录对应的下标
    }
    for (int i = 0; i < arcNum; i++) {
        arcNode* node = new arcNode();
        int start_index = this->index_map[routeVec[i][0]];
        node->end_index = this->index_map[routeVec[i][1]];

        if (!this->vexList[start_index]->first_rt) {
            // 直接接到尾部
            this->vexList[start_index]->first_rt = node;
        }
        else {
            arcNode* p = this->vexList[start_index]->first_rt;
            while (p->next) p = p->next;
            p->next = node;
        }
    }
}

// 通过广度优先搜索遍历有向图并寻找是否有对应路径
bool graph::hasWay(VortexType A, VortexType B) {
    int start_index = this->index_map[A];
    queue<vexNode*> q;
    q.push(this->vexList[start_index]);

    while (!q.empty()) {
        vexNode* node = q.front();
        node->visited = true;
        q.pop();
        // 判断是否达到
        if (node->vortex == B) {
            return true;
        }
        for (arcNode* p = node->first_rt; p; p = p->next) {
            if (!this->vexList[p->end_index]->visited) {
                q.push(this->vexList[p->end_index]);
            } 
        }
    }
    return false;
}

int main() {
    int  vexNum, arcNum;
    cin >> vexNum >> arcNum;
    vector<VortexType> vexVec;
    VortexType input, input2;
    for (int i = 0; i < vexNum; i++) {
        cin >> input;
        vexVec.push_back(input);
    }

    vector<vector<VortexType>> route;
    for (int i = 0; i < arcNum; i++) {
        cin >> input >> input2;
        vector<VortexType> newVec {input, input2};
        route.push_back(newVec);
    }
    // 初始化有向图
    graph g(vexVec,route,graphType::DG);

    VortexType start, end;
    cin >> start >> end;
    if (g.hasWay(start, end)) cout << "yes" << endl;
    else cout << "no" << endl;
    return 0;
}
```

`````

临接表的表示方法缺点是难以确定对应的行和列的图的进入节点，如果想要找哪个节点到对应的节点有边，需要穷举整个邻接表（也可以使用逆邻接表加入一个进行表示）

### (3) 十字链表表示方法
十字链表是有向图的一种链式存储结构，对于稀疏表的存储十分有效

(1) 十字链表表示的顶点结构为: 

| data | first in | first out |
| ---- | ------- | --------- |
其中，first in 和first out 分别指向第一个进入该节点的的表


(2) 十字链表表示的弧节点结构为:

| headvex | tailvex | head | tail | info | 
| ------- | ------- | ---- | ---- | ---- |

其中弧节点元素存储了弧尾和弧头的位置，tailevex是这个节点本身， tail指向其子表，包含到其他节点的路径， 其存储结构如图所示 : 
![[Excalidraw/第七章 图 2023-05-09 11.00.45|380]]

```cpp 
#define MAX_VERTEX_NUM 20

enum class graphType {
    DG,
    DN,
    UDG,
    UDN
};

// 定义节点的弧
struct arcNode{
	int row = 0, col = 0;
	DataType data;
	arcNode* right; 
	arcNode* down;
}

/* 也可以使用如下的方法
typedef struct _ArcNode
{
  int  tailVex, headVex;  // 弧的头尾顶点的位置, row, col
  struct _ArcNode *hLink;  // 弧头相同的弧的链域, 相当于down
  struct _ArcNode *tLink;  // 弧尾相同的弧的链域, 相当于right
  AdjType  weight;
}ArcNode;
*/
```

也可以使用如下的存储方法， 这个方法的左侧的节点第一个表示行的第一个， 第二个指针表示列指针，其表示思路就是将上面的矩阵的行和列合并了：

![[attachments/Pasted image 20230509111450.png|400]]
对于使用十字链表表示的树，<mark style="background: transparent; color: yellow">优点是可以通过对应的节点直接找其入节点(或者说以该节点为弧尾的节点)</mark>， 出节点从列向下遍历，入节点从行<mark style="background: transparent; color: yellow">向右遍历</mark>即可

具体实例参考[[#]]

### (4) 邻接多重表表示方法
图的邻接多重表表示方法为： 

| data | firstedge |
| ---- | --------- |
为顶点

| mark | ivex | jvex | ilink | jlink | info |
| ---- | ---- | ---- | ----- | ----- | ---- |
为边
其中mark为是否被搜索过，`ivex, jvex`为两个边的顶点在图中的位置， 即 row, col, 并可以使用ilink和jlink作为根节点的指向

## 三、图的搜索算法
带权图中最常见的算法是最短路径算法，它可以用来找到两个节点之间的最短路径。其中，Dijkstra算法和Floyd算法是最常用的两种方法。

在带权图中，我们可以通过构建最小生成树来找到连接所有节点所需的最小花费路径。其中，Prim算法和Kruskal算法是常用的两种方法。

图广搜的难点是搜索过程中的<mark style="background: transparent; color: yellow">状态判重</mark>

### (1) 图的深度优先搜索

使用邻接矩阵表示的图

`````ad-note 
title: 文献查找
collapse: close
[文献查找](https://www.luogu.com.cn/problem/P5318)
```cpp 
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <queue>
using namespace std;

typedef int vortexType;

typedef struct arc {
    int end = 0;
    arc* next = nullptr;
};

typedef struct node {
    vortexType data = 1;
    arc* next = nullptr;
    bool visited = false;
};

// 使用邻接矩阵方法存储的图
class graph {
public: 
    // 初始化表
    graph(int size) {
        this->size = size;
        this->nodes = new node*[size];
        for (int i = 0; i < size; i++) {
            this->nodes[i] = new node();  // 分配指针空间
            this->nodes[i]->data = i + 1;
        }
    }
    void insert_way(int start, int end);
    void show();
    void dfs(int index);
    void bfs(int index);
    void reinit();
private: 
    node** nodes = nullptr;
    int size;
};

// 在某两个节点间插入路径
void graph::insert_way(int start, int end) {
    node* cur = this->nodes[start - 1];
    if (!cur->next) {
        arc* L = new arc();
        L->end = end;   // end 存储1,2, ....
        cur->next = L;
    }
    else {
        // 按照从小到大的顺序建立邻接表
        arc* pre = cur->next;
        if (pre->end > end) {
            arc* L = new arc();
            L->end = end;
            L->next = pre;
            cur->next = L;
        }
        else{
            for (; pre->next && pre->next->end < end; pre = pre->next);
            arc* L = new arc();
            L->end = end;
            L->next = pre->next;
            pre->next = L;
        }
    }
}

void graph::show() {
    for (int i = 0; i < this->size; i++) {
        cout << i + 1 << " ";
        for (arc* p = this->nodes[i]->next; p; p = p->next) {
            cout << p->end << " ";
        }
        cout << endl;
    }
    // 重置visited标识
    for (int i = 0; i < this->size; i++) this->nodes[i]->visited = false;
}

// 深度优先遍历, index输入0
void graph::dfs(int index) {
    cout << this->nodes[index]->data << " ";
    this->nodes[index]->visited = true;
    for (arc* p = this->nodes[index]->next; p; p = p->next) {
        if (!this->nodes[p->end -1]->visited) dfs(p->end - 1); // 判定之前是否遍历过
    };
}

// 重置visited标识
void graph::reinit() {
    for (int i = 0; i < this->size; i++) this->nodes[i]->visited = false;
}

// 广度优先搜索算法
void graph::bfs(int index) {
    queue<int> q;
    q.push(index);
    this->nodes[index]->visited = true;

    while (!q.empty()) {
        int cur_index = q.front();
        q.pop();
        cout << this->nodes[cur_index]->data << " ";
        
        // 注意入队时visited的设置,需要在入队时直接设置为true
        for (arc* p = this->nodes[cur_index]->next; p; p = p->next) {
            int end = p->end - 1;
            if (!this->nodes[end]->visited) {
                this->nodes[end]->visited = true;
                q.push(end);
            }
        }
    }
}
    

// 首先直接通过数组实现图的存储结构
int main()
{
    int m, n;
    cin >> n >> m;   // n 为文章个数
    
    graph g(n);

    // 获取对应的引用关系
    int start, end;
    for (int i = 0; i < m; i++) {
        cin >> start >> end;
        g.insert_way(start, end);
    }
    // g.show();
    g.dfs(0);
    g.reinit();
    cout << endl;
    g.bfs(0);
    return 0;
}

/* Test Code 
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8
*/
```

`````

[图的遍历](https://www.luogu.com.cn/problem/P3916)
这个图的遍历思路是查找能达到的路径中最大的点
可以利用反向建边的方法进行遍历

### (2) 图的广度优先搜索
使用队列方法进行图的广度优先搜索
最终队列空则不可到达目标

```cpp 
this_node = stk.top()
stk.push(i); 
stk.pop();
```

`````ad-note
title: [食物链问题](https://www.luogu.com.cn/problem/P3183)
collapse: open

如图所示为某生态系统的食物网示意图，据图回答第 1 小题  
现在给你 n 个物种和 m 条能量流动关系，求其中的食物链条数。物种的名称为从 11 到 n 编号 M 条能量流动关系形如$a1​,b1​,a2​,b2​,a3​,b3​,…,a_{m−1}​,b_{m−1}​,am​,b_m​$。其中 ��ai​ 和 ��bi​ 表示能量从物种 ��ai​ 流向物种 ��bi​，注意单独的一种孤立生物不算一条食物链。

基本思路: 全局变量定义一个cnt ，每一次起始条件为无入有出，终止条件为next =null算一条

代码略去，较为简单
`````


## 四、图的典型问题
#### (1) [杂务问题](https://www.luogu.com.cn/problem/P1113)
问题见[[❔LeeCode Problems/杂务|杂务问题]]
首先，我们认为，第一个杂务是必须做的（如果有首先多个杂务需要做，可以建立一个节点）

我们使用反向建边的方法， 将每一个杂务的时间作为节点的data值

我们思考如何存储杂务需要的总时间
###### 方法一 (最直接的方法) 
全局定义一个计时器， 在每一个前序任务完成之后，计时器每+1, 则对应的图的节点(要求前序已经做完)剩余时间-1

实现较为简单， 略去代码

###### 方法二
但是我们可以不定义全局的计时器，只需要计算时间的差值即可。首先确定使用广度优先搜索方法以及时间先后排序的思想，每一次搜索时，将目前正在做的部分加入"目前的杂务队列"，按照剩余时间的大小存储，然后每一次完成时间最小的杂务(每个杂务的剩余时间-队列中最小的剩余时间)。

<mark style="background: transparent; color: yellow">需要说明的是， 每一次插入时需要插入到合适的位置上，因此采用十字链表结构类型进行存储</mark>
![[attachments/Pasted image 20230509111450.png|400]]
一个简单示例如下图
![[Excalidraw/第七章 图 2023-05-11 08.26.38|350]]
上图的十字链表存储结构为(节点编号-1)
```cpp 
============按列输出================
0 0,1 0,3
1 1,2 1,5 1,4
2 2,6
3 3,4 3,5
4 4,6
5 5,6
-----------按行输出(入度节点)----------------
1 1,0
2 2,1
3 3,0
4 4,1 4,3
5 5,1 5,3
6 6,2 6,5 6,4
==========================
```

我们对每一个节点维护一个left_time属性，每一次将正在做的节点放入表中，每次所有“在做”的排序表中，所有的事物减去排序表`List`中`left_time`最小的那一个的时间。 

当一个节点的left_time = 0时，将其出表， 那么这件事情就已经做完了

在出队完毕后，检查一次所有节点，如果某个节点<mark style="background: transparent; color: yellow">“目前可以做了”</mark>，则将其入队， 标识为现在在做的事情。

需要注意节点"目前可以做"的条件: 
1. 本身未做过，即`left_time != 0`
2. 所有的入节点`left_time`均等于0, 准备工作已经完成
3. 节点不在"在做"表中(如果在，则不能重复加入)

````ad-abstract
title: 代码示例
collapse: close 

```cpp 
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <queue>
#define MAX_SIZE 11000
using namespace std;

typedef int vortexType;  // 节点类型

// 弧节点, 链表节点，记录行列
typedef struct arc {
    int row;
    int col;
    arc* right;
    arc* down;
    arc() : row(0), col(0), right(nullptr), down(nullptr) {}
    arc(int row, int col) : row(row), col(col), right(nullptr), down(nullptr) {}
    arc(int row, int col, arc* right, arc* down) : row(row), col(col), right(right), down(down) {}
};

// 使用一个节点的压缩存储方法, 由于是数组，不用存储行列
typedef struct edge {
    vortexType vortex = 0;  // 空位
    int num = 0;        // 行列数
    int left_time = 0;      // 剩余时间
    arc* linNext = nullptr;
    arc* colNext = nullptr;
};

// 单链表存储对应的task
typedef struct SeqLink {
    edge* task = nullptr;
    SeqLink* next = nullptr;
};

SeqLink* insert_elem(SeqLink* root, edge* elem) {
    SeqLink* L = new SeqLink();
    L->task = elem;
    if (!root) {
        root = L;
    }
    else if (root->task->left_time > elem->left_time) { // 头结点
        L->next = root;
        root = L;
    }
    else {
        SeqLink* p = nullptr, * pre = nullptr;
        for (p = root, pre = root;p && p->task->left_time < elem->left_time; pre = p,p = p->next);
        L->next = pre->next;
        pre->next = L;
    }
    return root;
}

// 使用十字链表存储图的结构
class graph {
public:
    graph(int size) {
        this->size = size;
        // 初始化对应的row_col_edge节点
        for (int i = 0; i < size; i++) {
            this->row_col_edge[i] = new edge();
        }
    }
    void insert_way(int start, int end);
    void set_edge(int edgeIndex, int time);
    void show();
    int DoAll();

private:
    int size;
    bool canDo(SeqLink* List, edge* edge);
    edge* row_col_edge[MAX_SIZE]{nullptr};  // 边的节点, 指针数组类型
};

// 在某两个点中插入路径, start 和 end 为对应的下标,有行指向这个，则代表有路径
void graph::insert_way(int start, int end) {
    // 从列节点向下插入
    edge* e = this->row_col_edge[start];
    arc* c = new arc(end, start); // c->col = start; c->row = end;
    // 插头结点
    if (!e->colNext || (e->colNext && e->colNext->row > c->row)) {
        c->down = e->colNext;
        e->colNext = c;
    }
    else {
        arc *cur, *pre;
        for (cur=e->colNext, pre=e->colNext; cur && cur->row > c->row; pre = cur, cur = cur->down);
        c->down = pre->down;
        pre->down = c;
    }

    // 插入行节点
    edge* e2 = this->row_col_edge[end];
    if (!e2->linNext || (e2->linNext && e2->linNext->col > c->col)) {
        c->right = e2->linNext;
        e2->linNext = c;
    }
    else {
        arc* cur,*pre;
        for (cur = e2->linNext, pre = e2->linNext; cur && cur->col > c->col; pre = cur, cur = cur->right);
        c->right = pre->right;
        pre->right = c;
    }
};

// 设置边的时间
void graph::set_edge(int edgeIndex, int time) {
    this->row_col_edge[edgeIndex]->num = edgeIndex;
    this->row_col_edge[edgeIndex]->left_time = time;
}

void graph::show() {
    // 按序查找是否以前的事被做完
    cout << "============================" << endl;
    for (int i = 0; i < this->size; i++) {
        edge* e = this->row_col_edge[i];
        if (!e->colNext) continue;
        cout << e->num << " ";
        for (arc* p = e->colNext; p; p = p->down) {
            cout << p->row << " ";
        }
        cout << endl;
    }
    cout << "---------------------------" << endl;
    for (int i = 0; i < this->size; i++) {
        edge* e = this->row_col_edge[i];
        if (!e->linNext) continue;
        cout << e->num << " ";
        for (arc* p = e->linNext; p; p = p->right) {
            cout << p->col << " ";
        }
        cout << endl;
    }
    
}

// 可以做的要求: 1. 不能已经做完(left_time>0)  2. 不在链表中(不能重复加)  3. 前面的事情已经做完
bool graph::canDo(SeqLink* List, edge* edge) {
    if (!edge) throw runtime_error("Edge Initialize error");
    if (edge->left_time == 0) return false;
    for (SeqLink* p = List; p; p = p->next) {
        if (p->task == edge) return false;
    }
    // 按序查找是否以前的事被做完(检查left_time)
    if (edge->linNext == nullptr) return true;
    for (arc* p = edge->linNext; p; p = p->right) {
        if (this->row_col_edge[p->col]->left_time != 0) return false;
    }
    return true;
}

// 计算完成杂务的最少时间
int graph::DoAll() {
    SeqLink* List = nullptr;
    List = insert_elem(List, row_col_edge[0]);
    int cnt = 0; // 总时间 = 0
    // 循环直到空指针
    while (List!= nullptr) {
        int firstTime = List[0].task->left_time;
        for (SeqLink* p = List; p; p = p->next) {
            p->task->left_time -= firstTime;
        }
        // 删除leftTime对应的元素
        SeqLink* p = List;
        for (; p && p->task->left_time == 0; p = p->next);
        List = p;
        // 检测是否还有可做而未做的事务
        for (int i = 0; i < this ->size ; i++) {
            // 注意不能多次加入队列，一个事情只能做一次,这个集成到canDo之中
            if (canDo(List ,this->row_col_edge[i])) {
                List = insert_elem(List, this->row_col_edge[i]);
            }
        }
        cnt += firstTime;
    }
    return cnt;
}

// 首先直接通过数组实现图的存储结构
int main()
{
    int n;  // 需要做的杂务数量
    std::cin >> n;
    
    graph g(n);
    // 获取对应的引用关系
    int start, time,end;

    for (int i = 0; i < n; i++) {
        cin >> end; // 第一个是任务名称
        cin >> time;
        g.set_edge(end - 1, time);

        while (true) {
            cin >> start;
            if (start == 0) break;
            g.insert_way(start - 1, end - 1); // 建立边, 从准备事务开始
        }
    }
    // g.show();
    std::cout << g.DoAll() << endl;
    return 0;
}

/* Test Code
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
*/
```

````

#### (2) 迷宫和宝石的收集问题
在求解时， 必须集齐所有种类的宝石(宝石同一种类可能有多个)， 迷宫中有指定数量的传送门，
最少的步数，应当使用广度优先搜索进行获取， 采用身上带宝石的不同的状态进行判断(例如，在到达某一行列之后， 可能身上带有不同的宝石， 因此状态判重方法是在此基础上， 判断身上携带宝石的状态)

可以使用五位二进制数，减少多个状态的判断的次数

例如将五位二进制数的表示
s = s|(1 << 3); 使用对应的
![[Excalidraw/第七章 图 2023-05-09 10.38.24|200]]

状态判重，<mark style="background: transparent; color: yellow">一种方法是使用多维数组</mark>， 如定义一个数组 `int used[100][100][32]`
`used[3][5][9] = 1`表示到达过的状态，可以解决状态判重问题。

[八数码问题](https://blog.csdn.net/OCEANtroye/article/details/103859243)

#### (3) 图的表达式存储
将表达式表示为有向无环图的临接表，可以将表达式中的操作数和操作符表示为图中的节点，将它们之间的关系表示为有向边。可以按照表达式从左到右的顺序，依次将操作数和操作符转换为节点，并建立它们之间的有向边，使得每个操作符节点的入边对应其运算所需的操作数节点，出边对应运算结果。这样，整个表达式就被表示为一个有向无环图的临接表。

[有向无环图的表达式存储](https://blog.csdn.net/qq_43546676/article/details/107434564)

**有向无环图描述表达式的生成步骤**
1. 把各个操作数不重复地排成一排
2. 标出各个运算符的生效顺序（先后顺序优点出入无所谓，比如先算左边括号或者先算右边括号，当然是同级的情况）
3. 按顺序加入运算符，不同的运算级别层次不同，过程中如果已经存在某部分，则直接用
4. 最后生成的图就是有向无环图


![[attachments/Pasted image 20230507194830.png|400]]

![[attachments/Pasted image 20230507194622.png|400]]

通过使用有向无环图表示表达式，可以节省很多

## 五、图的两大算法
### (1) 最小生成树问题
方法是使用贪心算法的思路，每一次寻找已求得部分和未求得部分的最小的边，

`````ad-quote
title: 常见的最小生成树算法
collapse: open
建立最小生成树的方法有很多，其中比较常用的是Prim算法和Kruskal算法。

1. [Prim算法](https://blog.csdn.net/hzf0701/article/details/107927858)
Prim算法的思路是从一个起点开始，每次找到一个与已有树相邻的最小边，将其加入树中。具体实现时可以使用优先队列来维护当前与已有树相邻的边，每次取出队列中权值最小的边进行扩展。
2. [Kruskal算法](https://blog.csdn.net/hzf0701/article/details/107933639)
Kruskal算法的思路<mark style="background: transparent; color: yellow">是将所有边按照权值从小到大排序，然后依次加入树中，如果加入的边与已有边形成环，则舍弃该边。</mark>

对于Prim算法，往往针对节点数较少的适用，而Kruskal算法适用于边数较少的部分(往往适用于稀疏图, 其原因是边排序的复杂度)

对于Prim算法，可以在寻找最小的
`````
可以建立一个优先队列，对应的边建立优先队列
需要判断边加入之后是否形成回路

```cpp 
// 未修正的代码
#include <iostream> 
#include <set> 

typedef struct arcNode {
    int from;
    int to;
    int weight;
};

struct arcNode e[1000]; // 使用一个结构体存储对应的边

using namespace std;

int find(int y) {
    int y;
    y = x;
    while (p[y] != y) {
        y = p[y];
    }
    p[x] = y;
    return y;
}

// 使用并查集的方法, 每一次合并根节点进行集合的合并
void union_(arcNode* r1, arcNode* r2) {
    
}

// 比较函数使用sort进行调用，                     
bool cmp(arcNode* r1, arcNode* r2) {
    return r1->weight < r2->weight;
}
// sort (e, e+m, cmp)

int main() {
    int u, v; 
    input();
    init();
    sort(); // 首先对所有的结构体的边

    for (int i = 0; i < m; i++) {
        u = e[i].from; v = e[i].to;
        r1 = find(u); // 寻找对应的根节点 
        r2 = find(v); // 寻找对应的根节点
        // 如果根节点不相同，则不在同一集合中, 则将边进行合并
        if (r1 != r2) {
            combine(r1, r2);  // 合并两个点所在的集合
        }
    }
    return 0;
}
```

### (2) 最短路径问题
#### 1. Dijkstra 算法
Dijkstra 算法用于求解某一个顶点$v$到其余顶点的最短路径的长度

对于 Dijkstra 算法，方法是==每一次加入一个新的点，并使用这个节点更新其余的节点==， 注意在过程中并不加入某条路径
![[Excalidraw/第七章 图 2023-05-11 17.32.33|650]]

加入的节点是<mark style="background: transparent; color: yellow">目前更新后，其余节点路径中取得最小值的那个节点</mark>
1. 加入新的邻接点
2. 更新其余节点的信息

显然，有$n$个节点，则需要更新次数为$n-1$

首先使用邻接矩阵表示赋权图

`````ad-abstract
title: Dijkstra 算法的示例代码
collapse:close

```cpp 
#include <iostream>
#include <vector>
#define Inf 1000
#define MAX_SIZE 100

using namespace std;

// 邻接矩阵类
class Neighbor {
public:
	Neighbor(int n) {
		this->n = n;
		// 初始化
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (i == j) a[i][j] = 0;
				else a[i][j] = Inf;
			}
		}
	}
	void Dijkstra();
	void show();
	void show_matrix();
	void insert_way(int row, int col, int length);

private:
	int n = 0;
	int a[MAX_SIZE][MAX_SIZE];
	int d[MAX_SIZE]{}; // 得到的最短路径;
	bool s[MAX_SIZE]{}; // 已经求得最短路径的点的集合
};

void Neighbor::insert_way(int row, int col, int length) {
	a[row][col] = length;
	a[col][row] = length;
}

void Neighbor::Dijkstra() {
	d[0] = 0; s[0] = true;  // 0 已经寻找过
	// 初始化数组d，需要注意的是，仅使用a进行初始化, 取最小时仅使用d
	for (int i = 1; i < n; i++) {
		d[i] = min(Inf, a[0][i]);
		s[i] = false;
	}
	// 使用循环, n-1次, 每一次寻找路径最小的节点并加入
	for (int t = n-1; t > 0; t--) {
		int min = Inf;
		int min_index = 0;
		for (int i = 0; i < n; i++) {
			// 在其余(未求得最小值)的节点中，确定取得最小值的节点下标
			if ( s[i] || d[i]>=min) continue;  // min大于才做
			min_index = i; min = d[i];
		}
		// 得到d中值最小的节点，将其加入集合
		d[min_index] = min;
		s[min_index] = true;

		// 每一次更新其余节点的值
		for (int i = 0; i < n; i++) {
			if (s[i]) continue;
			// 如果两点之间有路径，则更新为对应的值
			d[i] = std::min(d[i], d[min_index] + a[min_index][i]);
		}
	}
}

void Neighbor::show() {
	for (int i = 0; i < n; i++) {
		std::cout << d[i] << " ";
	}
	std::cout << endl;
}

int main() {
	int n, m;
	// 初始化a的路径长度
	std::cin >> n >> m;
	Neighbor g(n);
	for (int i = 0; i < m; i++) {
		int start, end, length;
		std::cin >> start >> end >> length;
		g.insert_way(start-1, end-1, length);
	}
	g.Dijkstra();
	g.show();
	return 0;
}
```

2. Floyd 算法

任意两点的最短路径长度

先引入一个`d[i][j][k]`表示只利用k以内的节点(点从1开始)，从i到j的最短路径的长度

```cpp 
d(i,j,k) = min(d(i, j, k-1), d(i,k, k-1) + d(k,j, k-1));
// 前一种是只利用k-1内的节点，后一种是利用k节点
```

```cpp 
int d[100][100][100]; // 101 

// 初始化时，第0层位

// 第0层
d[i][j][0] = g[i][j];   // 其中g[i][j]没有路径时

// Floyd算法
for (int k = 0; k< n-1; k++){
	for (int i = 0; i < n; i++){
		for (int j = 0; j< n; j++){
			d[i][j][k] = max(d[i][j][k-1],  d[i][k][k-1] + d[k][j][k-1]);
		}
	}
}
```
`````

### (3)有向无环图的拓扑排序

拓扑序列是
任意找到一个入度为0的节点$v$，输出之后，在图中删除掉对应的节点和节点以及对应的边， 循环n次

注意：删除边是在记录点的入度的数组里面，将数组对应的入度-1\\
另外还有一个记录点的数组， = 0 表示点已经删除

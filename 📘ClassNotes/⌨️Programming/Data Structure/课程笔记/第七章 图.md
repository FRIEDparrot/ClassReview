## 一、基本概念
**图的定义**：
图是一种网状的数据结构， 其定义为**顶点数据**和和**顶点数据间关系**的集合的总和
$$\begin{matrix}
Graph = (V,R) \\
V = \{x|x \in DataObject\} \\ 
R = \{VR \} \\
\text{VR} = \{<x,y>|P(x,y), \quad \text{x,y}\in V \}
\end{matrix}$$
其中，$DataObject$为中体数据集合，$VR$表示两个顶点关系的集合

**弧**: 若两个定点之间的关系几何使用$VR\text{(vortex relationship)}$进行表示， 且$<x,y>\in VR$， 则$<x,y>$表示从$x$到$y$的一条弧，并称$x$为**弧尾(首端点)**，$y$为**弧头(终端点)**

**有向图和无向图**：由于$<x,y>$是有方向性的， 一般的图为**有向图**，而若$\forall <x,y>\in R, <y,x> \in R$， 则可以使用无序对$(x,y)$表示，此时图为无向图
![[attachments/Pasted image 20230502201003.png|250]]

`````ad-note
title: 一个简单的矩阵定义连通图的例子
collapse: close

```cpp
// GraphPractice.cpp : This file contains the 'main' function. Program execution begins and ends there.
#include <iostream>
#include <unordered_map>
using namespace std;

typedef int VortexType;

// 首先直接通过数组实现图的存储结构
int main()
{
    // 图的顶点数和边数
    int m, n;
    // 这里使用一个哈希表，保证各种顺序或者类型的输入都可以建立图(包括A,B,C,D,只需更改VortexType即可)
    unordered_map<VortexType, int> map; 

    cin >> m >> n;
    VortexType* vtx = new VortexType[m];

    // 使用false初始化存储数组
    bool** Road = new bool* [m];
    for (int lin = 0; lin < m; lin++) {
        Road[lin] = new bool[m];
        for (int col = 0; col < m; col++)
            Road[lin][col]= false;
    }

    for (int i = 0; i < m; i++) {
        VortexType node;
        cin >> node;
        vtx[i] = node;
        // 初始化节点对应下标的哈希表
        map[vtx[i]] = i;
    }
    
    int node1, node2;
    for (int i = 0; i < n; i++) {
        cin >> node1 >> node2;
        int index1 = map[node1], index2 = map[node2];
        Road[index1][index2] = true;
    }

    VortexType panode1, panode2;
    int pan1, pan2;
    cin >> panode1 >> panode2;
    pan1 = map[node1], pan2 = map[node2];

    if (Road[pan1][pan2]) {
        cout << "yes" << endl;
    }
    else {
        cout << "no" << endl; 
    }
    return 0; 
}

/*
4 4
1 2 3 4
1 2
1 3
1 4
2 3
1 4
*/
```

`````

可以<mark style="background: transparent; color: yellow">使用邻接矩阵的方法</mark>表示**图在每一个其他元素上是否有路径**
其中$G_{i,j} = 1$表示两点之间是否可以形成通路(有路径且指向)
一个简单的示例如下: 
$$\left[\begin{matrix}
 & 1 \\
1 & & 1 & 1\\ 
& 1 \\
& 1
\end{matrix} \right]$$
其中**顶点的度**($TD$)包含所有和该点的边，包含顶点的**出度**(OD)和**入度**(ID)(从该点出， 入的数目)， 同时定义**图的度**为所有顶点度数之和，即$\sum\limits_{v\in V}TD(v)$。

对于一个图$G=(V,E)$来说，若存在一个子集$V'\subseteq V$使得子集内任意两点$v_i,v_j\in V'$均连通，则称这个子集为一个**连通分量**。如果一个图只有一个连通分量，则被称为**连通图**；否则称为**非连通图**。
一般地， 有
$$e = \frac{1}{2}\left(\sum^{n}_{i=1} TD (V_i) \right)$$
其中$e$为弧的数量

根据边的数量相对顶点的数量可以分为稀疏图$(e < n\log n)$和稠密图$(e>=n\log n)$

**连通图**: 在无向图中，如果x,y之间<mark style="background: transparent; color: yellow">存在路径</mark>(注意不一定双向)，则称x,y是连通的，如果图中的任意两个点都是连通的，则称图$G$为**连通图**

**连通分量(Connected component)**: 无向图中的极大连通子图（不存在包含且有更多分量的部分， 注意与强连通图区分）

**子图**：设有两个图$G = (V, |E|)$和图$G'  =(V' , |E'|)$， 对于$V\subseteq U, E'\subseteq E$， 则称$G'$是$G$的子图

**强连通图:** 任意两个顶点都<mark style="background: transparent; color: yellow">互相可以到达</mark>的图
**强连通分量**：<mark style="background: transparent; color: yellow">极大强连通子图</mark>， 即最多的可以相互到达的图

**完全图**是每一个顶点都和其余的n-1个顶点有边连接

**权**: 图中<mark style="background: transparent; color: yellow">每条边都有一个数字或权值与之关联</mark>，用来表示该边距离等特征。对于带权图，通常使用邻接矩阵或邻接表中**存储的不再是 0 或 1，而是边的权值**。 
在图论中，有许多算法和问题需要考虑图的权值，如<mark style="background: transparent; color: yellow">最短路径问题、最小生成树问题等</mark>。

**网**: **带权的图**称为网， 也称为赋权图

在带权图中还有一种重要的概念叫做<mark style="background: transparent; color: yellow">生成树</mark>。生成树是指**一个无向连通图中所有节点都被覆盖，并且不存在环路的子图**。对于一个**连通图的生成树， 是连通图的一个极小连通子图**(子图包含图的所有顶点)

权值之和最小的生成树，称为<mark style="background: transparent; color: yellow">图的最小生成树</mark> 

## 二、图的表示方法
### (1) 邻接矩阵表示方法
邻接矩阵的表示方法是使用一个较大的矩阵， 即使用$g[i][j]$来代表点$i$和点$j$之间是否有路径
```cpp 
[0, 1, 1, 0, 0]
[1, 0, 0, 1, 1]
[1, 0, 0, 0, 0]
[0, 1, 0, 0, 0]
[0, 1, 0, 0, 0]
```

邻接矩阵缺点是稀疏图的表示情况，空间浪费较大

`````ad-note
title: 图的定义代码示例
collapse: close

```cpp 
#include <iostream> 
#define Inf 23768          // 定义无穷大
#define MAX_VORTEX_NUM 100 // 最大顶点个数

/* 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */
typedef enum graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义顶点的数据类型
typedef char VortexData;

//定义弧的节点类型
typedef struct arcNode {
    // adjType adj; 对于无权图, 使用1或0表示相邻，带权图为权值类型
    // OtherInfo info;
};

class adjMatrix {
public:
    VortexData vortex[MAX_VORTEX_NUM];
    arcNode route[MAX_VORTEX_NUM][MAX_VORTEX_NUM];
    int vexNum, arcNum; // 定义顶点数和弧的数量
    graphType type;
};

```

`````

### (2) 邻接表表示方法
##### 1) 数组+链表的临接表表示方法
对于每个顶点，我们维护一个链表，链表中包含该顶点所连向的所有顶点。
```cpp 
struct node{
int v;
struct node* next;
}
```

实现邻接表需要用到以下两种数据结构：
1. 链表：用于存储每个顶点所连向的其他顶点。
2. 数组：用于记录所有顶点以及它们所对应的链表。

邻接表示例如下图所示：
```cpp
1. a -> b -> c
2. b -> a -> d
3. c -> a -> d
4. d -> b -> c
// 上述方法可以定义
```

在邻接表中，可以很方便地找到某个节点所相邻的所有节点。如果我们要寻找某个节点v相邻的所有节点，只需要访问v对应的链表即可。具体实现时可以采用数组来记录每个节点对应的链表头指针，并且为了避免重复添加边，在添加边时需要先检查是否已经存在该边。

可以使用字典的方法定义对应的图以及对应的路径
```cpp 
# 定义图的邻接表表示 
graph = { 
	'A': ['B', 'C'], 
	'B': ['D', 'E'], 
	'C': ['F'], 
	'D': [], 
	'E': ['F'], 
	'F': []
}
```

`````ad-note
title: 邻接表的定义以及一个初始化示例
collapse: close

```cpp 
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#define Inf 23768          // 定义无穷大
using namespace std;

/* 
 * 定义图的种类
 * 其中DG表示有向图，DN为有向网, UDG表示无向图, UDN表示无向网
 */

 // 定义顶点的数据类型
typedef char VortexType;

typedef enum class graphType{
    DG,
    DN,
    UDG,
    UDN
};

// 定义弧的节点类型
struct arcNode {
    int end_index = 0;
    arcNode* next = nullptr;
};

//定义顶点的节点类型
struct vexNode {
    arcNode* first_rt = nullptr;  // 指向下一个存储的节点
    VortexType vortex = '\0';
    bool visited = false;
};


class graph {
public:
    graph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
        initgraph(vexVec, routeVec, type);
    };
    graphType type = graphType::DG;
    bool hasWay(VortexType A, VortexType B);
private:
    void initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type);
    int vexNum = 0, arcNum = 0; // 定义顶点数和边的数量
    vexNode** vexList;
    unordered_map<VortexType, int> index_map;
};

// 初始化有向图
void graph::initgraph(vector<VortexType> vexVec, vector<vector<VortexType>> routeVec, graphType type) {
    // 设置顶点和边的数量
    this->vexNum = vexVec.size(); 
    this->arcNum = routeVec.size();
    this->vexList = new vexNode * [this->vexNum]{nullptr}; // 分配指针的空间

    for (int i = 0; i < vexNum; i++) {
        this->vexList[i] = new vexNode();     // 还需要每一个单独分配数据空间
        this->vexList[i]->vortex = vexVec[i];  


        this->index_map[vexVec[i]] = i;       // 同时记录对应的下标
    }
    for (int i = 0; i < arcNum; i++) {
        arcNode* node = new arcNode();
        int start_index = this->index_map[routeVec[i][0]];
        node->end_index = this->index_map[routeVec[i][1]];

        if (!this->vexList[start_index]->first_rt) {
            // 直接接到尾部
            this->vexList[start_index]->first_rt = node;
        }
        else {
            arcNode* p = this->vexList[start_index]->first_rt;
            while (p->next) p = p->next;
            p->next = node;
        }
    }
}

// 通过广度优先搜索遍历有向图并寻找是否有对应路径
bool graph::hasWay(VortexType A, VortexType B) {
    int start_index = this->index_map[A];
    queue<vexNode*> q;
    q.push(this->vexList[start_index]);

    while (!q.empty()) {
        vexNode* node = q.front();
        node->visited = true;
        q.pop();
        // 判断是否达到
        if (node->vortex == B) {
            return true;
        }
        for (arcNode* p = node->first_rt; p; p = p->next) {
            if (!this->vexList[p->end_index]->visited) {
                q.push(this->vexList[p->end_index]);
            } 
        }
    }
    return false;
}

int main() {
    int  vexNum, arcNum;
    cin >> vexNum >> arcNum;
    vector<VortexType> vexVec;
    VortexType input, input2;
    for (int i = 0; i < vexNum; i++) {
        cin >> input;
        vexVec.push_back(input);
    }

    vector<vector<VortexType>> route;
    for (int i = 0; i < arcNum; i++) {
        cin >> input >> input2;
        vector<VortexType> newVec {input, input2};
        route.push_back(newVec);
    }
    // 初始化有向图
    graph g(vexVec,route,graphType::DG);

    VortexType start, end;
    cin >> start >> end;
    if (g.hasWay(start, end)) cout << "yes" << endl;
    else cout << "no" << endl;
    return 0;
}
```

`````

### (3) 十字链表表示方法

十字链表是有向图的一种链式存储结构，对于稀疏表的存储十分有效

(1) 十字链表表示的顶点结构为: 

| data | first in | first out |
| ---- | ------- | --------- |
其中，first in 和first out 分别指向第一个进入该节点的的表


(2) 十字链表表示的弧节点结构为:

| tailvex | headvex | tail | info |
| ------- | ------- | ----- | ----- |

其中弧节点元素存储了弧尾和弧头的位置，tailevex是这个节点本身，而headvex是路线的另一端
tail指向另一个字表，包含其余元素

```cpp 
#define MAX_VERTEX_NUM 20

enum class graphType {
    DG,
    DN,
    UDG,
    UDN
};

struct arcNode {
    int headvex, tailvex;
};
```


### (4) 邻接多重表表示方法
表示方法为： 

| mark | ivex | ilink | jvex | jlink | info | 
| ---- | ---- | ----- | ---- | ----- | ---- |


## 三、图的建立和遍历
### (1) 图的


### (2) 图的表达式存储
将表达式表示为有向无环图的临接表，可以将表达式中的操作数和操作符表示为图中的节点，将它们之间的关系表示为有向边。可以按照表达式从左到右的顺序，依次将操作数和操作符转换为节点，并建立它们之间的有向边，使得每个操作符节点的入边对应其运算所需的操作数节点，出边对应运算结果。这样，整个表达式就被表示为一个有向无环图的临接表。

[有向无环图的表达式存储](https://blog.csdn.net/qq_43546676/article/details/107434564)


## 四、图的搜索算法


带权图中最常见的算法是最短路径算法，它可以用来找到两个节点之间的最短路径。其中，Dijkstra算法和Floyd算法是最常用的两种方法。

在带权图中，我们可以通过构建最小生成树来找到连接所有节点所需的最小花费路径。其中，Prim算法和Kruskal算法是常用的两种方法。

### (1) 图的深度优先搜索
使用邻接矩阵表示的图

[文献查找](https://www.luogu.com.cn/problem/P5318)
[图的遍历](https://www.luogu.com.cn/problem/P3916)

### (2) 图的广度优先搜索
使用队列方法进行图的广度优先搜索

最终队列空则不可到达目标

```cpp 
this_node = stk.top()
stk.push(i); 
stk.pop();
```


(3) [食物链问题](https://www.luogu.com.cn/problem/P3183)

如图所示为某生态系统的食物网示意图，据图回答第 1 小题  
现在给你 n 个物种和 m 条能量流动关系，求其中的食物链条数。物种的名称为从 11 到 n 编号 M 条能量流动关系形如$a1​,b1​,a2​,b2​,a3​,b3​,…,a_{m−1}​,b_{m−1}​,am​,b_m​$。其中 ��ai​ 和 ��bi​ 表示能量从物种 ��ai​ 流向物种 ��bi​，注意单独的一种孤立生物不算一条食物链。

(4) [杂务问题](https://www.luogu.com.cn/problem/P1113)


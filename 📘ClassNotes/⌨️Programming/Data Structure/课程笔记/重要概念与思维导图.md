---

mindmap-plugin: rich

---

# 数据结构
``` json
{"theme":"","mindData":[[{"id":"e452908b-be2a-f00f","text":"数据结构","isRoot":true,"main":true,"x":4000,"y":4000,"isExpand":true,"layout":{"layoutName":"mindmap2","direct":"mindmap"},"stroke":""},{"id":"c4c4ccc0-70f5-e8b4","text":"数据的概念与类型","stroke":"#3c0aa8","x":4182,"y":3148.5,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"d733d6e8-a9ad-9f4e","text":"顺序表和链表","stroke":"#94c643","x":4182,"y":3592.5,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"91b3cb64-03cd-a507","text":"栈和队列","stroke":"#d6ef56","x":4182,"y":4158.5,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"7d7709f4-8eed-861a","text":"稀疏数组和广义表部分","stroke":"#2244cc","x":4182,"y":4871.5,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"a52298f6-2001-9f22","text":"树和二叉树","stroke":"#7aefc8","x":3844,"y":3305,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"1fc02a05-14a8-dfdf","text":"图","stroke":"#8cf74f","x":3921,"y":4028,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"8929581d-51e3-dea4","text":"哈希表","stroke":"#ce5b50","x":3882,"y":4506,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"3859d229-3ffa-b540","text":"内部排序","stroke":"#ff87ad","x":3863,"y":4716,"layout":null,"isExpand":true,"pid":"e452908b-be2a-f00f"},{"id":"c13b7135-c025-0605","text":"基本数据类型","stroke":"#3c0aa8","x":4386,"y":2936,"isExpand":true,"layout":null,"pid":"c4c4ccc0-70f5-e8b4"},{"id":"12dbefdd-01e2-ef2f","text":"抽象数据类型","stroke":"#3c0aa8","x":4386,"y":3149.5,"layout":null,"isExpand":true,"pid":"c4c4ccc0-70f5-e8b4"},{"id":"c9c609d2-6798-2d80","text":"数据的逻辑结构","stroke":"#3c0aa8","x":4386,"y":3247.5,"layout":null,"isExpand":true,"pid":"c4c4ccc0-70f5-e8b4"},{"id":"0878d635-aa44-c170","text":"数据的存储结构","stroke":"#3c0aa8","x":4386,"y":3352.5,"layout":null,"isExpand":true,"pid":"c4c4ccc0-70f5-e8b4"},{"id":"c2a96329-b3f3-5eef","text":"算法的定义","stroke":"#3c0aa8","x":4386,"y":3475,"layout":null,"isExpand":true,"pid":"c4c4ccc0-70f5-e8b4"},{"id":"7465bd17-ff8d-1259","text":"1. 链表的建立，既可以依次插入元素，也可以先存储在一个数组中，并使用数组初始化链表","stroke":"#94c643","x":4347,"y":3555,"layout":null,"isExpand":true,"pid":"d733d6e8-a9ad-9f4e"},{"id":"1b596305-9c8e-45d7","text":"2. 注意在删除指针时，调用delete(c语言里面是free)释放指针空间","stroke":"#94c643","x":4347,"y":3611,"layout":null,"isExpand":true,"pid":"d733d6e8-a9ad-9f4e"},{"id":"3cbab262-51e9-25b7","text":"单链表，双链表和循环链表部分","stroke":"#94c643","x":4347,"y":3646,"layout":null,"isExpand":true,"pid":"d733d6e8-a9ad-9f4e"},{"id":"ddf1357f-bd66-111b","text":"栈","stroke":"#d6ef56","x":4309,"y":3726,"layout":null,"isExpand":true,"pid":"91b3cb64-03cd-a507"},{"id":"ffd6ad43-0f02-131f","text":"队列","stroke":"#d6ef56","x":4309,"y":3876.5,"layout":null,"isExpand":true,"pid":"91b3cb64-03cd-a507"},{"id":"0e8c329e-63e1-2984","text":"应用","stroke":"#d6ef56","x":4309,"y":4066,"layout":null,"isExpand":true,"pid":"91b3cb64-03cd-a507"},{"id":"3fbabe63-0e95-8cb3","text":"栈和队列的初始化","stroke":"#d6ef56","x":4309,"y":4251,"layout":null,"isExpand":true,"pid":"91b3cb64-03cd-a507"},{"id":"679dda60-52ed-b903","text":"重点 : 递归算法","stroke":"#d6ef56","x":4309,"y":4502,"layout":null,"isExpand":true,"pid":"91b3cb64-03cd-a507"},{"id":"8a61826c-4f39-c0d1","text":"存储位置的计算","stroke":"#2244cc","x":4424,"y":4687,"layout":null,"isExpand":true,"pid":"7d7709f4-8eed-861a"},{"id":"ec4c571c-d1f0-4d41","text":"稀疏数组的存储方式","stroke":"#2244cc","x":4424,"y":4739.5,"layout":null,"isExpand":true,"pid":"7d7709f4-8eed-861a"},{"id":"b00e8df7-d257-8103","text":"常见的稀疏数组算法","stroke":"#2244cc","x":4424,"y":4827,"layout":null,"isExpand":true,"pid":"7d7709f4-8eed-861a"},{"id":"0eedbca2-b2ab-061a","text":"==重点:广义表的表达==","stroke":"#2244cc","x":4424,"y":4984.5,"layout":null,"isExpand":true,"pid":"7d7709f4-8eed-861a"},{"id":"ba0641bd-2a37-7831","text":"树和二叉树的定义","stroke":"#7aefc8","x":3678,"y":2959.5,"layout":null,"isExpand":true,"pid":"a52298f6-2001-9f22"},{"id":"e4a02dda-4ac2-e32c","text":"二叉树的表示方法","stroke":"#7aefc8","x":3678,"y":3226,"layout":null,"isExpand":true,"pid":"a52298f6-2001-9f22"},{"id":"c5b6ac4e-a234-0b3d","text":"二叉树的基本操作","stroke":"#7aefc8","x":3678,"y":3488.5,"layout":null,"isExpand":true,"pid":"a52298f6-2001-9f22"},{"id":"158e85d9-36e2-c316","text":"哈夫曼树及哈夫曼编码","stroke":"#7aefc8","x":3646,"y":3667,"layout":null,"isExpand":true,"pid":"a52298f6-2001-9f22"},{"id":"2a0bbb53-647a-cf5b","text":"堆排序","stroke":"#7aefc8","x":3758,"y":3758,"layout":null,"isExpand":true,"pid":"a52298f6-2001-9f22"},{"id":"ebea61a3-63f7-f7e7","text":"基本概念和定义","stroke":"#8cf74f","x":3747,"y":3753,"note":"**图的定义**：\n图是一种网状的数据结构， 其定义为**顶点数据**和和**顶点数据间关系**的集合的总和\n$$\\begin{matrix}\nGraph = (V,R) \\\\\nV = \\{x|x \\in DataObject\\} \\\\ \nR = \\{VR \\} \\\\\n\\text{VR} = \\{<x,y>|P(x,y), \\quad \\text{x,y}\\in V \\}\n\\end{matrix}$$\n其中，$DataObject$为中体数据集合，$VR$表示两个顶点关系的集合\n","layout":null,"isExpand":true,"pid":"1fc02a05-14a8-dfdf"},{"id":"b4ff87cf-7ba7-8a3f","text":"三种常见的表示方法","stroke":"#8cf74f","x":3739,"y":3823,"layout":null,"isExpand":true,"pid":"1fc02a05-14a8-dfdf"},{"id":"0b134a29-4990-145d","text":"图的深度优先搜索和广度优先搜索算法","stroke":"#8cf74f","x":3611,"y":3893,"layout":null,"isExpand":true,"pid":"1fc02a05-14a8-dfdf"},{"id":"c86f8603-cb9a-3946","text":"两大问题","stroke":"#8cf74f","x":3819,"y":4001.5,"layout":null,"isExpand":true,"pid":"1fc02a05-14a8-dfdf"},{"id":"11e44504-6d5e-bb62","text":"拓扑排序和关键路径","stroke":"#8cf74f","x":3739,"y":4214.5,"layout":null,"isExpand":true,"pid":"1fc02a05-14a8-dfdf"},{"id":"85753141-3f55-ac9f","text":"哈希函数的构造","stroke":"#ce5b50","x":3732,"y":4409,"layout":null,"isExpand":true,"pid":"8929581d-51e3-dea4"},{"id":"8c33cfe1-95d4-bae9","text":"处理冲突的办法","stroke":"#ce5b50","x":3732,"y":4566.5,"layout":null,"isExpand":true,"pid":"8929581d-51e3-dea4"},{"id":"755b88e2-5d65-cd22","text":"==平均查找长度的计算==","stroke":"#ce5b50","x":3700,"y":4671.5,"layout":null,"isExpand":true,"pid":"8929581d-51e3-dea4"},{"id":"3bef8872-f75b-0589","text":"==堆排序的过程==","stroke":"#ff87ad","x":3729,"y":4671.5,"layout":null,"isExpand":true,"pid":"3859d229-3ffa-b540"},{"id":"0550fc92-bb75-3c5b","text":"希尔排序 -> 基于插入排序","stroke":"#ff87ad","x":3641,"y":4706.5,"layout":null,"isExpand":true,"pid":"3859d229-3ffa-b540"},{"id":"a42e7393-24e0-430e","text":"快速排序 -> 冒泡的改进","stroke":"#ff87ad","x":3657,"y":4741.5,"layout":null,"isExpand":true,"pid":"3859d229-3ffa-b540"},{"id":"d086a8db-d134-fe83","text":"归并排序 -> 插入排序方法","stroke":"#ff87ad","x":3641,"y":4776.5,"layout":null,"isExpand":true,"pid":"3859d229-3ffa-b540"},{"id":"856be3ae-e202-b1ad","text":"研究内容: 数据的组织和管理","stroke":"#3c0aa8","x":4520,"y":2803,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"d89c1def-023b-9878","text":"数据由==数据元素和数据对象==构成","stroke":"#3c0aa8","x":4520,"y":2838,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"d07006c9-395d-980e","text":"==数据元素==是**组成数据的基本单位**， 其中数据项是有<mark style=\"background: transparent; color: yellow\">独立含义的最小单位</mark>","stroke":"#3c0aa8","x":4520,"y":2873,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"dc2db6f0-3aeb-4032","text":"数据结构的概念","stroke":"#3c0aa8","x":4520,"y":2918.5,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"bde8886e-af32-19f2","text":"基本逻辑结构包括<mark style=\"background: transparent; color: yellow\">线性结构和非线性结构</mark>","stroke":"#3c0aa8","x":4520,"y":2964,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"8caa582f-b4b2-e0a8","text":"基本存储结构有<mark style=\"background: transparent; color: yellow\">顺序存储和非顺序存储</mark>","stroke":"#3c0aa8","x":4520,"y":2999,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"06c98fe7-9afe-8ba4","text":"数据类型是==一组性质相同的值的集合和定义在值集合上的一组操作的总称==","stroke":"#3c0aa8","x":4520,"y":3034,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"51266448-b4ce-5256","text":"数据类型按照**值的不同特性**可以分为原子类型(不可再分)和结构类型(可分解)","stroke":"#3c0aa8","x":4520,"y":3069,"layout":null,"isExpand":true,"pid":"c13b7135-c025-0605"},{"id":"d4f114c7-7909-37f5","text":"在高级编程语言中， 整形，实型，字符型是基本的抽象数据类型","stroke":"#3c0aa8","x":4520,"y":3104,"layout":null,"isExpand":true,"pid":"12dbefdd-01e2-ef2f"},{"id":"661ec16e-bce1-5b9a","text":"<mark style=\"background: transparent; color: yellow\">抽象数据类型的特征是使用与实现分类，实现封装和信息隐蔽(类型的定义与其实现分离)</mark>","stroke":"#3c0aa8","x":4520,"y":3139,"layout":null,"isExpand":true,"pid":"12dbefdd-01e2-ef2f"},{"id":"179e7f36-4863-72de","text":"<mark style=\"background: transparent; color: yellow\">抽象数据类型最重要的特点是数据抽象与信息屏蔽</mark>","stroke":"#3c0aa8","x":4520,"y":3195,"layout":null,"isExpand":true,"pid":"12dbefdd-01e2-ef2f"},{"id":"36ae8314-754c-d152","text":"四种基本的数据结构类型","stroke":"#3c0aa8","x":4536,"y":3230,"note":"1. 集合结构\n2. 线性结构\n3. 树形结构\n4. 图形结构或者网状结构","layout":null,"isExpand":true,"pid":"c9c609d2-6798-2d80"},{"id":"ee45a87e-547d-9fbf","text":"四种基本结构可以概括为线性结构和非线性结构","stroke":"#3c0aa8","x":4536,"y":3265,"layout":null,"isExpand":true,"pid":"c9c609d2-6798-2d80"},{"id":"f5d7918b-aa04-58eb","text":"概念: 数据的存储结构是==逻辑结构在计算机中的存储映像==","stroke":"#3c0aa8","x":4536,"y":3300,"layout":null,"isExpand":true,"pid":"0878d635-aa44-c170"},{"id":"23659665-54c0-9f9a","text":"逻辑结构和存储结构的关系","stroke":"#3c0aa8","x":4536,"y":3352.5,"layout":null,"isExpand":true,"pid":"0878d635-aa44-c170"},{"id":"b9e06fe6-53bf-3e01","text":"数据结构研究数据的表示以及一系列相关的操作","stroke":"#3c0aa8","x":4536,"y":3405,"layout":null,"isExpand":true,"pid":"0878d635-aa44-c170"},{"id":"94970ba4-daa2-7bc5","text":"需要有限性，可行性，输入和输入等几个特性","stroke":"#3c0aa8","x":4504,"y":3440,"layout":null,"isExpand":true,"pid":"c2a96329-b3f3-5eef"},{"id":"bfd1cda2-9f34-bd92","text":"<mark style=\"background: transparent; color: orange\">正确性，可读性，健壮性(鲁棒性)，高效率和低存储量</mark>","stroke":"#3c0aa8","x":4504,"y":3475,"layout":null,"isExpand":true,"pid":"c2a96329-b3f3-5eef"},{"id":"0cedf529-c27d-f2d6","text":"时间和空间性能分析","stroke":"#3c0aa8","x":4504,"y":3510,"layout":null,"isExpand":true,"pid":"c2a96329-b3f3-5eef"},{"id":"76c4d22b-4b19-1c9c","text":"在栈的数组连续存储定义中，top==指向栈顶的下一个元素==","stroke":"#d6ef56","x":4363,"y":3691,"layout":null,"isExpand":true,"pid":"ddf1357f-bd66-111b"},{"id":"77ff998b-8d32-64e4","text":"栈顶元素 = stk[top -1] , 若top  = base = 0,则栈空","stroke":"#d6ef56","x":4363,"y":3726,"layout":null,"isExpand":true,"pid":"ddf1357f-bd66-111b"},{"id":"8e5fba27-ea73-6eea","text":"需要注意的是出栈时先top-1之后，再取对应的元素","stroke":"#d6ef56","x":4363,"y":3761,"layout":null,"isExpand":true,"pid":"ddf1357f-bd66-111b"},{"id":"d3efe5a2-68d7-f682","text":"队首指针指向队首的==上一个元素==，队尾指向队尾元素","stroke":"#d6ef56","x":4379,"y":3796,"layout":null,"isExpand":true,"pid":"ffd6ad43-0f02-131f"},{"id":"df0c4d31-7175-8e93","text":"初始时，队首 = 队尾 = 0, 每一次入队队尾指针+1, 出队队首指针+1","stroke":"#d6ef56","x":4379,"y":3831,"layout":null,"isExpand":true,"pid":"ffd6ad43-0f02-131f"},{"id":"93cc377a-9855-87d0","text":"往往使用循环队列的方法，即加之后除MAXSIZE","stroke":"#d6ef56","x":4379,"y":3866,"layout":null,"isExpand":true,"pid":"ffd6ad43-0f02-131f"},{"id":"f2b532ad-8c1f-c425","text":"注意判断队列的溢出条件，如果(队尾 + 1)/MAXSIZE= 队首，则队满, 而队空对应front  = rear","stroke":"#d6ef56","x":4379,"y":3901,"layout":null,"isExpand":true,"pid":"ffd6ad43-0f02-131f"},{"id":"5f872d3d-5276-3c42","text":"长度 = 队尾 - 队首","stroke":"#d6ef56","x":4379,"y":3957,"layout":null,"isExpand":true,"pid":"ffd6ad43-0f02-131f"},{"id":"cb526528-d3ef-3f79","text":"==逆波兰表达式求值及其原理==","stroke":"#d6ef56","x":4379,"y":4066,"layout":null,"isExpand":true,"pid":"0e8c329e-63e1-2984"},{"id":"69667f80-96f1-2fb7","text":"需要注意的是，栈和队列的定义中，尤其是队列的链式存储定义中，需要另外定义一个结构体，存储队首和队尾的Node ， 而在节点结构体中，仅需要按单链表进行定义即可 。 而栈的定义只需要直接定义栈顶元素的指针和一阶节点即可。","stroke":"#d6ef56","x":4475,"y":4175,"layout":null,"isExpand":true,"pid":"3fbabe63-0e95-8cb3"},{"id":"7ae76b6f-db77-c4a3","text":"初始化队列时， 令rear = front = nullptr\n入队时， 如果为空，则将font = rear设置为同一个指针\n否则每一次 入队将rear置为Q(新节点)， 出队将font = front ->next;","stroke":"#d6ef56","x":4475,"y":4251,"layout":null,"isExpand":true,"pid":"3fbabe63-0e95-8cb3"},{"id":"82b7921c-783e-a812","text":"注意: 有两种方法，如果队列带有头结点，则首元素为front -> next -> data","stroke":"#d6ef56","x":4475,"y":4327,"layout":null,"isExpand":true,"pid":"3fbabe63-0e95-8cb3"},{"id":"bde76e6e-1d2e-1827","text":"汉诺塔算法","stroke":"#d6ef56","x":4456,"y":4362,"layout":null,"isExpand":true,"pid":"679dda60-52ed-b903"},{"id":"039ab310-86b1-26a5","text":"数字拆分算法","stroke":"#d6ef56","x":4456,"y":4449.5,"layout":null,"isExpand":true,"pid":"679dda60-52ed-b903"},{"id":"5bebd536-3c9c-c5e1","text":"穷举n 位m进制数的问题","stroke":"#d6ef56","x":4456,"y":4537,"layout":null,"isExpand":true,"pid":"679dda60-52ed-b903"},{"id":"0746b28f-1155-b9a4","text":"排列穷举问题","stroke":"#d6ef56","x":4456,"y":4572,"layout":null,"isExpand":true,"pid":"679dda60-52ed-b903"},{"id":"c3d2d37d-adc1-7fb5","text":"素数环问题","stroke":"#d6ef56","x":4456,"y":4607,"layout":null,"isExpand":true,"pid":"679dda60-52ed-b903"},{"id":"49d03e00-141b-1803","text":"其他知识点","stroke":"#d6ef56","x":4456,"y":4642,"note":"**递归进层需要做的三件事**：\n1. 保留本层参数与返回地址\n2. 为被调用的函数分配存储区，并给下一层参数赋值\n3. 将程序转义到被调用函数的入口处\n\n**被调用函数返回调用函数**做的三件事: \n1. 保存被调用函数的计算结果\n2. 释放被调用函数的数据区， 恢复上层参数\n3. 依照被调用函数的返回地址将控制转移给回调函数","layout":null,"isExpand":true,"pid":"679dda60-52ed-b903"},{"id":"aaa761cd-d55a-e4b3","text":"需要注意==乘的部分是列==","stroke":"#2244cc","x":4574,"y":4687,"layout":null,"isExpand":true,"pid":"8a61826c-4f39-c0d1"},{"id":"fcc2c182-c9be-4b51","text":"三元组","stroke":"#2244cc","x":4606,"y":4722,"layout":null,"isExpand":true,"pid":"ec4c571c-d1f0-4d41"},{"id":"7ebdb5c6-10ae-1247","text":"十字链表","stroke":"#2244cc","x":4606,"y":4757,"layout":null,"isExpand":true,"pid":"ec4c571c-d1f0-4d41"},{"id":"507bc6ac-4adc-6740","text":"==三元组的转置==","stroke":"#2244cc","x":4606,"y":4827,"layout":null,"isExpand":true,"pid":"b00e8df7-d257-8103"},{"id":"cac76e1d-4760-b24f","text":"关键是使用union, 将对应的元素和广义表定义成同样的类型","stroke":"#2244cc","x":4594,"y":4897,"layout":null,"isExpand":true,"pid":"0eedbca2-b2ab-061a"},{"id":"567fd98d-f1e4-6d6e","text":"存储结构的表示","stroke":"#2244cc","x":4594,"y":4967,"layout":null,"isExpand":true,"pid":"0eedbca2-b2ab-061a"},{"id":"5b0c5069-ec42-f7fd","text":"重要定义","stroke":"#2244cc","x":4594,"y":5037,"layout":null,"isExpand":true,"pid":"0eedbca2-b2ab-061a"},{"id":"47cb88ac-add4-c189","text":"表达式的广义表存储(之后记得补上)","stroke":"#2244cc","x":4594,"y":5072,"layout":null,"isExpand":true,"pid":"0eedbca2-b2ab-061a"},{"id":"240a2153-3f0f-1c79","text":"树的定义: 树是一个集合， 除空树以外，每个树有一个根节点，每个节点分为m个不相交的子集， 并且每个子集均满足树的条件。","stroke":"#7aefc8","x":3048,"y":2868,"layout":null,"isExpand":true,"pid":"ba0641bd-2a37-7831"},{"id":"9b94622b-a1d5-eb12","text":"森林是m棵互不相交的树的集合","stroke":"#7aefc8","x":3419,"y":2924,"layout":null,"isExpand":true,"pid":"ba0641bd-2a37-7831"},{"id":"105546f7-d7ce-5a0b","text":"满足以下两个条件的树称为二叉树","stroke":"#7aefc8","x":3400,"y":2976.5,"layout":null,"isExpand":true,"pid":"ba0641bd-2a37-7831"},{"id":"8310f082-09f0-f224","text":"如果二叉树中，最多只有下面两层的度可以小于2, 且下面一层的叶节点都从左向右依次排布，这样的二叉树为完全二叉树 `->` 可以进行连续存储","stroke":"#7aefc8","x":3048,"y":3029,"layout":null,"isExpand":true,"pid":"ba0641bd-2a37-7831"},{"id":"06db7f30-0527-331e","text":"基本的二叉树表示","stroke":"#7aefc8","x":3512,"y":3138.5,"layout":null,"isExpand":true,"pid":"e4a02dda-4ac2-e32c"},{"id":"08dcd1be-ec95-7784","text":"树和森林的存储结构","stroke":"#7aefc8","x":3496,"y":3296,"layout":null,"isExpand":true,"pid":"e4a02dda-4ac2-e32c"},{"id":"7176ff76-7bcc-7b86","text":"树的遍历","stroke":"#7aefc8","x":3576,"y":3418.5,"layout":null,"isExpand":true,"pid":"c5b6ac4e-a234-0b3d"},{"id":"167ec140-dbbf-533b","text":"==二叉树的中序线索化==","stroke":"#7aefc8","x":3472,"y":3471,"note":"TreeNode* pre = nullptr;\nvoid thread_tree(TreeNode* root)\n{\n\tif (!root) return;\n\t// 先访问左树\n\tthread_tree(root->left);\n\tif (pre && !pre->right)\n\t{\n\t\tpre->right = root;\n\t\tpre->right_tag = true;\n\t}\n\tif (!root -> left)\n\t{\n\t\troot->left = pre;\n\t\troot->left_tag = true;\n\t}\n\tpre = root;\n\tthread_tree(root->right);\n}","layout":null,"isExpand":true,"pid":"c5b6ac4e-a234-0b3d"},{"id":"9c8857d2-8bb4-e8b7","text":"树转化为二叉树","stroke":"#7aefc8","x":3528,"y":3506,"layout":null,"isExpand":true,"pid":"c5b6ac4e-a234-0b3d"},{"id":"7b95287d-e712-e96e","text":"树和森林的转换","stroke":"#7aefc8","x":3528,"y":3541,"layout":null,"isExpand":true,"pid":"c5b6ac4e-a234-0b3d"},{"id":"5237f920-c4f2-475b","text":"并查集操作","stroke":"#7aefc8","x":3560,"y":3576,"layout":null,"isExpand":true,"pid":"c5b6ac4e-a234-0b3d"},{"id":"56991636-810e-f17e","text":"哈夫曼编码->前缀编码","stroke":"#7aefc8","x":3449,"y":3621.5,"layout":null,"isExpand":true,"pid":"158e85d9-36e2-c316"},{"id":"08d25c80-e9d8-675d","text":"相关概念","stroke":"#7aefc8","x":3520,"y":3677.5,"note":"1. **路径**： 一个节点到另一个节点的分支序列\n2. **路径长度**：一个节点到另一个节点所经过的分支数目\n3. **树的路径长度**：从根节点到每个节点的路径长度之和\n4. 节点的权： 我们在实际应用中，人们常常给数的每个节点赋予一个具有某种实际意义的实数，并称这个实数为**节点的权**, 记为$w_i$\n5. **节点的带权路径长度**\n设某个节点从根节点到该节点的路径长度为$l_i$, 且该节点的权值为$\\omega_i$, 则节点的带权路径长度为 :\n$$w_i \\times  l_i$$\n6. **树的带权路径长度**\n对于树中的每一个终端节点$k_i$, 有一个权值$w_i$与数中的节点对应，并取$l_i$为从根节点到叶节点的路径长度， 则<mark style=\"background: transparent; color: yellow\">根节点到每一个叶节点的带权路径长度之和</mark>为树的带权路径长度\n$$WPL  = \\sum^{n}_{i=1} w_i \\times l_i$$","layout":null,"isExpand":true,"pid":"158e85d9-36e2-c316"},{"id":"e1ad0b53-90d7-4580","text":"哈夫曼树的创建方法","stroke":"#7aefc8","x":3464,"y":3723,"layout":null,"isExpand":true,"pid":"158e85d9-36e2-c316"},{"id":"31a5545d-3316-3407","text":"方法: 事先的构造和自顶向下进行交换","stroke":"#7aefc8","x":3455,"y":3758,"layout":null,"isExpand":true,"pid":"2a0bbb53-647a-cf5b"},{"id":"27a70917-4ded-18b5","text":"弧头和弧尾的概念","stroke":"#8cf74f","x":3581,"y":3753,"layout":null,"isExpand":true,"pid":"ebea61a3-63f7-f7e7"},{"id":"97966497-e55f-1207","text":"邻接矩阵表示法","stroke":"#8cf74f","x":3589,"y":3788,"layout":null,"isExpand":true,"pid":"b4ff87cf-7ba7-8a3f"},{"id":"39f11374-e0c9-22dc","text":"邻接表表示法","stroke":"#8cf74f","x":3605,"y":3823,"layout":null,"isExpand":true,"pid":"b4ff87cf-7ba7-8a3f"},{"id":"69ce9584-3379-26d7","text":"十字链表表示法","stroke":"#8cf74f","x":3589,"y":3858,"layout":null,"isExpand":true,"pid":"b4ff87cf-7ba7-8a3f"},{"id":"05d330bb-c1e7-cc2d","text":"难点是状态判重，如八数码问题等","stroke":"#8cf74f","x":3333,"y":3893,"layout":null,"isExpand":true,"pid":"0b134a29-4990-145d"},{"id":"2efa9806-f673-3df8","text":"最小生成树问题","stroke":"#8cf74f","x":3645,"y":3945.5,"note":"权值之和最小的生成树，称为<mark style=\"background: transparent; color: yellow\">图的最小生成树</mark> ","layout":null,"isExpand":true,"pid":"c86f8603-cb9a-3946"},{"id":"fac76a63-8b62-7567","text":"最短路径问题","stroke":"#8cf74f","x":3685,"y":4036.5,"layout":null,"isExpand":true,"pid":"c86f8603-cb9a-3946"},{"id":"a5ca947b-6aff-8b1a","text":"方法是使用栈的方法， 每一次出栈一个节点并更新到达点的入度","stroke":"#8cf74f","x":3249,"y":4110,"layout":null,"isExpand":true,"pid":"11e44504-6d5e-bb62"},{"id":"3f1c41f0-f185-bdde","text":"如果一个节点的入度达到0，则将节点入栈","stroke":"#8cf74f","x":3404,"y":4145,"layout":null,"isExpand":true,"pid":"11e44504-6d5e-bb62"},{"id":"a8e3d3cc-0fd0-21ec","text":"==关键路径算法是通过计算最早开始时间和最晚开始时间来进行的==","stroke":"#8cf74f","x":3253,"y":4180,"layout":null,"isExpand":true,"pid":"11e44504-6d5e-bb62"},{"id":"ea559b98-f58f-7b3d","text":"首先寻找每个事件的最早开始时间\n通过拓扑排序, 得到拓扑序列，通过拓扑序列进行访问节点更新时间，则一遍直接即可确定每个节点的最早发生时间\n寻找每个事件的最晚开始时间\n然后在逆拓扑序列下，从终点向前倒推最晚开始时间， 这个是使用拓扑排序的(逆拓扑序列)倒序来进行倒推的， 求解各个节点的最迟发生时间","stroke":"#8cf74f","x":3109,"y":4215,"layout":null,"isExpand":true,"pid":"11e44504-6d5e-bb62"},{"id":"cccd0f05-a40b-a349","text":"直接地址法","stroke":"#ce5b50","x":3614,"y":4339,"layout":null,"isExpand":true,"pid":"85753141-3f55-ac9f"},{"id":"6b5c6665-6ae5-0464","text":"数字分析方法","stroke":"#ce5b50","x":3598,"y":4374,"layout":null,"isExpand":true,"pid":"85753141-3f55-ac9f"},{"id":"b86d15e7-2e56-3011","text":"平方取中法","stroke":"#ce5b50","x":3614,"y":4409,"layout":null,"isExpand":true,"pid":"85753141-3f55-ac9f"},{"id":"22427919-0fa5-a3f1","text":"除留余数法","stroke":"#ce5b50","x":3614,"y":4444,"layout":null,"isExpand":true,"pid":"85753141-3f55-ac9f"},{"id":"939847dc-b95a-1436","text":"分段叠加法","stroke":"#ce5b50","x":3614,"y":4479,"layout":null,"isExpand":true,"pid":"85753141-3f55-ac9f"},{"id":"148c930e-6d8b-9ef3","text":"开放定址法(再散列法)","stroke":"#ce5b50","x":3539,"y":4514,"layout":null,"isExpand":true,"pid":"8c33cfe1-95d4-bae9"},{"id":"e571ade1-b90f-fd3c","text":"再哈希法","stroke":"#ce5b50","x":3630,"y":4549,"layout":null,"isExpand":true,"pid":"8c33cfe1-95d4-bae9"},{"id":"6b1b9964-8c33-0aff","text":"链地址法","stroke":"#ce5b50","x":3630,"y":4584,"layout":null,"isExpand":true,"pid":"8c33cfe1-95d4-bae9"},{"id":"be436033-a741-ed24","text":"公共溢出区方法","stroke":"#ce5b50","x":3582,"y":4619,"layout":null,"isExpand":true,"pid":"8c33cfe1-95d4-bae9"},{"id":"413f8dd6-c8c3-1550","text":"找到情况下","stroke":"#ce5b50","x":3582,"y":4654,"layout":null,"isExpand":true,"pid":"755b88e2-5d65-cd22"},{"id":"8dfa5fb4-dd99-6b81","text":"没有找到情况下","stroke":"#ce5b50","x":3550,"y":4689,"layout":null,"isExpand":true,"pid":"755b88e2-5d65-cd22"},{"id":"825ada5c-d4d9-9340","text":"==值相互之间存在一种或者多种关系==的**数据元素**集合，例如<mark style=\"background: transparent; color: yellow\">表结构，树形结构和图结构</mark>等等","stroke":"#3c0aa8","x":4670,"y":2908,"layout":null,"isExpand":true,"pid":"dc2db6f0-3aeb-4032"},{"id":"99854cf5-1491-6e5d","text":"存储结构是逻辑关系的映像和元素本身的映像","stroke":"#3c0aa8","x":4766,"y":3335,"layout":null,"isExpand":true,"pid":"23659665-54c0-9f9a"},{"id":"33fe8fb6-395f-ae2a","text":"==逻辑结构是数据结构的抽象，存储结构是数据结构的实现==","stroke":"#3c0aa8","x":4766,"y":3370,"layout":null,"isExpand":true,"pid":"23659665-54c0-9f9a"},{"id":"121ef105-b4ed-cc7b","text":"两个栈，数字和运算符栈","stroke":"#d6ef56","x":4609,"y":3992,"layout":null,"isExpand":true,"pid":"cb526528-d3ef-3f79"},{"id":"2245a9f7-1c51-1aad","text":"遇到优先级低的，进行出栈操作, 一直出栈到左括号, 或者遇到更低优先级符号, 或者栈空为止","stroke":"#d6ef56","x":4609,"y":4027,"layout":null,"isExpand":true,"pid":"cb526528-d3ef-3f79"},{"id":"ce5c52ca-23b0-240f","text":"在出栈(时， 直接舍弃","stroke":"#d6ef56","x":4609,"y":4083,"layout":null,"isExpand":true,"pid":"cb526528-d3ef-3f79"},{"id":"896021b0-3842-0943","text":"逆波兰表达式的求值原理：仍然使用两个栈(主要是数字栈) `->` 如果遇到运算符， 则出栈两个元素并使用运算符计算对应的值， 再将所获得的值压入栈中, 得到对应的值","stroke":"#d6ef56","x":4609,"y":4118,"layout":null,"isExpand":true,"pid":"cb526528-d3ef-3f79"},{"id":"96a7a9c0-a9f2-a6c8","text":"递归方法是从小到大进行拆分，end条件是剩余的数字为0","stroke":"#d6ef56","x":4590,"y":4397,"layout":null,"isExpand":true,"pid":"039ab310-86b1-26a5"},{"id":"263caa8f-7f71-1d51","text":"深度优先的搜索思想","stroke":"#d6ef56","x":4590,"y":4432,"layout":null,"isExpand":true,"pid":"039ab310-86b1-26a5"},{"id":"e7efb8c9-d275-4e57","text":"对于状态判重，一种方法是降序拆分， 即比较拆出的数字和目前的数字","stroke":"#d6ef56","x":4590,"y":4467,"layout":null,"isExpand":true,"pid":"039ab310-86b1-26a5"},{"id":"fea2b643-b8a8-5821","text":"根据深度搜索的特点，到0时弹出最后的两个数","stroke":"#d6ef56","x":4590,"y":4502,"layout":null,"isExpand":true,"pid":"039ab310-86b1-26a5"},{"id":"eb67bf3c-700f-62d7","text":"使用的是先swap然后换回来的方法","stroke":"#d6ef56","x":4590,"y":4572,"layout":null,"isExpand":true,"pid":"0746b28f-1155-b9a4"},{"id":"203fb780-0ef5-2b9e","text":"一共需要定义三个数组","stroke":"#2244cc","x":4740,"y":4792,"layout":null,"isExpand":true,"pid":"507bc6ac-4adc-6740"},{"id":"a61d4fb5-51ac-fe75","text":"ElemNum, TotElem, CurIndex, 分别记录元素个数，总元素个数和对应的下标","stroke":"#2244cc","x":4740,"y":4827,"layout":null,"isExpand":true,"pid":"507bc6ac-4adc-6740"},{"id":"036a3c24-ad1e-ce22","text":"关键代码","stroke":"#2244cc","x":4740,"y":4862,"note":"```cpp\t\t\nint loc = curcol[index];\n// 行列转置\nnewLinVec[loc] =  this->Elem[n].col;\nnewColVec[loc] =  this->Elem[n].lin;\nnewDataVec[loc] = this->Elem[n].data;\ncurcol[index] += 1; // currentCol对应位置的下标加1\n```","layout":null,"isExpand":true,"pid":"507bc6ac-4adc-6740"},{"id":"3139aa2b-67e4-60c1","text":"递归括号序列表示","stroke":"#2244cc","x":4744,"y":4932,"layout":null,"isExpand":true,"pid":"567fd98d-f1e4-6d6e"},{"id":"cbbf053c-efc7-195c","text":"头尾节点表示方法","stroke":"#2244cc","x":4744,"y":4967,"layout":null,"isExpand":true,"pid":"567fd98d-f1e4-6d6e"},{"id":"9e1adcd8-5d92-9ae7","text":"同层节点式存储结构","stroke":"#2244cc","x":4744,"y":5002,"layout":null,"isExpand":true,"pid":"567fd98d-f1e4-6d6e"},{"id":"b63adf0d-6206-f2e2","text":"==表头和表尾==","stroke":"#2244cc","x":4696,"y":5037,"note":"1. ==第一个元素$d_1$为表头==，\n2. ==其余元素$d_2...d_n$**构成的广义表**为表尾==\n\n例如$A =  (a, (b,c,d))$,则a的表尾是$((b,c,d))$， 即$(b,c,d)$构成的广义表","layout":null,"isExpand":true,"pid":"5b0c5069-ec42-f7fd"},{"id":"15a623bf-c85d-bfde","text":"1. 每个节点的度均不大于2","stroke":"#7aefc8","x":3173,"y":2959,"layout":null,"isExpand":true,"pid":"105546f7-d7ce-5a0b"},{"id":"ab9a0369-e524-ddfe","text":"2. 每个节点的子节点次序不能任意颠倒","stroke":"#7aefc8","x":3086,"y":2994,"layout":null,"isExpand":true,"pid":"105546f7-d7ce-5a0b"},{"id":"fb93c942-def4-692a","text":"括号表示办法 A(B(D,E,F), C(H,I,J))","stroke":"#7aefc8","x":3226,"y":3086,"layout":null,"isExpand":true,"pid":"06db7f30-0527-331e"},{"id":"4cc55dd0-31e7-7b01","text":"左右子节点表示方法","stroke":"#7aefc8","x":3330,"y":3121,"layout":null,"isExpand":true,"pid":"06db7f30-0527-331e"},{"id":"9faeee1f-6f19-7422","text":"父节点 + 左右子节点, 三叉数组静态存储方法","stroke":"#7aefc8","x":3159,"y":3156,"layout":null,"isExpand":true,"pid":"06db7f30-0527-331e"},{"id":"defde0d9-209c-b4e6","text":"二叉链表的表示方法","stroke":"#7aefc8","x":3330,"y":3191,"layout":null,"isExpand":true,"pid":"06db7f30-0527-331e"},{"id":"8e1dd4b7-347e-45d2","text":"树的表示","stroke":"#7aefc8","x":3394,"y":3261,"layout":null,"isExpand":true,"pid":"08dcd1be-ec95-7784"},{"id":"5fc12048-bfa9-2fe1","text":"森林表示","stroke":"#7aefc8","x":3394,"y":3348.5,"layout":null,"isExpand":true,"pid":"08dcd1be-ec95-7784"},{"id":"bee9a002-f23a-808a","text":"递归方法","stroke":"#7aefc8","x":3474,"y":3401,"layout":null,"isExpand":true,"pid":"7176ff76-7bcc-7b86"},{"id":"b8d014e5-f00c-2949","text":"跌代方法","stroke":"#7aefc8","x":3474,"y":3436,"layout":null,"isExpand":true,"pid":"7176ff76-7bcc-7b86"},{"id":"75e7cca8-a2a9-7641","text":"访问前驱和后继的方法","stroke":"#7aefc8","x":3274,"y":3471,"layout":null,"isExpand":true,"pid":"167ec140-dbbf-533b"},{"id":"b7278963-5d9b-6dd2","text":"首儿子， 下一兄弟的表示方法","stroke":"#7aefc8","x":3278,"y":3506,"layout":null,"isExpand":true,"pid":"9c8857d2-8bb4-e8b7"},{"id":"1b323361-168f-91f6","text":"前缀编码\n**定义**:在编码系统中，**任何一个编码都不是其他编码的左侧子串**","stroke":"#7aefc8","x":2975,"y":3611,"layout":null,"isExpand":true,"pid":"56991636-810e-f17e"},{"id":"c8f32554-4317-6b95","text":"**哈夫曼树定义**：将给定权值和元素的节点，构造成一棵**外部通路带权树的路径长度最短的二叉树**，称为哈夫曼树。","stroke":"#7aefc8","x":2890,"y":3667,"layout":null,"isExpand":true,"pid":"08d25c80-e9d8-675d"},{"id":"09297e96-4239-b652","text":"每一次合并权值最小的两个节点，并将其权值相加，构造出一个新的节点","stroke":"#7aefc8","x":2914,"y":3723,"layout":null,"isExpand":true,"pid":"e1ad0b53-90d7-4580"},{"id":"1439a23c-9cd6-5d58","text":"Prim算法","stroke":"#8cf74f","x":3542,"y":3928,"layout":null,"isExpand":true,"pid":"2efa9806-f673-3df8"},{"id":"0e1eba66-d68c-aa93","text":"CursKal算法","stroke":"#8cf74f","x":3518,"y":3963,"layout":null,"isExpand":true,"pid":"2efa9806-f673-3df8"},{"id":"394918e0-66ff-3d7f","text":"==Floyd算法==","stroke":"#8cf74f","x":3552,"y":4019,"layout":null,"isExpand":true,"pid":"fac76a63-8b62-7567","note":"```cpp\n#include <iostream> \n#define MAX_SIZE 100\n#define Inf 10000\nusing namespace std;\n\n// 邻接矩阵, 其中第0层为第一次迭代的矩阵\nint D[MAX_SIZE][MAX_SIZE][MAX_SIZE];\n\nvoid Floyd(int n) {\n    for (int k = 0; k < n; k++) {\n        // 每一次加入中间节点k,即可能的中间节点有k, 由于有n个点，更新n次\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                D[i][j][k+1] = min(D[i][j][k], D[i][k][k] + D[k][j][k]);\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int row, col, data;\n    // 初始化无向图\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            D[i][j][0] = Inf;\n        }\n        D[i][i][0] = 0;\n    }\n    while (true) {\n        cin >> row >> col >> data;\n        if (row == 0 && col == 0 && data == 0) break;\n        D[row][col][0] = data;\n        D[col][row][0] = data;\n    }\n    Floyd(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << D[i][j][n] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```"},{"id":"3d6bdbe6-2a4f-cb40","text":"Dijkstra算法","stroke":"#8cf74f","x":3538,"y":4075,"layout":null,"isExpand":true,"pid":"fac76a63-8b62-7567","note":"```cpp \n#include <iostream>\n#include <vector>\n#define Inf 1000\n#define MAX_SIZE 100\n\nusing namespace std;\n\n// 邻接矩阵类\nclass Neighbor {\npublic:\n\tNeighbor(int n) {\n\t\tthis->n = n;\n\t\t// 初始化\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) a[i][j] = 0;\n\t\t\t\telse a[i][j] = Inf;\n\t\t\t}\n\t\t}\n\t}\n\tvoid Dijkstra();\n\tvoid show();\n\tvoid show_matrix();\n\tvoid insert_way(int row, int col, int length);\n\nprivate:\n\tint n = 0;\n\tint a[MAX_SIZE][MAX_SIZE];\n\tint d[MAX_SIZE]{}; // 得到的最短路径;\n\tbool s[MAX_SIZE]{}; // 已经求得最短路径的点的集合\n};\n\nvoid Neighbor::insert_way(int row, int col, int length) {\n\ta[row][col] = length;\n\ta[col][row] = length;\n}\n\nvoid Neighbor::Dijkstra() {\n\td[0] = 0; s[0] = true;  // 0 已经寻找过\n\t// 初始化数组d，需要注意的是，仅使用a进行初始化, 取最小时仅使用d\n\tfor (int i = 1; i < n; i++) {\n\t\td[i] = min(Inf, a[0][i]);\n\t\ts[i] = false;\n\t}\n\t// 使用循环, n-1次, 每一次寻找路径最小的节点并加入\n\tfor (int t = n-1; t > 0; t--) {\n\t\tint min = Inf;\n\t\tint min_index = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// 在其余(未求得最小值)的节点中，确定取得最小值的节点下标\n\t\t\tif ( s[i] || d[i]>=min) continue;  // min大于才做\n\t\t\tmin_index = i; min = d[i];\n\t\t}\n\t\t// 得到d中值最小的节点，将其加入集合\n\t\td[min_index] = min;\n\t\ts[min_index] = true;\n\n\t\t// 每一次更新其余节点的值\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (s[i]) continue;\n\t\t\t// 如果两点之间有路径，则更新为对应的值\n\t\t\td[i] = std::min(d[i], d[min_index] + a[min_index][i]);\n\t\t}\n\t}\n}\n\nvoid Neighbor::show() {\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cout << d[i] << \" \";\n\t}\n\tstd::cout << endl;\n}\n\nint main() {\n\tint n, m;\n\t// 初始化a的路径长度\n\tstd::cin >> n >> m;\n\tNeighbor g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint start, end, length;\n\t\tstd::cin >> start >> end >> length;\n\t\tg.insert_way(start-1, end-1, length);\n\t}\n\tg.Dijkstra();\n\tg.show();\n\treturn 0;\n}\n```"},{"id":"ba275730-ed57-eb12","text":"重点: 通过图计算关键路径的两个时间","stroke":"#8cf74f","x":2950,"y":4180,"layout":null,"isExpand":true,"pid":"a8e3d3cc-0fd0-21ec"},{"id":"8733a2c3-ce3d-a2fb","text":"空表为nullptr","stroke":"#2244cc","x":4910,"y":4967,"layout":null,"isExpand":true,"pid":"cbbf053c-efc7-195c"},{"id":"0a2f1d7b-24cf-b519","text":"空表为一个表节点, 其头尾均为空指针","stroke":"#2244cc","x":4926,"y":5002,"layout":null,"isExpand":true,"pid":"9e1adcd8-5d92-9ae7"},{"id":"b655069a-f48a-3aaf","text":"1. 父节点型存储结构(仅存储父节点)","stroke":"#7aefc8","x":3101,"y":3226,"layout":null,"isExpand":true,"pid":"8e1dd4b7-347e-45d2"},{"id":"e4baf3af-8c9f-71c2","text":"2. 子链式存储结构","stroke":"#7aefc8","x":3224,"y":3261,"layout":null,"isExpand":true,"pid":"8e1dd4b7-347e-45d2"},{"id":"a359f423-36d8-a811","text":"3. 左孩子指针和右兄弟表示方法","stroke":"#7aefc8","x":3128,"y":3296,"layout":null,"isExpand":true,"pid":"8e1dd4b7-347e-45d2"},{"id":"c3c2124c-5ece-787a","text":"和树的三种表示方法相同","stroke":"#7aefc8","x":3180,"y":3331,"layout":null,"isExpand":true,"pid":"5fc12048-bfa9-2fe1"},{"id":"335c3852-3f51-128b","text":"左孩子，右兄弟的表示方法","stroke":"#7aefc8","x":3164,"y":3366,"layout":null,"isExpand":true,"pid":"5fc12048-bfa9-2fe1"},{"id":"b7a4db05-16b3-2fb6","text":"适用于节点数较少的","stroke":"#8cf74f","x":3360,"y":3928,"layout":null,"isExpand":true,"pid":"1439a23c-9cd6-5d58"},{"id":"1bad8761-7cfa-1fba","text":"适用于边数较少的部分","stroke":"#8cf74f","x":3320,"y":3963,"layout":null,"isExpand":true,"pid":"0e1eba66-d68c-aa93"},{"id":"f143ae22-61a8-62ca","text":"核心思路","stroke":"#8cf74f","x":3426,"y":4019,"note":"首先对于每两个顶点之间的最短路径， 新建一个数组$D[i][j][k]$存储每两个节点中的最短路径\n\n**为何能通过更新求解出所有的最短路径**? \n首先对于$v_i$和$v_j$节点，将其路径初始化为$D[i][j]$。\n这个使用的是动态规划的思想， 需要注意的是， 每一次，求解时求解三点之间的最短路径，在更新到第1次时，则$D[i][j][1]$是<mark style=\"background: transparent; color: yellow\">加入了中间节点1</mark><u>(即经过的中间节点可能有1)</u>之后， 三元路径长度之和。\n\n第二次加入点2进行更新时，显然<mark style=\"background: transparent; color: yellow\">中间节点有1</mark>的三元路径长度已经被加入过，从而下次计算出的是中间节点加入2的最短路径长度，此时，<mark style=\"background: transparent; color: red\">中间节点可能有1，2</mark>\n\n循环更新n次，直到所有的n个节点都被加入到中间节点中，因此<mark style=\"background: transparent; color: red\">可以经过的中间节点即有1,2,3,...n</mark>，因而得到的就是任意两点间的最短路径\n","layout":null,"isExpand":true,"pid":"394918e0-66ff-3d7f"},{"id":"3a97a9a1-51bd-b6e2","text":"适用于合并","stroke":"#7aefc8","x":2983,"y":3226,"layout":null,"isExpand":true,"pid":"b655069a-f48a-3aaf"},{"id":"c6b6f7c1-7e41-2a0e","text":"稍多使用","stroke":"#7aefc8","x":3122,"y":3261,"layout":null,"isExpand":true,"pid":"e4baf3af-8c9f-71c2"},{"id":"78dab6b9-d743-7a84","text":"对应的遍历方法","stroke":"#7aefc8","x":2978,"y":3296,"layout":null,"isExpand":true,"pid":"a359f423-36d8-a811"},{"id":"ae4483e9-76ed-1e0e","text":"常用于森林的遍历和二叉树的转换","stroke":"#7aefc8","x":2886,"y":3366,"layout":null,"isExpand":true,"pid":"335c3852-3f51-128b"},{"id":"537ad6ec-105e-1535","text":"在记录中添加最短路径时，<mark style=\"background: transparent; color: orange\">使用的方式是直接丢弃原数组，并将Way[i][k], Way[k][j]两个数组整体合并之后，作为新的最短路径</mark>，而不是仅仅在路径中添加k点或者将k以后的部分接到`Way[i][j]`上面","stroke":"#8cf74f","x":2796,"y":3998,"layout":null,"isExpand":true,"pid":"f143ae22-61a8-62ca"}]],"induceData":[],"wireFrameData":[],"relateLinkData":[],"calloutData":[{"nodeId":"e452908b-be2a-f00f","rootData":{"id":"983d4c84-3434-b437","text":"程序 = 控制结构+数据结构","nodeType":"callout","style":{"background-color":"#f06","color":"#fff","font-size":"12px"},"x":3833,"y":3943,"layout":null,"isExpand":true,"stroke":"","point":{"x":4000,"y":4013.5},"box":{"dx":-1.176056338028169,"dy":-0.9344262295081968,"px":0,"py":0.22131147540983606}},"color":"#f06","direct":"top"}]}
```

![[attachments/Pasted image 20230516114600.png|550]]
## 一、静态查找表

## 二、动态查找表
### 1. 二叉排序树
二叉排序树的定义：

定义: 
1. 插入
[[Excalidraw/第八章 查找算法 2023-05-23 10.34.12|示例]]
实际上是查找位置之后插入的方法
2. 删除
在删除对应的节点之后，将下面部分的
3. 查找 
只需通过循环进行查找， 如果根节点相等

### 2. 平衡二叉树(AVL)
- 平衡二叉树又称AVL树。是一棵二叉排序树。
- 它或者是一棵空树，或者是具有下列性质的二叉树：
- 它的左右子树均为平衡二叉树，且左右子树的深度之差的绝对值不超过1。
- 平衡因子BF (Balance Factor)为该结点的左子树的深度减去右子树的深度。
- 在平衡二叉树上所有结点平衡因子只可能为-1, 0, 1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。

1. 平衡二叉树的插入
[[Excalidraw/第八章 查找算法 2023-05-23 11.06.32]]

可以考虑双亲

2. 平衡二叉树的删除 
![[Excalidraw/第八章 查找算法 2023-05-23 11.12.18|150]]

### 3. B树和B+树
B树存储大量的文件， 内存中无法索引时的索引方法
B+树可以从外存中进行访问。

(1) B树及其查找： B树**主要用于高维数据检索和文件的索引**
B树的定义：
一棵m阶的B树，或为空树，或是满足下列特性的m叉树：
- 树中每个结点至多有m棵子树；
- 若根结点不是叶子结点，则至少有两棵子树；
- 除根之外的所有非终端结点至少有ém/2ù棵子树；
- 所有非终端结点中包含下列信息数据$(n, A_0, K_1, A_1, K_2, …, Kn, An)$
  
其中$K_i(i=1,..,n)$为关键字，且$K_i < K_{i+1}(i=1,…,n-1)$; $A_i(i=0,…,n)$为指向子树根结点的指针，且$A_{i-1}$所指子树中所有结点的关键字均小于$K_i(i=1,…,n)$, $A_n$所指子树中所有结点的关键字均大于$Kn$, $n([m/2]-1 \leq n \leq m-1)$为关键字的个数（或$n+1$为子树个数）。
- 所有叶子结点都出现在同一层上，并且不带信息。实际上这些结点不存在，指向这些结点的指针为空。

B树是改进的树，有一个数值n, 有n个关键字，
1. 在B树中查找节点
2. 在B树中查找关键字


## 三、哈希表
### (1) 相关概念
哈希表方法又称散列方法，杂凑方法和<mark style="background: transparent; color: yellow">关键字地址计算方法</mark>。可以在多付出$20\%$空间的情况下，达到平均1.5次的查找效率。

哈希表的基本思想是首先在元素的==关键字$k$和存储位置==$p$之间建立一个关系$H$(即**哈希函数**), 使得$p = H(K)$，达到按照关键字的存取元素的目的

需要注意的是，如果两个不同的关键字**计算出的地址是相同**的， 则产生了**冲突**。

主要问题包括**哈希函数的设计**和**冲突的解决**

### (2) 哈希函数的构造
#### 1. 直接地址方法
取关键字或者其某个线性函数作为地址的值


#### 2. 数字分析方法
各个关键字中，从关键字中取**分布较为均匀**的**几位**构成哈希地址， 往往是取变化比较大的部门

```cpp

```

#### 3. 平方取中方法
取关键字**平方的中间的几位**作为哈希地址

#### 4. 折叠方法
将关键字分成位数相等的几部分，然后将这几部分相加， 并舍弃最高位的数字， 具体的方法包括**折叠叠加方法**和**移位叠加方法**



#### 5. 随机数方法

#### 6. 除留余数方法

#### 7. 伪随机数方法
使用一个伪随机函数作为哈希函数

### (3) 解决冲突的方法
#### 1. 开放定址方法
在地址$h_0$出现冲突时，以该数为基础产生一个地址$h_1$, 如果仍然冲突，则地址再加，可以按照如下的方法进行增量的取值

线性探测再散列: 
$$d_i = 1, 2,3, ... m-1$$
二次探测再散列: 
$$d_i = \pm 1, \pm 4 , ... $$
伪随机再散列: 使用伪随机数序列作为增量

例如对于八数码问题， 每一个状态可以使用

| 2   | 5   | 1   |
| --- | --- | --- |
| 7   | 8   |     |
| 6   | 4   | 3   |

#### 2. 再哈希方法
对于相应的状态，可以<mark style="background: transparent; color: yellow">构造多个不同的哈希函数</mark>
$$H_i = RH_i (key)  \quad i = 1,2, ... k$$
计算第一个哈希函数冲突，则计算第二个哈希函数

优点是不容易产生聚集，但是增加了计算时间

#### 3. 链地址方法
将同义词的关键字放在同一线性链表中。

适用于经常进行插入和删除的情况

#### 4. 溢出向量表方法
可以建立一个公共的溢出区， 和基本表发生冲突的元素填入溢出表中

### (4) 哈希表的查找过程
假设需要查找关键字为key的元素，则对应的查找过程为：
1. 首先计算$h_0  = hash(key)$， 即找到原有的存储地址
2. 如果单元为空，则该元素不存在
3. 比较<mark style="background: transparent; color: yellow">原有的key</mark>和<mark style="background: transparent; color: yellow">表中的key</mark>为$K$， 如果相同则找到， 如果不同，则按照对应的解决冲突方法的寻址方式， 每一次寻找下一个哈希地址，直到找到对应的元素


<mark style="background: transparent; color: yellow">平均查找长度的计算</mark>

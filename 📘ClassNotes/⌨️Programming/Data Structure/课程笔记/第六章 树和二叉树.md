## 1. 树的基本知识和遍历方法
[[📘ClassNotes/⌨️Programming/Data Structure/课程笔记/基础知识/复习 树的基本知识|树的基本知识复习和基本的功能实现]]

树的定义: 使用递归的定义方法
==树是一个集合。除空树外，每个树有一个根节点， 每个节点分为$m$个不想交的子集==
森林是m (m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
树的<mark style="background: transparent; color: yellow">度为子树的个数</mark>， 叶节点定义为<mark style="background: transparent; color: yellow">度为0的节点</mark>


## 2. 二叉树及其基本存储结构
### (1) 二叉树的定义和性质
二叉树定义：**满足下列两个条件的树结构称为二叉树** 
1. 每个节点的度都不大于2
2. 每个节点的孩子节点次序不能任意颠倒

二叉树的性质：
1. n层满二叉树有$2^n-1$个节点， 第i层有$2^{i-1}$个节点
2. 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为$n_2$，则$n_0=n_2+1$。
3. 具有n个结点的完全二叉树的深度为$[\log_2 n]+1$，其中$[a]$表示不大于的最大整数

如果二叉树中最多只有最小面两层的节点度可以小于2，<mark style="background: transparent; color: yellow">且下面一层的叶节点都从左向右进行依次排布</mark>， 则称二叉树为**完全二叉树**，<mark style="background: transparent; color: yellow">完全二叉树可以进行连续存储结构的排布
</mark>

二叉树有顺序存储结构和链式存储结构两种基本存储结构，叙述如下

### (2) 二叉树的顺序存储结构
对于完全二叉树的存储， 可以使用顺序存储的存储结构， 如果不是完全二叉树，可以补全称为完全二叉树

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

可以使用: 左子树：$2 * i +1$ , 右子树：$2*i +2$的寻址方式：
![[attachments/Pasted image 20230411114343.png|300]]

对于完全二叉树，存储不浪费空间且方便使用，但是对于一般二叉树，需要使用虚节点存储，可能最多造成$2^{k}-1$个指针存储单元的浪费(其中二叉树深度为$k$)

### (3) 二叉树的链式存储结构(即最广泛使用的二叉树结构)
对于二叉树的定义，往往使用二叉链表的结构，可以参考[[📘ClassNotes/⌨️Programming/Data Structure/课程笔记/基础知识/复习 树的基本知识#二、二叉树及其基本性质|二叉树的定义以及遍历方法]]

此处讲解: 
**1. 扩充二叉树**
对二叉树的”扩充“操作是将原二叉树的每一个子节点都变为度数为2的分支节点，这样扩充对一个二叉树而言， 扩充二叉树中，新增加的都是节点

设原先的二叉树节点数量为$n$, 则可以总结得出，初始时"空位"有两个，且每增加一个节点，“空位”增加一个，因此会新产生$n+1$个节点(变为$2n+1$个)， 新增加的外部节点的个数比原来的内部节点的个数多1
![[Excalidraw/第六章 树和二叉树 2023-04-26 13.17.41|400]]

**2. 三叉链表的静态存储方法** 

使用一个较大的数组，记录所有的节点，leftChild 和 rightChild
![[attachments/Pasted image 20230411115341.png|400]]

## 二、 二叉树的初始化
### (1) 字符串二叉树初始化

`````ad-note
title: 字符串初始化二叉树
collapse: close
使用字符串初始化二叉树的方法主要有递归函数方法和栈方法
1. 递归函数方法
```cpp 
#include <iostream>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

void PreOrderTransverse(TreeNode* root) {
	if (!root) return;
	cout << root->data;
	PreOrderTransverse(root->left);
	PreOrderTransverse(root->right);
}

// 使用递归法建立二叉树, 这个必须有返回值不然报错
TreeNode* CreateTree(TreeNode* root) {
	char ch; bool run = true;
	while (run) // 套一个循环, 两边都create之后
	{
		cin >> ch;
		if (ch == ' ') continue;
		else if (ch == ')' ||ch ==',') return root;
		// 最终达到)时，返回栈
		switch (ch) {
		case'(': // 继续cin
			root->left = CreateTree(root->left); // createTree以,为结束
			// 中间有一个分隔号 ','因此以,为左侧结束符
			root->right = CreateTree(root->right);  // 以)为结束
			break;
		default:
			TreeNode* L = new TreeNode(); // 新建这个节点
			L->data = ch;
			root = L; // 这样新建节点, 而不是直接给root 分配
			continue; // 继续循环
		}
	};
}
// 由于原理是cin到最后一个标志后返回，导致无法停止，所以有必要第一个单独搞停止

TreeNode* CreateBinaryTree(TreeNode* root) {
	cin >> root->data;
	char a;
	cin >> a; // (
	root->left=CreateTree(root->left);  // 中间逗号自动cin
	root->right=CreateTree(root->right);
	return root;
}

int main() {
	TreeNode* tree = new TreeNode();
	tree = CreateBinaryTree(tree); // 调用递归函数，创建节点

	PreOrderTransverse(tree);
	return 0;
}

/* Test Input
A(B(#,D),C(E(#,F),#))
*/
```

2. 使用栈的初始化方法
其中需要注意的是，使用栈时需要先将栈顶元素初始化之后再对元素进行赋值

```cpp 
#include <iostream>
#include <stack>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

void PreOrderTransverse(TreeNode* root) {
	if (!root) return;
	cout << root->data;
	PreOrderTransverse(root->left);
	PreOrderTransverse(root->right);
}

// 使用栈的方法建立二叉树
void CreateTree(TreeNode* root, string str) {
	stack<TreeNode*> stk;
	stk.push(root); // 放入根节点
	for (char ch: str) {
		// 往往通过栈满和栈空判断终止条件
		switch (ch) {
		case ')':
			stk.pop();
			break;
		case '(':
			stk.top()->left = new TreeNode(); // 为了防止返回时覆盖, 这里需要注意
			stk.push(stk.top()->left);
			break;
		case ',':
			stk.pop();
			stk.top()->right = new TreeNode();
			stk.push(stk.top()->right); // 换为右节点
			break;
		default:
			stk.top()->data = ch;  
			// 注意使用这样的方法为其赋值, 不要使用 p = L ,因为这样会重指
		}
	}
}
// 由于原理是cin到最后一个标志后返回，导致无法停止，所以有必要第一个单独搞停止

int main() {
	TreeNode* tree = new TreeNode();
	string str;
	getline(cin, str);
	CreateTree(tree, str); // 调用递归函数，创建节点
	PreOrderTransverse(tree);
	return 0;
}

/* Test Input
A(B(#,D),C(E(#,F),#))
*/
```

`````

### (2) 二叉树的扩展先序遍历序列创建

最简单的方法是定义一个全局变量记录下标

```cpp 
// 全局变量定义创建下标(仅创建一次)
int create_index = 0;

// 使用扩展二叉序列创建二叉树
TreeNode* create_tree(const vector<char> vec)
{
	TreeNode* node = nullptr;
	if (vec[create_index]!= '#')
	{
		node = new TreeNode();
		node->data = vec[create_index];
		create_index++; // 进行自增
		node->left = create_tree(vec);
		node->right = create_tree(vec);
	}
	else{
		create_index++;
	}
	return node;
}

int main() {
	const vector<char> vec{ 'a','b','#','#','c', '#','d','#','#'};
	TreeNode* root = create_tree(vec);
}
```

`````ad-note
title:序列二叉树的初始化递归代码
collapse: close

可以使用先序遍历序列ABD##EH###CF#I##G##类似的代码来初始化二叉树，代码如下

```cpp 
TreeNode* CreateTree() {
	char ch;
	cin >> ch;
	TreeNode* root = nullptr;  
	// 事先初始化节点
	if (ch != '#') { // 空节点
		root = new TreeNode();
		root->data = ch;
		root->left = CreateTree();
		root->right = CreateTree();
	}
	return root;
}
```
`````

### (3) 前序序列和中序序列建立二叉树
<mark style="background: transparent; color: yellow">方法是左子树和右子树的分开方法</mark>
我们以下面的二叉树为例
![[attachments/Pasted image 20230419213434.png|350]]
则其先序序列和中序序列分别为：
![[attachments/Pasted image 20230419213600.png|450]]
利用下图中的特点，我们可以总结出一个通过前序遍历和中序遍历序列构建二叉树的过程:
每一次计算好不同区间的start来建立序列， 并取mid序列$A$左边的部分为左子树序列，右边的部分为右子树序列，并每一次取start为根节点即可
![[attachments/Pasted image 20230419231836.png|650]]

````ad-note
title: 给出先序和中序序列创建二叉树的代码
collapse: close

下面的代码每一次是取其中的左子树序列和右子树序列，并且记录它们的两个不同的start值，
```cpp 
#include <iostream>
#include <vector>
#include <stack>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

// 后序遍历输出
void dfs(TreeNode* root) {
	if (!root) return;
	dfs(root->left);
	dfs(root->right);
	cout << root->data;
}

vector<DataType> pre;
vector<DataType> mid;

// 使用两个向量进行建立, gen_arr是用来生成对应子树的向量(包含根节点)
TreeNode* CreateTree(int start, int end, vector<DataType> gen_arr) {
	TreeNode* root = new TreeNode();
	root->data = pre[start];   // 设置这个树的根节点
	DataType temp = root->data;
	vector<DataType> vector1; // 用来创建左子树的vector
	vector<DataType> vector2; // 用于创建右子树
	
	int i = 0;
	// 构建左子树序列, 在gen_arr的temp左侧为对应的元素
	for (; gen_arr[i] != temp; i++) vector1.push_back(gen_arr[i]);
	// 右子树序列, temp右侧的元素
	for (i++; i < gen_arr.size(); i++) vector2.push_back(gen_arr[i]);
	if (!vector1.empty()) root->left = CreateTree(start + 1, start + vector1.size(), vector1);
	if (!vector2.empty()) root->right = CreateTree(start + vector1.size() + 1,start + vector1.size() + vector2.size(), vector2);
	return root;
}

int main() {
	string input;
	getline(cin, input);
	for (char ch : input) pre.push_back(ch);
	getline(cin, input);
	for (char ch : input) mid.push_back(ch);
	// 初始化先序和中序遍历向量
	TreeNode* root = CreateTree(0, pre.size()-1, mid); 
	// 初始设置mid整个为gen_arr
	dfs(root);
	return 0;
}

/* Test Input
ABDFGCEH
BFDGACEH

** result *** 
FGDBHECA  // 后序遍历结果
*/

```

````

`````ad-faq
title: 如何考虑不建立二叉树而使用递归的方法直接输出后序遍历
collapse: open
`````

## 三、二叉树的基本操作
### (1) 表达式的二叉树结构
对于下图的表达式存储： 
![[Excalidraw/第六章 树和二叉树 2023-04-20 10.38.47|300]]
其前序遍历：$-+a*bc/dc$
中序遍历: $a+ b*c - d/c$ (即真实表达式)
后序遍历: $abc*+ dc/-$ (即逆波兰表达式)
```cpp 
typedef struct ParTreeNode{
	DataType info; 
	int parent;
};
typedef struct ParTree{
	ParTreeNode nodelist[MAXNUM];
	int n;
};
```

### (2) 分治算法求解二叉树的高度
可以使用极其简单的算法求解二叉树高度
```cpp 
int depth(TreeNode* root)
{
	if (!root) return 0;
	return max(depth(root->left), depth(root->right)) + 1;
}
```

### (3) 二叉树的横向图形显示
首先输出顺序是逆中序输出
只需要在递归的函数中多定义一个layer参数然后输出空格即可
```cpp 
// 逆中序遍历方法输出
void print_tree(TreeNode* root, int layer)
{
	if (!root) return;
	print_tree(root->right, layer + 1);
	for (int i = 0; i < layer; i++) cout << " ";
	cout << root->data << endl;
	print_tree(root->left, layer + 1);
}
```

## 四、二叉树的线索化(Threading)
### (1) 线索化的概念和创建
二叉树的线索化是通过二叉树线索方法将二叉树节点按照一定的规律线性化的过程， 当我们以二叉链表为存储结构是，不可能直接得到<mark style="background: transparent; color: yellow">节点在遍历序列中的前驱和后继信息</mark>。

较好的方法是利用链表中原有的空链域将遍历过程的前驱和后继信息进行保存

我们可以付出一定的空间代价，定义一个ltag和一个rtag， 表示这个指针的左右节点是否被利用
下图表示了前序线索化和中序线索化一棵树的结构

![[Excalidraw/第六章 树和二叉树 2023-04-26 14.59.06|500]]
在二叉树的线索化中，我们记录一个指向刚访问过的指针pre
线索二叉树(Threading binary Tree)

进行中序二叉线索化的核心代码为： 
```cpp
TreeNode* pre = nullptr;
void thread_tree(TreeNode* root)
{
	if (!root) return;
	// 先访问左树
	thread_tree(root->left);
	if (pre && !pre->right)
	{
		pre->right = root;
		pre->right_tag = true;
	}
	if (!root -> left)
	{
		root->left = pre;
		root->left_tag = true;
	}
	pre = root;
	thread_tree(root->right);
}
```

`````ad-note
title: 二叉树的中序线索化的代码实现
collapse: close

下列代码演示了二叉树的前序建立和中序线索化，示例输入中的树结构为

![[Excalidraw/第六章 树和二叉树 2023-04-19 15.49.59|250]]

其中使用向右搜索遍历下一个中序节点的方法将二叉树进行了中序输出

```cpp 
// 二叉树中序线索化的建立代码
#include <iostream>
using namespace std;

typedef char DataType;

// 二叉树节点定义
typedef struct TreeNode {
    DataType data;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
    bool ltag = false, rtag = false;
    // 左右的标签
};

// 先序建立二叉树
TreeNode* CreateTree() {
    char ch;
    TreeNode* p = nullptr;
    cin >> ch;
    // 除了使用if_else;
    if (ch != '#'){
        p = new TreeNode();   // 先序建立树的节点
        p->data = ch;
        p->left = CreateTree();
        p->right = CreateTree();
    }
    return p;   // 注意单出口函数，如果多出口有可能遗漏而报错
}

// 全局定义一个指针last,指向刚刚访问过的节点
TreeNode* last = nullptr; 

/*中序线索化*/
void ThreadTree(TreeNode* root) {
    // 中序遍历一次
    if (root) {
        // 使用左节点，接上上一个访问的元素
        ThreadTree(root->left);

        //处理当前节点
        // 向前接上
        // 向前接上
        if (!root->left) {
            root->ltag = true; // 左节点被利用
            root->left = last; // right指向下一个访问的元素
        }

        if (last && !last->right) {
            last->rtag = true;  // 标志这个节点的右节点原先是空节点，现在被利用
            // 注意是last的rtag
            last->right = root; // last指向前一个访问的元素
        }

        last = root;  // 将上一个节点设置为根节点 

        ThreadTree(root->right);
    }
}

/*中序遍历函数*/ 
void MidOrderTransverse(TreeNode* root) {
    TreeNode* p = root;
    if (!p) return;
    while (p->left) {
        p = p->left;
    } // 找到中序遍历的头结点
    // 进行中序遍历
    while (p!= nullptr) {
        // 先输出本身
        cout << p->data;
        if (p->rtag) { // true
            p = p->right;
        }// rtag == 1 时，直接使用right作为后继节点
        else { // 先找到右子树, 再搜索右子树的最左下节点
            p = p->right;
            while (p && p->left && p->ltag == false) p = p->left;
            // 最终到达最左下的一个节点，即为下一个访问的节点
        }
    }
}

int main()
{
    TreeNode* root; 
    root = CreateTree(); // 先序建立
    ThreadTree(root); // 使用扩充二叉树进行中序线索化
    last->right = nullptr;
    MidOrderTransverse(root);
}
/* Test Code: 
ABD###CE##F##
*/
```

`````

### (2) 线索化的前驱和后继节点查找方法

对于前驱节点的查找，如果`left_tag = true`, 则前驱节点记为左节点`left->tag` ，否则其前驱是其<mark style="background: transparent; color: yellow">左子树的右下端节点</mark>
```cpp 
// 查找中序前驱节点
TreeNode* pre_find(const TreeNode* root)
{
	if (!root || !root->left) return nullptr;
	if (root->left_tag) return root->left;
	TreeNode* p = root->left;
	while (p->right != nullptr && !p->right_tag)
		p = p->right;
	return p;
}
```

后继节点查找时，如果`right_tag = true` 则后继节点为右节点，否则为<mark style="background: transparent; color: yellow">右子树的左下端节点</mark>
```cpp 
TreeNode* next_find(const TreeNode* root)
{
	if (!root || !root->right) return nullptr;
	if (root->right_tag) return root->right;
	TreeNode* p = root->right;
	while (p->left != nullptr && !p->left_tag)
		p = p->left;
	return p;
}
```

对于线索化二叉树遍历，首先找到根节点的最左下节点然后开始遍历即可(由于节点修改，不能使用原先遍历方法)
```cpp 
void travel_mid(TreeNode* root)
{
	if (!root) return;
	TreeNode* p = root;
	while (p->left){
		p = p->left;
	}
	while (p)
	{
		cout << p->data << " ";
		p = next_find(p);
	}
	cout << endl;
}
```

### (3) 两种需要使用三叉链表的情况
![[attachments/Pasted image 20230426155327.png|400]]
![[attachments/Pasted image 20230426155351.png|400]]

## 五、树和森林的表示
### 1. 树的表示
#### (1) 双亲节点的表示方法
`````ad-quote
title: 并查集
collapse: open
`````
可以使用双亲表示法进行合并
![[Excalidraw/第六章 树和二叉树 2023-04-20 10.47.16|250]]
两次查找， 并进行一次赋值，为了减小查找的深度，可以直接使用双亲节点表示，存储双亲节点，如果是根节点则设置为-1

下面给出一种**双亲节点方法的节点类型定义**
```cpp 
typedef struct ParTreeNode{
	DataType data;  
	int parent; // 表示i号节点是根节点
}
```
==在这种表示中，容易找到父结点及其所有的祖先；也能找到结点的子女和兄弟（虽然比较麻烦）。但它没有表示出结点之间的左右次序，所以无法求树中某个指定结点的最左子结点和右兄弟结点等基本运算。==

改进方法是按一种遍历次序**在数组中存放结点**。其中较常见的一种方法是<mark style="background: transparent; color: yellow">依次存放树的先根序列</mark>，如图：
![[attachments/Pasted image 20230426155759.png|400]]
```cpp 
typedef  struct ParTree{
  ParTreeNode  nodelist[MAXNUM];
  int  n;
}ParTree, *PParTree;
```

#### (2) 子表的表示方法
可以使用子节点链表的方法，
```cpp 
typedef struct EdgeNode{  /*字表中的节点的结构*/
	int node_position;
	struct EdgeNode* link;  // 指向第一个子节点节点
};
typedef struct TreeNode{
	// 第二个结构体的定义
	/*结点表中的节点结构*/
	DataType data;
	struct EdgeNode* children; // 初始化第一个子表节点
};
typedef struct ChiTree{ 
	/*整个树结构的数组*/
	TreeNode* node_list[MAXNUM]; // 存储节点
	int root; // 根节点在线性表中的位置
	int num;  // 存储树的节点个数
};
```

其三个结构体的定义的图示如下： 
![[Excalidraw/第六章 树和二叉树 2023-04-20 11.12.27|600]]

如何建立上图的存储结构：
使用 $p$-> 右侧元素之后循环实现(注意不能从p开始，由于节点类型不同)

#### (3) 左子树和sibling的表示方法

```cpp 
typedef  struct CSNode{
  DataType  info;
  struct CSNode  *lchild;
  struct CSNode  *rsibling;
};
```
结构如图
![[attachments/Pasted image 20230420113745.png|200]]

### 2. 森林的表示
#### (1) 双亲表示方法
parent = -1为根节点
表示方法如下图
![[attachments/Pasted image 20230420113348.png|400]]
#### (2) 子表表示方法
字表的表示方法在森林表示中不常使用
==缺点是找不到根节点==，一种方法是在全部表中扫描， 
![[attachments/Pasted image 20230420113439.png|400]]

#### (3) 左子节点和右sibling节点的表示
这种方法是一种常见的森林的存储方法，可以将不同的树的根并联在一起，然后有选择性地遍历树或者整个森林

![[attachments/Pasted image 20230420113612.png|600]]
对于树和森林的遍历方法，可以使用第三种方法进行遍历，唯一区别是<mark style="background: transparent; color: yellow">遍历根节点的方法
</mark>

## 六、哈夫曼树和哈夫曼编码
### (1) 相关概念
1. **路径**： 一个节点到另一个节点的分支序列
2. **路径长度**：一个节点到另一个节点所经过的分支数目
3. 树的路径长度：从根节点到每个节点的路径长度之和
4. 节点的权： 我们在实际应用中，人们常常给数的每个节点赋予一个具有某种实际意义的实数，并称这个实数为**节点的权**, 记为$w_i$
5. **节点的带权路径长度**
$$w_i \times  l_i$$
6. **树的带权路径长度**
对于树中的每一个终端节点$k_i$, 有一个权值$w_i$与数中的节点对应，并取$l_i$为从根节点到叶节点的路径长度。
$$WPL  = \sum^{n}_{i=1} w_i \times l_i$$
### (2) 哈夫曼树
将给定权值和元素的节点，构造成一**颗外部通路带权树的路径长度最短的二叉树**，称为哈夫曼树。

![[Excalidraw/第六章 树和二叉树 2023-04-25 10.45.58|350]]
通过带权二叉树进行编码，可以通过此法进行数据压缩，在上图中，$c$的搜索权值最大，因此其路径长度最短， 从而达到较大的搜索效率

`````ad-summary
title: 哈夫曼树的创建方法
collapse: close
按照权值左边小右边大的方式，每一次**循环找最小的两个二叉树并且进行合并操作**， 并**将其根节点的权值记为两个节点的权值之和**，可以构造出如图的一颗二叉树

我们以下面的树的创建为例
![[Excalidraw/第六章 树和二叉树 2023-04-25 11.31.07|500]]
`````

使用数组方法进行存储对应的叶节点， 每一次 ，寻找parent为0的最小的两个节点，并建立一个根节点并建立一颗树

也有一种较好的存储结构是使用链表， 

```cpp 
#define MAXNODE 100
#define MAXNUM 50
// 哈夫曼树的定义方法 
typedef struct TreeNode{
	int weight;
	int parent,lchild, rchild;
}

typedef struct HuffmanTree{
	TreeNode* ht[MAXNODE]
}
```


输出每一个字符的编码：从字符向上进行倒序输出


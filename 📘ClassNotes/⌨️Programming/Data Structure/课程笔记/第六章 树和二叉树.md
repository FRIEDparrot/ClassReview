[[📘ClassNotes/⌨️Programming/Data Structure/课程笔记/基础知识/复习 树的基本知识|树的基本知识复习和基本的功能实现]]

树的定义: 使用递归的定义方法
树是一个集合。除空树外，每个树有一个根节点， 每个节点分为$m$个不想交的子集

森林是m (m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
```cpp 
typedef struct TreeNode{
	
}

class BinaryTree{
public: 
	TreeNode* root;
private: 
	
}
```


对于二叉树:
每个节点都有数据指针， <mark style="background: transparent; color: yellow">n-1个指针有用</mark>，对于m个指针的部分，往往不使用'

二叉树的性质：
n层满二叉树有$2^n-1$个节点
完全二叉树为

如果二叉树中最多只有最小面两层的节点度可以小于2，<mark style="background: transparent; color: yellow">且下面一层的叶节点都从左向右进行依次排布</mark>， 则称二叉树为**完全二叉树**，完全二叉树可以进行连续存储

可以使用: 左子树：$2 * n +1$ , 右子树：$2 * n +2$的寻址方式：
![[attachments/Pasted image 20230411114343.png|300]]

对于扩充二叉树， 

三叉链表的静态存储方法 : 
![[attachments/Pasted image 20230411115341.png|400]]


$DEB\rightarrow FC\rightarrow A$

二叉树的遍历

通过递归进行建立二叉树: 
给定先序的开始位置和 s 

$$A\rightarrow BC \rightarrow DEF$$
中序遍历的顺序为
$$ BC\rightarrow A\rightarrow DEF$$
显然后序是不变的， 找前序的长度只需

左子树开始位置为 + 1

`````ad-bug
`````

```cpp 
// 创建二叉树 

struct BTreeNode{
char data; 
BTreeNode *left, *right;
}

char s1 = {'A', 'B','C', 'D', 'E', 'F'}; // 先序序列部分
char s2 = {'B', 'C','A', 'F', 'E', 'D'}; // 中序序列部分

BTreeNode* create(BTreeNode* root,int start1, int start2, int length){
	char pre = s1[start2];
	// 其中Length为子树的长度
	if (length == 0){
		return nullptr;
	}
	else{// 首先建立根节点
		BTreeNode *t = new BTreeNode();
		t -> data = s1[start2]; // = pre
		// 先求解长度(计算), 在第二个序列中找
		int i = start1
		for (; h[i]!= pre; i++){
		}
		llength = i - start2; 
		rlength = length - llength -1
		// 建立左子树和右子树
		// start2 + 1是左子树的起始位置, 
		t -> left = create(start2+1, start1, start2, llength); // 整个树的长度为左树的长度
		t -> left = create(start2+len + 1, start2+len+1, rlength)
	}
}

int main(){
	struct BTreeNode* root;
	root = create(0,0, strlen(g));
}
```

如何考虑不建立二叉树而使用递归的方法直接输出后序遍历



```cpp 
int index;

void createTree(TreeNode* node){
	if (!p) return;
	index ++;
	createTree(node->left);
	createTree(node->right);
}
```

相同前序遍历序列的二叉树种类:
给定一个先序序列，根节点是一定的，
考虑每一个节点的分配： 向左分配和向右分配

<mark style="background: transparent; color: yellow">方法是左子树和右子树的分开方法</mark>

如前面两个是左子树，后面的是右子树 

线索二叉树(Threading binary Tree)

指向刚访问过的指针，
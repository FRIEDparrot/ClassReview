## ä¸€ã€äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ
### 1. æ ‘çš„åŸºæœ¬çŸ¥è¯†å’Œéå†æ–¹æ³•
[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/Data Structure/C++åŸºç¡€çŸ¥è¯†/å¤ä¹  æ ‘çš„åŸºæœ¬çŸ¥è¯†|æ ‘çš„åŸºæœ¬çŸ¥è¯†å¤ä¹ å’ŒåŸºæœ¬çš„åŠŸèƒ½å®ç°]]

æ ‘çš„å®šä¹‰: ä½¿ç”¨é€’å½’çš„å®šä¹‰æ–¹æ³•
==æ ‘æ˜¯ä¸€ä¸ªé›†åˆã€‚é™¤ç©ºæ ‘å¤–ï¼Œæ¯ä¸ªæ ‘æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œ æ¯ä¸ªèŠ‚ç‚¹åˆ†ä¸º$m$ä¸ªä¸æƒ³äº¤çš„å­é›†==
æ£®æ—æ˜¯m (m>=0)æ£µäº’ä¸ç›¸äº¤çš„æ ‘çš„é›†åˆã€‚å¯¹æ ‘ä¸­æ¯ä¸ªç»“ç‚¹è€Œè¨€ï¼Œå…¶å­æ ‘çš„é›†åˆå³ä¸ºæ£®æ—ã€‚
æ ‘çš„<mark style="background: transparent; color: yellow">åº¦ä¸ºå­æ ‘çš„ä¸ªæ•°</mark>ï¼Œ å¶èŠ‚ç‚¹å®šä¹‰ä¸º<mark style="background: transparent; color: yellow">åº¦ä¸º0çš„èŠ‚ç‚¹</mark>

### 2. äºŒå‰æ ‘åŠå…¶åŸºæœ¬å­˜å‚¨ç»“æ„
### (1) äºŒå‰æ ‘çš„å®šä¹‰å’Œæ€§è´¨
äºŒå‰æ ‘å®šä¹‰ï¼š**æ»¡è¶³ä¸‹åˆ—ä¸¤ä¸ªæ¡ä»¶çš„æ ‘ç»“æ„ç§°ä¸ºäºŒå‰æ ‘** 
1. æ¯ä¸ªèŠ‚ç‚¹çš„åº¦éƒ½ä¸å¤§äº2
2. æ¯ä¸ªèŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹æ¬¡åºä¸èƒ½ä»»æ„é¢ å€’

äºŒå‰æ ‘çš„æ€§è´¨ï¼š
1. nå±‚æ»¡äºŒå‰æ ‘æœ‰$2^n-1$ä¸ªèŠ‚ç‚¹ï¼Œ ç¬¬iå±‚æœ‰$2^{i-1}$ä¸ªèŠ‚ç‚¹
2. å¯¹ä»»ä½•ä¸€æ£µäºŒå‰æ ‘Tï¼Œå¦‚æœå…¶ç»ˆç«¯ç»“ç‚¹æ•°ä¸ºn0ï¼Œåº¦ä¸º2çš„ç»“ç‚¹æ•°ä¸º$n_2$ï¼Œåˆ™$n_0=n_2+1$ã€‚
3. å…·æœ‰nä¸ªç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„æ·±åº¦ä¸º$[\log_2 n]+1$ï¼Œå…¶ä¸­$[a]$è¡¨ç¤ºä¸å¤§äºçš„æœ€å¤§æ•´æ•°

å¦‚æœäºŒå‰æ ‘ä¸­æœ€å¤šåªæœ‰æœ€å°é¢ä¸¤å±‚çš„èŠ‚ç‚¹åº¦å¯ä»¥å°äº2ï¼Œ<mark style="background: transparent; color: yellow">ä¸”ä¸‹é¢ä¸€å±‚çš„å¶èŠ‚ç‚¹éƒ½ä»å·¦å‘å³è¿›è¡Œä¾æ¬¡æ’å¸ƒ</mark>ï¼Œ åˆ™ç§°äºŒå‰æ ‘ä¸º**å®Œå…¨äºŒå‰æ ‘**ï¼Œ<mark style="background: transparent; color: yellow">å®Œå…¨äºŒå‰æ ‘å¯ä»¥è¿›è¡Œè¿ç»­å­˜å‚¨ç»“æ„çš„æ’å¸ƒ
</mark>

äºŒå‰æ ‘æœ‰é¡ºåºå­˜å‚¨ç»“æ„å’Œé“¾å¼å­˜å‚¨ç»“æ„ä¸¤ç§åŸºæœ¬å­˜å‚¨ç»“æ„ï¼Œå™è¿°å¦‚ä¸‹

### (2) äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨ç»“æ„
å¯¹äºå®Œå…¨äºŒå‰æ ‘çš„å­˜å‚¨ï¼Œ å¯ä»¥ä½¿ç”¨é¡ºåºå­˜å‚¨çš„å­˜å‚¨ç»“æ„ï¼Œ å¦‚æœä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œå¯ä»¥è¡¥å…¨ç§°ä¸ºå®Œå…¨äºŒå‰æ ‘

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

å¯ä»¥ä½¿ç”¨: å·¦å­æ ‘ï¼š$2 * i +1$ , å³å­æ ‘ï¼š$2*i +2$çš„å¯»å€æ–¹å¼ï¼š
![[attachments/Pasted image 20230411114343.png|300]]

å¯¹äºå®Œå…¨äºŒå‰æ ‘ï¼Œå­˜å‚¨ä¸æµªè´¹ç©ºé—´ä¸”æ–¹ä¾¿ä½¿ç”¨ï¼Œä½†æ˜¯å¯¹äºä¸€èˆ¬äºŒå‰æ ‘ï¼Œéœ€è¦ä½¿ç”¨è™šèŠ‚ç‚¹å­˜å‚¨ï¼Œå¯èƒ½æœ€å¤šé€ æˆ$2^{k}-1$ä¸ªæŒ‡é’ˆå­˜å‚¨å•å…ƒçš„æµªè´¹(å…¶ä¸­äºŒå‰æ ‘æ·±åº¦ä¸º$k$)

### (3) äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æ„(å³æœ€å¹¿æ³›ä½¿ç”¨çš„äºŒå‰æ ‘ç»“æ„)
å¯¹äºäºŒå‰æ ‘çš„å®šä¹‰ï¼Œå¾€å¾€ä½¿ç”¨äºŒå‰é“¾è¡¨çš„ç»“æ„ï¼Œå¯ä»¥å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/Data Structure/C++åŸºç¡€çŸ¥è¯†/å¤ä¹  æ ‘çš„åŸºæœ¬çŸ¥è¯†#äºŒã€äºŒå‰æ ‘åŠå…¶åŸºæœ¬æ€§è´¨|äºŒå‰æ ‘çš„å®šä¹‰ä»¥åŠéå†æ–¹æ³•]]

æ­¤å¤„è®²è§£: 
**1. æ‰©å……äºŒå‰æ ‘**
å¯¹äºŒå‰æ ‘çš„â€æ‰©å……â€œæ“ä½œæ˜¯å°†åŸäºŒå‰æ ‘çš„æ¯ä¸€ä¸ªå­èŠ‚ç‚¹éƒ½å˜ä¸ºåº¦æ•°ä¸º2çš„åˆ†æ”¯èŠ‚ç‚¹ï¼Œè¿™æ ·æ‰©å……å¯¹ä¸€ä¸ªäºŒå‰æ ‘è€Œè¨€ï¼Œ æ‰©å……äºŒå‰æ ‘ä¸­ï¼Œæ–°å¢åŠ çš„éƒ½æ˜¯èŠ‚ç‚¹

è®¾åŸå…ˆçš„äºŒå‰æ ‘èŠ‚ç‚¹æ•°é‡ä¸º$n$, åˆ™å¯ä»¥æ€»ç»“å¾—å‡ºï¼Œåˆå§‹æ—¶"ç©ºä½"æœ‰ä¸¤ä¸ªï¼Œä¸”æ¯å¢åŠ ä¸€ä¸ªèŠ‚ç‚¹ï¼Œâ€œç©ºä½â€å¢åŠ ä¸€ä¸ªï¼Œå› æ­¤ä¼šæ–°äº§ç”Ÿ$n+1$ä¸ªèŠ‚ç‚¹(å˜ä¸º$2n+1$ä¸ª)ï¼Œ æ–°å¢åŠ çš„å¤–éƒ¨èŠ‚ç‚¹çš„ä¸ªæ•°æ¯”åŸæ¥çš„å†…éƒ¨èŠ‚ç‚¹çš„ä¸ªæ•°å¤š1
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-26 13.17.41|400]]

**2. ä¸‰å‰é“¾è¡¨çš„é™æ€å­˜å‚¨æ–¹æ³•** 

ä½¿ç”¨ä¸€ä¸ªè¾ƒå¤§çš„æ•°ç»„ï¼Œè®°å½•æ‰€æœ‰çš„èŠ‚ç‚¹ï¼ŒleftChild å’Œ rightChild
![[attachments/Pasted image 20230411115341.png|400]]

## äºŒã€ äºŒå‰æ ‘çš„åˆå§‹åŒ–
### (1) å­—ç¬¦ä¸²äºŒå‰æ ‘åˆå§‹åŒ–

`````ad-note
title: å­—ç¬¦ä¸²åˆå§‹åŒ–äºŒå‰æ ‘
collapse: close
ä½¿ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–äºŒå‰æ ‘çš„æ–¹æ³•ä¸»è¦æœ‰é€’å½’å‡½æ•°æ–¹æ³•å’Œæ ˆæ–¹æ³•
1. é€’å½’å‡½æ•°æ–¹æ³•
```cpp 
#include <iostream>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

void PreOrderTransverse(TreeNode* root) {
	if (!root) return;
	cout << root->data;
	PreOrderTransverse(root->left);
	PreOrderTransverse(root->right);
}

// ä½¿ç”¨é€’å½’æ³•å»ºç«‹äºŒå‰æ ‘, è¿™ä¸ªå¿…é¡»æœ‰è¿”å›å€¼ä¸ç„¶æŠ¥é”™
TreeNode* CreateTree(TreeNode* root) {
	char ch; bool run = true;
	while (run) // å¥—ä¸€ä¸ªå¾ªç¯, ä¸¤è¾¹éƒ½createä¹‹å
	{
		cin >> ch;
		if (ch == ' ') continue;
		else if (ch == ')' ||ch ==',') return root;
		// æœ€ç»ˆè¾¾åˆ°)æ—¶ï¼Œè¿”å›æ ˆ
		switch (ch) {
		case'(': // ç»§ç»­cin
			root->left = CreateTree(root->left); // createTreeä»¥,ä¸ºç»“æŸ
			// ä¸­é—´æœ‰ä¸€ä¸ªåˆ†éš”å· ','å› æ­¤ä»¥,ä¸ºå·¦ä¾§ç»“æŸç¬¦
			root->right = CreateTree(root->right);  // ä»¥)ä¸ºç»“æŸ
			break;
		default:
			TreeNode* L = new TreeNode(); // æ–°å»ºè¿™ä¸ªèŠ‚ç‚¹
			L->data = ch;
			root = L; // è¿™æ ·æ–°å»ºèŠ‚ç‚¹, è€Œä¸æ˜¯ç›´æ¥ç»™root åˆ†é…
			continue; // ç»§ç»­å¾ªç¯
		}
	};
}
// ç”±äºåŸç†æ˜¯cinåˆ°æœ€åä¸€ä¸ªæ ‡å¿—åè¿”å›ï¼Œå¯¼è‡´æ— æ³•åœæ­¢ï¼Œæ‰€ä»¥æœ‰å¿…è¦ç¬¬ä¸€ä¸ªå•ç‹¬æåœæ­¢

TreeNode* CreateBinaryTree(TreeNode* root) {
	cin >> root->data;
	char a;
	cin >> a; // (
	root->left=CreateTree(root->left);  // ä¸­é—´é€—å·è‡ªåŠ¨cin
	root->right=CreateTree(root->right);
	return root;
}

int main() {
	TreeNode* tree = new TreeNode();
	tree = CreateBinaryTree(tree); // è°ƒç”¨é€’å½’å‡½æ•°ï¼Œåˆ›å»ºèŠ‚ç‚¹

	PreOrderTransverse(tree);
	return 0;
}

/* Test Input
A(B(#,D),C(E(#,F),#))
*/
```

2. ä½¿ç”¨æ ˆçš„åˆå§‹åŒ–æ–¹æ³•
å…¶ä¸­éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨æ ˆæ—¶éœ€è¦å…ˆå°†æ ˆé¡¶å…ƒç´ åˆå§‹åŒ–ä¹‹åå†å¯¹å…ƒç´ è¿›è¡Œèµ‹å€¼

```cpp 
#include <iostream>
#include <stack>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

void PreOrderTransverse(TreeNode* root) {
	if (!root) return;
	cout << root->data;
	PreOrderTransverse(root->left);
	PreOrderTransverse(root->right);
}

// ä½¿ç”¨æ ˆçš„æ–¹æ³•å»ºç«‹äºŒå‰æ ‘
void CreateTree(TreeNode* root, string str) {
	stack<TreeNode*> stk;
	stk.push(root); // æ”¾å…¥æ ¹èŠ‚ç‚¹
	for (char ch: str) {
		// å¾€å¾€é€šè¿‡æ ˆæ»¡å’Œæ ˆç©ºåˆ¤æ–­ç»ˆæ­¢æ¡ä»¶
		switch (ch) {
		case ')':
			stk.pop();
			break;
		case '(':
			stk.top()->left = new TreeNode(); // ä¸ºäº†é˜²æ­¢è¿”å›æ—¶è¦†ç›–, è¿™é‡Œéœ€è¦æ³¨æ„
			stk.push(stk.top()->left);
			break;
		case ',':
			stk.pop();
			stk.top()->right = new TreeNode();
			stk.push(stk.top()->right); // æ¢ä¸ºå³èŠ‚ç‚¹
			break;
		default:
			stk.top()->data = ch;  
			// æ³¨æ„ä½¿ç”¨è¿™æ ·çš„æ–¹æ³•ä¸ºå…¶èµ‹å€¼, ä¸è¦ä½¿ç”¨ p = L ,å› ä¸ºè¿™æ ·ä¼šé‡æŒ‡
		}
	}
}
// ç”±äºåŸç†æ˜¯cinåˆ°æœ€åä¸€ä¸ªæ ‡å¿—åè¿”å›ï¼Œå¯¼è‡´æ— æ³•åœæ­¢ï¼Œæ‰€ä»¥æœ‰å¿…è¦ç¬¬ä¸€ä¸ªå•ç‹¬æåœæ­¢

int main() {
	TreeNode* tree = new TreeNode();
	string str;
	getline(cin, str);
	CreateTree(tree, str); // è°ƒç”¨é€’å½’å‡½æ•°ï¼Œåˆ›å»ºèŠ‚ç‚¹
	PreOrderTransverse(tree);
	return 0;
}

/* Test Input
A(B(#,D),C(E(#,F),#))
*/
```

`````

### (2) äºŒå‰æ ‘çš„æ‰©å±•å…ˆåºéå†åºåˆ—åˆ›å»º

æœ€ç®€å•çš„æ–¹æ³•æ˜¯å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡è®°å½•ä¸‹æ ‡

```cpp 
// å…¨å±€å˜é‡å®šä¹‰åˆ›å»ºä¸‹æ ‡(ä»…åˆ›å»ºä¸€æ¬¡)
int create_index = 0;

// ä½¿ç”¨æ‰©å±•äºŒå‰åºåˆ—åˆ›å»ºäºŒå‰æ ‘
TreeNode* create_tree(const vector<char> vec)
{
	TreeNode* node = nullptr;
	if (vec[create_index]!= '#')
	{
		node = new TreeNode();
		node->data = vec[create_index];
		create_index++; // è¿›è¡Œè‡ªå¢
		node->left = create_tree(vec);
		node->right = create_tree(vec);
	}
	else{
		create_index++;
	}
	return node;
}

int main() {
	const vector<char> vec{ 'a','b','#','#','c', '#','d','#','#'};
	TreeNode* root = create_tree(vec);
}
```

`````ad-note
title:åºåˆ—äºŒå‰æ ‘çš„åˆå§‹åŒ–é€’å½’ä»£ç 
collapse: close

å¯ä»¥ä½¿ç”¨å…ˆåºéå†åºåˆ—ABD##EH###CF#I##G##ç±»ä¼¼çš„ä»£ç æ¥åˆå§‹åŒ–äºŒå‰æ ‘ï¼Œä»£ç å¦‚ä¸‹

```cpp 
TreeNode* CreateTree() {
	char ch;
	cin >> ch;
	TreeNode* root = nullptr;  
	// äº‹å…ˆåˆå§‹åŒ–èŠ‚ç‚¹
	if (ch != '#') { // ç©ºèŠ‚ç‚¹
		root = new TreeNode();
		root->data = ch;
		root->left = CreateTree();
		root->right = CreateTree();
	}
	return root;
}
```
`````

### (3) å‰åºåºåˆ—å’Œä¸­åºåºåˆ—å»ºç«‹äºŒå‰æ ‘
<mark style="background: transparent; color: yellow">æ–¹æ³•æ˜¯å·¦å­æ ‘å’Œå³å­æ ‘çš„åˆ†å¼€æ–¹æ³•</mark>
æˆ‘ä»¬ä»¥ä¸‹é¢çš„äºŒå‰æ ‘ä¸ºä¾‹
![[attachments/Pasted image 20230419213434.png|350]]
åˆ™å…¶å…ˆåºåºåˆ—å’Œä¸­åºåºåˆ—åˆ†åˆ«ä¸ºï¼š
![[attachments/Pasted image 20230419213600.png|450]]
åˆ©ç”¨ä¸‹å›¾ä¸­çš„ç‰¹ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å‡ºä¸€ä¸ªé€šè¿‡å‰åºéå†å’Œä¸­åºéå†åºåˆ—æ„å»ºäºŒå‰æ ‘çš„è¿‡ç¨‹:
æ¯ä¸€æ¬¡è®¡ç®—å¥½ä¸åŒåŒºé—´çš„startæ¥å»ºç«‹åºåˆ—ï¼Œ å¹¶å–midåºåˆ—$A$å·¦è¾¹çš„éƒ¨åˆ†ä¸ºå·¦å­æ ‘åºåˆ—ï¼Œå³è¾¹çš„éƒ¨åˆ†ä¸ºå³å­æ ‘åºåˆ—ï¼Œå¹¶æ¯ä¸€æ¬¡å–startä¸ºæ ¹èŠ‚ç‚¹å³å¯
![[attachments/Pasted image 20230419231836.png|650]]

````ad-note
title: ç»™å‡ºå…ˆåºå’Œä¸­åºåºåˆ—åˆ›å»ºäºŒå‰æ ‘çš„ä»£ç 
collapse: close

ä¸‹é¢çš„ä»£ç æ¯ä¸€æ¬¡æ˜¯å–å…¶ä¸­çš„å·¦å­æ ‘åºåˆ—å’Œå³å­æ ‘åºåˆ—ï¼Œå¹¶ä¸”è®°å½•å®ƒä»¬çš„ä¸¤ä¸ªä¸åŒçš„startå€¼ï¼Œ
```cpp 
#include <iostream>
#include <vector>
#include <stack>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

// ååºéå†è¾“å‡º
void dfs(TreeNode* root) {
	if (!root) return;
	dfs(root->left);
	dfs(root->right);
	cout << root->data;
}

vector<DataType> pre;
vector<DataType> mid;

// ä½¿ç”¨ä¸¤ä¸ªå‘é‡è¿›è¡Œå»ºç«‹, gen_arræ˜¯ç”¨æ¥ç”Ÿæˆå¯¹åº”å­æ ‘çš„å‘é‡(åŒ…å«æ ¹èŠ‚ç‚¹)
TreeNode* CreateTree(int start, int end, vector<DataType> gen_arr) {
	TreeNode* root = new TreeNode();
	root->data = pre[start];   // è®¾ç½®è¿™ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹
	DataType temp = root->data;
	vector<DataType> vector1; // ç”¨æ¥åˆ›å»ºå·¦å­æ ‘çš„vector
	vector<DataType> vector2; // ç”¨äºåˆ›å»ºå³å­æ ‘
	
	int i = 0;
	// æ„å»ºå·¦å­æ ‘åºåˆ—, åœ¨gen_arrçš„tempå·¦ä¾§ä¸ºå¯¹åº”çš„å…ƒç´ 
	for (; gen_arr[i] != temp; i++) vector1.push_back(gen_arr[i]);
	// å³å­æ ‘åºåˆ—, tempå³ä¾§çš„å…ƒç´ 
	for (i++; i < gen_arr.size(); i++) vector2.push_back(gen_arr[i]);
	if (!vector1.empty()) root->left = CreateTree(start + 1, start + vector1.size(), vector1);
	if (!vector2.empty()) root->right = CreateTree(start + vector1.size() + 1,start + vector1.size() + vector2.size(), vector2);
	return root;
}

int main() {
	string input;
	getline(cin, input);
	for (char ch : input) pre.push_back(ch);
	getline(cin, input);
	for (char ch : input) mid.push_back(ch);
	// åˆå§‹åŒ–å…ˆåºå’Œä¸­åºéå†å‘é‡
	TreeNode* root = CreateTree(0, pre.size()-1, mid); 
	// åˆå§‹è®¾ç½®midæ•´ä¸ªä¸ºgen_arr
	dfs(root);
	return 0;
}

/* Test Input
ABDFGCEH
BFDGACEH

** result *** 
FGDBHECA  // ååºéå†ç»“æœ
*/

```

````

`````ad-faq
title: å¦‚ä½•è€ƒè™‘ä¸å»ºç«‹äºŒå‰æ ‘è€Œä½¿ç”¨é€’å½’çš„æ–¹æ³•ç›´æ¥è¾“å‡ºååºéå†
collapse: open
`````

`````ad-tip
title: è¯´æ˜
collapse: open

æ ¹æ®ç»™å®šçš„éå†åºåˆ—èƒ½å¦ç¡®å®šäºŒå‰æ ‘çš„ç»„åˆæƒ…å†µ

![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-05-01 10.22.53|500]]

| éå†åºåˆ—   | èƒ½å¦å”¯ä¸€ç¡®å®š |
| ---------- | ------------ |
| å…ˆåº,ä¸­åº  | èƒ½           |
| ä¸­åº,ååº  | èƒ½           |
| å…ˆåº, ååº | ä¸èƒ½         |

`````

## ä¸‰ã€äºŒå‰æ ‘çš„åŸºæœ¬æ“ä½œ
### (1) è¡¨è¾¾å¼çš„äºŒå‰æ ‘ç»“æ„
å¯¹äºä¸‹å›¾çš„è¡¨è¾¾å¼å­˜å‚¨ï¼š 
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-20 10.38.47|300]]
å…¶å‰åºéå†ï¼š$-+a*bc/dc$
ä¸­åºéå†: $a+ b*c - d/c$ (å³çœŸå®è¡¨è¾¾å¼)
ååºéå†: $abc*+ dc/-$ (å³é€†æ³¢å…°è¡¨è¾¾å¼)
```cpp 
typedef struct ParTreeNode{
	DataType info; 
	int parent;
};
typedef struct ParTree{
	ParTreeNode nodelist[MAXNUM];
	int n;
};
```

### (2) åˆ†æ²»ç®—æ³•æ±‚è§£äºŒå‰æ ‘çš„é«˜åº¦
å¯ä»¥ä½¿ç”¨æå…¶ç®€å•çš„ç®—æ³•æ±‚è§£äºŒå‰æ ‘é«˜åº¦
```cpp 
int depth(TreeNode* root)
{
	if (!root) return 0;
	return max(depth(root->left), depth(root->right)) + 1;
}
```

### (3) äºŒå‰æ ‘çš„æ¨ªå‘å›¾å½¢æ˜¾ç¤º
é¦–å…ˆè¾“å‡ºé¡ºåºæ˜¯é€†ä¸­åºè¾“å‡º
åªéœ€è¦åœ¨é€’å½’çš„å‡½æ•°ä¸­å¤šå®šä¹‰ä¸€ä¸ªlayerå‚æ•°ç„¶åè¾“å‡ºç©ºæ ¼å³å¯
```cpp 
// é€†ä¸­åºéå†æ–¹æ³•è¾“å‡º
void print_tree(TreeNode* root, int layer)
{
	if (!root) return;
	print_tree(root->right, layer + 1);
	for (int i = 0; i < layer; i++) cout << " ";
	cout << root->data << endl;
	print_tree(root->left, layer + 1);
}
```


## å››ã€äºŒå‰æ ‘çš„çº¿ç´¢åŒ–(Threading)
### (1) çº¿ç´¢åŒ–çš„æ¦‚å¿µå’Œåˆ›å»º
äºŒå‰æ ‘çš„çº¿ç´¢åŒ–æ˜¯é€šè¿‡äºŒå‰æ ‘çº¿ç´¢æ–¹æ³•å°†äºŒå‰æ ‘èŠ‚ç‚¹æŒ‰ç…§ä¸€å®šçš„è§„å¾‹çº¿æ€§åŒ–çš„è¿‡ç¨‹ï¼Œ å½“æˆ‘ä»¬ä»¥äºŒå‰é“¾è¡¨ä¸ºå­˜å‚¨ç»“æ„æ˜¯ï¼Œä¸å¯èƒ½ç›´æ¥å¾—åˆ°<mark style="background: transparent; color: yellow">èŠ‚ç‚¹åœ¨éå†åºåˆ—ä¸­çš„å‰é©±å’Œåç»§ä¿¡æ¯</mark>ã€‚

è¾ƒå¥½çš„æ–¹æ³•æ˜¯åˆ©ç”¨é“¾è¡¨ä¸­åŸæœ‰çš„ç©ºé“¾åŸŸå°†éå†è¿‡ç¨‹çš„å‰é©±å’Œåç»§ä¿¡æ¯è¿›è¡Œä¿å­˜

æˆ‘ä»¬å¯ä»¥ä»˜å‡ºä¸€å®šçš„ç©ºé—´ä»£ä»·ï¼Œå®šä¹‰ä¸€ä¸ªltagå’Œä¸€ä¸ªrtagï¼Œ è¡¨ç¤ºè¿™ä¸ªæŒ‡é’ˆçš„å·¦å³èŠ‚ç‚¹æ˜¯å¦è¢«åˆ©ç”¨
ä¸‹å›¾è¡¨ç¤ºäº†å‰åºçº¿ç´¢åŒ–å’Œä¸­åºçº¿ç´¢åŒ–ä¸€æ£µæ ‘çš„ç»“æ„

![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-26 14.59.06|500]]
åœ¨äºŒå‰æ ‘çš„çº¿ç´¢åŒ–ä¸­ï¼Œæˆ‘ä»¬è®°å½•ä¸€ä¸ªæŒ‡å‘åˆšè®¿é—®è¿‡çš„æŒ‡é’ˆpre
çº¿ç´¢äºŒå‰æ ‘(Threading binary Tree)

è¿›è¡Œä¸­åºäºŒå‰çº¿ç´¢åŒ–çš„æ ¸å¿ƒä»£ç ä¸ºï¼š 
```cpp
TreeNode* pre = nullptr;
void thread_tree(TreeNode* root)
{
	if (!root) return;
	// å…ˆè®¿é—®å·¦æ ‘
	thread_tree(root->left);
	if (pre && !pre->right)
	{
		pre->right = root;
		pre->right_tag = true;
	}
	if (!root -> left)
	{
		root->left = pre;
		root->left_tag = true;
	}
	pre = root;
	thread_tree(root->right);
}
```

`````ad-note
title: äºŒå‰æ ‘çš„ä¸­åºçº¿ç´¢åŒ–çš„ä»£ç å®ç°
collapse: close

ä¸‹åˆ—ä»£ç æ¼”ç¤ºäº†äºŒå‰æ ‘çš„å‰åºå»ºç«‹å’Œä¸­åºçº¿ç´¢åŒ–ï¼Œç¤ºä¾‹è¾“å…¥ä¸­çš„æ ‘ç»“æ„ä¸º

![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-19 15.49.59|250]]

å…¶ä¸­ä½¿ç”¨å‘å³æœç´¢éå†ä¸‹ä¸€ä¸ªä¸­åºèŠ‚ç‚¹çš„æ–¹æ³•å°†äºŒå‰æ ‘è¿›è¡Œäº†ä¸­åºè¾“å‡º

```cpp 
// äºŒå‰æ ‘ä¸­åºçº¿ç´¢åŒ–çš„å»ºç«‹ä»£ç 
#include <iostream>
using namespace std;

typedef char DataType;

// äºŒå‰æ ‘èŠ‚ç‚¹å®šä¹‰
typedef struct TreeNode {
    DataType data;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
    bool ltag = false, rtag = false;
    // å·¦å³çš„æ ‡ç­¾
};

// å…ˆåºå»ºç«‹äºŒå‰æ ‘
TreeNode* CreateTree() {
    char ch;
    TreeNode* p = nullptr;
    cin >> ch;
    // é™¤äº†ä½¿ç”¨if_else;
    if (ch != '#'){
        p = new TreeNode();   // å…ˆåºå»ºç«‹æ ‘çš„èŠ‚ç‚¹
        p->data = ch;
        p->left = CreateTree();
        p->right = CreateTree();
    }
    return p;   // æ³¨æ„å•å‡ºå£å‡½æ•°ï¼Œå¦‚æœå¤šå‡ºå£æœ‰å¯èƒ½é—æ¼è€ŒæŠ¥é”™
}

// å…¨å±€å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆlast,æŒ‡å‘åˆšåˆšè®¿é—®è¿‡çš„èŠ‚ç‚¹
TreeNode* last = nullptr; 

/*ä¸­åºçº¿ç´¢åŒ–*/
void ThreadTree(TreeNode* root) {
    // ä¸­åºéå†ä¸€æ¬¡
    if (root) {
        // ä½¿ç”¨å·¦èŠ‚ç‚¹ï¼Œæ¥ä¸Šä¸Šä¸€ä¸ªè®¿é—®çš„å…ƒç´ 
        ThreadTree(root->left);

        //å¤„ç†å½“å‰èŠ‚ç‚¹
        // å‘å‰æ¥ä¸Š
        // å‘å‰æ¥ä¸Š
        if (!root->left) {
            root->ltag = true; // å·¦èŠ‚ç‚¹è¢«åˆ©ç”¨
            root->left = last; // rightæŒ‡å‘ä¸‹ä¸€ä¸ªè®¿é—®çš„å…ƒç´ 
        }

        if (last && !last->right) {
            last->rtag = true;  // æ ‡å¿—è¿™ä¸ªèŠ‚ç‚¹çš„å³èŠ‚ç‚¹åŸå…ˆæ˜¯ç©ºèŠ‚ç‚¹ï¼Œç°åœ¨è¢«åˆ©ç”¨
            // æ³¨æ„æ˜¯lastçš„rtag
            last->right = root; // lastæŒ‡å‘å‰ä¸€ä¸ªè®¿é—®çš„å…ƒç´ 
        }

        last = root;  // å°†ä¸Šä¸€ä¸ªèŠ‚ç‚¹è®¾ç½®ä¸ºæ ¹èŠ‚ç‚¹ 

        ThreadTree(root->right);
    }
}

/*ä¸­åºéå†å‡½æ•°*/ 
void MidOrderTransverse(TreeNode* root) {
    TreeNode* p = root;
    if (!p) return;
    while (p->left) {
        p = p->left;
    } // æ‰¾åˆ°ä¸­åºéå†çš„å¤´ç»“ç‚¹
    // è¿›è¡Œä¸­åºéå†
    while (p!= nullptr) {
        // å…ˆè¾“å‡ºæœ¬èº«
        cout << p->data;
        if (p->rtag) { // true
            p = p->right;
        }// rtag == 1 æ—¶ï¼Œç›´æ¥ä½¿ç”¨rightä½œä¸ºåç»§èŠ‚ç‚¹
        else { // å…ˆæ‰¾åˆ°å³å­æ ‘, å†æœç´¢å³å­æ ‘çš„æœ€å·¦ä¸‹èŠ‚ç‚¹
            p = p->right;
            while (p && p->left && p->ltag == false) p = p->left;
            // æœ€ç»ˆåˆ°è¾¾æœ€å·¦ä¸‹çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³ä¸ºä¸‹ä¸€ä¸ªè®¿é—®çš„èŠ‚ç‚¹
        }
    }
}

int main()
{
    TreeNode* root; 
    root = CreateTree(); // å…ˆåºå»ºç«‹
    ThreadTree(root); // ä½¿ç”¨æ‰©å……äºŒå‰æ ‘è¿›è¡Œä¸­åºçº¿ç´¢åŒ–
    last->right = nullptr;
    MidOrderTransverse(root);
}
/* Test Code: 
ABD###CE##F##
*/
```

`````

### (2) çº¿ç´¢åŒ–çš„å‰é©±å’Œåç»§èŠ‚ç‚¹æŸ¥æ‰¾æ–¹æ³•

å¯¹äºå‰é©±èŠ‚ç‚¹çš„æŸ¥æ‰¾ï¼Œå¦‚æœ`left_tag = true`, åˆ™å‰é©±èŠ‚ç‚¹è®°ä¸ºå·¦èŠ‚ç‚¹`left->tag` ï¼Œå¦åˆ™å…¶å‰é©±æ˜¯å…¶<mark style="background: transparent; color: yellow">å·¦å­æ ‘çš„å³ä¸‹ç«¯èŠ‚ç‚¹</mark>
```cpp 
// æŸ¥æ‰¾ä¸­åºå‰é©±èŠ‚ç‚¹
TreeNode* pre_find(const TreeNode* root)
{
	if (!root || !root->left) return nullptr;
	if (root->left_tag) return root->left;
	TreeNode* p = root->left;
	while (p->right != nullptr && !p->right_tag)
		p = p->right;
	return p;
}
```

åç»§èŠ‚ç‚¹æŸ¥æ‰¾æ—¶ï¼Œå¦‚æœ`right_tag = true` åˆ™åç»§èŠ‚ç‚¹ä¸ºå³èŠ‚ç‚¹ï¼Œå¦åˆ™ä¸º<mark style="background: transparent; color: yellow">å³å­æ ‘çš„å·¦ä¸‹ç«¯èŠ‚ç‚¹</mark>
```cpp 
TreeNode* next_find(const TreeNode* root)
{
	if (!root || !root->right) return nullptr;
	if (root->right_tag) return root->right;
	TreeNode* p = root->right;
	while (p->left != nullptr && !p->left_tag)
		p = p->left;
	return p;
}
```

å¯¹äºçº¿ç´¢åŒ–äºŒå‰æ ‘éå†ï¼Œé¦–å…ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„æœ€å·¦ä¸‹èŠ‚ç‚¹ç„¶åå¼€å§‹éå†å³å¯(ç”±äºèŠ‚ç‚¹ä¿®æ”¹ï¼Œä¸èƒ½ä½¿ç”¨åŸå…ˆéå†æ–¹æ³•)
```cpp 
// æ›´ç®€æ´çš„éå†çº¿ç´¢æ ‘æ–¹æ³•
void mid_travel(TreeNode* root) {
    while (root->left) {
        root = root->left;
    }
    for (TreeNode* p = root; p ; p = next_find(p)) {
        cout << p->data << " ";
    }
}
```

### (3) ä¸¤ç§éœ€è¦ä½¿ç”¨ä¸‰å‰é“¾è¡¨çš„æƒ…å†µ
![[attachments/Pasted image 20230426155327.png|400]]
![[attachments/Pasted image 20230426155351.png|400]]

## äº”ã€æ ‘å’Œæ£®æ—çš„è¡¨ç¤º
### 1. æ ‘çš„è¡¨ç¤º
#### (1) åŒäº²èŠ‚ç‚¹çš„è¡¨ç¤ºæ–¹æ³•
å¯ä»¥ä½¿ç”¨åŒäº²è¡¨ç¤ºæ³•è¿›è¡Œåˆå¹¶
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-20 10.47.16|250]]
ä¸¤æ¬¡æŸ¥æ‰¾ï¼Œ å¹¶è¿›è¡Œä¸€æ¬¡èµ‹å€¼ï¼Œä¸ºäº†å‡å°æŸ¥æ‰¾çš„æ·±åº¦ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨åŒäº²èŠ‚ç‚¹è¡¨ç¤ºï¼Œå­˜å‚¨åŒäº²èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯æ ¹èŠ‚ç‚¹åˆ™è®¾ç½®ä¸º-1

ä¸‹é¢ç»™å‡ºä¸€ç§**åŒäº²èŠ‚ç‚¹æ–¹æ³•çš„èŠ‚ç‚¹ç±»å‹å®šä¹‰**
```cpp 
typedef struct ParTreeNode{
	DataType data;
	int parent; // è¡¨ç¤ºiå·èŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹
}
typedefÂ  struct ParTree{
Â  ParTreeNodeÂ  nodelist[MAXNUM];
Â  intÂ  n;
}ParTree, *PParTree;
```

==åœ¨è¿™ç§è¡¨ç¤ºä¸­ï¼Œå®¹æ˜“æ‰¾åˆ°çˆ¶ç»“ç‚¹åŠå…¶æ‰€æœ‰çš„ç¥–å…ˆï¼›ä¹Ÿèƒ½æ‰¾åˆ°ç»“ç‚¹çš„å­å¥³å’Œå…„å¼Ÿï¼ˆè™½ç„¶æ¯”è¾ƒéº»çƒ¦ï¼‰ã€‚ä½†å®ƒæ²¡æœ‰è¡¨ç¤ºå‡ºç»“ç‚¹ä¹‹é—´çš„å·¦å³æ¬¡åºï¼Œæ‰€ä»¥æ— æ³•æ±‚æ ‘ä¸­æŸä¸ªæŒ‡å®šç»“ç‚¹çš„æœ€å·¦å­ç»“ç‚¹å’Œå³å…„å¼Ÿç»“ç‚¹ç­‰åŸºæœ¬è¿ç®—ã€‚==

æ”¹è¿›æ–¹æ³•æ˜¯æŒ‰ä¸€ç§éå†æ¬¡åº**åœ¨æ•°ç»„ä¸­å­˜æ”¾ç»“ç‚¹**ã€‚å…¶ä¸­è¾ƒå¸¸è§çš„ä¸€ç§æ–¹æ³•æ˜¯<mark style="background: transparent; color: yellow">ä¾æ¬¡å­˜æ”¾æ ‘çš„å…ˆæ ¹åºåˆ—</mark>ï¼Œå¦‚å›¾ï¼š
![[attachments/Pasted image 20230426155759.png|400]]

`````ad-note
title: åŒäº²èŠ‚ç‚¹è¡¨ç¤ºæ–¹æ³•åˆå§‹åŒ–ç¤ºä¾‹
collapse: close
```cpp 
#include <iostream>
#include <vector>
#define MAXSIZE 100  // NOLINT(modernize-macro-to-enum)
using namespace std;

typedef char DataType;

// ä½¿ç”¨çˆ¶èŠ‚ç‚¹è¡¨ç¤ºçš„äºŒå‰æ ‘èŠ‚ç‚¹
typedef struct TreeNode {
    DataType data = '\0';
    int parent = 0;   // å­˜å‚¨çˆ¶èŠ‚ç‚¹çš„ä¸‹æ ‡
};

// å»ºç«‹äºŒå‰æ ‘
struct binary_tree
{
    TreeNode node[MAXSIZE];
    int size;
};

// ä½¿ç”¨æ•°ç»„æ–¹æ³•å»ºç«‹äºŒå‰æ ‘, å³0,1,2 å‘ä¸‹è¿›è¡Œæ’åº
binary_tree* create_tree(vector<DataType> vec)
{
    binary_tree* tree = new binary_tree();  // åˆå§‹åŒ–æ ‘
    tree->size = vec.size();
    for (int i = 0; i < vec.size(); i++)
    {
        tree->node[i].data = vec[i];
        tree->node[i].parent = i == 0? -1: (i - 1) / 2;
    }
    return tree;
}

// å°½é‡å…¨éƒ¨ä½¿ç”¨
void show_tree(binary_tree* tree)
{
    for (int i = 0; i< tree->size; i++)
    {
        cout << i << " " << tree->node[i].data << " " << tree->node[i].parent << endl;
    }
}

int main()
{
    vector<DataType> vec{'A', 'B', 'C', 'D', 'E', 'F', 'G'};
    binary_tree* new_tree = create_tree(vec);
    show_tree(new_tree);
    return 0;
}
```
`````

#### (2) å­è¡¨çš„è¡¨ç¤ºæ–¹æ³•
å¯ä»¥ä½¿ç”¨å­èŠ‚ç‚¹é“¾è¡¨çš„æ–¹æ³•ï¼Œ
```cpp 
typedef struct EdgeNode{  /*å­—è¡¨ä¸­çš„èŠ‚ç‚¹çš„ç»“æ„*/
	int node_position;
	struct EdgeNode* link;  // æŒ‡å‘ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹èŠ‚ç‚¹
};
typedef struct TreeNode{
	// ç¬¬äºŒä¸ªç»“æ„ä½“çš„å®šä¹‰
	/*ç»“ç‚¹è¡¨ä¸­çš„èŠ‚ç‚¹ç»“æ„*/
	DataType data;
	struct EdgeNode* children; // åˆå§‹åŒ–ç¬¬ä¸€ä¸ªå­è¡¨èŠ‚ç‚¹
};
typedef struct ChiTree{ 
	/*æ•´ä¸ªæ ‘ç»“æ„çš„æ•°ç»„*/
	TreeNode* node_list[MAXNUM]; // å­˜å‚¨èŠ‚ç‚¹
	int root; // æ ¹èŠ‚ç‚¹åœ¨çº¿æ€§è¡¨ä¸­çš„ä½ç½®
	int num;  // å­˜å‚¨æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
};
```

å…¶ä¸‰ä¸ªç»“æ„ä½“çš„å®šä¹‰çš„å›¾ç¤ºå¦‚ä¸‹ï¼š 
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-20 11.12.27|600]]

å¦‚ä½•å»ºç«‹ä¸Šå›¾çš„å­˜å‚¨ç»“æ„ï¼š
ä½¿ç”¨ $p$-> å³ä¾§å…ƒç´ ä¹‹åå¾ªç¯å®ç°(æ³¨æ„ä¸èƒ½ä»på¼€å§‹ï¼Œç”±äºèŠ‚ç‚¹ç±»å‹ä¸åŒ)

`````ad-note
title: äºŒå‰æ ‘çš„å­è¡¨è¡¨ç¤ºæ–¹æ³•ä»£ç å®ç°
collapse: close

```cpp 
#include <iostream>
#include <vector>
#define MAXSIZE 100  // NOLINT(modernize-macro-to-enum)
using namespace std;

typedef char DataType;

struct TreeNode
{
    int index;
    TreeNode* next;
};

// ä½¿ç”¨å­èŠ‚ç‚¹é“¾è¡¨è¡¨æ–¹æ³•è¡¨ç¤ºçš„æ ‘çš„ç»“æ„
struct EdgeNode
{
    DataType data;
    TreeNode* first_child = nullptr;
};

struct binary_tree
{
    EdgeNode nodes[MAXSIZE];
    int size;
};

// åœ¨å»ºç«‹å­è¡¨æ—¶ï¼Œé¦–æ¬¡éœ€è¦ä½¿ç”¨
void create_edge(binary_tree* tree, int edge_index)
{
    int size = tree->size;
    // æœ€å¤šæœ‰ä¸¤ä¸ªå­è¡¨
    int left_index = 2 * edge_index + 1;
    int right_index = 2 * edge_index + 2;
    if (left_index >= size) return;
    TreeNode* left_node = new TreeNode();
    left_node->index = left_index;
    tree->nodes[edge_index].first_child = left_node;

    if (left_index + 1 >= size) return;
    TreeNode* right_node = new TreeNode();
    right_node->index = left_index + 1;
    left_node->next = right_node;
}

void show_tree(binary_tree* tree)
{
    for (int i = 0; i < tree->size; i++)
    {
        cout << i << " " << tree->nodes[i].data << " ";
        TreeNode* p = tree->nodes[i].first_child;
        while (p)
        {
            cout << p->index << " ";
            p = p->next;
        }
        cout << endl;
    }
}

binary_tree* create_tree(vector<DataType> vec)
{
    binary_tree* tree = new binary_tree();
    tree->size = vec.size();

    for (int i = 0; i < vec.size(); i++)
    {
        EdgeNode edge;
        edge.data = vec[i];
        tree->nodes[i] = edge;
        create_edge(tree, i);
    }
    return tree; 
}

int main()
{
    vector<DataType> vec{'A', 'B', 'C','D','E','F','G', 'H'};
    binary_tree* tree = create_tree(vec);
    show_tree(tree);
    return 0;
}
```

`````

`````ad-check
title: è¾ƒæœ‰æŒ‘æˆ˜æ€§çš„åˆ›å»ºæ–¹æ³•
collapse: open
é¦–å…ˆä½¿ç”¨å¸¦æ‹¬å·çš„è¡¨è¾¾å¼é€’å½’æ–¹æ³•, åˆ›å»ºå®Œå…¨äºŒå‰æ ‘ï¼Œå†æ ¹æ®äºŒå‰æ ‘çš„å…ˆæ ¹éå†åºåˆ—åˆ›å»ºå­è¡¨ï¼Œåˆ›å»ºæ—¶åªéœ€è¦æ¯ä¸€æ¬¡åˆ¤æ–­å¯¹åº”çš„ä¸‹æ ‡å³å¯ã€‚
`````

#### (3) å·¦å­æ ‘å’Œsiblingçš„è¡¨ç¤ºæ–¹æ³•

```cpp 
typedefÂ  struct CSNode{
Â  DataTypeÂ  info;
Â  struct CSNodeÂ  *lchild;
Â  struct CSNodeÂ  *rsibling;
};
```
ç»“æ„å¦‚å›¾
![[attachments/Pasted image 20230420113745.png|200]]
åˆ›å»ºæ–¹æ³•ç±»ä¼¼äºç›´æ¥åˆ›å»ºäºŒå‰æ ‘ï¼Œä¸è¯¦ç»†è®²

### 2. æ£®æ—çš„è¡¨ç¤º
#### (1) åŒäº²è¡¨ç¤ºæ–¹æ³•
parent = -1ä¸ºæ ¹èŠ‚ç‚¹
è¡¨ç¤ºæ–¹æ³•å¦‚ä¸‹å›¾
![[attachments/Pasted image 20230420113348.png|400]]

#### (2) å­è¡¨è¡¨ç¤ºæ–¹æ³•
å­—è¡¨çš„è¡¨ç¤ºæ–¹æ³•åœ¨æ£®æ—è¡¨ç¤ºä¸­ä¸å¸¸ä½¿ç”¨
==ç¼ºç‚¹æ˜¯æ‰¾ä¸åˆ°æ ¹èŠ‚ç‚¹==ï¼Œå¦‚æœä¸è¿›è¡Œè®°å½•ï¼Œåˆ™éœ€è¦åœ¨å…¨éƒ¨è¡¨ä¸­æ‰«æï¼Œ 
![[attachments/Pasted image 20230420113439.png|400]]

#### (3) å·¦å­èŠ‚ç‚¹å’Œå³siblingèŠ‚ç‚¹çš„è¡¨ç¤º
è¿™ç§æ–¹æ³•æ˜¯ä¸€ç§å¸¸è§çš„æ£®æ—çš„å­˜å‚¨æ–¹æ³•ï¼Œå¯ä»¥å°†ä¸åŒçš„æ ‘çš„æ ¹å¹¶è”åœ¨ä¸€èµ·ï¼Œç„¶åæœ‰é€‰æ‹©æ€§åœ°éå†æ ‘æˆ–è€…æ•´ä¸ªæ£®æ—

![[attachments/Pasted image 20230420113612.png|600]]
å¯¹äºæ ‘å’Œæ£®æ—çš„éå†æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨ç¬¬ä¸‰ç§æ–¹æ³•è¿›è¡Œéå†ï¼Œå”¯ä¸€åŒºåˆ«æ˜¯<mark style="background: transparent; color: yellow">éå†æ ¹èŠ‚ç‚¹çš„æ–¹æ³•
</mark>


## å…­ã€æ ‘ï¼Œæ£®æ—äºŒå‰æ ‘çš„è½¬åŒ–

#### (1) æ ‘è½¬åŒ–ä¸ºäºŒå‰æ ‘
<mark style="background: transparent; color: yellow">æ ‘è½¬æ¢ä¸ºäºŒå‰æ ‘æ˜¯å·¦å­æ ‘å’Œä¸‹ä¸€å…„å¼Ÿæ ‘çš„è½¬æ¢æ€è·¯</mark>
äºŒå‰æ ‘ä¸­çš„å·¦å³å­èŠ‚ç‚¹æœ‰åŒºåˆ«
1. çº¦å®šæ ‘ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºè¿›è¡Œç¼–å·ï¼Œå°†å…¶å½“åšæœ‰åºæ ‘çœ‹å¾…
2. å¯¹äºæ ‘ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ ä»…ä¿ç•™å’Œç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹çš„è¿çº¿ï¼Œåˆ é™¤å…¶ä½™çš„å­èŠ‚ç‚¹çš„è¿çº¿
3. é‡æ•´ç»“æ„ï¼Œå¦‚ä¸‹å›¾

![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-05-01 10.37.27|450]]

`````ad-hint
title: æ£®æ—è½¬äºŒå‰æ ‘
collapse: open
åªéœ€è¦å…ˆå°†æ£®æ—ä¸­æ¯ä¸€æ£µè½¬æ¢ä¸ºäºŒå‰æ ‘ï¼Œå†å°†æ ¹èŠ‚ç‚¹ç”¨å·¦å­æ ‘å³å…„å¼Ÿè¿æ¥èµ·æ¥å³å¯
`````

## ä¸ƒã€å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç 
### (1) ç›¸å…³æ¦‚å¿µ
1. **è·¯å¾„**ï¼š ä¸€ä¸ªèŠ‚ç‚¹åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹çš„åˆ†æ”¯åºåˆ—
2. **è·¯å¾„é•¿åº¦**ï¼šä¸€ä¸ªèŠ‚ç‚¹åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹æ‰€ç»è¿‡çš„åˆ†æ”¯æ•°ç›®
3. **æ ‘çš„è·¯å¾„é•¿åº¦**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ä¹‹å’Œ
4. èŠ‚ç‚¹çš„æƒï¼š æˆ‘ä»¬åœ¨å®é™…åº”ç”¨ä¸­ï¼Œäººä»¬å¸¸å¸¸ç»™æ•°çš„æ¯ä¸ªèŠ‚ç‚¹èµ‹äºˆä¸€ä¸ªå…·æœ‰æŸç§å®é™…æ„ä¹‰çš„å®æ•°ï¼Œå¹¶ç§°è¿™ä¸ªå®æ•°ä¸º**èŠ‚ç‚¹çš„æƒ**, è®°ä¸º$w_i$
5. **èŠ‚ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦**
è®¾æŸä¸ªèŠ‚ç‚¹ä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ä¸º$l_i$, ä¸”è¯¥èŠ‚ç‚¹çš„æƒå€¼ä¸º$\omega_i$, åˆ™èŠ‚ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¸º :
$$w_i \times  l_i$$
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-05-01 11.32.50|200]]
6. **æ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦**
å¯¹äºæ ‘ä¸­çš„æ¯ä¸€ä¸ªç»ˆç«¯èŠ‚ç‚¹$k_i$, æœ‰ä¸€ä¸ªæƒå€¼$w_i$ä¸æ•°ä¸­çš„èŠ‚ç‚¹å¯¹åº”ï¼Œå¹¶å–$l_i$ä¸ºä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ï¼Œ åˆ™<mark style="background: transparent; color: yellow">æ ¹èŠ‚ç‚¹åˆ°æ¯ä¸€ä¸ªå¶èŠ‚ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¹‹å’Œ</mark>ä¸ºæ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦
$$WPL  = \sum^{n}_{i=1} w_i \times l_i$$
```cpp 
// å¸¦æƒèŠ‚ç‚¹çš„é•¿åº¦åˆå§‹åŒ–
typedef char DataType;
typedef struct TreeNode{
    int weight; // èŠ‚ç‚¹çš„æƒ
    DataType data;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
};
```

### (2) å“ˆå¤«æ›¼æ ‘
1. é¦–å…ˆï¼Œå¯¹äºæŸä¸€ä¸ªç¡®å®šçš„æ ‘ï¼Œå¦‚æœæŒ‰ç…§$n = 1,2,3,...$æ’åˆ—ï¼ŒèŠ‚ç‚¹$n$å¯¹åº”çš„æ ‘çš„è·¯å¾„é•¿åº¦PLä¸º$[\log_{2}n]$ï¼Œ
(å¤§äºçš„æœ€å°æ•´æ•°)ï¼Œ å‰$k$é¡¹ä¹‹å’Œä¸º$\sum^{n}_{k=1} [\log_{2}k]$
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-05-01 12.21.03|200]]
2. å¯¹äºå¸¦æƒè·¯å¾„æœ€çŸ­é—®é¢˜ï¼Œ ä½¿ç”¨å“ˆå¤«æ›¼æ ‘ç®—æ³•ï¼Œæ„å»ºå¤–éƒ¨é€šè·¯å¸¦æƒè·¯å¾„é•¿åº¦æœ€çŸ­çš„æ ‘

**å“ˆå¤«æ›¼æ ‘å®šä¹‰**ï¼šå°†ç»™å®šæƒå€¼å’Œå…ƒç´ çš„èŠ‚ç‚¹ï¼Œæ„é€ æˆä¸€æ£µ**å¤–éƒ¨é€šè·¯å¸¦æƒæ ‘çš„è·¯å¾„é•¿åº¦æœ€çŸ­çš„äºŒå‰æ ‘**ï¼Œç§°ä¸ºå“ˆå¤«æ›¼æ ‘ã€‚
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-25 10.45.58|350]]
é€šè¿‡å¸¦æƒäºŒå‰æ ‘è¿›è¡Œç¼–ç ï¼Œå¯ä»¥é€šè¿‡æ­¤æ³•è¿›è¡Œæ•°æ®å‹ç¼©ï¼Œåœ¨ä¸Šå›¾ä¸­ï¼Œ$c$çš„æœç´¢æƒå€¼æœ€å¤§ï¼Œå› æ­¤å…¶è·¯å¾„é•¿åº¦æœ€çŸ­ï¼Œ ä»è€Œè¾¾åˆ°è¾ƒå¤§çš„æœç´¢æ•ˆç‡ (å‡è®¾æƒå€¼ä¸ºæœç´¢æ¬¡æ•°)

`````ad-caution
title: å“ˆå¤«æ›¼æ ‘çš„åˆ›å»ºæ–¹æ³•
collapse: close
æŒ‰ç…§æƒå€¼å·¦è¾¹å°å³è¾¹å¤§çš„æ–¹å¼ï¼Œæ¯ä¸€æ¬¡**å¾ªç¯æ‰¾æœ€å°çš„ä¸¤ä¸ªäºŒå‰æ ‘å¹¶ä¸”è¿›è¡Œåˆå¹¶æ“ä½œ**ï¼Œ å¹¶**å°†å…¶æ ¹èŠ‚ç‚¹çš„æƒå€¼è®°ä¸ºä¸¤ä¸ªèŠ‚ç‚¹çš„æƒå€¼ä¹‹å’Œ**ï¼Œå¯ä»¥æ„é€ å‡ºå¦‚å›¾çš„ä¸€é¢—äºŒå‰æ ‘

æˆ‘ä»¬ä»¥ä¸‹é¢çš„æ ‘çš„åˆ›å»ºä¸ºä¾‹
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-25 11.31.07|500]]
`````

**å“ˆå¤«æ›¼æ ‘çš„åˆå§‹åŒ–æ–¹æ³•**

| number | data | parent | left | right |
| ------ | ---- | ------ | ---- | ----- |
| 0      | A    | -1     | 1    | 2     |
| 1      | B    | 1      | -1   | -1    |
| 2      | C    | 1      | -1   | -1    | 
ä½¿ç”¨**ä¸‰å‰é“¾è¡¨çš„æ–¹æ³•è¿›è¡Œå­˜å‚¨**ï¼Œå…¶ç»“æ„ä½“å®šä¹‰å¦‚ä¸‹ :

```cpp 
typedef char DataType;
typedef struct TreeNode{
    int weight; // èŠ‚ç‚¹çš„æƒ
    DataType data;
    int parent;
    int left;
    int right;
};
typedef struct HuffTree
{
    TreeNode* nodes[MAXSIZE];
    int size;
};
```

ä½¿ç”¨æ•°ç»„æ–¹æ³•è¿›è¡Œå­˜å‚¨å¯¹åº”çš„å¶èŠ‚ç‚¹ï¼Œ æ¯ä¸€æ¬¡ ï¼Œå¯»æ‰¾parentä¸º-1çš„æƒå€¼æœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å»ºç«‹ä¸€ä¸ªæ ¹èŠ‚ç‚¹å¹¶å»ºç«‹ä¸€æ£µæ ‘

ä¹Ÿæœ‰ä¸€ç§è¾ƒå¥½çš„å­˜å‚¨ç»“æ„æ˜¯ä½¿ç”¨é“¾è¡¨ç›´æ¥å­˜å‚¨

```cpp 
#define MAXNODE 100
#define MAXNUM 50
// å“ˆå¤«æ›¼æ ‘çš„å®šä¹‰æ–¹æ³• 
typedef struct TreeNode{
	int weight;
	int parent,lchild, rchild;
}

typedef struct HuffmanTree{
	TreeNode* ht[MAXNODE]
}
```

è¾“å‡ºæ¯ä¸€ä¸ªå­—ç¬¦çš„ç¼–ç ï¼šä»å­—ç¬¦å‘ä¸Šè¿›è¡Œå€’åºè¾“å‡º

å¾ªç¯n-1æ¬¡å¹¶å¯»æ‰¾å¯¹åº”çš„æœ€å°çš„ï¼Œæ¯ä¸€æ¬¡åˆå¹¶æ ¹èŠ‚ç‚¹

`````ad-note
title: å“ˆå¤«æ›¼æ ‘çš„åˆ›å»ºçš„ä»£ç ç¤ºä¾‹
collapse: close

ä¸‹é¢çš„ä»£ç åˆ›å»ºäº†ä¸€ä¸ªå¦‚å›¾çš„å“ˆå¤«æ›¼æ ‘
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-05-01 16.09.13|450]]
```cpp 
#include <iostream>
#include <vector>
#define MAXSIZE 1000
using namespace std;

typedef char DataType;

typedef struct TreeNode{
    int weight = 0; // èŠ‚ç‚¹çš„æƒ
    DataType data = '\0';
    int parent = -1;
    int left   = -1;
    int right  = -1;
};

typedef struct HuffTree
{
    TreeNode* nodes[MAXSIZE];
    int size;
};

template <typename ItemType>
void show_vector(vector<ItemType> vec) {
    for (ItemType data : vec) {
        cout << data << " ";
    }
    cout << endl;
}

// å¿«é€Ÿæ’åºå‡½æ•°, ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆè¿›è¡Œå¿«é€Ÿæ’åº, æ³¨æ„éœ€è¦å‚æ•°ä¸­åŠ  & æ‰èƒ½ä¿®æ”¹å¯¹åº”çš„åœ°å€ 
void quick_sort(vector<int>& vec1, vector<DataType>& vec2, int begin, int end)
{
    if (end - begin <= 1){
        if (vec1[begin] > vec1[end])
        {
            swap(vec1[begin], vec1[end]);
            swap(vec2[begin], vec2[end]);
        }
        return;
    }
    // ä»¥å·¦è¾¹çš„æ•°ä¸ºåŸºå‡†æ•°
    int base = vec1[begin];
    int i = begin + 1, j = end;
    while(j!= i){ 
        // å‘å³æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”åŸºå‡†æ•°å¤§çš„æ•°
        for (; i!=j && vec1[i] <= base; i++);   // åœç•™åœ¨ç¬¬ä¸€ä¸ªå¤§äºbaseçš„æ•°ä¸Š
        for (; i!=j && vec1[j] > base;  j--);   // åœç•™åˆ°ç¬¬ä¸€ä¸ªå°äºç­‰äºbaseçš„æ•°ä¸Š
        swap(vec1[i], vec1[j]);
        swap(vec2[i], vec2[j]);
        // æœ€ç»ˆçš„ä¼šåˆåœ°ç‚¹æ˜¯ç¬¬ä¸€ä¸ªæ¯”baseå¤§çš„æ•°, å¦‚æœæ•°ç»„ä¸­æ²¡æœ‰ï¼Œåˆ™ä¼šåˆåˆ°æœ«å°¾
    }
    if (vec1[i] <= vec1[begin]) {
        // è¿™è¯´æ˜ç¬¬ä¸€ä¸ªæ•°æœ€å¤§, æ­¤æ—¶å’Œæœ€åä¸€ä¸ªäº¤æ¢
        swap(vec1[begin], vec1[i]);
        swap(vec2[begin], vec2[i]);
        quick_sort(vec1, vec2, begin, end - 1); // å‰é¢çš„å†æ’åº
    }
    else{ // æ­¤æ—¶æ±‡åˆç‚¹æ¯”åŸæ¥çš„æ•°å¤§ï¼Œåˆ™äº¤æ¢ä¼šåˆç‚¹å‰é¢çš„ç¬¬ä¸€ä¸ªæ•°
        swap(vec1[begin], vec1[i - 1]);
        swap(vec2[begin], vec2[i - 1]);
        quick_sort(vec1, vec2, begin, i-1); // i-1å¯èƒ½ä¸ºstart
        quick_sort(vec1, vec2, i, end);
    }
}

// ä¼ å…¥åœ°å€, min1. min2ä¸ºä¸‹æ ‡ 
void select(TreeNode* vec[],int size,int &min1, int &min2) {
    min1; min2;  // åŠ ä¸Šä¸¤ä¸ªè¶³å¤Ÿå¤§çš„æƒå€¼

    int min_value1 = 10000, min_value2 = 10000;
    // ä¸¤æ¬¡éå†å–å¾—ä¸¤ä¸ªæœ€å°å€¼
    for (int i = 0; i < size ; i++) {
        if (vec[i]->parent == -1 && vec[i]->weight <= min_value1) {
            min_value1 = vec[i]->weight;
            min1 = i;
        }
    }
    for (int i = 0; i < size; i++) {
        if (i == min1) continue;
        if (vec[i]->parent == -1 && vec[i]->weight <= min_value2) {
            min_value2 = vec[i]->weight;
            min2 = i;
        }
    }
}

// åˆ›å»ºå“ˆå¤«æ›¼æ ‘
HuffTree* create_tree(vector<int> weight_vec, vector<DataType> data_vec)
{
    // é¦–å…ˆå¯¹å‘é‡æŒ‰ç…§æƒå€¼å¤§å°è¿›è¡Œæ’åº
    if (data_vec.size() != weight_vec.size()) {
        cout << "Array Size not correspond: program shut down";
        exit(0);
    }
    // å¾—åˆ°çš„åºåˆ—æ˜¯é€’å¢çš„åºåˆ—,è¿›è¡Œç¿»è½¬
    quick_sort(weight_vec, data_vec, 0, weight_vec.size() - 1);
    reverse(weight_vec.begin(), weight_vec.end());
    reverse(weight_vec.begin(), weight_vec.end());

    HuffTree* root = new HuffTree();
    root->size = 2 * weight_vec.size() - 1;  // æ–°å»ºçš„èŠ‚ç‚¹æ•°ç›®æ˜¯ size-1ä¸ª
    
    // åˆ›å»ºæ ¹èŠ‚ç‚¹
    for (int j = 0; j < weight_vec.size(); j++) {
        TreeNode* new_node = new TreeNode();
        new_node->data = data_vec[j];
        new_node->weight = weight_vec[j];
        new_node->parent = -1;
        root->nodes[j] = new_node;
    }

    // åˆå¹¶æ ¹èŠ‚ç‚¹å¹¶åˆ›å»ºæ–°çš„æ ¹èŠ‚ç‚¹
    for (int j = 0; j < weight_vec.size() - 1; j++) {
        // æœç´¢weightæœ€å°çš„ä¸¤ä¸ªæ ¹èŠ‚ç‚¹
        int min1, min2;
        select(root->nodes, weight_vec.size() + j, min1, min2);
        
        int index = weight_vec.size() + j; // æ–°èŠ‚ç‚¹ä½ç½®

        TreeNode* new_node = new TreeNode();
        
        new_node->parent = -1;
        new_node->left = min1;
        new_node->right = min2;
        new_node->weight = root->nodes[min1]->weight + root->nodes[min2]->weight;

        root->nodes[min1]->parent = index;
        root->nodes[min2]->parent = index;
        
        root->nodes[index] = new_node;
    }
    return root;
}


int main()
{
    vector<int> weight_vector{ 3,5,6,4,7,1,2 };
    vector<DataType> data_vector{ 'A', 'B', 'C', 'D' ,'E','F','G'};
    HuffTree* tree = create_tree(weight_vector, data_vector);
    return 0;
}
```

`````

### (3) å“ˆå¤«æ›¼ç¼–ç 

å“ˆå¤«æ›¼ç¼–ç æ˜¯å¯¹äºç»™å®šçš„å¸¦æƒè·¯å¾„æ±‚è§£è§„æ¨¡æœ€å°çš„é—®é¢˜
1. å“ˆå¤«æ›¼ç¼–ç çš„æ¦‚å¿µ
ä½¿ç”¨è®¡ç®—æœºå¤„ç†å­—ç¬¦æ—¶ï¼Œ éœ€è¦å…ˆå¯¹å­—ç¬¦è¿›è¡ŒäºŒè¿›åˆ¶ç¼–ç ï¼Œå¦‚åœ¨è®¡ç®—æœºä¸­çš„è‹±æ–‡å­—ç¬¦æ—¶8ä½çš„å®šé•¿ç¼–ç 
è€Œå¯¹äºç¼©çŸ­æ•°æ®æ–‡ä»¶çš„é•¿åº¦ï¼Œå¯ä»¥ä½¿ç”¨ä¸å®šé•¿ç¼–ç æ–¹æ³•ï¼Œ å¯¹äºä½¿ç”¨é¢‘ç‡è¾ƒé«˜çš„å­—ç¬¦ï¼Œå¯ä»¥ç¼–è¾ƒçŸ­çš„ç¼–ç 

1) å‰ç¼€ç¼–ç 
**å®šä¹‰**:åœ¨ç¼–ç ç³»ç»Ÿä¸­ï¼Œ**ä»»ä½•ä¸€ä¸ªç¼–ç éƒ½ä¸æ˜¯å…¶ä»–ç¼–ç çš„å·¦ä¾§å­ä¸²** 
å¯¹äºå‰ç¼€ç¼–ç ç³»ç»Ÿï¼Œå¯ä»¥ä¸ä½¿ç”¨åˆ†éš”ç¬¦

2) å“ˆå¤«æ›¼ç¼–ç  
å¯¹äºå“ˆå¤«æ›¼æ ‘ä¸­çš„æ¯ä¸ªå·¦åˆ†æ”¯è®¾ç½®ä¸º1, è€Œå³åˆ†æ”¯è®¾ç½®ä¸º0, æ˜¾ç„¶ç”±äºè·¯å¾„æ²¡æœ‰å®Œå…¨é‡åˆéƒ¨åˆ†ï¼Œå› æ­¤æ˜¯å‰ç¼€ç¼–ç ï¼Œæˆ‘ä»¬ä»¤$w_i$ä¸ºç¬¬$i$ä¸ªå­—ç¬¦çš„ä½¿ç”¨é¢‘åº¦
æ€§è´¨ï¼š==å“ˆå¤«æ›¼ç¼–ç æ˜¯æœ€ä¼˜çš„å‰ç¼€ç¼–ç ==ï¼Œ å³
$$\sum^{n}_{i=1} w_i p_i$$
å–å¾—æœ€å°å€¼

å¯¹äºä¸€ä¸ªæƒå€¼æœªçŸ¥çš„éƒ¨åˆ†çš„å“ˆå¤«æ›¼ç¼–ç ï¼Œå¯ä»¥éšä¾¿å»ºç«‹æ ¹èŠ‚ç‚¹ä¸€ä¸ªäºŒå‰æ ‘å­˜å‚¨å¯¹åº”çš„å€¼

`````ad-note
title: è‹±æ–‡å­—æ¯ä»¥åŠç©ºæ ¼çš„ä½¿ç”¨é¢‘ç‡
collapse: close
è‹±æ–‡å­—æ¯å’Œç©ºæ ¼çš„æ•²å‡»é¢‘ç‡ï¼Œå¹¶æŒ‰ç…§ä»å¤§åˆ°å°çš„é¡ºåºç»™å‡ºå®ƒä»¬çš„æƒå€¼ï¼š
1. ç©ºæ ¼ - 19.18%
2. E - 10.74%
3. T - 7.71%
4. A - 6.42%
5. O - 6.31%
6. N - 6.28%
7. I - 5.84%
8. S - 5.56%
9. R - 5.48%
10. H - 4.92%
11. L - 3.56%
12. D - 3.32%
13. U - 2.73%
14. C - 2.71%
15. M - 2.61%
16. F - 2.30%
17. Y - 2.11%
18. W - 2.09%
19. G - 2.03%
20. P - 1.82%
21. B - 1.49%
22. V - 0.98%
23. K - 0.77%
24. X - 0.15%
25. Q - 0.10%
26. J - 0.10%
27. Z - 0.05%
æƒå€¼è¡¨ç¤ºæ¯ä¸ªå­—æ¯å’Œç©ºæ ¼åœ¨æ•²å‡»ä¸­çš„ç›¸å¯¹é¢‘ç‡ï¼Œä»¥ç™¾åˆ†æ¯”è¡¨ç¤ºã€‚ç”±æ­¤å¯è§ï¼Œç©ºæ ¼æ˜¯æœ€å¸¸ç”¨çš„å­—ç¬¦ï¼Œè€ŒJã€Qã€Xç­‰å­—æ¯çš„ä½¿ç”¨é¢‘ç‡åˆ™ç›¸å¯¹è¾ƒä½ã€‚
`````

`````ad-note
title: å“ˆå¤«æ›¼æ ‘å®ç°çš„ç®€å•è‹±æ–‡ç¼–ç å™¨
collapse: close

ä¸‹å›¾æ›´æ”¹äº†ä¸Šè¿°çš„ä»£ç , å¯ä»¥æ–¹ä¾¿åœ°å®ç°è‹±æ–‡å°å†™å­—æ¯å’Œç©ºæ ¼çš„åŠ å¯†å’Œè§£å¯†

```cpp 
#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include <unordered_map>
#define MAXSIZE 100
using namespace std;

typedef char DataType;

typedef struct TreeNode {
    double weight = 0; // èŠ‚ç‚¹çš„æƒ
    DataType data = '\0';
    int parent = -1;
    int left = -1;
    int right = -1;
};

typedef struct HuffTree
{
    TreeNode* nodes[MAXSIZE];
    int size;
};

template <typename ItemType>
void show_vector(vector<ItemType> vec) {
    for (ItemType data : vec) {
        cout << data << " ";
    }
    cout << endl;
}

// å¿«é€Ÿæ’åºå‡½æ•°, ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆè¿›è¡Œå¿«é€Ÿæ’åº, æ³¨æ„éœ€è¦å‚æ•°ä¸­åŠ  & æ‰èƒ½ä¿®æ”¹å¯¹åº”çš„åœ°å€ 
void quick_sort(vector<double>& vec1, vector<DataType>& vec2, int begin, int end)
{
    if (end - begin <= 1) {
        if (vec1[begin] > vec1[end])
        {
            swap(vec1[begin], vec1[end]);
            swap(vec2[begin], vec2[end]);
        }
        return;
    }
    // ä»¥å·¦è¾¹çš„æ•°ä¸ºåŸºå‡†æ•°
    int base = vec1[begin];
    int i = begin + 1, j = end;
    while (j != i) {
        // å‘å³æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”åŸºå‡†æ•°å¤§çš„æ•°
        for (; i != j && vec1[i] <= base; i++);   // åœç•™åœ¨ç¬¬ä¸€ä¸ªå¤§äºbaseçš„æ•°ä¸Š
        for (; i != j && vec1[j] > base; j--);   // åœç•™åˆ°ç¬¬ä¸€ä¸ªå°äºç­‰äºbaseçš„æ•°ä¸Š
        swap(vec1[i], vec1[j]);
        swap(vec2[i], vec2[j]);
        // æœ€ç»ˆçš„ä¼šåˆåœ°ç‚¹æ˜¯ç¬¬ä¸€ä¸ªæ¯”baseå¤§çš„æ•°, å¦‚æœæ•°ç»„ä¸­æ²¡æœ‰ï¼Œåˆ™ä¼šåˆåˆ°æœ«å°¾
    }
    if (vec1[i] <= vec1[begin]) {
        // è¿™è¯´æ˜ç¬¬ä¸€ä¸ªæ•°æœ€å¤§, æ­¤æ—¶å’Œæœ€åä¸€ä¸ªäº¤æ¢
        swap(vec1[begin], vec1[i]);
        swap(vec2[begin], vec2[i]);
        quick_sort(vec1, vec2, begin, end - 1); // å‰é¢çš„å†æ’åº
    }
    else { // æ­¤æ—¶æ±‡åˆç‚¹æ¯”åŸæ¥çš„æ•°å¤§ï¼Œåˆ™äº¤æ¢ä¼šåˆç‚¹å‰é¢çš„ç¬¬ä¸€ä¸ªæ•°
        swap(vec1[begin], vec1[i - 1]);
        swap(vec2[begin], vec2[i - 1]);
        quick_sort(vec1, vec2, begin, i - 1); // i-1å¯èƒ½ä¸ºstart
        quick_sort(vec1, vec2, i, end);
    }
}

// ä¼ å…¥åœ°å€, min1. min2ä¸ºä¸‹æ ‡ 
void select(TreeNode* vec[], int size, int& min1, int& min2) {
    min1; min2;  // åŠ ä¸Šä¸¤ä¸ªè¶³å¤Ÿå¤§çš„æƒå€¼

    int min_value1 = 10000, min_value2 = 10000;
    // ä¸¤æ¬¡éå†å–å¾—ä¸¤ä¸ªæœ€å°å€¼
    for (int i = 0; i < size; i++) {
        if (vec[i]->parent == -1 && vec[i]->weight <= min_value1) {
            min_value1 = vec[i]->weight;
            min1 = i;
        }
    }
    for (int i = 0; i < size; i++) {
        if (i == min1) continue;
        if (vec[i]->parent == -1 && vec[i]->weight <= min_value2) {
            min_value2 = vec[i]->weight;
            min2 = i;
        }
    }
}

// åˆ›å»ºå“ˆå¤«æ›¼æ ‘
HuffTree* create_tree(vector<double> weight_vec, vector<DataType> data_vec)
{
    // é¦–å…ˆå¯¹å‘é‡æŒ‰ç…§æƒå€¼å¤§å°è¿›è¡Œæ’åº
    if (data_vec.size() != weight_vec.size()) {
        cout << "Array Size not correspond: program shut down";
        exit(0);
    }
    // å¾—åˆ°çš„åºåˆ—æ˜¯é€’å¢çš„åºåˆ—,è¿›è¡Œç¿»è½¬
    quick_sort(weight_vec, data_vec, 0, weight_vec.size() - 1);
    reverse(weight_vec.begin(), weight_vec.end());
    reverse(weight_vec.begin(), weight_vec.end());

    HuffTree* root = new HuffTree();
    root->size = 2 * weight_vec.size() - 1;  // æ–°å»ºçš„èŠ‚ç‚¹æ•°ç›®æ˜¯ size-1ä¸ª

    // åˆ›å»ºæ ¹èŠ‚ç‚¹
    for (int j = 0; j < weight_vec.size(); j++) {
        TreeNode* new_node = new TreeNode();
        new_node->data = data_vec[j];
        new_node->weight = weight_vec[j];
        new_node->parent = -1;
        root->nodes[j] = new_node;
    }

    // åˆå¹¶æ ¹èŠ‚ç‚¹å¹¶åˆ›å»ºæ–°çš„æ ¹èŠ‚ç‚¹
    for (int j = 0; j < weight_vec.size() - 1; j++) {
        // æœç´¢weightæœ€å°çš„ä¸¤ä¸ªæ ¹èŠ‚ç‚¹
        int min1, min2;
        select(root->nodes, weight_vec.size() + j, min1, min2);

        int index = weight_vec.size() + j; // æ–°èŠ‚ç‚¹ä½ç½®

        TreeNode* new_node = new TreeNode();

        new_node->parent = -1;
        new_node->left = min1;
        new_node->right = min2;
        new_node->weight = root->nodes[min1]->weight + root->nodes[min2]->weight;

        root->nodes[min1]->parent = index;
        root->nodes[min2]->parent = index;

        root->nodes[index] = new_node;
    }
    return root;
}

// æ¨¡æ‹Ÿç¼–ç è¿‡ç¨‹,ç”Ÿæˆä¸€ä¸ªæ¯ä¸ªå­—ç¬¦å¯¹åº”çš„å“ˆå¸Œè¡¨
void generate_encode_map(HuffTree* tree, int root_index, unordered_map<char, string>& char_map, string &current_step) {
    // è°ƒç”¨æ—¶ï¼Œå¿…é¡»è¾“å…¥æ ¹èŠ‚ç‚¹å·ç å’Œä¸€ä¸ªç©ºçš„å“ˆå¸Œè¡¨å’Œä¸€ä¸ªç©ºçš„å‘é‡
    char ch = tree->nodes[root_index]->data;
    if (ch != '\0') {
        char_map[ch] = current_step;
    }
    else {
        int left = tree->nodes[root_index]->left;
        current_step.append("1"); // å‘å·¦èµ°
        generate_encode_map(tree, left, char_map, current_step);
        current_step.pop_back();

        int right = tree->nodes[root_index]->right;
        current_step.append("0"); // å‘å³èµ°
        generate_encode_map(tree, right, char_map, current_step);
        current_step.pop_back(); 
    }
}

string encode(HuffTree* tree,unordered_map<char, string> char_map, string str) {
    string result;
    for (char ch : str) {
        if (char_map.find(ch) == char_map.end()) {
            cout << "no characters in map!";
            exit(-1);
        }
        result.append(char_map[ch]);
    }
    return result;
}



string decode(HuffTree* tree, string str) {
    string result; // è§£ç ç»“æœ
    int i = 0;
    TreeNode* p = tree->nodes[tree->size - 1];

    while (i < str.size()) {
        switch(str[i])
        {
        case '1':
            p = tree->nodes[p->left];
            break;
        case '0':
            p = tree->nodes[p->right];
            break;
        default:
            break;
        }
        if (p->data != '\0') {
            result.append(&(p->data));       // è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶è¿æ¥
            p = tree->nodes[tree->size - 1]; // å¤åŸä¸ºæ ¹èŠ‚ç‚¹
        }
        i++;
    }
    return result;
}

int main()
{
    vector<double> weight_vector{ 19.18, 10.74, 7.71 , 6.42, 6.31, 6.28, 5.84, 5.56, 5.48, 4.92, 3.56, 3.32, 2.73, 2.71, 2.61, 2.30, 2.11, 2.09, 2.03, 1.82, 1.49, 0.98, 0.77, 0.15, 0.10, 0.10, 0.05};
    vector<DataType> code_vector{ ' ', 'e', 't','a','o','n','i','s','r','h','l','d','u','c','m','f','y','w','g','p','b','v','k','x','q','j','z'};
    HuffTree* tree = create_tree(weight_vector, code_vector);
    
    unordered_map<char, string> char_map;
    string step;
    generate_encode_map(tree, tree->size - 1, char_map, step);

    string str, result;
    getline(cin, str);

    result = encode(tree, char_map, str);

    cout << result << endl;

    cout << decode(tree, result) << endl;
    return 0;
}
```

`````

`````ad-note
title: ä½¿ç”¨é“¾è¡¨ç»“æ„çš„å“ˆå¤«æ›¼ç¼–ç å’Œè¯‘ç å®ç°
collapse: close
```cpp 
#include <iostream>
#include <vector>
#include <string>
using namespace std;
#define Inf 10000;

typedef char DataType;

// äºŒå‰æ ‘èŠ‚ç‚¹éƒ¨åˆ†
typedef struct Node{
    int weight = 0;
    Node* left = nullptr;
    Node* right = nullptr;
    DataType data = '\0';
};

void ShowVec(vector<Node*> vec) {
    for (Node* node : vec) {
        cout << node->weight << " ";
    }
    cout << endl;
}

class HuffTree {
public:
    HuffTree(vector<DataType> DataVec, vector<int> weightVec) {
        if (DataVec.size() != weightVec.size()) exit (-1);
        CreateTree(DataVec, weightVec);
    }
    string encode(string input);
    string decode(string input);
private:
    bool enchar(Node* node, char ch, string &res);
    void CreateTree(vector<DataType> DataVec, vector<int> weightVec);
    Node* root;
    int elem_num;
};

void HuffTree::CreateTree(vector<DataType> DataVec, vector<int> weightVec) {
    vector<Node*> NodeVec;
    this -> elem_num = DataVec.size();

    for (int i = 0; i < this -> elem_num; i++) {
        Node* node = new Node();
        node->data = DataVec[i];
        node->weight = weightVec[i];
        NodeVec.push_back(node);
    }

    // æ¯ä¸€æ¬¡åœ¨å‘é‡ä¸­å¯»æ‰¾æƒå€¼æœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹,åˆ é™¤å¹¶åˆæˆä¸€ä¸ªæ–°çš„åŠ å…¥
    for (int t = this ->elem_num -1 ; t > 0; t--) {
        int m_i1 = 0, m_i2 = 0, min = Inf;
        for (int i = 0; i < NodeVec.size(); i++) {
            if (NodeVec[i]->weight < min) {
                min = NodeVec[i]->weight;
                m_i1 = i;
            }
        }
        min = Inf; // é‡ç½®
        for (int i = 0; i < NodeVec.size(); i++) {
            if (NodeVec[i]->weight < min && i != m_i1) {
                min = NodeVec[i]->weight;
                m_i2 = i;
            }
        }
        // ShowVec(NodeVec);
        Node* p1 = NodeVec[m_i1], *p2 = NodeVec[m_i2];
        
        Node* L = new Node();
        L->left = p1; L->right = p2;  // å·¦è¾¹æƒå€¼å°,å³è¾¹å¤§
        L->weight = p1->weight + p2->weight; // æƒå€¼æ˜¯ä¸¤è¾¹å’Œ

        // åˆ é™¤ä¸¤ä¸ªå…ƒç´ 
        if (m_i1 > m_i2) {
            NodeVec.erase(NodeVec.begin() + m_i1);
            NodeVec.erase(NodeVec.begin() + m_i2);
        }
        else {
            NodeVec.erase(NodeVec.begin() + m_i2);
            NodeVec.erase(NodeVec.begin() + m_i1);
        }
        NodeVec.push_back(L);
    }
    this -> root = NodeVec[0];
}

string HuffTree::encode(string input) {
    string res;
    for (char ch : input) {
        // æœç´¢å¹¶ä¸”è¿”å›å…¶
        string a;
        enchar(this ->root,ch ,a);
        res.append(a);
    }
    return res;
}

// æ·±æœ
bool HuffTree::enchar(Node* node , char ch, string &res) {
    if (node->data == ch) return true;
    else if (node->data == '\0') {
        // å·¦å­æ ‘
        res.append("0");
        if (enchar(node->left, ch, res)) return true;
        res.pop_back();// æ¸…é™¤æœ€åä¸€ä¸ªå…ƒç´ 

        res.append("1");
        if (enchar(node->right, ch, res))return true;
        res.pop_back();
    }
    return false;
}

string HuffTree::decode(string input) {
    string res;
    Node* p = root;
    for (int i = 0; i < input.length(); i++) {
        if (input[i] == '0') {
            p = p->left;
        }
        else {
            p = p->right;
        }
        if (p->data != '\0') {
            res.push_back(p->data); // åŠ å…¥å­—ç¬¦
            p = root;
        }
    }
    return res;
}

int main() {
    vector<DataType> DataVec;
    vector<int> weightVec;

    int n;
    cin >> n;
    DataType input;

    for (int i = 0; i < n; i++) {
        cin >> input;
        DataVec.push_back(input);
    }
    int weight;
    for (int i = 0; i < n; i++) {
        cin >> weight;
        weightVec.push_back(weight);
    }

    HuffTree tree(DataVec, weightVec);

    string str;
    cin >> str;

    string res = tree.encode(str);
    cout << res << endl;

    cout << tree.decode(res) << endl;
    return 0;
}

/*
5 a b c d e 12 40 15 8 25
bbbaddeccbbb
*/
```
`````

## å…«ã€å †å­˜å‚¨çš„æ¦‚å¿µ
å‚è€ƒï¼š[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/Data Structure/C++åŸºç¡€çŸ¥è¯†/å¤ä¹  ä¸ƒå¤§æ’åºç®—æ³•#å››ã€å †æ’åºç®—æ³•|å †æ’åº]]
å †å¯ä»¥åˆ†ä¸ºå¤§æ ¹å †å’Œå°æ ¹å †ï¼Œå †æ˜¯å®Œå…¨äºŒå‰æ ‘çš„æ¦‚å¿µï¼Œæœ€åŸºæœ¬çš„æ“ä½œæœ‰
1. åˆ é™¤å †é¡¶çš„å…ƒç´ 
2. æ’å…¥å…ƒç´ 

å¯¹äºåˆ é™¤å †é¡¶å…ƒç´ ï¼Œ ä¸èƒ½è°å°å°±å‘å‰æï¼Œç”±äºè¿™æ ·ä¼šç ´åå®Œå…¨äºŒå‰æ ‘ç»“æ„

å› æ­¤æˆ‘ä»¬ä½¿ç”¨å¦‚ä¸‹çš„æ–¹æ³•ï¼šï¼ˆä»¥ç»´æŠ¤å¤§æ ¹å †ä¸ºä¾‹ï¼‰
(1) æ’å…¥å…ƒç´ 
é¦–å…ˆ<mark style="background: transparent; color: yellow">å°†å…ƒç´ æ’å…¥åˆ°å †çš„æ•°ç»„</mark>ä¸­
è‡ªåº•å‘ä¸Šå’Œçˆ¶èŠ‚ç‚¹åšæ¯”è¾ƒï¼Œ ==å¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œ åˆ™å’Œçˆ¶èŠ‚ç‚¹è¿›è¡Œäº¤æ¢==

å¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å°ï¼Œç»“æŸæ’å…¥

(2) åˆ é™¤å †é¡¶å…ƒç´ 
1. é¦–å…ˆå°†å †å°¾éƒ¨å…ƒç´ æ”¾åˆ°å †é¡¶å¹¶ç§»é™¤å †é¡¶å…ƒç´ 
2. ==å‘ä¸‹å·¦å³è¿›è¡Œæ¯”è¾ƒ==ï¼Œå…¶ä¸­éœ€è¦æ¯”è¾ƒä¸‹é¢å·¦å³å­æ ‘æ¯ä¸€ä¸ªå…ƒç´ å’Œè¿™ä¸ªèŠ‚ç‚¹çš„å¤§å°
å¦‚æœèŠ‚ç‚¹çš„å€¼å¤§äºè¿™ä¸ªå€¼ï¼Œåˆ™äº¤æ¢è¿™ä¸¤ä¸ªå…ƒç´ 

åœ¨æ’å…¥å’Œåˆ é™¤è¿‡ç¨‹ä¸­ï¼Œéœ€è¦æ³¨æ„æ•°ç»„çš„è¶Šç•Œé—®é¢˜

`````ad-todo
title: ç»ƒä¹ 
collapse: open
`````

## ä¹ã€ å¹¶æŸ¥é›†
### (1) å¹¶æŸ¥é›†çš„å®šä¹‰
å¹¶æŸ¥é›†éœ€è¦æœ‰ä¸¤ç§åŸºæœ¬çš„æ“ä½œï¼š
1. ç¡®å®šä¸€ä¸ªå…ƒç´ æ‰€åœ¨çš„å­é›†(ä¸€ç»„äº’ä¸ç›¸äº¤çš„å­é›†)
2. åˆå¹¶ä¸¤ä¸ªå­é›†
é€šè¿‡å¹¶æŸ¥é›†å¯ä»¥æœ‰æ•ˆåœ°å®ç°é›†åˆçš„è¿ç®—
æ­¤å¤„ä½¿ç”¨æ ‘çš„ç»“æ„æ¥è¡¨ç¤ºå¹¶æŸ¥é›†

å…¶ä¸­ä½¿ç”¨æ ‘ç»“æ„æ—¶ï¼Œ 
1. ä»»æ„ç»™ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåªéœ€æ²¿ç€çˆ¶æŒ‡é’ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œå³å¯ç¡®å®šå…¶æ‰€åœ¨çš„å­é›†
2. åªè¦å°†ä¸¤æ£µæ ‘çš„æ ¹è¿›è¡Œåˆå¹¶ï¼Œå³å¯å®ç°ä¸¤ä¸ªå­é›†çš„åˆå¹¶æ“ä½œ 

æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ä¸€ä¸ªæ•°æ®ç±»å‹çš„æ•°ç»„å’Œä¸€ä¸ªparentè®°å½•å…¶çˆ¶èŠ‚ç‚¹å³å¯ï¼Œåœ¨æŸ¥æ‰¾æŸä¸ªå…ƒç´ å±äºå“ªä¸ªé›†åˆï¼Œåªéœ€æŒ‰ç…§parentä¾æ¬¡è¿”å›å³å¯

```cpp 
typedef int DataType;
typedef struct MFset(){
	DataType data;
	int parent = -1;
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåˆå¹¶ä¸¤æ£µå­é›†æ ‘æ—¶ï¼Œ å¦‚æœåˆå¹¶æ“ä½œç”¨å°†é«˜åº¦è¾ƒå°çš„æ ‘åŠ å…¥é«˜åº¦è¾ƒå¤§çš„æ ‘ï¼Œ åˆ™ä¼šæé«˜å¹³å‡æŸ¥æ‰¾æ•ˆç‡ã€‚ ä¸ºäº†èŠ‚çœå­˜å‚¨ç©ºé—´ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºï¼ŒèŠ‚ç‚¹è¶Šå¤šé«˜åº¦ä¸€èˆ¬è¶Šé«˜ã€‚å¯ä»¥ä½¿ç”¨æ ¹èŠ‚ç‚¹çš„`parent`åŸŸå­˜æ”¾`-node_num`

æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªè¾ƒä¸ºåŠ¨æ€çš„ç®—æ³•ï¼Œæ¯ä¸€æ¬¡æŸ¥æ‰¾æŸä¸ªå…ƒç´ ä¹‹å‰ï¼Œè®¾ç½®é«˜åº¦ä¸ºå®šå€¼ï¼Œè€ŒæŸ¥æ‰¾ä¹‹åï¼Œè®°å½•é¢‘æ¬¡ï¼Œå¹¶å¯ä»¥é™ä½å­é›†æ ‘çš„é«˜åº¦æ¥æé«˜æŸ¥æ‰¾æ•ˆç‡


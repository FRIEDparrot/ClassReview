## 1. æ ‘çš„åŸºæœ¬çŸ¥è¯†å’Œéå†æ–¹æ³•
[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/Data Structure/è¯¾ç¨‹ç¬”è®°/åŸºç¡€çŸ¥è¯†/å¤ä¹  æ ‘çš„åŸºæœ¬çŸ¥è¯†|æ ‘çš„åŸºæœ¬çŸ¥è¯†å¤ä¹ å’ŒåŸºæœ¬çš„åŠŸèƒ½å®ç°]]

æ ‘çš„å®šä¹‰: ä½¿ç”¨é€’å½’çš„å®šä¹‰æ–¹æ³•
==æ ‘æ˜¯ä¸€ä¸ªé›†åˆã€‚é™¤ç©ºæ ‘å¤–ï¼Œæ¯ä¸ªæ ‘æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œ æ¯ä¸ªèŠ‚ç‚¹åˆ†ä¸º$m$ä¸ªä¸æƒ³äº¤çš„å­é›†==
æ£®æ—æ˜¯m (m>=0)æ£µäº’ä¸ç›¸äº¤çš„æ ‘çš„é›†åˆã€‚å¯¹æ ‘ä¸­æ¯ä¸ªç»“ç‚¹è€Œè¨€ï¼Œå…¶å­æ ‘çš„é›†åˆå³ä¸ºæ£®æ—ã€‚

æ ‘çš„<mark style="background: transparent; color: yellow">åº¦ä¸ºå­æ ‘çš„ä¸ªæ•°</mark>ï¼Œ å¶èŠ‚ç‚¹å®šä¹‰ä¸º<mark style="background: transparent; color: yellow">åº¦ä¸º0çš„èŠ‚ç‚¹</mark>

## 2. äºŒå‰æ ‘åŠå…¶åŸºæœ¬å­˜å‚¨ç»“æ„
**äºŒå‰æ ‘çš„å®šä¹‰**
æ»¡è¶³ä¸‹åˆ—ä¸¤ä¸ªæ¡ä»¶çš„æ ‘ç»“æ„ç§°ä¸ºäºŒå‰æ ‘ 
1. æ¯ä¸ªèŠ‚ç‚¹çš„åº¦éƒ½ä¸å¤§äº2
2. æ¯ä¸ªèŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹æ¬¡åºä¸èƒ½ä»»æ„é¢ å€’

å¯¹äºäºŒå‰æ ‘:
æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰æ•°æ®æŒ‡é’ˆï¼Œ <mark style="background: transparent; color: yellow">n-1ä¸ªæŒ‡é’ˆæœ‰ç”¨</mark>ï¼Œå¯¹äº$m$ä¸ªæŒ‡é’ˆçš„éƒ¨åˆ†ï¼Œå¾€å¾€ä¸ä½¿ç”¨
`````ad-todo
title: è¡¥å…… 
collapse: open
`````

äºŒå‰æ ‘çš„æ€§è´¨ï¼š
nå±‚æ»¡äºŒå‰æ ‘æœ‰$2^n-1$ä¸ªèŠ‚ç‚¹

å¦‚æœäºŒå‰æ ‘ä¸­æœ€å¤šåªæœ‰æœ€å°é¢ä¸¤å±‚çš„èŠ‚ç‚¹åº¦å¯ä»¥å°äº2ï¼Œ<mark style="background: transparent; color: yellow">ä¸”ä¸‹é¢ä¸€å±‚çš„å¶èŠ‚ç‚¹éƒ½ä»å·¦å‘å³è¿›è¡Œä¾æ¬¡æ’å¸ƒ</mark>ï¼Œ åˆ™ç§°äºŒå‰æ ‘ä¸º**å®Œå…¨äºŒå‰æ ‘**ï¼Œ<mark style="background: transparent; color: yellow">å®Œå…¨äºŒå‰æ ‘å¯ä»¥è¿›è¡Œè¿ç»­å­˜å‚¨ç»“æ„çš„æ’å¸ƒ
</mark>

äºŒå‰æ ‘æœ‰é¡ºåºå­˜å‚¨ç»“æ„å’Œé“¾å¼å­˜å‚¨ç»“æ„ä¸¤ç§åŸºæœ¬å­˜å‚¨ç»“æ„
1. äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨ç»“æ„
å¯¹äºå®Œå…¨äºŒå‰æ ‘çš„å­˜å‚¨ï¼Œ
å¯ä»¥ä½¿ç”¨: å·¦å­æ ‘ï¼š$2 * i +1$ , å³å­æ ‘ï¼š$2*i +2$çš„å¯»å€æ–¹å¼ï¼š
![[attachments/Pasted image 20230411114343.png|300]]

å¯¹äºæ‰©å……äºŒå‰æ ‘ï¼Œ 

2. äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æ„(å³æœ€å¹¿æ³›ä½¿ç”¨çš„äºŒå‰æ ‘ç»“æ„)

ä¸‰å‰é“¾è¡¨çš„é™æ€å­˜å‚¨æ–¹æ³• : 
![[attachments/Pasted image 20230411115341.png|400]]

$DEB\rightarrow FC\rightarrow A$

äºŒå‰æ ‘çš„éå†

é€šè¿‡é€’å½’è¿›è¡Œå»ºç«‹äºŒå‰æ ‘: 
ç»™å®šå…ˆåºçš„å¼€å§‹ä½ç½®å’Œ s 

$$A\rightarrow BC \rightarrow DEF$$
ä¸­åºéå†çš„é¡ºåºä¸º
$$ BC\rightarrow A\rightarrow DEF$$
æ˜¾ç„¶ååºæ˜¯ä¸å˜çš„ï¼Œ æ‰¾å‰åºçš„é•¿åº¦åªéœ€

å·¦å­æ ‘å¼€å§‹ä½ç½®ä¸º + 1

`````ad-bug
`````

## äºŒã€ äºŒå‰æ ‘çš„åˆå§‹åŒ–
### (1) å¸¸è§çš„äºŒå‰æ ‘åˆå§‹åŒ–

`````ad-note
title: å­—ç¬¦ä¸²åˆå§‹åŒ–äºŒå‰æ ‘
collapse: close
ä½¿ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–äºŒå‰æ ‘çš„æ–¹æ³•ä¸»è¦æœ‰é€’å½’å‡½æ•°æ–¹æ³•å’Œæ ˆæ–¹æ³•
1. é€’å½’å‡½æ•°æ–¹æ³•
```cpp 
#include <iostream>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

void PreOrderTransverse(TreeNode* root) {
	if (!root) return;
	cout << root->data;
	PreOrderTransverse(root->left);
	PreOrderTransverse(root->right);
}

// ä½¿ç”¨é€’å½’æ³•å»ºç«‹äºŒå‰æ ‘, è¿™ä¸ªå¿…é¡»æœ‰è¿”å›å€¼ä¸ç„¶æŠ¥é”™
TreeNode* CreateTree(TreeNode* root) {
	char ch; bool run = true;
	while (run) // å¥—ä¸€ä¸ªå¾ªç¯, ä¸¤è¾¹éƒ½createä¹‹å
	{
		cin >> ch;
		if (ch == ' ') continue;
		else if (ch == ')' ||ch ==',') return root;
		// æœ€ç»ˆè¾¾åˆ°)æ—¶ï¼Œè¿”å›æ ˆ
		switch (ch) {
		case'(': // ç»§ç»­cin
			root->left = CreateTree(root->left); // createTreeä»¥,ä¸ºç»“æŸ
			// ä¸­é—´æœ‰ä¸€ä¸ªåˆ†éš”å· ','å› æ­¤ä»¥,ä¸ºå·¦ä¾§ç»“æŸç¬¦
			root->right = CreateTree(root->right);  // ä»¥)ä¸ºç»“æŸ
			break;
		default:
			TreeNode* L = new TreeNode(); // æ–°å»ºè¿™ä¸ªèŠ‚ç‚¹
			L->data = ch;
			root = L; // è¿™æ ·æ–°å»ºèŠ‚ç‚¹, è€Œä¸æ˜¯ç›´æ¥ç»™root åˆ†é…
			continue; // ç»§ç»­å¾ªç¯
		}
	};
}
// ç”±äºåŸç†æ˜¯cinåˆ°æœ€åä¸€ä¸ªæ ‡å¿—åè¿”å›ï¼Œå¯¼è‡´æ— æ³•åœæ­¢ï¼Œæ‰€ä»¥æœ‰å¿…è¦ç¬¬ä¸€ä¸ªå•ç‹¬æåœæ­¢

TreeNode* CreateBinaryTree(TreeNode* root) {
	cin >> root->data;
	char a;
	cin >> a; // (
	root->left=CreateTree(root->left);  // ä¸­é—´é€—å·è‡ªåŠ¨cin
	root->right=CreateTree(root->right);
	return root;
}

int main() {
	TreeNode* tree = new TreeNode();
	tree = CreateBinaryTree(tree); // è°ƒç”¨é€’å½’å‡½æ•°ï¼Œåˆ›å»ºèŠ‚ç‚¹

	PreOrderTransverse(tree);
	return 0;
}

/* Test Input
A(B(#,D),C(E(#,F),#))
*/
```

2. ä½¿ç”¨æ ˆçš„åˆå§‹åŒ–æ–¹æ³•
å…¶ä¸­éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨æ ˆæ—¶éœ€è¦å…ˆå°†æ ˆé¡¶å…ƒç´ åˆå§‹åŒ–ä¹‹åå†å¯¹å…ƒç´ è¿›è¡Œèµ‹å€¼

```cpp 
#include <iostream>
#include <stack>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

void PreOrderTransverse(TreeNode* root) {
	if (!root) return;
	cout << root->data;
	PreOrderTransverse(root->left);
	PreOrderTransverse(root->right);
}

// ä½¿ç”¨æ ˆçš„æ–¹æ³•å»ºç«‹äºŒå‰æ ‘
void CreateTree(TreeNode* root, string str) {
	stack<TreeNode*> stk;
	stk.push(root); // æ”¾å…¥æ ¹èŠ‚ç‚¹
	for (char ch: str) {
		// å¾€å¾€é€šè¿‡æ ˆæ»¡å’Œæ ˆç©ºåˆ¤æ–­ç»ˆæ­¢æ¡ä»¶
		switch (ch) {
		case ')':
			stk.pop();
			break;
		case '(':
			stk.top()->left = new TreeNode(); // ä¸ºäº†é˜²æ­¢è¿”å›æ—¶è¦†ç›–, è¿™é‡Œéœ€è¦æ³¨æ„
			stk.push(stk.top()->left);
			break;
		case ',':
			stk.pop();
			stk.top()->right = new TreeNode();
			stk.push(stk.top()->right); // æ¢ä¸ºå³èŠ‚ç‚¹
			break;
		default:
			stk.top()->data = ch;  
			// æ³¨æ„ä½¿ç”¨è¿™æ ·çš„æ–¹æ³•ä¸ºå…¶èµ‹å€¼, ä¸è¦ä½¿ç”¨ p = L ,å› ä¸ºè¿™æ ·ä¼šé‡æŒ‡
		}
	}
}
// ç”±äºåŸç†æ˜¯cinåˆ°æœ€åä¸€ä¸ªæ ‡å¿—åè¿”å›ï¼Œå¯¼è‡´æ— æ³•åœæ­¢ï¼Œæ‰€ä»¥æœ‰å¿…è¦ç¬¬ä¸€ä¸ªå•ç‹¬æåœæ­¢

int main() {
	TreeNode* tree = new TreeNode();
	string str;
	getline(cin, str);
	CreateTree(tree, str); // è°ƒç”¨é€’å½’å‡½æ•°ï¼Œåˆ›å»ºèŠ‚ç‚¹
	PreOrderTransverse(tree);
	return 0;
}

/* Test Input
A(B(#,D),C(E(#,F),#))
*/
```

`````

### (2) äºŒå‰æ ‘çš„æ‰©å±•å…ˆåºéå†åºåˆ—åˆ›å»º

`````ad-note
title:åºåˆ—äºŒå‰æ ‘çš„åˆå§‹åŒ–é€’å½’ä»£ç 
collapse: close

å¯ä»¥ä½¿ç”¨å…ˆåºéå†åºåˆ—ABD##EH###CF#I##G##ç±»ä¼¼çš„ä»£ç æ¥åˆå§‹åŒ–äºŒå‰æ ‘ï¼Œä»£ç å¦‚ä¸‹

```cpp 
TreeNode* CreateTree() {
	char ch;
	cin >> ch;
	TreeNode* root = nullptr;  
	// äº‹å…ˆåˆå§‹åŒ–èŠ‚ç‚¹
	if (ch != '#') { // ç©ºèŠ‚ç‚¹
		root = new TreeNode();
		root->data = ch;
		root->left = CreateTree();
		root->right = CreateTree();
	}
	return root;
}
```
`````

### (3) å‰åºåºåˆ—å’Œä¸­åºåºåˆ—å»ºç«‹äºŒå‰æ ‘
æˆ‘ä»¬ä»¥ä¸‹é¢çš„äºŒå‰æ ‘ä¸ºä¾‹
![[attachments/Pasted image 20230419213434.png|350]]
åˆ™å…¶å…ˆåºåºåˆ—å’Œä¸­åºåºåˆ—åˆ†åˆ«ä¸ºï¼š
![[attachments/Pasted image 20230419213600.png|450]]
åˆ©ç”¨ä¸‹å›¾ä¸­çš„ç‰¹ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å‡ºä¸€ä¸ªé€šè¿‡å‰åºéå†å’Œä¸­åºéå†åºåˆ—æ„å»ºäºŒå‰æ ‘çš„è¿‡ç¨‹:
æ¯ä¸€æ¬¡è®¡ç®—å¥½ä¸åŒåŒºé—´çš„startæ¥å»ºç«‹åºåˆ—ï¼Œ å¹¶å–midåºåˆ—$A$å·¦è¾¹çš„éƒ¨åˆ†ä¸ºå·¦å­æ ‘åºåˆ—ï¼Œå³è¾¹çš„éƒ¨åˆ†ä¸ºå³å­æ ‘åºåˆ—ï¼Œå¹¶æ¯ä¸€æ¬¡å–startä¸ºæ ¹èŠ‚ç‚¹å³å¯
![[attachments/Pasted image 20230419231836.png|650]]

````ad-note
title: ç»™å‡ºå…ˆåºå’Œä¸­åºåºåˆ—åˆ›å»ºäºŒå‰æ ‘çš„ä»£ç 
collapse: close

ä¸‹é¢çš„ä»£ç æ¯ä¸€æ¬¡æ˜¯å–å…¶ä¸­çš„å·¦å­æ ‘åºåˆ—å’Œå³å­æ ‘åºåˆ—ï¼Œå¹¶ä¸”è®°å½•å®ƒä»¬çš„ä¸¤ä¸ªä¸åŒçš„startå€¼ï¼Œ
```cpp 
#include <iostream>
#include <vector>
#include <stack>
#include <string>
using namespace std;

typedef char DataType;

typedef struct TreeNode {
	DataType data = '\0';
	TreeNode* left = nullptr;
	TreeNode* right = nullptr;
};

// ååºéå†è¾“å‡º
void dfs(TreeNode* root) {
	if (!root) return;
	dfs(root->left);
	dfs(root->right);
	cout << root->data;
}

vector<DataType> pre;
vector<DataType> mid;

// ä½¿ç”¨ä¸¤ä¸ªå‘é‡è¿›è¡Œå»ºç«‹, gen_arræ˜¯ç”¨æ¥ç”Ÿæˆå¯¹åº”å­æ ‘çš„å‘é‡(åŒ…å«æ ¹èŠ‚ç‚¹)
TreeNode* CreateTree(int start, int end, vector<DataType> gen_arr) {
	TreeNode* root = new TreeNode();
	root->data = pre[start];   // è®¾ç½®è¿™ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹
	DataType temp = root->data;
	vector<DataType> vector1; // ç”¨æ¥åˆ›å»ºå·¦å­æ ‘çš„vector
	vector<DataType> vector2; // ç”¨äºåˆ›å»ºå³å­æ ‘
	
	int i = 0;
	// æ„å»ºå·¦å­æ ‘åºåˆ—, åœ¨gen_arrçš„tempå·¦ä¾§ä¸ºå¯¹åº”çš„å…ƒç´ 
	for (; gen_arr[i] != temp; i++) vector1.push_back(gen_arr[i]);
	// å³å­æ ‘åºåˆ—, tempå³ä¾§çš„å…ƒç´ 
	for (i++; i < gen_arr.size(); i++) vector2.push_back(gen_arr[i]);
	if (!vector1.empty()) root->left = CreateTree(start + 1, start + vector1.size(), vector1);
	if (!vector2.empty()) root->right = CreateTree(start + vector1.size() + 1,start + vector1.size() + vector2.size(), vector2);
	return root;
}

int main() {
	string input;
	getline(cin, input);
	for (char ch : input) pre.push_back(ch);
	getline(cin, input);
	for (char ch : input) mid.push_back(ch);
	// åˆå§‹åŒ–å…ˆåºå’Œä¸­åºéå†å‘é‡
	TreeNode* root = CreateTree(0, pre.size()-1, mid); 
	// åˆå§‹è®¾ç½®midæ•´ä¸ªä¸ºgen_arr
	dfs(root);
	return 0;
}

/* Test Input
ABDFGCEH
BFDGACEH

** result *** 
FGDBHECA  // ååºéå†ç»“æœ
*/

```

````

```cpp 
// åˆ›å»ºäºŒå‰æ ‘ 

struct BTreeNode{
char data; 
BTreeNode *left, *right;
}

char s1 = {'A', 'B','C', 'D', 'E', 'F'}; // å…ˆåºåºåˆ—éƒ¨åˆ†
char s2 = {'B', 'C','A', 'F', 'E', 'D'}; // ä¸­åºåºåˆ—éƒ¨åˆ†

BTreeNode* create(BTreeNode* root,int start1, int start2, int length){
	char pre = s1[start2];
	// å…¶ä¸­Lengthä¸ºå­æ ‘çš„é•¿åº¦
	if (length == 0){
		return nullptr;
	}
	else{ // é¦–å…ˆå»ºç«‹æ ¹èŠ‚ç‚¹
		BTreeNode *t = new BTreeNode();
		t -> data = s1[start2]; // = pre
		// å…ˆæ±‚è§£é•¿åº¦(è®¡ç®—), åœ¨ç¬¬äºŒä¸ªåºåˆ—ä¸­æ‰¾
		int i = start1;
		for (; h[i]!= pre; i++){
		}
		llength = i - start2; 
		rlength = length - llength -1
		// å»ºç«‹å·¦å­æ ‘å’Œå³å­æ ‘
		// start2 + 1æ˜¯å·¦å­æ ‘çš„èµ·å§‹ä½ç½®, 
		
		// è¿™ä¸ªä»ç„¶æ˜¯éœ€è¦å››ä¸ªå‚æ•° -> å’Œä¸Šé¢çš„ç¨‹åºæœ¬è´¨ç›¸åŒ
		t -> left = create(start2+1, start1, start2, llength); // æ•´ä¸ªæ ‘çš„é•¿åº¦ä¸ºå·¦æ ‘çš„é•¿åº¦
		t -> left = create(start2+len + 1, start2+len+1, rlength)
	}
}

int main(){
	struct BTreeNode* root;
	root = create(0,0, strlen(g));
}
```

`````ad-faq
title: å¦‚ä½•è€ƒè™‘ä¸å»ºç«‹äºŒå‰æ ‘è€Œä½¿ç”¨é€’å½’çš„æ–¹æ³•ç›´æ¥è¾“å‡ºååºéå†
collapse: open
`````

ç›¸åŒå‰åºéå†åºåˆ—çš„äºŒå‰æ ‘ç§ç±»:
ç»™å®šä¸€ä¸ªå…ˆåºåºåˆ—ï¼Œæ ¹èŠ‚ç‚¹æ˜¯ä¸€å®šçš„ï¼Œ
è€ƒè™‘æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„åˆ†é…ï¼š å‘å·¦åˆ†é…å’Œå‘å³åˆ†é…

<mark style="background: transparent; color: yellow">æ–¹æ³•æ˜¯å·¦å­æ ‘å’Œå³å­æ ‘çš„åˆ†å¼€æ–¹æ³•</mark>

## ä¸‰ã€äºŒå‰æ ‘çš„éå†
### (1) è¡¨è¾¾å¼çš„äºŒå‰æ ‘ç»“æ„
å¯¹äºä¸‹å›¾çš„è¡¨è¾¾å¼å­˜å‚¨ï¼š 
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-20 10.38.47|300]]
å…¶å‰åºéå†ï¼š$-+a*bc/dc$
ä¸­åºéå†: $a+ b*c - d/c$ (å³çœŸå®è¡¨è¾¾å¼)
ååºéå†: $abc*+ dc/-$ (å³é€†æ³¢å…°è¡¨è¾¾å¼)
```cpp 
typedef struct ParTreeNode{
	DataType info; 
	int parent;
};
typedef struct ParTree{
	ParTreeNode nodelist[MAXNUM];
	int n;
};
```

## å››ã€äºŒå‰æ ‘çš„çº¿ç´¢åŒ–(Threading)


äºŒå‰æ ‘çš„çº¿ç´¢åŒ–æ˜¯é€šè¿‡äºŒå‰æ ‘çº¿ç´¢æ–¹æ³•
æŒ‡å‘åˆšè®¿é—®è¿‡çš„æŒ‡é’ˆ
çº¿ç´¢äºŒå‰æ ‘(Threading binary Tree)
`````ad-note
title: äºŒå‰æ ‘çš„ä¸­åºçº¿ç´¢åŒ–çš„ä»£ç å®ç°
collapse: close

ä¸‹åˆ—ä»£ç æ¼”ç¤ºäº†äºŒå‰æ ‘çš„å‰åºå»ºç«‹å’Œä¸­åºçº¿ç´¢åŒ–ï¼Œç¤ºä¾‹è¾“å…¥ä¸­çš„æ ‘ç»“æ„ä¸º

![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-19 15.49.59|250]]

å…¶ä¸­ä½¿ç”¨å‘å³æœç´¢éå†ä¸‹ä¸€ä¸ªä¸­åºèŠ‚ç‚¹çš„æ–¹æ³•å°†äºŒå‰æ ‘è¿›è¡Œäº†ä¸­åºè¾“å‡º

```cpp 
// äºŒå‰æ ‘ä¸­åºçº¿ç´¢åŒ–çš„å»ºç«‹ä»£ç 
#include <iostream>
using namespace std;

typedef char DataType;

// äºŒå‰æ ‘èŠ‚ç‚¹å®šä¹‰
typedef struct TreeNode {
    DataType data;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
    bool ltag = false, rtag = false;
    // å·¦å³çš„æ ‡ç­¾
};

// å…ˆåºå»ºç«‹äºŒå‰æ ‘
TreeNode* CreateTree() {
    char ch;
    TreeNode* p = nullptr;
    cin >> ch;
    // é™¤äº†ä½¿ç”¨if_else;
    if (ch != '#'){
        p = new TreeNode();   // å…ˆåºå»ºç«‹æ ‘çš„èŠ‚ç‚¹
        p->data = ch;
        p->left = CreateTree();
        p->right = CreateTree();
    }
    return p;   // æ³¨æ„å•å‡ºå£å‡½æ•°ï¼Œå¦‚æœå¤šå‡ºå£æœ‰å¯èƒ½é—æ¼è€ŒæŠ¥é”™
}

// å…¨å±€å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆlast,æŒ‡å‘åˆšåˆšè®¿é—®è¿‡çš„èŠ‚ç‚¹
TreeNode* last = nullptr; 

/*ä¸­åºçº¿ç´¢åŒ–*/
void ThreadTree(TreeNode* root) {
    // ä¸­åºéå†ä¸€æ¬¡
    if (root) {
        // ä½¿ç”¨å·¦èŠ‚ç‚¹ï¼Œæ¥ä¸Šä¸Šä¸€ä¸ªè®¿é—®çš„å…ƒç´ 
        ThreadTree(root->left);

        //å¤„ç†å½“å‰èŠ‚ç‚¹
        // å‘å‰æ¥ä¸Š
        // å‘å‰æ¥ä¸Š
        if (!root->left) {
            root->ltag = true; // å·¦èŠ‚ç‚¹è¢«åˆ©ç”¨
            root->left = last; // rightæŒ‡å‘ä¸‹ä¸€ä¸ªè®¿é—®çš„å…ƒç´ 
        }

        if (last && !last->right) {
            last->rtag = true;  // æ ‡å¿—è¿™ä¸ªèŠ‚ç‚¹çš„å³èŠ‚ç‚¹åŸå…ˆæ˜¯ç©ºèŠ‚ç‚¹ï¼Œç°åœ¨è¢«åˆ©ç”¨
            // æ³¨æ„æ˜¯lastçš„rtag
            last->right = root; // lastæŒ‡å‘å‰ä¸€ä¸ªè®¿é—®çš„å…ƒç´ 
        }

        last = root;  // å°†ä¸Šä¸€ä¸ªèŠ‚ç‚¹è®¾ç½®ä¸ºæ ¹èŠ‚ç‚¹ 

        ThreadTree(root->right);
    }
}

/*ä¸­åºéå†å‡½æ•°*/ 
void MidOrderTransverse(TreeNode* root) {
    TreeNode* p = root;
    if (!p) return;
    while (p->left) {
        p = p->left;
    } // æ‰¾åˆ°ä¸­åºéå†çš„å¤´ç»“ç‚¹
    // è¿›è¡Œä¸­åºéå†
    while (p!= nullptr) {
        // å…ˆè¾“å‡ºæœ¬èº«
        cout << p->data;
        if (p->rtag) { // true
            p = p->right;
        }// rtag == 1 æ—¶ï¼Œç›´æ¥ä½¿ç”¨rightä½œä¸ºåç»§èŠ‚ç‚¹
        else { // å…ˆæ‰¾åˆ°å³å­æ ‘, å†æœç´¢å³å­æ ‘çš„æœ€å·¦ä¸‹èŠ‚ç‚¹
            p = p->right;
            while (p && p->left && p->ltag == false) p = p->left;
            // æœ€ç»ˆåˆ°è¾¾æœ€å·¦ä¸‹çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³ä¸ºä¸‹ä¸€ä¸ªè®¿é—®çš„èŠ‚ç‚¹
        }
    }
}

int main()
{
    TreeNode* root; 
    root = CreateTree(); // å…ˆåºå»ºç«‹
    ThreadTree(root); // ä½¿ç”¨æ‰©å……äºŒå‰æ ‘è¿›è¡Œä¸­åºçº¿ç´¢åŒ–
    last->right = nullptr;
    MidOrderTransverse(root);
}
/* Test Code: 
ABD###CE##F##
*/
```

`````

## äº”ã€æ ‘å’Œæ£®æ—çš„è¡¨ç¤º
### 1. æ ‘çš„è¡¨ç¤º
#### (1) åŒäº²èŠ‚ç‚¹çš„è¡¨ç¤ºæ–¹æ³•

`````ad-quote
title: å¹¶æŸ¥é›†
collapse: open
`````
å¯ä»¥ä½¿ç”¨åŒäº²è¡¨ç¤ºæ³•è¿›è¡Œåˆå¹¶
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-20 10.47.16|300]]
ä¸¤æ¬¡æŸ¥æ‰¾ï¼Œ å¹¶è¿›è¡Œä¸€æ¬¡èµ‹å€¼ï¼Œä¸ºäº†å‡å°æŸ¥æ‰¾çš„æ·±åº¦ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨åŒäº²èŠ‚ç‚¹è¡¨ç¤ºï¼Œå­˜å‚¨åŒäº²èŠ‚ç‚¹

åŒäº²èŠ‚ç‚¹æ–¹æ³•çš„èŠ‚ç‚¹ç±»å‹å®šä¹‰
```cpp 
typedef struct ParTreeNode{
	DataType data;  
	int parent; // è¡¨ç¤ºiå·èŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹
	
}
typedefÂ  struct ParTree{
Â  ParTreeNodeÂ  nodelist[MAXNUM];
Â  intÂ  n;
}ParTree, *PParTree;
```


#### (2) å­è¡¨è¡¨ç¤ºæ–¹æ³•

å¯ä»¥ä½¿ç”¨å­èŠ‚ç‚¹é“¾è¡¨çš„æ–¹æ³•ï¼Œ
```cpp 
typedef struct EdgeNode{  /*å­—è¡¨ä¸­çš„èŠ‚ç‚¹çš„ç»“æ„*/
	int node_position;
	struct EdgeNode* link;  // æŒ‡å‘ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹èŠ‚ç‚¹
};
typedef struct TreeNode{
	// ç¬¬äºŒä¸ªç»“æ„ä½“çš„å®šä¹‰
	/*ç»“ç‚¹è¡¨ä¸­çš„èŠ‚ç‚¹ç»“æ„*/
	DataType info;
	struct EdgeNode* children; // åˆå§‹åŒ–ç¬¬ä¸€ä¸ªå­è¡¨èŠ‚ç‚¹
	
};
typedef struct ChiTree{ 
	/*æ•´ä¸ªæ ‘ç»“æ„çš„æ•°ç»„*/
	TreeNode* node_list[MAXNUM]; // å­˜å‚¨èŠ‚ç‚¹
	int root; 
	int n;
};
```

å…¶ä¸‰ä¸ªç»“æ„ä½“çš„å®šä¹‰çš„å›¾ç¤ºå¦‚ä¸‹ï¼š 
![[Excalidraw/ç¬¬å…­ç«  æ ‘å’ŒäºŒå‰æ ‘ 2023-04-20 11.12.27|600]]

å¦‚ä½•å»ºç«‹ä¸Šå›¾çš„å­˜å‚¨ç»“æ„ï¼š
ä½¿ç”¨ $p$-> å³ä¾§å…ƒç´ ä¹‹åå¾ªç¯å®ç°

#### (3) å·¦å³å­æ ‘å’Œsiblingçš„è¡¨ç¤ºæ–¹æ³•

```cpp 
typedefÂ  struct CSNode{
Â  DataTypeÂ  info;
Â  struct CSNodeÂ  *lchild;
Â  struct CSNodeÂ  *rsibling;
};
```
ç»“æ„å¦‚å›¾
![[attachments/Pasted image 20230420113745.png|200]]

### 2. æ£®æ—çš„è¡¨ç¤º
#### (1) åŒäº²è¡¨ç¤ºæ–¹æ³•
parent = -1ä¸ºæ ¹èŠ‚ç‚¹
è¡¨ç¤ºæ–¹æ³•å¦‚ä¸‹å›¾
![[attachments/Pasted image 20230420113348.png|400]]
#### (2) å­—è¡¨è¡¨ç¤ºæ–¹æ³•

ç¼ºç‚¹æ˜¯æ‰¾ä¸åˆ°æ ¹èŠ‚ç‚¹ï¼Œä¸€ç§æ–¹æ³•æ˜¯åœ¨å…¨éƒ¨è¡¨ä¸­æ‰«æï¼Œ 
![[attachments/Pasted image 20230420113439.png|400]]

#### (3) å·¦å­èŠ‚ç‚¹å’Œå³siblingèŠ‚ç‚¹çš„è¡¨ç¤º

![[attachments/Pasted image 20230420113612.png|600]]
#### (4) æ£®æ—çš„éå†æ–¹æ³•
ä½¿ç”¨ç¬¬ä¸‰ç§æ–¹æ³•è¿›è¡Œéå†
å”¯ä¸€åŒºåˆ«æ˜¯<mark style="background: transparent; color: yellow">éå†æ ¹èŠ‚ç‚¹çš„æ–¹æ³•
</mark>


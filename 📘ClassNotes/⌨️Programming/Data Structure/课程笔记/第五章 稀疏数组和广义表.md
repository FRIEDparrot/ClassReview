元素个数 < 5%的数组称为稀疏数组

需要记录**矩阵的总的行列数，以及非零的元素数量**
规定三元组数组的序列进行存储，考虑顺序， 每一次进行加法时，有可能需要进行重新排序

存储结构(**链式存储和顺序存储**): 顺序存储为三元组存储，链式存储为十字链表存储。 三元组往往在加减上有优点， 而十字链表往往用于求解矩阵的乘积

## 一、三元组

`````ad-caution
title: 三元组式稀疏矩阵的定义方法
collapse: close
```cpp 
#include <iostream>
#include <algorithm>
#include <vector>        // 初始矩阵规模
#include <unordered_map> 
// 如果使用动态算法，则使用哈希表存储每个
#define Max_Size 1000
using namespace std;

// 
typedef int DataType;
typedef struct Triple{
	int lin; 
	int col;
	DataType data;
}

class SparseMatrix{
public:
	// 使用行，列，data数组初始化稀疏矩阵
	SparseMatrix(vector<int> linVec, vector<int> colVec, vector<DataType> elemVec){
		// 自动判断行，列数量, 给出非零元素的矩阵存储
		InitSparseMat(linVec, colVec, elemVec);  // 初始化矩阵
	};
	SparseMatrix(vector<int> linVec, vector<int> colVec, vector<DataType> elemVec, int linNum, int colNum) {
		size[0] = linNum;
		size[1] = colNum;
		InitSparseMat(linVec, colVec, elemVec);  // 初始化矩阵
	}
	int ElemNum = 0;		 // 元素个数
	int colNum = 0;
	int linNum = 0;
	int size[2] = {0,0};
	Triple Elem[Max_Size];  // 在下面的另一种方式定义中，会初始化为空指针
	SparseMatrix Transpose(SparseMatrix A);
	void ShowMatrix();
private: 
	
}
```
`````

#### (1) 矩阵的转置
方法一 : 先转置，再进行排序， 此时，转置的时间复杂度为$O(n)$，排序的时间复杂度最低为$O(\log t(u))$
转置最也可以进行按列进行转置，但是时间复杂度极高。如果每一次仅扫描一列，则时间$(t(u) * N(u))$

**原理：如果能预先确定矩阵M中每一列（即T中的每一行）的第一个非零元素在T中的合适位置，那么在对M进行转置时就可以直接放到T中的恰当位置上去。为了确定这些位置，应先求得M的每一列中非零元的个数，进而求得每一列的第一个非零元在T中的位置**

首先做数据的预处理， 在输入后直接赋值并先排序一次，保证初始时是有序的

| 0   | 1   | 12  |
| --- | --- | --- |
| 0   | 2   | 3   |
| 0   | 4   | 5   |
| 1   | 5   | 13  | 

数据的预处理**需要统计每一行，每一列出现的元素个数。** 时间复杂度为$t(u)$， 并**使用一个足够大的count数组**进行一遍的扫描。
进行累加时， 再次做一次累计工作，将元素进行逐行累加后即可得到转置后即可得到对应的需要放的位置
例如对下图中每一列的数量做统计
得到的每列的元素数量

| 列数 | 元素个数 | 对应转之后的起始下标 |
| ---- | -------- | -------------------- |
| 1    | 2        | 0                    |
| 2    | 1        | 2                    |
| 3    | 1        | 3                    | 
然后在转置时， 定义一个currcol 来存储对应的元素的下标， 由于元素是按行升序排列的， 所以可以每一次对应的列的下标加一， 具体实现代码如下：
```cpp 
// 矩阵的新增转置
SparseMatrix SparseMatrix::Transpose() {
	// 重新定义
	vector<int> newLinVec(ElemNum);
	vector<int> newColVec(ElemNum);
	vector<DataType> newDataVec(ElemNum);
	// 和this->linVec对应并存储当前一行的初始化位置
	vector<int> curcol;
	for (int col : this->colVec) {
		curcol.push_back(this->ColIndex[col]);
	}
	// curcol 储存需要填写的首位置
	for (int n = 0; n < ElemNum; n++){
		// index : 对应的列在列数组中的下标
		int index = BSearchIndex(colVec, this->Elem[n].col); 
		// loc 为最终放置的位置
		int loc = curcol[index];
		// 行列转置
		newLinVec[loc] =  this->Elem[n].col;
		newColVec[loc] =  this->Elem[n].lin;
		newDataVec[loc] = this->Elem[n].data;
		curcol[index] += 1; // currentCol对应位置的下标加1
	}
	SparseMatrix Result( newLinVec, newColVec, newDataVec,this->size[1], this->size[0]); 
	return Result;
}
```

![[attachments/Sparse_Matrix.drawio.png|700]]
在矩阵累计完成之后，

````ad-caution
title:使用动态存储方法分配稀疏矩阵的相加和转置的比较完整的实现
collapse: close

下面使用哈希表unordered_map(而不是使用数组)存储每一行列的元素个数和转置后对应的下标

并使用向量存储矩阵的有元素的行和列
Header.h

```cpp
#pragma once
#ifndef HEADER
#define HEADER
#include <iostream>
#include <vector>
using namespace std;

// 在有序递增数组内,二分查找并返回对应下标, 要求是必须有对应的元素
int BSearchIndex(vector<int> vec, int elem) {
	if (vec.size() == 1) return 0;
	int l = 0, r = vec.size() - 1;
	if (vec[l] == elem) return l;
	if (vec[r] == elem) return r;
	int mid = l + (r - l) / 2;
	while (r - l > 1) {
		mid = l + (r - l) / 2;
		if (vec[mid] == elem) break;
		if (vec[mid] < elem) l = mid;
		else r = mid;
	}
	return mid;
}
#endif // !Header
```

主程序: 
```cpp 
#include <iostream>
#include <algorithm>
#include <vector> // 初始矩阵规模
#include "Header.h"
#include <unordered_map>
using namespace std;
typedef int DataType;

// 三元组
typedef struct MatCell {
	int lin;
	int col;
	DataType data;
};

// 稀疏矩阵
class SparseMatrix{
public:
	SparseMatrix(vector<int> linVec, vector<int> colVec, vector<DataType> elemVec){
		// 自动判断行，列数量, 给出非零元素的矩阵存储
		InitSparseMat(linVec, colVec, elemVec);  // 初始化矩阵
	};
	SparseMatrix(vector<int> linVec, vector<int> colVec, vector<DataType> elemVec, int linNum, int colNum) {
		size[0] = linNum;
		size[1] = colNum;
		InitSparseMat(linVec, colVec, elemVec);  // 初始化矩阵
	}
	
	int ElemNum = 0;		 // 元素个数
	int colNum = 0;
	int linNum = 0;
	int size[2] = {0,0};
	MatCell* Elem = nullptr; // 首先是空指针
	SparseMatrix Transpose();
	void ShowAllData();
	void ShowMatrix();
	
private:  // 使用数组存储
	vector<int> linVec;
	vector<int> colVec;
	void InitSparseMat(vector<int> linVec, vector<int> colVec, vector<DataType> NumVec);
	void SortSelf();
	unordered_map<int, int> LinCount, ColCount, ColIndex; // LinIndex
	// Count存储每一行有几个元素, Index存储每行第一个元素存储的下标,实际上是行元素的和
};

// 预处理冒泡排序,(需要ElemNum以及提前初始化)
void SparseMatrix::SortSelf() {
	if (linVec.size() == 1) return;  // 无需排序
	// 冒泡排序, 从后向前, 每一次将最大的交换到最后
	for (int i = ElemNum - 1; i > 0; i--) {
		for (int j = 0; j < i; j ++) {
			// 逐个交换元素(注意不能直接交换结构体,会出现内存释放的错误)
			if (Elem[j].lin > Elem[j+1].lin || (Elem[j].lin == Elem[j+1].lin)&&(Elem[j].col > Elem[j+1].col)){
				swap(Elem[j], Elem[j+1]);  // 调用C++自带的swap来进行交换
			}
		}
	}
}

// 初始化稀疏矩阵
void SparseMatrix::InitSparseMat(vector<int> linVec, vector<int> colVec, vector<DataType> NumVec) {
	// ====== 自动初始化最大行列 ======
	if (linVec.size() != colVec.size() || linVec.size() != NumVec.size() || linVec.size() == 0) {
		cout << "size initialized wrongly" << endl;
		throw - 1;
	}
	ElemNum = NumVec.size();
	// 赋值ElemNum; 
	if (size[0] == 0 && size[1] == 0) {
		// 自动判断最大行和最大列,并判断所有的行列加入到行列数组中
		size[0] = *max_element(linVec.begin(), linVec.end());
		size[1] = *max_element(colVec.begin(), colVec.end());
	}
	else {
		if (size[0] <= 0 || size[1] <= 0) { 
			cout << "Error in size initialization, check your input" << endl;
			throw - 1;
		}
	}

	// ====== 初始化数据并进行排序 ====
	Elem = new MatCell[ElemNum];   // 动态分配对应的空间
	for (int i = 0; i < ElemNum; i++) {
		Elem[i].lin = linVec[i];
		Elem[i].col = colVec[i];
		Elem[i].data = NumVec[i];
	}
	SortSelf(); // 对内部的预处理排序
	// 计算每一行的元素数量
	for (int i = 0; i < ElemNum; i++) {
		int lin = linVec[i], col = colVec[i];
		if (LinCount.find(lin) == LinCount.end()) {
;			this->linVec.push_back(lin);
			LinCount[lin] = 0;
		}
		LinCount[lin]++;
		if (ColCount.find(col) == ColCount.end()) {
			this->colVec.push_back(col);
			ColCount[col] = 0;
		}
		ColCount[col]++;
	}
	// 为了保证有序性, 应当先对linVec和colVec进行排序
	sort(this->linVec.begin(), this->linVec.end());
	sort(this->colVec.begin(), this->colVec.end());
	this->linNum = this->linVec.size();
	this->colNum = this->colVec.size();
	
	// 计算好每个元素放入数组的位置, 即LinIndex和ColIndex
	int linSum = 0, colSum = 0;
	/*
	for (int i = 0; i < linNum; i++) {
		int lin = this->linVec[i];
		LinIndex[lin] = linSum;
		linSum += LinCount[lin];
	}
	*/
	for (int i = 0; i < colNum; i++) {
		int col = this->colVec[i];
		ColIndex[col] = colSum;
		colSum += ColCount[col];
	}
}

// 矩阵的新增转置(注意优化的部分:可能转置部分的for循环需要进一步优化)
SparseMatrix SparseMatrix::Transpose() {
	// 重新定义
	vector<int> newLinVec(ElemNum);
	vector<int> newColVec(ElemNum);
	vector<DataType> newDataVec(ElemNum);
	// 和this->linVec对应并存储当前一行的初始化位置
	vector<int> curcol;
	for (int col : this->colVec) {
		curcol.push_back(this->ColIndex[col]);
	}
	// curcol 储存需要填写的首位置
	for (int n = 0; n < ElemNum; n++){
		// index : 对应的列在列数组中的下标
		int index = BSearchIndex(colVec, this->Elem[n].col); 
		// loc 为最终放置的位置
		int loc = curcol[index];
		// 行列转置
		newLinVec[loc] =  this->Elem[n].col;
		newColVec[loc] =  this->Elem[n].lin;
		newDataVec[loc] = this->Elem[n].data;
		curcol[index] += 1; // currentCol对应位置的下标加1
	}
	SparseMatrix Result( newLinVec, newColVec, newDataVec,this->size[1], this->size[0]); 
	return Result;
}

void SparseMatrix::ShowAllData() {
	cout << "============= Sparse Matrix ===============" << endl;
	cout << "size : (" << size[0] << "," << size[1] << ")" << endl;
	cout << "NoneZero Element Number : " << ElemNum <<endl;
	cout << "------------ matrix data ------------------" << endl; // 输出矩阵三元组
	for (int i = 0; i < ElemNum; i++) {
		cout << Elem[i].lin << " " << Elem[i].col << " " << Elem[i].data << endl;
	}
	cout << "-------  line : linecount ---------" << endl;
	for (int lin : this->linVec) cout << lin << " : " << LinCount[lin] << endl; // " : " << LinIndex[lin] << endl;
	cout << "------ column : columncnt : index ---------" << endl;
	for (int col : this->colVec) cout << col << " : " << ColCount[col] << " : " << ColIndex[col] << endl;
	cout << "================== end ====================" << endl;
}

void SparseMatrix::ShowMatrix() {
	for (int i = 0; i < ElemNum; i++) {
		cout << Elem[i].lin << " " << Elem[i].col << " " << Elem[i].data << endl;
	}
}

#pragma region MatFunctions
// 矩阵相加
SparseMatrix MatAdd(SparseMatrix A, SparseMatrix B) {
	int linNum = max(A.size[0], B.size[0]);
	int colNum = max(A.size[1], B.size[1]);
	vector <int> newLinVec;
	vector <int> newColVec;
	vector <int> newDataVec;
	int i = 0, j = 0, k = 0;
	// 分别构造一个新的linNum,colNum以及新的NumVec，再用这个重初始化一个新的稀疏矩阵作为结果
	while (i < A.ElemNum && j < B.ElemNum) {
		// 两个元素相加
		if (A.Elem[i].lin == B.Elem[j].lin && A.Elem[i].col == B.Elem[j].col) {
			DataType result = A.Elem[i].data + B.Elem[j].data;
			if (result != 0) {
				newLinVec.push_back(A.Elem[i].lin);
				newColVec.push_back(A.Elem[i].col);
				newDataVec.push_back(result);
				k++;
			} // 否则之后删除元素，k不自增
			i++, j++;  // i, j 后移
		}
		else if (A.Elem[i].lin < B.Elem[j].lin || (A.Elem[i].lin == B.Elem[j].lin && A.Elem[i].col < B.Elem[j].col)) {
			// 在对应位置放A元素的情况
			newLinVec.push_back(A.Elem[i].lin);
			newColVec.push_back(A.Elem[i].col);
			newDataVec.push_back(A.Elem[i].data);
			i++, k++;
		}
		else {
			newLinVec.push_back(B.Elem[j].lin);
			newColVec.push_back(B.Elem[j].col);
			newDataVec.push_back(B.Elem[j].data);
			j++, k++;
		}
	}
	while (i < A.ElemNum) {
		newLinVec.push_back(A.Elem[i].lin);
		newColVec.push_back(A.Elem[i].col);
		newDataVec.push_back(A.Elem[i].data);
		i++, k++;
	}
	while (j < B.ElemNum) {
		newLinVec.push_back(B.Elem[j].lin);
		newColVec.push_back(B.Elem[j].col);
		newDataVec.push_back(B.Elem[j].data);
		j++, k++;
	}
	SparseMatrix C(newLinVec, newColVec, newDataVec);
	return C;
}

#pragma endregion

int main() {
	vector<int> vec1 = { 3, 1, 1, 2 };
	vector<int> vec2 = { 6, 6, 5, 8 };
	vector<DataType> vec3 = { 9, 10, 3, 11 };
	SparseMatrix mat1(vec1, vec2, vec3);
	mat1.ShowAllData();
	SparseMatrix mat2 = mat1.Transpose();
	mat2.ShowAllData();
	return 0;
}
```
````

## 二、十字链表

矩阵乘法可以使用<mark style="background: transparent; color: yellow">十字链表</mark>进行求解，可以很方便地找到每一行和每一列
可以找到<mark style="background: transparent; color: yellow">此行的下一个元素和本列的下一个元素</mark>

首先使用一个向量存储每一行列的首元素
需要 `chead`指针指向当前元素的下一个元素


```cpp 
typedef int DataType;
typedef struct OLNode{
	int i,j;//元素的行标和列标
	int data;//元素的值
	struct OLNode * right,*down;//两个指针域
}OLNode;
```

`````ad-question
title: 原地算法和重新赋值
collapse: open
`````

## 三、广义表
定义$GL = (d_1, d_2 ,...... d_n)$为广义表
当广义表非空时， 其第一个元素$d_1$为表头，其余元素$d_2...d_n$**构成的广义表**为表尾

注意：例如$A =  (a, (b,c,d))$,则a的表尾是$((b,c,d))$

如果重复出现相同的元素，可以使用大写字母表示广义表并写成下列的广义表 :
$B = (A,A,D)$为元素为广义表的广义表

要求是<mark style="background: transparent; color: yellow">元素和广义表定义成同样的类型</mark>
![[attachments/Pasted image 20230406105911.png|400]]
![[attachments/Pasted image 20230406105811.png|200]]
表节点包括标志域(指向表头的指针域和指向表尾的指针域)
原子节点仅需标志域和值域（浪费的空间）

```cpp 
typedef enum ElemTag{
...
} ;

typedef 
typedef struct GLNode 
{
	ElemTag tag;
	union{ // 定义共用体, 其中各个变量的位置是互斥的，tag = 0为原子，而tag=1为广义表
		AtomType atom;  // 原子节点的值域
		struct Graph{
			struct GLNode* head, *tail;
		}
	}
}
```
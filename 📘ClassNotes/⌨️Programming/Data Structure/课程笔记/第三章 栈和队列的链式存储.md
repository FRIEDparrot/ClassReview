## ä¸€ã€æ ˆçš„é“¾å¼å­˜å‚¨å®šä¹‰æ–¹æ³•
### (1) ä¸åŒç§ç±»æ ˆçš„å®šä¹‰å’Œä½¿ç”¨
å¯¹äºæ ˆçš„è¿ç»­å­˜å‚¨çš„æ•°ç»„å®šä¹‰ï¼Œ å¯ä»¥å‚è€ƒ[[å¤ä¹  æ ˆå’Œé˜Ÿåˆ—|æ ˆçš„æ•°ç»„å®šä¹‰æ–¹æ³•]]

å¯¹äºæ ˆçš„é“¾å¼å­˜å‚¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥é“¾è¡¨çš„å¤´ç»“ç‚¹ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œ é¦–å…ˆï¼Œç©ºæ ˆçš„ `data = NULL` , è€Œç¬¬ä¸€æ¬¡å…¥æ ˆæ—¶ï¼Œä¸æ’å…¥å…ƒç´ ï¼Œä¹‹åå…¥æ ˆæ—¶ï¼Œä¼šä¿®æ”¹å¤´ç»“ç‚¹ä¸ºæ ˆé¡¶å…ƒç´ å¹¶ä¸”è¿”å›å¤´ç»“ç‚¹

å…¶ä¼˜ç‚¹æ˜¯åŠ¨æ€åˆ†é…å†…å­˜ï¼Œä¸å‡ºç°æ ˆæ»¡çš„æƒ…å†µ

å¦ä¸€ç§æ–¹æ³•æ˜¯ä»¥å¤´ç»“ç‚¹çš„nextèŠ‚ç‚¹ä½œä¸ºæ ˆé¡¶å…ƒç´ ï¼Œæ¯ä¸€æ¬¡è¿›æ ˆæ—¶åªéœ€è¦ä½¿ç”¨å¤´æ’æ³•æ’å…¥å…ƒç´ ï¼Œåˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼Œåªéœ€è¦çœ‹top-> next == NULL å³å¯

`````ad-note
title: å¯åˆ†é…å­˜å‚¨ç©ºé—´çš„è¿ç»­æ ˆä»£ç å®ç°
collapse: close

æœ€åˆåˆå§‹åŒ–top = -1
åœ¨åˆ†é…æ–°çš„ç©ºé—´æ—¶ï¼Œæ–°åˆ›å»ºæŒ‡é’ˆå¹¶å¤åˆ¶ä¸€ä»½å¯¹åº”çš„å…ƒç´ ç»™æ–°çš„æ•°ç»„

å¦å¤–ä¸‹é¢åœ¨æ ˆä¸­å†™å¥½äº†templateç±»å‹ï¼Œtemplate å‡½æ•°æ”¾åœ¨å¤–éƒ¨å®šä¹‰æ—¶ä¸€å®šè¦åœ¨æ¯ä¸ªå‡½æ•°å‰é¢éƒ½åŠ ä¸Štemplate
```cpp 
#include <iostream>
#define MAX_STACK_SIZE 100
#define STACK_SIZE_INCREASE 10
using namespace std;

template<class ElemType>
// é¡ºåºæ ˆç±»å‹
class SeqStack{
public:
	SeqStack() {
		InitSeqStack();
	};
	void push(ElemType elem);
	ElemType pop();
	bool isEmpty();
private:
	ElemType* Elem = new ElemType[MAX_STACK_SIZE];
	// åŸºäºæ•°ç»„çš„è¿ç»­å­˜å‚¨çš„æ ˆ
	void InitSeqStack();  // å°†å…¶ç§æœ‰åŒ–ï¼Œä½¿ç”¨æ—¶ç›´æ¥åˆå§‹åŒ–
	int top = -1;
	int size = MAX_STACK_SIZE;
};

template<class ElemType>
// åˆ›å»ºé¡ºåºæ ˆç±»å‹, topæŒ‡å‘çš„æ˜¯æ ˆçš„é¡¶éƒ¨å…ƒç´ 
void SeqStack<ElemType>::InitSeqStack(){ // æœ€åˆä½¿ç”¨top = -1æ¥æ„é€ ä¸€ä¸ªç©ºæ ˆ
	this->top = -1;
}

// å…¥æ ˆ
template<class ElemType>
void SeqStack<ElemType>::push(ElemType elem) {
	if (!this) return; // æ­¤æ—¶sä¸ºç©ºæŒ‡é’ˆ
	if (this->top < this->size-1) { // å¦‚æœæ ˆæ»¡ï¼Œåˆ™éœ€è¦é‡æ–°åˆ†é…ç©ºé—´æœ€å¤š98
		this->top++;
		this->Elem[this->top] = elem; // è®¿é—®å†…éƒ¨çš„
	}
	else { // é‡æ–°åˆ†é…ç©ºé—´ï¼Œç„¶åå¤åˆ¶ä¸€ä»½åŸå…ˆçš„æ•°ç»„ç»™æ–°çš„å¢åŠ çš„æ•°ç»„
		this->top++;
		this->size += STACK_SIZE_INCREASE;
		ElemType* s2 = new ElemType[this->size + STACK_SIZE_INCREASE];
		ElemType* p = this->Elem;
		for (int i = 0; i < this->size; i++) {
			s2[i] = this->Elem[i];
		}
		delete p;
		this->Elem = s2; // å°†æŒ‡é’ˆå€¼èµ‹å€¼ç»™s2;
		// ç”±äºæ˜¯æŒ‡é’ˆï¼Œä¸ç®—å±€éƒ¨å˜é‡
	}
}

// å‡ºæ ˆ
template<class ElemType>
ElemType SeqStack<ElemType>::pop() {
	// å¦‚æœæ ˆä¸ºç©ºï¼Œåˆ™è¿”å›ç©ºï¼Œä¸è¿›è¡Œpopæ“ä½œ
	if (this!=NULL && this->top != -1) {
		ElemType e = this->Elem[this->top];
		(this->top)--;
		return e;
	}
	else {
		return NULL; 
	}
}

// åˆ¤æ–­ä¸€ä¸ªæ ˆæ˜¯å¦ä¸ºç©º
template<class ElemType>
bool SeqStack<ElemType>::isEmpty(){
	return this->top == -1;
}

/* Test Code*/
int main() {
	SeqStack<int>* s1 = new SeqStack<int>();
	for (int i = 0; i < 250; i++) {
		s1->push(i);
	}
	cout << s1->pop() << endl;
	return 0;
}
```

`````

````ad-note
title: é“¾è¡¨å‹æ ˆçš„ä»£ç å®ç°
collapse:close

ä¸‹é¢çš„ä»£ç ç»™å‡ºäº†ä¸€ä¸ªé“¾è¡¨å­˜å‚¨ç±»å‹æ ˆçš„å®ç°

```cpp 
#include <iostream>
#include <vector>
using namespace std;
typedef int DataType;

// æ ˆï¼Œå…¶ä¸­å¤´ç»“ç‚¹ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œ å°¾ç»“ç‚¹ä¸ºæ ˆåº•å…ƒç´ 
typedef struct stack{
	// å¯¹äºé“¾å¼å­˜å‚¨çš„æ ˆï¼Œä¸å­˜åœ¨æº¢å‡ºçš„æƒ…å†µ
	stack* next = NULL;
	DataType data = NULL;
};

// æ’å…¥å¹¶æ›´æ–°å¤´ç»“ç‚¹ä¸ºæ–°çš„æ ˆé¡¶
stack* push(stack* top, DataType data) { 
	if (top->data == NULL) {
		top->data = data; // æœ€ä¸‹é¢çš„ä¸€ä¸ªçš„nextå¿…å®šä¸ºnull
	}
	else {
		stack* Node = new stack();
		Node->next = top;
		Node->data = data; // æ³¨æ„èµ‹å€¼
		top = Node;
	}
	return top;
}

stack* pop(stack* top, DataType* data) {
	// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œå¹¶ä½¿ç”¨æŒ‡é’ˆå°†å‡ºæ ˆå…ƒç´ æ›´æ–°åˆ°dataä¸­
	if (top->data == NULL) { // ç©ºæ ˆ
		cout << "pop failed!" << endl;
	} 
	else if (top->next == NULL) {
		(*data) = top->data;
		top->data = NULL;
	}
	else{
		(*data) = top->data;
		stack* p = top;
		top = top->next;
		delete p; // é‡Šæ”¾pæŒ‡é’ˆçš„å†…å­˜ç©ºé—´, newå¯¹è±¡ä½¿ç”¨deleteè¿›è¡Œé‡Šæ”¾
	}
	return top;
}

int main() {
	int s1, s2;
	cin >> s1 >> s2;
	vector<int> v1, v2; // æ³¨æ„å‘é‡åˆå§‹åŒ–æ—¶ï¼Œä¸ç”¨å…ˆåˆ†é…
	int input;
	for (int i = 0; i < s1; i++) {
		cin >> input;
		v1.push_back(input);
	}
	for (int i = 0; i < s2; i++) {
		cin >> input;
		v2.push_back(input);
	}

	stack* T = new stack();  // æ–°å»ºä¸€ä¸ªstackç»“æ„ä½“

	for (int i = 0, j = 0; !(s1 == i && s2 == j);){
		if (i == s1) {
			T = push(T, v2[j]); j++;
		}
		else if (j ==  s2) {
			T = push(T, v1[i]); i++;
		}
		else {
			if (v1[i] < v2[j]) {
				T = push(T, v1[i]); i++;
			}
			else {
				T = push(T, v2[j]); j++;
			}
		}
	}

	DataType output;
	for (int i = 0; i < s1 + s2; i++) {
		T = pop(T, &output);
		cout << output << " ";
	}
	return 0;
}
```
````

`````ad-note
title:å¸¦æœ‰templateçš„é“¾æ ˆä»£ç 
collapse:close
```cpp 
#include <iostream>
#include <vector>
using namespace std;

template <typename DataType>
struct Stack { // å®šä¹‰ç±»å‹ï¼Œä¸‹é¢çš„stackæ˜¯å®ä¾‹åŒ–ç”¨çš„
	// å¯¹äºé“¾å¼å­˜å‚¨çš„æ ˆï¼Œä¸å­˜åœ¨æº¢å‡ºçš„æƒ…å†µ
	Stack* next = NULL;
	DataType data = NULL;
};

// æ ˆï¼Œä¸å¸¦å¤´ç»“ç‚¹ï¼Œå¤´æŒ‡é’ˆä¸ºæ ˆé¡¶å…ƒç´ ï¼Œ å°¾ç»“ç‚¹ä¸ºæ ˆåº•å…ƒç´ 
template <class DataType>
class LinkStack { // ä¹‹åè€ƒè™‘é‡è½½é—®é¢˜
public:
	LinkStack() {
		InitStack();
	};
	void push(DataType data);
	DataType pop();
	// åœ¨ç±»å†…å®šä¹‰æ ˆ
private:
	Stack<DataType>* top = NULL;  // å®šä¹‰ä¸€ä¸ªæ ˆé¡¶æŒ‡é’ˆ
	void InitStack();
};

template <class DataType>
void LinkStack<DataType>::InitStack() {
	this->top = new Stack<DataType>; // nextå’Œdataè‡ªåŠ¨åˆå§‹åŒ–ä¸ºNULL
}

// æ’å…¥å¹¶æ›´æ–°å¤´ç»“ç‚¹ä¸ºæ–°çš„æ ˆé¡¶
template <class DataType>
void LinkStack<DataType>::push(DataType data) {
	if (top->data == NULL) {
		top->data = data; // æœ€ä¸‹é¢çš„ä¸€ä¸ªçš„nextå¿…å®šä¸ºnull
	}
	else {
		Stack<DataType>* Node = new Stack<DataType>();
		Node->next = top;
		Node->data = data; // æ³¨æ„èµ‹å€¼
		top = Node;
	}
}

template <class DataType>
DataType LinkStack<DataType>::pop() {
	// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œå¹¶ä½¿ç”¨æŒ‡é’ˆå°†å‡ºæ ˆå…ƒç´ æ›´æ–°åˆ°dataä¸­
	if (top->data == NULL) return NULL; // ç©ºæ ˆ
	else if (top->next == NULL){ // åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œè¿›è¡Œå¼¹å‡º
		DataType data = top->data;
		top->data = NULL;
		return data;
	}
	else{
		DataType data = top->data;
		Stack<DataType>* p = top;
		top = top->next;
		delete p; // é‡Šæ”¾pæŒ‡é’ˆçš„å†…å­˜ç©ºé—´, newå¯¹è±¡ä½¿ç”¨deleteè¿›è¡Œé‡Šæ”¾
		return data;
	}
}

int main() {
	LinkStack<int> T;  // æ–°å»ºä¸€ä¸ªstackç»“æ„ä½“
	for (int i = 0; i < 100; i++) {
		T.push(i);
	}
	for (int i = 0; i < 100; i++) {
		cout << T.pop() << " ";
	}
	return 0;
}

```
`````

å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ ä¸Šè¿°æ–¹æ³•å®šä¹‰çš„æ˜¯ä¸å¸¦å¤´ç»“ç‚¹çš„æ ˆï¼Œå¦‚æœå®šä¹‰å¸¦æœ‰å¤´ç»“ç‚¹çš„æ ˆï¼Œ åˆ™å¾€å¾€`top -> next`æŒ‡å‘æ ˆé¡¶çš„å…ƒç´ ï¼Œ`top`æŒ‡å‘æ ˆé¡¶çš„ä¸‹ä¸€ä¸ªå…ƒç´ 

åœ¨c++ä¸­ï¼Œå®šä¹‰æ ˆåªéœ€è¦ä½¿ç”¨`#include<stack>` å°±å¯ä»¥äº†ï¼Œ å¹¶ä½¿ç”¨
`stack<int> s1`æ¥å®šä¹‰æ ˆ

å¾€å¾€å¯ä»¥ä½¿ç”¨`copy`çš„æ–¹æ³•æ¥å¤åˆ¶æ ˆä¸­çš„å…ƒç´ ç„¶åé‡æ–°åˆ†é…æ ˆç©ºé—´ï¼Œ å¦‚

```cpp 
int main() {
	int a[3] = { 1,2,3 };
	int b[5];
	std::copy(begin(a), end(a), begin(b));
	cout << b[0];
	return 0;
}
```

### (2) å¤šæ ˆå…±äº«æŠ€æœ¯
å¯¹äºè¿ç»­å­˜å‚¨çš„æ ˆï¼Œä¸ºäº†é˜²æ­¢ç”±äºå¯¹æ ˆçš„ç©ºé—´ä¼°è®¡ä¸è¶³ä¸ºå¯¼è‡´çš„æ ˆçš„æº¢å‡ºï¼Œå¯ä»¥ä½¿ç”¨å¤šä¸ªæ ˆæ¥å…±äº«ä¸€ä¸ªè¶³å¤Ÿå¤§çš„æ•°ç»„ç©ºé—´ï¼Œé€šè¿‡åˆ©ç”¨æ ˆçš„åŠ¨æ€ç‰¹æ€§è¿›è¡Œå­˜å‚¨ç©ºé—´ç›¸äº’è¡¥å……

```cpp 
#define MAZ_STACK_SIZE 100
typedef struct DStack{
DataType Stack[MAX_STACK_SIZE];
int top[2] = {-1, M}; // å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ, åˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªæ ˆé¡¶, å…¶ä¸­top[0]ä¸º0å·æ ˆ, [1]ä¸º1å·æ ˆ
}

void InitStack(DStack* stack){
	S->top[0] = -1; // 0å·æ ˆ
	S->top[1] = M; // 1å·æ ˆçš„æ ˆåº•ä¸ºM
}

// å¯¹äºåˆ¤æ–­æ ˆå·²æ»¡çš„æ“ä½œï¼Œåªéœ€è¦åˆ¤æ–­:
S->top[0] + 1 == S->top[1];
```

### (3) é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼çš„å®ç°æ–¹æ³•
#### 1. é€†æ³¢å…°è¡¨è¾¾å¼çš„æ„é€ 
æ³¨æ„è¾“å…¥ä¸€æ•´è¡Œæ•°å¯ä»¥ä½¿ç”¨
`getline(cin, s);`
æ¥è¿›è¡Œå®ç°
ä¸€è¡Œè¾“å…¥å¤šä¸ªæ•°å­—åˆ°ç©ºæ ¼ä¹‹åbreak:
```cpp 
while (cin >> input){
		Que.push(input);
		if (cin.get() == '\n') break;
	}
```

é€†æ³¢å…°è¡¨è¾¾å¼çš„ç»“æ„ä¸º : 

| ä¸­ç¼€è¡¨è¾¾å¼         | é€†æ³¢å…°è¡¨è¾¾å¼    |
|---------------|-----------|
| A + B         | A B +     |
| A * B         | A B *     |
| A +B * C      | A B C * + |
| A * ( B + C ) | A B C + * |

æ„é€ æ–¹æ³•å‚è€ƒå¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç«  
[é€†æ³¢å…°è¡¨è¾¾å¼](https://www.cnblogs.com/lanhaicode/p/10776166.html)

æ¯ä¸€æ¬¡ï¼Œå¯¹äºå³æ‹¬å·å‡ºç°æ—¶ï¼Œæ‰¾åˆ°æœ€è¿‘çš„å·¦æ‹¬å·ï¼Œå¹¶å°†å·¦å³æ‹¬å·å†…çš„éƒ¨åˆ†å¼¹å‡ºæ ˆsignStk

æˆ‘ä»¬ä»¥å¦‚ä¸‹çš„è¡¨è¾¾å¼è®¡ç®—ä¸ºä¾‹ï¼š
$$a * b+ c +(d*e+f*g) *h$$
[[Reverse_Poland_Expression.jpg|è¿‡ç¨‹å‚è€ƒ]]
åˆ™å¾—å‡ºçš„é€†æ³¢å…°è¡¨è¾¾å¼ä¸ºï¼š 
$$ab*cde*fg+h*++$$
åœ¨signæ ˆå‡ºæ ˆå’Œå…¥æ ˆçš„è¿‡ç¨‹ä¸­ï¼Œåœ¨signä¸­çš„æ“ä½œæ•°ï¼Œ<mark style="background: transparent; color: yellow">è¶Šé è¿‘æ ˆé¡¶ï¼Œä¼˜å…ˆçº§è¶Šé«˜</mark>ï¼Œä¸è¿‡ä»…é™äºå·¦æ‹¬å·åé¢çš„éƒ¨åˆ†

å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé‡åˆ°è¿ç®—ç¬¦æ¯”è¿™ä¸ªé«˜çš„éƒ¨åˆ†(å³ä¸Šè¿°è¿‡ç¨‹ä¸­çš„ç¬¬1, 2æ­¥)ï¼Œåˆ™<mark style="background: transparent; color: yellow">å°†å‰é¢å…¨éƒ¨ä¼˜å…ˆçº§æ›´ä½çš„è¿ç®—ç¬¦å…¨éƒ¨å‡ºæ ˆï¼Œç„¶åå°†è‡ªå·±å…¥æ ˆ</mark>ï¼Œä½†æ˜¯é‡åˆ°å·¦æ‹¬å·æ—¶ï¼Œä¸ç”¨æ‰§è¡Œå‡ºæ ˆæ“ä½œ ã€‚

å¯ä»¥ç»™å¦å¤–ä¸€ä¸ªæ³¢å…°è¡¨è¾¾å¼çš„æ±‚å€¼ç¤ºä¾‹
$$5 ^ 3 + 2 * 1$$
æ ˆåˆ†åˆ«ä¸º

| num  | 5   | ^   | 3   | 2   | 1   | 
| ---- | --- | --- | --- | --- | --- |
| sign | +   | *   |     |     |     |

å‡ºæ ˆåçš„é€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼ä¸ºï¼š 

| num  | 5   | ^   | 3   | 2   | 1   | *   | +   |
| ---- | --- | --- | --- | --- | --- | --- | --- |
| sign |     |     |     |     |     |     |     |

`````ad-note
title: å°†è¡¨è¾¾å¼è½¬æ¢ä¸ºé€†æ³¢å…°è¡¨è¾¾å¼çš„ä»£ç ç¤ºä¾‹
collapse: close
å…¶ä¸­è¿ç®—å˜é‡ä»¥a,b,cç­‰ç­‰è¡¨ç¤º
```cpp 
#include<iostream>
#include<stack>
#include<string>
#include<unordered_map>
using namespace std;

// ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å¯¹åº”çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§
unordered_map<char, int> Priority = {
	{'+',1},
	{'-',1},
	{'*',2},
	{'/',2},
	{'^',3},
	{'(',4},
	{')',4}
};

int main() {
	string s;
	getline(cin, s);
	stack<char> numStk, signStk;
	for (char ch : s) { 
		// è¿›è¡Œå…¥æ ˆå’Œå‡ºæ ˆæ“ä½œ, è¾“å‡ºé€†æ³¢å…°è¡¨è¾¾å¼
		if (ch >= 97 && ch <= 122) { 
			// å­—ç¬¦a-z 
			numStk.push(ch);  // æ”¾å…¥æ•°å­—
		}
		else if (Priority.count(ch)) {
			// è¾“å…¥çš„éƒ¨åˆ†ä¸ºè¿ç®—ç¬¦, æ³¨æ„æ ˆæœ‰å¯èƒ½æ˜¯ç©ºçš„
			if (signStk.empty()) {
				signStk.push(ch);
			}
			else if (ch == ')') {  // é¦–å…ˆåˆ¤æ–­å³æ‹¬å·
				while (signStk.top() != '(') {
					numStk.push(signStk.top());
					signStk.pop();
				}
				signStk.pop(); // å‡ºæ ˆ(å¹¶èˆå¼ƒ
			}
			else if (Priority[ch] < Priority[signStk.top()]) {
				// å‰ä¸€ä¸ªè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§åˆ«æ¯”è¿™ä¸ªå¤§ï¼Œåˆ™æŒç»­å‡ºæ ˆç›´åˆ°é‡åˆ°å·¦æ‹¬å·
				while (!signStk.empty() && signStk.top() != '(') {
					numStk.push(signStk.top());
					signStk.pop();
				}
				// ç„¶åè¿™ä¸ªè¿ç®—ç¬¦å…¥æ ˆ
				signStk.push(ch);
			}
			else {
				signStk.push(ch); // è¿ç®—ç¬¦å…¥æ ˆ
			}
		}
	}
	// è¡¨è¾¾å¼éå†å®Œæ¯•åï¼Œå¯¹è¿ç®—ç¬¦æ ˆå†…çš„éƒ¨åˆ†è¿›è¡Œå‡ºæ ˆ
	while (!signStk.empty()) {
		numStk.push(signStk.top());
		signStk.pop();
	}

	stack<char> preStk;

	while (!numStk.empty()) {
		preStk.push(numStk.top());
		numStk.pop();
	}

	while (!preStk.empty()) {
		cout << preStk.top();
		preStk.pop();
	}
	return 0;
}
```

`````

#### 2. æœ‰æ•ˆè¡¨è¾¾å¼çš„åˆ¤æ–­ä»£ç ç¤ºä¾‹
è§é—®é¢˜[[å­—ç¬¦ä¸²çš„æ‹¬å·åŒ¹é…é—®é¢˜]]

#### 3. é€†æ³¢å…°è¡¨è¾¾å¼çš„è¿ç®—

åœ¨è®¡ç®—è¿™äº›è¡¨è¾¾å¼çš„å€¼æ—¶ï¼Œé€šè¿‡å°†æ•°å­—å…¥æ ˆï¼Œé‡åˆ°**è¿ç®—ç¬¦**ååœ¨æŠŠæ•°å­—å‡ºæ ˆï¼Œ**è®¡ç®—**ï¼Œè®¡ç®—å®Œå†æ¬¡å…¥æ ˆã€‚ä¸€ç›´å¾ªç¯â€¦â€¦
![[attachments/Pasted image 20230324195855.png|500]]

## äºŒã€é˜Ÿåˆ—çš„é“¾å¼å®šä¹‰æ–¹æ³•
### (1) è¿ç»­å­˜å‚¨çš„é˜Ÿåˆ—å®šä¹‰æ–¹æ³•
åœ¨è¿ç»­å­˜å‚¨çš„é˜Ÿåˆ—å®šä¹‰ä¸­ï¼Œä¼šå®šä¹‰ä¸€ä¸ªfronté˜Ÿé¦–æ•°å­—å’Œä¸€ä¸ªrearé˜Ÿå°¾æ•°å­—
å…¶ä¸­font è¡¨ç¤º**é˜Ÿé¦–çš„å…ƒç´ **, rearè¡¨ç¤º**é˜Ÿå°¾å…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ **
å› æ­¤å¯ä»¥ç›´æ¥é€šè¿‡frontæ¥è¿›è¡Œè®¿é—®
[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/Data Structure/è¯¾ç¨‹ç¬”è®°/åŸºç¡€çŸ¥è¯†/å¤ä¹  æ ˆå’Œé˜Ÿåˆ—#ä¸€ã€é˜Ÿåˆ—|è¿ç»­å­˜å‚¨é˜Ÿåˆ—çš„å®šä¹‰]]

`````ad-summary
title:å¸¦templateçš„é“¾å¼é˜Ÿåˆ—å®šä¹‰
collapse:close

```cpp 
#include <iostream>
#define MAX_QUEUE_SIZE 100
using namespace std;

// æ³¨æ„: é€šè¿‡æ­¤ç§æ–¹å¼å®šä¹‰çš„è¿ç»­å­˜å‚¨çš„é˜Ÿåˆ—å¯èƒ½ä¼šäº§ç”Ÿæº¢å‡ºæƒ…å†µ
template <typename DataType>
struct queueNode {
	// é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨
	DataType* Data = new DataType[MAX_QUEUE_SIZE];
	int rear;
	int front;
};

template <class DataType>
class SeqQueue{
public:
	SeqQueue() {
		InitQueue();
	}
	bool IsEmpty();
	void push(DataType data);
	void ClearQueue();
	int GetQueueLength();
	DataType pop();

private:
	void InitQueue();
	queueNode<DataType> queue;
};

template <class DataType>
void SeqQueue<DataType>::InitQueue() { 
	// åˆå§‹åŒ–é“¾å¼å­˜å‚¨çš„é˜Ÿåˆ—
	queue.front = 0;
	queue.rear = 0;
	// å…¶ä¸­front = rearæ—¶,é˜Ÿåˆ—ä¸ºç©º
}

template <class DataType>
int SeqQueue<DataType>::GetQueueLength() {
	return queue.rear - queue.front;
}

template <class DataType>
void SeqQueue<DataType>::ClearQueue() { 
	// æ¸…ç©ºé˜Ÿåˆ—
	queue->front = 0;
	queue->rear = 0;
}

template <class DataType>
bool SeqQueue<DataType>::IsEmpty() {
	return queue.rear == queue.front;
}

template <class DataType>
void SeqQueue<DataType>::push(DataType data) {
	if (queue.rear < MAX_QUEUE_SIZE -1 ) {
		queue.Data[queue.rear++] = data;
	}
}

template <class DataType>
DataType SeqQueue<DataType>::pop() {
	if (IsEmpty()) return NULL; // ç©ºé˜Ÿï¼Œç›´æ¥è¿”å›
	else {
		return queue.Data[queue.front++];
	}
}

int main() {
	SeqQueue<int> q;
	cout << q.IsEmpty()<< endl;
	for (int i = 0; i < 20; i++) {
		q.push(i);
	}
	cout << q.GetQueueLength() << endl;
	for (int i = 0; i < 20; i++) {
		cout << q.pop() << " ";
	}
	cout << endl;
	cout << q.IsEmpty() << endl;
	return 0;
}
```

`````

### (2) å¾ªç¯é˜Ÿåˆ—éƒ¨åˆ†
å¯¹äºå¾ªç¯é˜Ÿåˆ—çš„å®šä¹‰ï¼Œåœ¨é˜Ÿåˆ—æ»¡æ—¶ï¼Œrear = front, é˜Ÿåˆ—ç©ºæ—¶ï¼Œrear = front ï¼Œ åˆ™åœ¨pushæ—¶éœ€è¦è¿›è¡Œåˆ¤æ–­é˜Ÿä¼ç©ºè¿˜æ˜¯é˜Ÿä¼æ»¡

æ–¹æ³•ä¸€æ˜¯æµªè´¹ä¸€ä¸ªç©ºé—´æ¥è¿›è¡Œåˆ¤æ–­ï¼Œ å³ $(rear+1)\%size = front$ æ—¶ä¸ºé˜Ÿæ»¡ï¼Œè€Œ$rear =front$æ—¶é˜Ÿç©º

æ–¹æ³•äºŒæ˜¯åœ¨æ€»ç»“æ„ä½“ä¸­å®šä¹‰lengthæ¥å­˜å‚¨ç›®å‰é˜Ÿä¼ä¸­çš„å…ƒç´ ä¸ªæ•°

ä¸¤ç§æ–¹æ³•å‡éœ€è¦ä½¿ç”¨å¤šä½™çš„ä¸€ä¸ªç©ºé—´ï¼Œä¸è¿‡åœ¨æ—¶é—´ä¸Šç¬¬äºŒç§æ¯æ¬¡éœ€è¦è¿ç®—é•¿åº¦

### (3) é“¾å¼å­˜å‚¨çš„é˜Ÿåˆ—å®šä¹‰æ–¹æ³•

é“¾å¼å­˜å‚¨çš„é˜Ÿåˆ—åœ¨èŠ‚ç‚¹ç»“æ„ä½“ä¸­ä»…å®šä¹‰ä¸€ä¸ªnextæŒ‡é’ˆ, å½¢æˆå•å‘é“¾è¡¨çš„æ ¼å¼
è€Œåœ¨ç»“æ„ä½“å¼çš„å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦å¦å¤–å®šä¹‰ä¸€ä¸ªç»“æ„ä½“å­˜å‚¨é˜Ÿé¦–å’Œé˜Ÿå°¾å³å¯

```cpp 
typedef struct Node{
DataType data;
struct *next;
};

typedef struct LinkQueue{
Node *font;
Node *rear;
};
```

æ­¤å¤„ä½¿ç”¨class ä¸­çš„ç§æœ‰å˜é‡å®šä¹‰é˜Ÿé¦–å’Œé˜Ÿå°¾æŒ‡é’ˆ

`````ad-summary
title: ç±»å®šä¹‰ä»£ç 
collapse: close
rearæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ 
```cpp 
#include <iostream>
using namespace std;

template <typename DataType>
struct QueueNode {
	DataType data = NULL;
	QueueNode* next = NULL; // å­˜å‚¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
};

template <class DataType>
class LinkQueue {
public:
	LinkQueue() {
		InitQueue();
	}
	void push(DataType data);
	DataType pop();
	bool IsEmpty();
	DataType GetHead();

private:
	void InitQueue();
	QueueNode<DataType>* front;
	QueueNode<DataType>* rear;
};

// ä½¿ç”¨å¸¦å¤´ç»“ç‚¹çš„æ–¹å¼è¿›è¡Œåˆå§‹åŒ–
template <class DataType>
void LinkQueue<DataType>::InitQueue() {
	front = new QueueNode<DataType>(); // ä½¿ç”¨é¢å¤–çš„å¤´æŒ‡é’ˆ
	rear = front; // å¤´æŒ‡é’ˆå’Œå°¾æŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªèŠ‚ç‚¹
	// front->next = NULL: åˆå§‹åŒ–æŒ‡é’ˆä¸ºNULL
}

// å…¥é˜Ÿï¼ŒrearæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ 
template <class DataType>
void LinkQueue<DataType>::push(DataType data) {
	QueueNode<DataType>* Q = new QueueNode<DataType>(); //
	rear ->next = Q;
	rear = rear->next;
	rear ->data = data;
}

// å‡ºé˜Ÿï¼Œhead-> nextä¸ºå¤´å…ƒç´ 
template <class DataType>
DataType LinkQueue<DataType>::pop() {
	// å®é™…popçš„dataåº”è¯¥æ˜¯front-> next -> data
	QueueNode<DataType>* Q = front;
	front = front->next;
	DataType data = front->data;
	delete Q;
	front->data = NULL; // è®¾ç½®ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸ºå¤´ç»“ç‚¹
	return data;
}

template <class DataType>
bool LinkQueue<DataType>::IsEmpty() {
	return rear == front;
}

template <class DataType>
DataType LinkQueue<DataType>::GetHead() { 
	// è®¿é—®é˜Ÿé¦–å…ƒç´ 
	if (!front->next) return NULL;  // ç©ºé˜Ÿ
	return front->next->data;
}

int main() {
	LinkQueue<int> Q;
	for (int i = 0; i < 100; i++) {
		Q.push(i);
	}

	for (int i = 0; i < 100; i++) {
		cout << Q.pop() << " ";
	}
	return 0;
}
```

`````
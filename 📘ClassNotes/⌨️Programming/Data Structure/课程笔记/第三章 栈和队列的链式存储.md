## 一、栈的链式存储定义方法
### (1) 不同种类栈的定义和使用
对于栈的连续存储的数组定义， 可以参考[[复习 栈和队列|栈的数组定义方法]]

对于栈的链式存储，我们可以以链表的头结点为栈顶元素， 首先，空栈的 `data = NULL` , 而第一次入栈时，不插入元素，之后入栈时，会修改头结点为栈顶元素并且返回头结点

其优点是动态分配内存，不出现栈满的情况

另一种方法是以头结点的next节点作为栈顶元素，每一次进栈时只需要使用头插法插入元素，判断栈是否为空，只需要看top-> next == NULL 即可

`````ad-note
title: 可分配存储空间的连续栈代码实现
collapse: close

最初初始化top = -1
在分配新的空间时，新创建指针并复制一份对应的元素给新的数组

另外下面在栈中写好了template类型，template 函数放在外部定义时一定要在每个函数前面都加上template
```cpp 
#include <iostream>
#define MAX_STACK_SIZE 100
#define STACK_SIZE_INCREASE 10
using namespace std;

template<class ElemType>
// 顺序栈类型
class SeqStack{
public:
	SeqStack() {
		InitSeqStack();
	};
	void push(ElemType elem);
	ElemType pop();
	bool isEmpty();
private:
	ElemType* Elem = new ElemType[MAX_STACK_SIZE];
	// 基于数组的连续存储的栈
	void InitSeqStack();  // 将其私有化，使用时直接初始化
	int top = -1;
	int size = MAX_STACK_SIZE;
};

template<class ElemType>
// 创建顺序栈类型, top指向的是栈的顶部元素
void SeqStack<ElemType>::InitSeqStack(){ // 最初使用top = -1来构造一个空栈
	this->top = -1;
}

// 入栈
template<class ElemType>
void SeqStack<ElemType>::push(ElemType elem) {
	if (!this) return; // 此时s为空指针
	if (this->top < this->size-1) { // 如果栈满，则需要重新分配空间最多98
		this->top++;
		this->Elem[this->top] = elem; // 访问内部的
	}
	else { // 重新分配空间，然后复制一份原先的数组给新的增加的数组
		this->top++;
		this->size += STACK_SIZE_INCREASE;
		ElemType* s2 = new ElemType[this->size + STACK_SIZE_INCREASE];
		ElemType* p = this->Elem;
		for (int i = 0; i < this->size; i++) {
			s2[i] = this->Elem[i];
		}
		delete p;
		this->Elem = s2; // 将指针值赋值给s2;
		// 由于是指针，不算局部变量
	}
}

// 出栈
template<class ElemType>
ElemType SeqStack<ElemType>::pop() {
	// 如果栈为空，则返回空，不进行pop操作
	if (this!=NULL && this->top != -1) {
		ElemType e = this->Elem[this->top];
		(this->top)--;
		return e;
	}
	else {
		return NULL; 
	}
}

// 判断一个栈是否为空
template<class ElemType>
bool SeqStack<ElemType>::isEmpty(){
	return this->top == -1;
}

/* Test Code*/
int main() {
	SeqStack<int>* s1 = new SeqStack<int>();
	for (int i = 0; i < 250; i++) {
		s1->push(i);
	}
	cout << s1->pop() << endl;
	return 0;
}
```

`````

````ad-note
title: 链表型栈的代码实现
collapse:close

下面的代码给出了一个链表存储类型栈的实现

```cpp 
#include <iostream>
#include <vector>
using namespace std;
typedef int DataType;

// 栈，其中头结点为栈顶元素， 尾结点为栈底元素
typedef struct stack{
	// 对于链式存储的栈，不存在溢出的情况
	stack* next = NULL;
	DataType data = NULL;
};

// 插入并更新头结点为新的栈顶
stack* push(stack* top, DataType data) { 
	if (top->data == NULL) {
		top->data = data; // 最下面的一个的next必定为null
	}
	else {
		stack* Node = new stack();
		Node->next = top;
		Node->data = data; // 注意赋值
		top = Node;
	}
	return top;
}

stack* pop(stack* top, DataType* data) {
	// 栈顶元素出栈，并使用指针将出栈元素更新到data中
	if (top->data == NULL) { // 空栈
		cout << "pop failed!" << endl;
	} 
	else if (top->next == NULL) {
		(*data) = top->data;
		top->data = NULL;
	}
	else{
		(*data) = top->data;
		stack* p = top;
		top = top->next;
		delete p; // 释放p指针的内存空间, new对象使用delete进行释放
	}
	return top;
}

int main() {
	int s1, s2;
	cin >> s1 >> s2;
	vector<int> v1, v2; // 注意向量初始化时，不用先分配
	int input;
	for (int i = 0; i < s1; i++) {
		cin >> input;
		v1.push_back(input);
	}
	for (int i = 0; i < s2; i++) {
		cin >> input;
		v2.push_back(input);
	}

	stack* T = new stack();  // 新建一个stack结构体

	for (int i = 0, j = 0; !(s1 == i && s2 == j);){
		if (i == s1) {
			T = push(T, v2[j]); j++;
		}
		else if (j ==  s2) {
			T = push(T, v1[i]); i++;
		}
		else {
			if (v1[i] < v2[j]) {
				T = push(T, v1[i]); i++;
			}
			else {
				T = push(T, v2[j]); j++;
			}
		}
	}

	DataType output;
	for (int i = 0; i < s1 + s2; i++) {
		T = pop(T, &output);
		cout << output << " ";
	}
	return 0;
}
```
````

`````ad-note
title:带有template的链栈代码
collapse:close
```cpp 
#include <iostream>
#include <vector>
using namespace std;

template <typename DataType>
struct Stack { // 定义类型，下面的stack是实例化用的
	// 对于链式存储的栈，不存在溢出的情况
	Stack* next = NULL;
	DataType data = NULL;
};

// 栈，不带头结点，头指针为栈顶元素， 尾结点为栈底元素
template <class DataType>
class LinkStack { // 之后考虑重载问题
public:
	LinkStack() {
		InitStack();
	};
	void push(DataType data);
	DataType pop();
	// 在类内定义栈
private:
	Stack<DataType>* top = NULL;  // 定义一个栈顶指针
	void InitStack();
};

template <class DataType>
void LinkStack<DataType>::InitStack() {
	this->top = new Stack<DataType>; // next和data自动初始化为NULL
}

// 插入并更新头结点为新的栈顶
template <class DataType>
void LinkStack<DataType>::push(DataType data) {
	if (top->data == NULL) {
		top->data = data; // 最下面的一个的next必定为null
	}
	else {
		Stack<DataType>* Node = new Stack<DataType>();
		Node->next = top;
		Node->data = data; // 注意赋值
		top = Node;
	}
}

template <class DataType>
DataType LinkStack<DataType>::pop() {
	// 栈顶元素出栈，并使用指针将出栈元素更新到data中
	if (top->data == NULL) return NULL; // 空栈
	else if (top->next == NULL){ // 只有一个元素，进行弹出
		DataType data = top->data;
		top->data = NULL;
		return data;
	}
	else{
		DataType data = top->data;
		Stack<DataType>* p = top;
		top = top->next;
		delete p; // 释放p指针的内存空间, new对象使用delete进行释放
		return data;
	}
}

int main() {
	LinkStack<int> T;  // 新建一个stack结构体
	for (int i = 0; i < 100; i++) {
		T.push(i);
	}
	for (int i = 0; i < 100; i++) {
		cout << T.pop() << " ";
	}
	return 0;
}

```
`````

另外需要注意的是， 上述方法定义的是不带头结点的栈，如果定义带有头结点的栈， 则往往`top -> next`指向栈顶的元素，`top`指向栈顶的下一个元素

在c++中，定义栈只需要使用`#include<stack>` 就可以了， 并使用
`stack<int> s1`来定义栈

往往可以使用`copy`的方法来复制栈中的元素然后重新分配栈空间， 如

```cpp 
int main() {
	int a[3] = { 1,2,3 };
	int b[5];
	std::copy(begin(a), end(a), begin(b));
	cout << b[0];
	return 0;
}
```

### (2) 多栈共享技术
对于连续存储的栈，为了防止由于对栈的空间估计不足为导致的栈的溢出，可以使用多个栈来共享一个足够大的数组空间，通过利用栈的动态特性进行存储空间相互补充

```cpp 
#define MAZ_STACK_SIZE 100
typedef struct DStack{
DataType Stack[MAX_STACK_SIZE];
int top[2] = {-1, M}; // 定义两个指针, 分别指向两个栈顶, 其中top[0]为0号栈, [1]为1号栈
}

void InitStack(DStack* stack){
	S->top[0] = -1; // 0号栈
	S->top[1] = M; // 1号栈的栈底为M
}

// 对于判断栈已满的操作，只需要判断:
S->top[0] + 1 == S->top[1];
```

### (3) 逆波兰表达式求值的实现方法
#### 1. 逆波兰表达式的构造
注意输入一整行数可以使用
`getline(cin, s);`
来进行实现
一行输入多个数字到空格之后break:
```cpp 
while (cin >> input){
		Que.push(input);
		if (cin.get() == '\n') break;
	}
```

逆波兰表达式的结构为 : 

| 中缀表达式         | 逆波兰表达式    |
|---------------|-----------|
| A + B         | A B +     |
| A * B         | A B *     |
| A +B * C      | A B C * + |
| A * ( B + C ) | A B C + * |

构造方法参考可以参考这篇文章 
[逆波兰表达式](https://www.cnblogs.com/lanhaicode/p/10776166.html)

每一次，对于右括号出现时，找到最近的左括号，并将左右括号内的部分弹出栈signStk

我们以如下的表达式计算为例：
$$a * b+ c +(d*e+f*g) *h$$
[[Reverse_Poland_Expression.jpg|过程参考]]
则得出的逆波兰表达式为： 
$$ab*cde*fg+h*++$$
在sign栈出栈和入栈的过程中，在sign中的操作数，<mark style="background: transparent; color: yellow">越靠近栈顶，优先级越高</mark>，不过仅限于左括号后面的部分

另外需要注意的是，遇到运算符比这个高的部分(即上述过程中的第1, 2步)，则<mark style="background: transparent; color: yellow">将前面全部优先级更低的运算符全部出栈，然后将自己入栈</mark>，但是遇到左括号时，不用执行出栈操作 。

可以给另外一个波兰表达式的求值示例
$$5 ^ 3 + 2 * 1$$
栈分别为

| num  | 5   | ^   | 3   | 2   | 1   | 
| ---- | --- | --- | --- | --- | --- |
| sign | +   | *   |     |     |     |

出栈后的逆波兰表达式的值为： 

| num  | 5   | ^   | 3   | 2   | 1   | *   | +   |
| ---- | --- | --- | --- | --- | --- | --- | --- |
| sign |     |     |     |     |     |     |     |

`````ad-note
title: 将表达式转换为逆波兰表达式的代码示例
collapse: close
其中运算变量以a,b,c等等表示
```cpp 
#include<iostream>
#include<stack>
#include<string>
#include<unordered_map>
using namespace std;

// 使用哈希表存储对应的运算符优先级
unordered_map<char, int> Priority = {
	{'+',1},
	{'-',1},
	{'*',2},
	{'/',2},
	{'^',3},
	{'(',4},
	{')',4}
};

int main() {
	string s;
	getline(cin, s);
	stack<char> numStk, signStk;
	for (char ch : s) { 
		// 进行入栈和出栈操作, 输出逆波兰表达式
		if (ch >= 97 && ch <= 122) { 
			// 字符a-z 
			numStk.push(ch);  // 放入数字
		}
		else if (Priority.count(ch)) {
			// 输入的部分为运算符, 注意栈有可能是空的
			if (signStk.empty()) {
				signStk.push(ch);
			}
			else if (ch == ')') {  // 首先判断右括号
				while (signStk.top() != '(') {
					numStk.push(signStk.top());
					signStk.pop();
				}
				signStk.pop(); // 出栈(并舍弃
			}
			else if (Priority[ch] < Priority[signStk.top()]) {
				// 前一个运算符的优先级别比这个大，则持续出栈直到遇到左括号
				while (!signStk.empty() && signStk.top() != '(') {
					numStk.push(signStk.top());
					signStk.pop();
				}
				// 然后这个运算符入栈
				signStk.push(ch);
			}
			else {
				signStk.push(ch); // 运算符入栈
			}
		}
	}
	// 表达式遍历完毕后，对运算符栈内的部分进行出栈
	while (!signStk.empty()) {
		numStk.push(signStk.top());
		signStk.pop();
	}

	stack<char> preStk;

	while (!numStk.empty()) {
		preStk.push(numStk.top());
		numStk.pop();
	}

	while (!preStk.empty()) {
		cout << preStk.top();
		preStk.pop();
	}
	return 0;
}
```

`````

#### 2. 有效表达式的判断代码示例
见问题[[字符串的括号匹配问题]]

#### 3. 逆波兰表达式的运算

在计算这些表达式的值时，通过将数字入栈，遇到**运算符**后在把数字出栈，**计算**，计算完再次入栈。一直循环……
![[attachments/Pasted image 20230324195855.png|500]]

## 二、队列的链式定义方法
### (1) 连续存储的队列定义方法
在连续存储的队列定义中，会定义一个front队首数字和一个rear队尾数字
其中font 表示**队首的元素**, rear表示**队尾元素的下一个元素**
因此可以直接通过front来进行访问
[[📘ClassNotes/⌨️Programming/Data Structure/课程笔记/基础知识/复习 栈和队列#一、队列|连续存储队列的定义]]

`````ad-summary
title:带template的链式队列定义
collapse:close

```cpp 
#include <iostream>
#define MAX_QUEUE_SIZE 100
using namespace std;

// 注意: 通过此种方式定义的连续存储的队列可能会产生溢出情况
template <typename DataType>
struct queueNode {
	// 队列的链式存储
	DataType* Data = new DataType[MAX_QUEUE_SIZE];
	int rear;
	int front;
};

template <class DataType>
class SeqQueue{
public:
	SeqQueue() {
		InitQueue();
	}
	bool IsEmpty();
	void push(DataType data);
	void ClearQueue();
	int GetQueueLength();
	DataType pop();

private:
	void InitQueue();
	queueNode<DataType> queue;
};

template <class DataType>
void SeqQueue<DataType>::InitQueue() { 
	// 初始化链式存储的队列
	queue.front = 0;
	queue.rear = 0;
	// 其中front = rear时,队列为空
}

template <class DataType>
int SeqQueue<DataType>::GetQueueLength() {
	return queue.rear - queue.front;
}

template <class DataType>
void SeqQueue<DataType>::ClearQueue() { 
	// 清空队列
	queue->front = 0;
	queue->rear = 0;
}

template <class DataType>
bool SeqQueue<DataType>::IsEmpty() {
	return queue.rear == queue.front;
}

template <class DataType>
void SeqQueue<DataType>::push(DataType data) {
	if (queue.rear < MAX_QUEUE_SIZE -1 ) {
		queue.Data[queue.rear++] = data;
	}
}

template <class DataType>
DataType SeqQueue<DataType>::pop() {
	if (IsEmpty()) return NULL; // 空队，直接返回
	else {
		return queue.Data[queue.front++];
	}
}

int main() {
	SeqQueue<int> q;
	cout << q.IsEmpty()<< endl;
	for (int i = 0; i < 20; i++) {
		q.push(i);
	}
	cout << q.GetQueueLength() << endl;
	for (int i = 0; i < 20; i++) {
		cout << q.pop() << " ";
	}
	cout << endl;
	cout << q.IsEmpty() << endl;
	return 0;
}
```

`````

### (2) 循环队列部分
对于循环队列的定义，在队列满时，rear = front, 队列空时，rear = front ， 则在push时需要进行判断队伍空还是队伍满

方法一是浪费一个空间来进行判断， 即 $(rear+1)\%size = front$ 时为队满，而$rear =front$时队空

方法二是在总结构体中定义length来存储目前队伍中的元素个数

两种方法均需要使用多余的一个空间，不过在时间上第二种每次需要运算长度

### (3) 链式存储的队列定义方法

链式存储的队列在节点结构体中仅定义一个next指针, 形成单向链表的格式
而在结构体式的定义中，我们只需要另外定义一个结构体存储队首和队尾即可

```cpp 
typedef struct Node{
DataType data;
struct *next;
};

typedef struct LinkQueue{
Node *font;
Node *rear;
};
```

此处使用class 中的私有变量定义队首和队尾指针

`````ad-summary
title: 类定义代码
collapse: close
rear指向最后一个元素
```cpp 
#include <iostream>
using namespace std;

template <typename DataType>
struct QueueNode {
	DataType data = NULL;
	QueueNode* next = NULL; // 存储下一个节点的指针
};

template <class DataType>
class LinkQueue {
public:
	LinkQueue() {
		InitQueue();
	}
	void push(DataType data);
	DataType pop();
	bool IsEmpty();
	DataType GetHead();

private:
	void InitQueue();
	QueueNode<DataType>* front;
	QueueNode<DataType>* rear;
};

// 使用带头结点的方式进行初始化
template <class DataType>
void LinkQueue<DataType>::InitQueue() {
	front = new QueueNode<DataType>(); // 使用额外的头指针
	rear = front; // 头指针和尾指针指向同一个节点
	// front->next = NULL: 初始化指针为NULL
}

// 入队，rear指向最后一个元素
template <class DataType>
void LinkQueue<DataType>::push(DataType data) {
	QueueNode<DataType>* Q = new QueueNode<DataType>(); //
	rear ->next = Q;
	rear = rear->next;
	rear ->data = data;
}

// 出队，head-> next为头元素
template <class DataType>
DataType LinkQueue<DataType>::pop() {
	// 实际pop的data应该是front-> next -> data
	QueueNode<DataType>* Q = front;
	front = front->next;
	DataType data = front->data;
	delete Q;
	front->data = NULL; // 设置第一个节点为头结点
	return data;
}

template <class DataType>
bool LinkQueue<DataType>::IsEmpty() {
	return rear == front;
}

template <class DataType>
DataType LinkQueue<DataType>::GetHead() { 
	// 访问队首元素
	if (!front->next) return NULL;  // 空队
	return front->next->data;
}

int main() {
	LinkQueue<int> Q;
	for (int i = 0; i < 100; i++) {
		Q.push(i);
	}

	for (int i = 0; i < 100; i++) {
		cout << Q.pop() << " ";
	}
	return 0;
}
```

`````
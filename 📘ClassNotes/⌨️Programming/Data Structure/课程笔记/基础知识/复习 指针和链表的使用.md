## 1. C++ 字符串的使用
1. 字符串部分:
C++中，使用 getline来直接输入字符串

```cpp
#inlcude <string>
getline(cin, name); 
cout << "Thanks," << name << endl;
cin.ignore(256,'\n');
```

2. 整形和字符型的转换

```cpp 
#include <iostream>
# include <string>
#include <sstream>  // include the stringstream support
using namespace std;

int main() {
	// 1. 复习: 指针和结构体的使用
/*
* 首先在c 语言中，有int, double, long, char, 等等多种类型,
*/
	string term = "100";
	int number = 100; int num;
	stringstream stream;
	stream << term;    // Load the string  
	stream >> num;     // Extract the integar
	
	cout << num << endl;  // it will change the string type to the number; 
	stream.str(""); // clear the string content
	stream.Clear(); // Empty the bit flags 
	
	stream << num;   // load the number 
	stream >> term; // output the string
	// use string.size() for asking the character length of the string
	// string.capacity();
	// string.empty();     if it is emppty
	return 0;
}
```

also, use "+" for concatenate the string. 
also function `append` is available

```cpp
string.find();
string.insert(10, "another string ");
string.at(string.size() -1) << endl;
```

## 2. 文件操作类型

```cpp 
#include <fstream> // support for the 
int main(){
string poem  = "12345678";

ofstream writer("poem.txt");  // create a file stream
writer.close(); // close the file stream 

return 0;
}
```


| Mode        | Behavior                                                                   |
| ----------- | -------------------------------------------------------------------------- |
| ios::out    | open a file to write output                                                |
| ios::in     | open a file to read input                                                  |
| ios::app    | OPEN A FILE and append output at the end of any existing content           |
| ios::ate    | open without turncating and allow  data to be written anywhere in the file |
| ios::trunc  | truncate the existing file                                                 |
| ios::binary | treat the flie as binary format                                            |

```cpp 
ifstream reader("1.txt"); // create an input filestream object 

// check if the filestream exists
if(!reader){
cout << "Error when opening the file" << endl; 
return -1; 
}
```

```cpp 
// read each line into the string array 
while (!reader.eof()){
if ((i+1)%4 == 0) 
	getline (reader, tab[i++], '\n');
else
	getline (reader, tab[i++], '\t');
}
// this will read up to a '\t' tab at first three times and read up to a \n for the 

reader.close(); 
i = 0;   // reset the counter 

```

## 3. 输出的格式控制

![[Screenshot_20230308_165116_com.microsoft.skydrive.png|550]]
note that the manipulators marked with * are default 

```cpp 
cout.width(40); 
cout.fill("."); 
cout << "output" << endl ;

int isTrue = 1;
cout << isTrue << boolalpha << isTrue << endl ;
// 1True
cout << num << hex << showbase << uppercase << num << endl; 
```

## 4. 异常的抛出
try.....catch .. throw are basic syntax in cpp source files 
```cpp 
int main(){
string lang = "cpp"; 
try {
	lang.erase(4,6); 
}
catch (exception &e){
	cerr << "Exception:" << e.what() << endl; 
} 
return 0;
}
```

the `<stdexcept>` library is available to a program, too. 

```cpp 
# include <stdexcept> // standard error type
# include <typeinfo>  // error typ infoemation 
try{
}
catch (out_of_range e){
	cerr << "Range exception" << e.what() << endl;
	cerr << typeid(e).name() << end; // get the error type
	return -1;
}
```


## 5. 指针的用法
##### 1) 一般使用
一般使用方法
```c 
int *p;
p  = &a; // 使用指针指向某个部分的地址值
```

指针的值为0, 则称为0指针，也称为空指针
```c
int *p = 0; 
// 使用 *p = 2 进行间接引用总会导致程序出现严重异常错误

char *c = NULL; 
void fun(){
	char c ; 
	p = &c ; // 在函数调用结束之后，就会导致成为迷途指针，指针指的部分是未知的
}
// 为了避免使用迷途指针，结果应当即时设置为空指针
```

指针变量的自增和自减运算
`p++` 表达式的值(临时指针对象)指向变量$x$, 运算之后p指向$x$后方的第一个int型内存单元
`++p` 表达式的值和p均指向下一个内存单元

指针的强制类型转换
```c 
p = (int *) pf;  // 强制转换pf为指针int*类型
```

void指针可以通过强制类型转换为多种指针，指向的类型不明确

如果需要指向一个const型对象，需要使用const型的指针，即
```c
const int *p;
```

##### 2) 访问数组元素 

对于一维的数组元素，
```c
a[i];, p = a; 
p[i];
*(a + i) // 地址引用
*(p + i) // 地址引用
```


```c 
int a[10][10]; 
*p1 =  &a[0][0]; //  定义指针并且指向对应的元素

对于行数为N,列数为M的数组 a[M][N]，可以使用
p1[i * M + j]来访问a[i][j]的值
// 也可以使用 
*( *(a +i) + j) // 
// 或者
* (p + i*M + j)
```

对于<mark style="background: transparent; color: yellow">数组指针和指针数组</mark>，定义的一般形式有
其定义方式可以分为: 
```c
int (*p1)[4];  // 定义一个指向一维数组的指针,
int (*p2)[10]; 
// 上式中，*p 带有括号，因此定义的是数组指针，

int *p2 [10]; 
int *p1 [5]; 
// 定义指针数组
```

在数组指针中， $*p$就是该数组，此时，$*p$就是数组$a[0]$，
```c
// 下列两种方法均可以访问 a[0][j] 
(*p)[j] = 10;   // 等价于a[0][j] = 10;
*(*p+j) = 10;   // *(a[0] +j) = 10;
```

```c
int *s[4] = {a[0], a[1], a[2], a[3]}; // 一维数组指针的初始化
int a[4][4] = {1,2, .....,16} // 二维数组
s[0] = a[0]; 
s[1] = a[1]; 
s[2] = a[2];
s[3] = a[3]; // 每一个均指向一个一维的数组
// 对于指针数组, 可以使用s[i][j]来访问对应的值
// 即有
for (int i = 0; ...){
	for ...{
		print (s[i][j])
	}
}
```

`int **pp`
定义多级指针，`int a =20, *p = &a, **pp = &p`
可以使用`*(*p)`或者`**p`的方法来访问$a$的值
`**`的表达实质上是指向指针的指针

```c
// 下面是使用二级指针访问一维数组s的典型形式
pp = s; pp = & s[0]; // 其中s为一维指针数组
pp = s+ i; pp = &s[i]; pp + i;  // 访问s[i], 其中s为指针数组,由于
```

对于字符串指针，
```c 
char s[] = "halo";
// 这会自动在末尾补足 \0 的终止符号
// 并可以使用指针来指向整个字符串
```

注意：使用`%s`格式可以将输出的当前项作为字符串输出，如
```C
char str[] = "C language";
printf("%s\n", &str[7]); // 输出的内容为 age 
```

## 6. 动态内存的使用

注意：动态内存配合数组的使用可以达到自定义数组大小的效果

```c
#include <stdlib.h>
malloc  // 分配一个指定大小的内存空间
// 
p = (int*)malloc(sizeof(int)); // 分配一个int型空间

calloc // 用于分配n个连续的指定的大小的内存空间
int *p;
p = (int*)calloc(50,sizeof(int)); 

realloc // 调整已经分配的内存空间的大小
p = (int*)malloc(50 *sizeof(int)); // 分配一个有50个int整形的空间
p = (int*)malloc(p, 10*sizeof(int)); // 重新分配10的int型空间

free(A); // 释放数组A的空间
```

## 7. 结构体类型的数据定义

##### 1) 结构体

```C 
struct STUDENT{  // 全局声明结构体
int age, number;
// 声明成员
double score;
char sex;
} d1, d2; // 其中，d1,d2 是可以直接定义的结构体对象，在结构体中可以不加

typedef struct STUDENT stu;  // 可以使用typedef进行简化命名

int main(){
stu a1; 
return 0;
}
```

`````ad-note
title: 
collapse: open
使用预处理命令 `#pragma pack(n)` 可以设定对齐字节数n, 具体可以参考其他部分
```C
#pragma pack(push) // 保存设定
#pragma pack(1) // 设定保存的对齐字节数
#pragma pack(pop) // 恢复对齐字节数
```

`````

使用
```c
a1. score =1.0; // 访问其中的数据成员
```
对于数据多的结构体，整体赋值可能耗费大量时间


结构体数组的定义
```C
struct tagSTUFF{
	char* name; 
} a = {"afal"}, b;

struct tagSTUFF a[20]; // 定义结构体数组，其中每一个数据都是一个结构体
```

##### 2) 共用体

```C
union A{ // 成员共享存储空间的结构体类型
int m,n;
char a,b;
};

```

s## 一、树的基本概念和定义
### 1. 树的基本定义: 
树是一种典型的非线性结构，常用的有树和二叉树

树是由n个节点组成的有限集合，树的n个节点中，有一个是根节点root，树的每一个节点可以有零个或者多个直接后继，但除根节点以外，有且仅有一个直接前驱

### 2. 树的逻辑表示
有树形， 文氏图， 凹入表示三种图形表示
![[attachments/Tree_Explaination.drawio.png|400]]

也可以使用括号进行表示：
$$A(B(D,E), C(F))$$
其中，节点的字树个数为节点的度，各节点度最大值为树的度，并将度为$m$的树称为$m$次树。 
度为0的节点称为叶或者终端节点

森林是$m$棵互不相交的树的集合，可以使用森林和树的相互递归的定义来描述树

`````ad-note
title:性质补充
collapse: open

1. 度为$m$的树的第$i$层上至多有$m^{i-1}$个节点
2. 深度为$n$的$m$次树至多有$\frac{m^h -1}{m-1}$个节点(等比求和)
3. 有$n$个节点的$m$次树， 最小深度为$\left[\log_{m}  n(m-1) + 1\right]$
其中$[x]$为不小于$x$的最小整数
`````

### 3. 树的三种存储结构定义
1. 父节点型连续存储结构
双亲节点型结构的树是一种连续型存储的结构，使用一组连续空间存储树的所有节点，其中每个节点保存其父节点的位置
这种结构寻找父节点很容易，但是寻找某个节点的子节点需要遍历整个数组进行寻找
```cpp 
typedef int DataType;

// 连续存储型的树的定义
typedef struct SeqTree { 
    DataType data;
    int parent; 
}PTree[MAXSIZE];
// 其中, PTree为结构体数组类型
```

2. 子链式存储结构
每个节点包含指向所有子节点的指针
求解某节点的子节点容易，但是父节点即需要从根节点开始进行逐个递归寻找
```cpp 
typedef int DataType;

// 子链式存储结构
typedef struct SonNode {
    DataType data;
    struct SonNode* sons[MAXSIZE]; 
    // 定义一个指向子节点指针数组类型
};
```

3. 子链和同级节点链式存储结构
每一个节点包含指向所有子节点的指针域和指向同级节点的指针域，形成了子节点链和
sibling 节点链 ， 使查找子链和sibling节点时方便而查找父节点时，需要从根递归查找

```cpp 
typedef int DataType;
// 子链和同级节点链式存储结构
typedef struct TNode {
    DataType data;
    struct TNode* sb[MAXSIZE];    // 指向同级节点的指针
    struct TNode* child[MAXSIZE]; // 子节点指针
};
```



## 二、二叉树及其基本性质
### 1. 二叉树的定义方法
对于二叉树的双亲表示法和子节点表示法，可以参考[树的定义和C++实现](https://blog.csdn.net/qq_30611601/article/details/80652731)
二叉树中需要实现的常见操作有：
1. 构造空二叉树 
2. 销毁二叉树 `Destroy()`
3. 判断是否为空树
4. 返回树的深度
5. 返回二叉树的根 `Root(T)`
6. 返回某个节点的值 `Value(T,*e)`
7. 搜索父节点 `Parent(T, e)`
8. 返回左子树 `left(T, e)` , 右子树 `right(T,e)`
9. 插入节点 `Insert(T, p, LR, c);` 根据LR为0,1插入c为T中p指向的节点的左右子树
10. 删除节点 `Delete(T, p, LR, c);`
11. 前序遍历 `PreTravel(*T, visit());`
12. 后序遍历 `PostTravel(*T, visit());`
13. 中序遍历 `MidTravel(*T, visit());`

一棵二叉树中，如果所有的分支节点都有所有子节点，并且**叶节点都在二叉树的最下面的一层**, 则称其二叉树为<mark style="background: transparent; color: yellow">满二叉树</mark>

如果二叉树中最多只有最小面两层的节点度可以小于2，且下面一层的叶节点都从左向右进行依次排布， 则称二叉树为**完全二叉树**

`````ad-note
title: 二叉树定义的代码实现部分
collapse: close
下面是一个基本的二叉树结构体定义

```cpp 
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    // 下面定义的部分是初始化方法
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 初始化val为x,left 和right均初始化为nullptr
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}  // 同时定义left和right节点
};
```

在c++语言中的带有模板的二叉树的定义代码示例

```cpp 
template <class DataType>
struct BiNode
{
    DataType data;
    BiNode<DataType> * lchild,*rchild;
};

template <class DataType>
class BiTree
{
public:
    BiTree(){root = Create(root);}
    ~BiTree(){Release(root);}
    void PreOrder(){PreOrder(root);}	//前序遍历
    void InOrder(){InOrder(root);}		//中序遍历
    void PostOrder(){PostOrder(root);}	//后序遍历
private:
    BiNode<DataType> * root;
    BiNode<DataType> * Create(BiNode<DataType> *bt);
    void Release(BiNode<DataType> *bt);
    void PreOrder(BiNode<DataType> *bt);
    void InOrder(BiNode<DataType> *bt);
    void PostOrder(BiNode<DataType> *bt);
};
```

`````

### 2. 二叉树的遍历算法
#### (1) 递归方法实现二叉树遍历
一、递归的前序遍历算法
```cpp 
class Solution {
public:
    vector<int> result;  // 全局变量定义result向量
    vector<int> preorderTraversal(TreeNode* root) {
        if (root) {
	        // 这一句可以表示为 visit (&(T->data)); 
            this->result.push_back(root->val);
            preorderTraversal(root->left);
            preorderTraversal(root->right);
        }
        return result;
    }
};
```

其中前序遍历的核心代码为
```cpp 
visit (&(T->data)); 
preorderTraversal(root->left);
preorderTraversal(root->right);
```

中序遍历核心代码只需 
```cpp 
preorderTraversal(root->left);
visit (&(T->data));
preorderTraversal(root->right);
```
后序遍历
```cpp 
preorderTraversal(root->left);
preorderTraversal(root->right);
visit (&(T->data));
```

#### (2) 遍历算法的迭代方法实现
##### (1) 前序遍历
使用栈的方法来进行前序，中序和后序遍历，只需要对于每一个节点
首先定义一个**结构体指针类型的栈**
每一次，<mark style="background: transparent; color: yellow">右子树先进栈， 左子树后进栈，每一次访问一层时，只需出栈一个节点并访问</mark>

前序遍历优先遍历左节点， 按照根节点-左子树-右子树的方式进行树的遍历
比如对于下面的一个完全二叉树:
![[Excalidraw/复习 树的基本知识 2023-03-26 18.46.11|200]]
其遍历顺序是$1 ,2,4,8, 9, 5, 10, 3,6, 7$
迭代方法实现的二叉树前序遍历如下:
```cpp 
#include <stack>
// 前序遍历二叉树,其中visit以DataType*类型为传入参数
void BTree::preOrderTravel(void(*visit)(DataType*)){
	TreeNode* Node = root; // 使用根节点
	stack<TreeNode*> NodeStack;
	NodeStack.push(root);
	while (!NodeStack.empty()){
		Node = NodeStack.top();
		visit(&(Node->val));    // 对Node的val调用输出函数
		NodeStack.pop();
		// 判断并执行, 左右子树均需要进栈
		if (Node->right!=nullptr) {
			NodeStack.push(Node->right);
		}
		if (Node->left!=nullptr) {
			NodeStack.push(Node->left);
		}
	}
}
```

##### (2) 中序遍历
中序遍历是先全部访问左子树，
方法是事先访问根节点的所有左节点并将其入栈
此时，栈顶没有左子树或者左子树已经访问过，则将最末端的左节点出栈并且进行访问

![[attachments/Iteraion_algorithm_of_mid_travel.drawio.png|600]]
另外需要注意的是，在二叉树中序遍历的算法中，是<mark style="background: transparent; color: yellow">先入栈所有左下节点并逐一弹出</mark>的。 每一次如果没有检测到右节点，则<mark style="background: transparent; color: yellow">持续进行出栈操作，遇到右节点则进栈右节点，停止出栈并继续遍历</mark>

综上，就是每一次入栈所有的节点和左下的节点，每一次出栈时检测右节点是否存在，如果有右节点则连右节点带所有其左节点入栈

`````ad-summary
title:中序迭代遍历的代码实现
collapse:close
```cpp 
class Solution {
public:
	stack<TreeNode*> NodeStack;
	vector<int> result;
	TreeNode* SetNodeLeft(TreeNode* Node) {
		// 扫描所有左下节点并进栈, 不进栈头结点
		while (Node->left != nullptr)
		{
			Node = Node->left;
			NodeStack.push(Node);
		}
		return Node;
	}
	vector<int> inorderTraversal(TreeNode* root) {
		TreeNode* Node = root;
		if (!Node) return result;
		NodeStack.push(Node); // 注意先push了根节点一次，所以之后不能重新push
		// 每一次，先遍历这个节点，然后遍历右节点并每一次先入栈根节点和所有左节点
		while (!NodeStack.empty()) {
			Node = SetNodeLeft(NodeStack.top());  // 入栈其他的节点
			while (!NodeStack.empty()) {
				Node = NodeStack.top();  // 置为栈顶元素
				result.push_back(NodeStack.top()->val);
				NodeStack.pop(); // 出栈节点
				// 如果这个节点有右节点，则入栈并进入下一次循环, 否则继续执行出栈输出操作
				if (Node->right) {
					NodeStack.push(Node->right);
					// break 之后，这个节点已经push,之后即可搜寻左下元素
					break;
				}
			}
		}
		return result;
	}
};
```

官方的解答中,直接使用`root = root->left;`, 之后使用root->val

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
	        // 在stk不是empty情况下执行, root!=null
            while (root != nullptr) {
	            // 把全部左节点部分入栈
                stk.push(root);
                root = root->left;
            }
            root = stk.top();  // 每一次取栈顶元素
            stk.pop();
            res.push_back(root->val); // 出栈
            root = root->right; 
            // 由于使用的是root = root -> right, 那么如果没有右节点则置为null, 则不会导致停留在此节点而重复遍历左节点的问题
	        // 由于root节点已经出栈，所以不用考虑重复遍历右节点的问题, 这与后续遍历不同
            // 考虑右节点是否入栈，如果为null且stk非空,则左节点入栈
        }
        return res;
    }
};
```

`````

`````ad-note
title: Mirrors中序遍历
collapse: close

[中序遍历的Mirrors实现](https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solution)

```cpp 
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        TreeNode *predecessor = nullptr;

        while (root != nullptr) {
            if (root->left != nullptr) {
                // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
                predecessor = root->left;
                while (predecessor->right != nullptr && predecessor->right != root) {
                    predecessor = predecessor->right;
                }
                
                // 让 predecessor 的右指针指向 root，继续遍历左子树
                if (predecessor->right == nullptr) {
                    predecessor->right = root;
                    root = root->left;
                }
                // 说明左子树已经访问完了，我们需要断开链接
                else {
                    res.push_back(root->val);
                    predecessor->right = nullptr;
                    root = root->right;
                }
            }
            // 如果没有左孩子，则直接访问右孩子
            else {
                res.push_back(root->val);
                root = root->right;
            }
        }
        return res;
    }
};
```
`````

##### (3) 后序遍历
后序遍历算法是先访问节点的左右子树之后，再访问节点本身的算法
![[Excalidraw/复习 树的基本知识 2023-03-26 18.46.11|200]]
以图为例，上述的输出顺序为: 
$8-9-4-10-5-2-6-7-3-1$

![[attachments/Iteraion_algorithm_of_past_travel.drawio.png|600]]

`````ad-abstract
````ad-tip
title: 不带调试代码的代码
collapse: close
```cpp 
class Solution {
public:
    vector<int> result;
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> ans;
        if (!root) return ans;
        TreeNode* pre = nullptr; // 需要增加定义一个指针p来记录上次访问过的节点
        // 头结点入栈
        stk.push(root);
        while (!stk.empty()) {
            if (root -> left && root->left!=pre &&  (!root->right || root ->right!=pre)){ 
                // 注意right可以为null. 如果这个节点的left = pre, 则跳出循环,检测右边然后出栈这个节点
                for (; root-> left;) {
                    // 入栈左边节点部分
                    root = root->left;
                    stk.push(root);
                } // root变为最后一个元素
            }
            root = stk.top();
            if (root->right && root->right != pre){
                root = root -> right;
                stk.push(root); // 这个节点入栈
            }
            else{ // 如果有右节点入栈，则先遍历右节点,只有切到右节点时需要首元素入栈操作
                root = stk.top();
                pre = root; // 显然如果出栈根节点时，右节点刚出栈，则将pre赋值为刚出栈过的节点
                ans.push_back(stk.top()->val);
                stk.pop();
                if (!stk.empty()) root = stk.top(); // 然后重新取top节点
            }
        }
        return ans;
    }
};
```
````

````ad-tip 
title:官方解法
collapse:close 
```cpp 
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        stack<TreeNode *> stk;
        TreeNode *prev = nullptr;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.emplace(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            if (root->right == nullptr || root->right == prev) {
                res.emplace_back(root->val);
                prev = root;
                root = nullptr;
            } else {
                stk.emplace(root);
                root = root->right;
            }
        }
        return res;
    }
};
```

````

````ad-tip
title: 带调试代码
collapse: close
```cpp 
class Solution {
public:
	vector<int> result;
	vector<int> postorderTraversal(TreeNode* root) {
		stack<TreeNode*> stk;
		vector<int> ans;
		if (!root) return ans;
		TreeNode* pre = nullptr; // 需要增加定义一个指针p来记录上次访问过的节点
		// 头结点入栈
		stk.push(root);
		cout << "push" << root->val << endl;
		while (!stk.empty()) {
			cout << "top: " << stk.top()->val << endl;
			if (root->left && root->left != pre && (!root->right || root->right != pre)) { // 注意right可以为null
				// 如果这个节点的left = pre, 则跳出循环,检测右边然后出栈这个节点
				for (; root->left;) {
					// 入栈左边节点部分
					root = root->left;
					stk.push(root);
					cout << "push" << root->val << endl;
				} // root变为最后一个元素
			}
			cout << "-----" << endl;
			root = stk.top();
			if (root->right && root->right != pre) {
				cout << "righting : " << root->val;
				root = root->right;
				stk.push(root); // 这个节点入栈
				cout << " push : " << root->val << endl;
			}
			else { // 如果有右节点入栈，则先遍历右节点
				root = stk.top();
				pre = root; // 显然如果出栈根节点时，右节点刚出栈，则将pre赋值为刚出栈过的节点
				ans.push_back(stk.top()->val);
				cout << "pop :" << stk.top()->val << endl;
				stk.pop();
				if (!stk.empty()) root = stk.top(); // 然后重新取top节点
			}
		}
		return ans;
	}
};
```
````

````ad-tip
title: Mirror遍历法
collapse: close 
```cpp 
class Solution {
public:
    void addPath(vector<int> &vec, TreeNode *node) {
        int count = 0;
        while (node != nullptr) {
            ++count;
            vec.emplace_back(node->val);
            node = node->right;
        }
        reverse(vec.end() - count, vec.end());
    }

    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        TreeNode *p1 = root, *p2 = nullptr;

        while (p1 != nullptr) {
            p2 = p1->left;
            if (p2 != nullptr) {
                while (p2->right != nullptr && p2->right != p1) {
                    p2 = p2->right;
                }
                if (p2->right == nullptr) {
                    p2->right = p1;
                    p1 = p1->left;
                    continue;
                } else {
                    p2->right = nullptr;
                    addPath(res, p1->left);
                }
            }
            p1 = p1->right;
        }
        addPath(res, root);
        return res;
    }
};
```

````

`````

#### (3) 层次遍历算法遍历树的节点
层次遍历法是一层一层访问树节点的方法，每一次假定树的深度为$k$, 

层次遍历方法可以通过队列进行实现

`````ad-summary
title:通过队列方法实现二叉树的向量赋值
collapse:close 
```cpp 
// 使用使用层次遍历,用向量赋值建立完全二叉树
void BTree::CreateTree(vector<DataType> Vec){
	// 层次遍历可以使用队列实现, 每一次将遍历的节点入队
	// 这样就可以保证先遍历的是已经入队的节点，而且在前面一层的节点总是先入队的
	if (Vec.size() == 0) return;
	int index = 0;
	root = new TreeNode(Vec[0]); // 首先建立根节点
	if (Vec.size() == 1) return; 
	queue<TreeNode*> NodeQueue;
	NodeQueue.push(root);
	bool isLeft = true;
	// 每一次创建左右节点并入栈
	for (int i = 1; i < Vec.size(); i++) {
		TreeNode* node = NodeQueue.front();
		// 通过top, 然后将所有的节点进行入栈, 每一层直接出到空栈为止
		NodeQueue.pop();
		// 直接分别为左右节点赋值
		node->left = new TreeNode(Vec[i]);
		NodeQueue.push(node->left);
		
		i++;
		if (i == Vec.size()) break;

		node->right = new TreeNode(Vec[i]);
		NodeQueue.push(node->right);
		// 之后判断
	}
}
```

`````
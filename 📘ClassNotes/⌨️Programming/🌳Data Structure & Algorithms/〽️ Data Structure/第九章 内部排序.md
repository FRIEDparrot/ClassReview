选择排序->在交换次数上优于冒泡排序

[[📘ClassNotes/⌨️Programming/🌳Data Structure & Algorithms/C++基础知识/复习 七大排序算法|七大排序算法]]

**直接插入排序**的算法是数据在基本有序的情况下，效率极高

比较好的方法是结合动态规划，二分查找和分治算法来进行

算法的稳定性： 对于关键字， 如果能够保证**对于数值相等的数据**， 如果在排序之前， 序列中$R_i$领先于$R_j$, 如果在排序后的序列中，$R_i$仍然领先于$R_j$, 则称该方法是数值稳定的， 否则称为数值不稳定的算法。

每一步将一个待排序的记录，按照关键字的值，插入到已经排序的表的位置

首先建立一个大小为10 的链表存储10个已经排好序的人，并每一次将一个新的插入并使用二分插入方法

插入的排序过程近似为n，使用双向链表插入, 复杂度为1,  而指针移动的次数为：
$n *(\frac{1}{2} + \frac{1}{4} + \frac{1}{8} + ....) = n * \frac{1}{2}/ \frac{1}{2} = n$
可能的时间复杂度为O($n^2$)

但是如果将插入的方法能够实现插入位置的查找达到$O(log_2n)$, 则总算法的时间复杂度为$O(n*log_2 n)$

`````ad-note
title: 排序二叉树的折半查找实现思路
collapse: open

排序二叉树有<mark style="background: transparent; color: red">中序遍历有序且可以自上而下以低复杂度查找的优良性质</mark>

折半查找的查找效率更加高效， 复杂度为$O(log_2n)$， 使用排序树结构的插入需要先插入， 复杂度为$O(log_2n)$， 我们以**1000个人中选出最好的10个人为例**， 每一次使用10大小的链表，存储对应已经排好序的部分， 则每一次先查找到, 复杂度$O(log_2 n)$将新的节点插入，复杂度为$1$, 则插入查找的平均复杂度大约为$O(n * log_2 10)$

对于多个数的访问， 使用创建树的方法，每一次插入一个数即可， 由于一开始节点不是很多，实际运行次数小于 $O(n * log_2 n)$ (需要注意: 可能出现失衡情况， 这个可以通过平衡二叉树调整)

另外利用树结构进行排序的一种典型算法是堆排序，可以在已经有对应数组的情况下，直接通过维护树的性质来实现, 但是维护过程与冒泡类似, 复杂度较高
`````

快速排序可以使用下面代码实现: 
```cpp 
#include <iostream> 
#include <vector>
using namespace std;

// 快速排序
void quickSort(vector<int> & arr, int start, int end) {
    // 在长度 < 2 时进行快排
    if (end - start < 2) return;
    int bs = arr[start];
    // 循环找左边比基准大的元素， 
    int i = start + 1, j = end;
    while (i != j) {
        for (; arr[i] <= bs && i != end; i++);   // i 停留在第一个大于的元素上, 注意溢出条件
        for (; j != i && arr[j] > bs; j--);  // 最终i,j碰面时, 最终停留在第一个大于的数上面
        swap(arr[i], arr[j]);
    }
    swap(arr[i - 1], arr[start]);
    // 调换元素
    int mid = i - 1;
    quickSort(arr, start, mid);
    quickSort(arr, mid + 1, end);
    // 递归调用QuickSort这一段
}
```

堆排序: 
每次删除堆顶元素，再调整好;

1. 删除堆顶元素: 首先建立一个小顶堆
2. 自顶向下, 逆序则交换
![[Excalidraw/第九章 内部排序 2023-06-01 11.21.12|700]]

| 排序     | 稳定性 | 复杂度                       | 基于                              |
| -------- | ------ | ---------------------------- | --------------------------------- |
| 插入排序 | 稳定   |                              | 插入排序                          |
| 二分插入 | 稳定   |                              | 插入排序                          |
| 希尔排序 | 不稳定 |       $O(n^{1.3})$, 往往$O(n*logn)$                       | 插入排序(利用有序时插入极快)      |
| 快速排序 | 不稳定 | 最坏$n^2$， 最好$n * log(n)$ | 冒泡排序交换)                     |
| 堆排序   | 不稳定 |                              | 交换                              |
| 归并排序 |        |                              | 插入排序(归并)                    |
| 堆排序   |        |                              | 方法一是先插入到堆中，交换。 二是 | 


**基数排序**
定义一个大的计数器数组:来一个分数，则计数器+1
再**直接累加一遍**即可
算法复杂度为$n + 750(最大值)$


外排序一般使用归并排序方法
每一次取一块的最小元素先进行归并排序， 我们认为外存可以将数据按照大小分块记录下来

每一次分别取最小的一块排好序，填好最底部的一块，然后将结果和1的第一块排序

1. 在n较大时，仅考虑最高次的复杂度分析, 并忽略常数倍数

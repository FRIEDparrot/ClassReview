## ä¸€ã€åˆ†æ”¯é™ç•Œæ³•ç»¼è¿°
### (1) åˆ†æ”¯é™ç•Œæ³•çš„æ¦‚å¿µ
åˆ†æ”¯é™ç•Œæ³•æ˜¯ä¸€ç§ç±»ä¼¼äºå›æº¯æ³•çš„ï¼Œ åœ¨é—®é¢˜çš„è§£ç©ºé—´æ ‘ä¸Šæœç´¢é—®é¢˜è§£çš„ç®—æ³•ã€‚ä½†æ˜¯ä¸€èˆ¬<mark style="background: transparent; color: red">åˆ†æ”¯é™ç•Œæ³•çš„ç›®æ ‡ä¸å›æº¯æ³•çš„æ±‚è§£ç›®æ ‡ä¸åŒ</mark>, å³å›æº¯æ³•æ˜¯æ±‚å‡ºè§£ç©ºé—´æ ‘ä¸­<mark style="background: transparent; color: red">æ»¡è¶³çº¦æŸæ¡ä»¶çš„æ‰€æœ‰è§£</mark>, åˆ†æ”¯é™ç•Œæ³•æ˜¯æ‰¾å‡ºæ»¡è¶³çº¦æŸæ¡ä»¶çš„ä¸€ä¸ªè§£; æˆ–è€…æ˜¯åœ¨æ»¡è¶³çº¦æŸæ¡ä»¶çš„è§£ä¸­<mark style="background: transparent; color: red">æ‰¾å‡ºä½¿æŸä¸€ç›®æ ‡å‡½æ•°å€¼è¾¾åˆ°æå¤§æˆ–è€…æå°çš„è§£</mark>ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯, ç”±äºæ±‚è§£ç›®æ ‡ä¸åŒ, åˆ†æ”¯é™ç•Œæ³•å¯¹äºè§£ç©ºé—´æ ‘çš„æœç´¢æ–¹å¼ä¸åŒ, å³é‡‡ç”¨<b><mark style="background: transparent; color: blue">å¹¿åº¦ä¼˜å…ˆæœç´¢çš„æ–¹æ³•æˆ–è€…æœ€å°è€—è´¹ä¼˜å…ˆçš„æ–¹å¼, æœç´¢è§£ç©ºé—´æ ‘; åœ¨æ‰©å±•èŠ‚ç‚¹å¤„å…ˆç”Ÿæˆæ‰€æœ‰çš„å­èŠ‚ç‚¹, å†ä»å½“å‰çš„æ´»èŠ‚ç‚¹è¡¨ä¸­é€‰æ‹©ä¸‹ä¸€ä¸ªæ‰©å±•èŠ‚ç‚¹</mark></b>ã€‚åŒæ—¶, <mark style="background: transparent; color: red">ä¸ºäº†æœ‰æ•ˆåœ°é€‰æ‹©ä¸‹ä¸€æ‰©å±•èŠ‚ç‚¹, åˆ†æ”¯é™ç•Œæ³•ä¼šä»æ´»èŠ‚ç‚¹ä¸­é€‰æ‹©ä¸€ä¸ªæœ€æœ‰åˆ©çš„èŠ‚ç‚¹ä½œä¸ºæ‰©å±•èŠ‚ç‚¹ã€‚ä»è€Œæ˜¯æœç´¢æœè§£ç©ºé—´æ ‘ä¸Šå…·æœ‰æœ€ä¼˜è§£çš„åˆ†æ”¯è¿›è¡Œæ¨è¿›, ä»¥ä¾¿å°½å¿«æ‰¾å‡ºæœ€ä¼˜è§£ã€‚</mark>åˆ†æ”¯é™ç•Œæ³•**åœ¨ç¦»æ•£æœ€ä¼˜åŒ–é—®é¢˜æ±‚è§£ä¸Šå¾€å¾€å…·æœ‰è¾ƒå¥½çš„è¡¨ç°**ã€‚

åˆ†æ”¯é™ç•Œæ³•ä¸­ï¼Œ**æ¯ä¸€ä¸ªæ´»èŠ‚ç‚¹ä»…æœ‰ä¸€æ¬¡æœºä¼šæˆä¸ºæ‰©å±•èŠ‚ç‚¹, è€Œæ‰©å±•æ—¶ä¼šè¿›è¡Œå‡ºé˜Ÿå¹¶å°†å…¶å­èŠ‚ç‚¹ä¸­æœ‰å¯èƒ½äº§ç”Ÿæœ€ä¼˜è§£çš„éƒ¨åˆ†å…¥é˜Ÿ**ã€‚ä¹‹åä»å–å‡ºå’Œå‡ºé˜Ÿå³å¯ã€‚

> [!HINT] ä¼˜å…ˆé˜Ÿåˆ—çš„æ¦‚å¿µ
> ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„å…ƒç´ æŒ‰ç…§ä»å¤§åˆ°å°çš„æ–¹å¼è¿›è¡Œæ’åº, æ¯æ¬¡æ’å…¥å…ƒç´ æ—¶, éƒ½ä¼šæ ¹æ®ä¼˜å…ˆçº§è‡ªåŠ¨æ’åºã€‚å³éƒ½ä¼šå°†æ–°çš„å…ƒç´ æ”¾åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šã€‚
> æ¯ä¸€æ¬¡å‡ºé˜Ÿæ—¶, é‡‡ç”¨ top è·å–ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ ã€‚
> ä¼˜å…ˆé˜Ÿåˆ—å®é™…ä¸Šæ˜¯åˆ©ç”¨æ ‘å®ç°çš„, æ ¹èŠ‚ç‚¹çš„å€¼æœ€å¤§ã€‚è€Œæ¯æ¬¡å–å‡ºæ—¶ï¼Œä»æ ‘ä¸­å°†æ ¹èŠ‚ç‚¹å’ŒæŸä¸ªå¶å­èŠ‚ç‚¹äº¤æ¢, å†å–å‡ºå¶å­èŠ‚ç‚¹å¹¶ä¸”é‡æ–°æ’åº 

æœ€å¸¸è§çš„åˆ†æ”¯é™ç•Œæ³•æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼: 
1. é˜Ÿåˆ—å¼ (FIFO) åˆ†æ”¯é™ç•Œæ³•: å³å°†æ´»èŠ‚ç‚¹è¡¨ç»„ç»‡æˆé˜Ÿåˆ—, å¹¶æŒ‰ç…§é˜Ÿåˆ—è§„åˆ™é€‰å–èŠ‚ç‚¹
2. ä¼˜å…ˆé˜Ÿåˆ—å¼åˆ†æ”¯é™ç•Œæ³•: (ä¼˜å…ˆé˜Ÿåˆ—å‚è€ƒ[C++ä¼˜å…ˆé˜Ÿåˆ—çš„ä½¿ç”¨](https://blog.csdn.net/m0_75215937/article/details/132418111)) å°†æ´»èŠ‚ç‚¹ç»„ç»‡æˆä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¹¶ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­**é€‰å–ä¼˜å…ˆçº§æœ€é«˜çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ç§°ä¸ºæ‰©å±•èŠ‚ç‚¹**ã€‚<mark style="background: transparent; color: red">å…¶ä½™çš„å˜ä¸ºæ­»èŠ‚ç‚¹ä»¥èŠ‚çœæ—¶é—´ç©ºé—´</mark>

> [!NOTE] è¯´æ˜
> å®é™…ä¸Šåº”å½“æ ¹æ®é—®é¢˜æƒ…å†µ,é€‰ç”¨æœ€å¤§ä¼˜å…ˆé˜Ÿåˆ—æˆ–è€…æœ€å°ä¼˜å…ˆé˜Ÿåˆ—ã€‚ç”±äºæˆ‘ä»¬å¾€å¾€æ±‚è§£çš„æ˜¯å¯æ‰©å±•çš„é—®é¢˜ï¼ˆç±»ä¼¼äºæœ€å¤§å€¼ï¼‰ï¼Œå› æ­¤å¦‚æœå¯æ‰©å±•, åˆ™å…ˆæ‰©å±•å®Œæ‰€æœ‰çš„å­èŠ‚ç‚¹, ç„¶åå»é™¤å¤´ç»“ç‚¹ã€‚è€Œå½“**æ²¡æœ‰å¯ä»¥æ‰©å±•çš„èŠ‚ç‚¹æ—¶**, **åˆ™å°†å…¶è®°ä¸ºä¸€ä¸ªå¯è¡Œçš„å¶èŠ‚ç‚¹ã€‚è®¡ç®—å…¶ç»“æœå¹¶ä¸æœ€ä¼˜çš„ç»“æœæ¯”è¾ƒ**, <b><mark style="background: transparent; color: blue">ç„¶ååˆ é™¤è¿™ä¸ªèŠ‚ç‚¹</mark></b>

æˆ‘ä»¬ä»¥ä¸€ä¸ªèƒŒåŒ…é—®é¢˜è¯´æ˜åˆ†æ”¯é™ç•Œæ³•çš„æ€æƒ³: è®¾èƒŒåŒ…å®¹é‡ä¸º 25, åˆ™å¦‚ä¸‹å›¾æ‰€ç¤º:
![[Excalidraw/ç¬¬å…­ç«  åˆ†æ”¯é™ç•Œæ³•(BFS) 2024-09-28 10.39.36|600]]
éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œåˆ†æ”¯é™ç•Œæ³•å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢æå…¶ç±»ä¼¼, **å”¯ä¸€çš„ä¸åŒæ˜¯ä¸æœç´¢ä»¥ä¸å¯è¡ŒèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘**ã€‚
ä¸€èˆ¬åœ°ï¼Œä¾‹å¦‚æ—…è¡Œå•†ç­‰è´¹ç”¨æœ€å°é—®é¢˜å¯ä»¥é‡‡ç”¨æœ€å°å †çš„åˆ†æ”¯é™ç•Œæ³•è¿›è¡Œè§£å†³ã€‚

### (2) å…³é”®æ€æƒ³
1. <b><mark style="background: transparent; color: blue">é—®é¢˜åŸºæœ¬å…¥æ‰‹çš„æ–¹å‘: å­é›†æ ‘å»ºæ¨¡å’Œæ’åˆ—æ ‘å»ºæ¨¡æ–¹æ³•</mark></b>
2. æ ¹æ®å®é™…é—®é¢˜**ç¡®å®šé‡‡ç”¨æœ€å¤§å †æˆ–è€…æœ€å°å †çš„ç»“æ„**ã€‚
3. é‡‡ç”¨<mark style="background: transparent; color: red">æ¯æ¬¡è®°å½•ä¸Šä¸€æ¬¡çš„æœ€ä½³æœç´¢èŠ‚ç‚¹</mark>, ç”¨äºå›æº¯æœ€ç»ˆè·å¾—æœ€ä¼˜è§£ã€‚
4. ä¸“é—¨é’ˆå¯¹é›†è£…ç®±ç±»é—®é¢˜çš„<mark style="background: transparent; color: red">å­é›†æ ‘é—®é¢˜</mark>å¤„ç†æ–¹æ¡ˆï¼Œä»¥**æœ€å¯èƒ½è·å¾—æœ€å¤§**è¿›è¡Œä¼˜å…ˆï¼Œæ­¤æ—¶ä¸€æ—¦æ‰¾åˆ°æ ¹, åˆ™å¿…å®šä¸ºæœ€ä¼˜è§£ã€‚
5. åœ¨éå†å­é›†æ ‘æ—¶ï¼Œé€šè¿‡æ ‘ç»“æ„è®°å½•æœ€ä¼˜çš„æ­¥éª¤, ä»è€Œæœ€å°åŒ–éå†è§£ç©ºé—´æ‰€éœ€è®°å½•çš„è·¯å¾„æ•°é‡ã€‚

> [!caution] å…³é”®:ä¼˜å…ˆé˜Ÿåˆ—çš„æœç´¢æ€æƒ³
> åœ¨è®¸å¤šæƒ…å†µä¸‹, ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—è¿›è¡Œåˆ†æ”¯é™ç•Œæ–¹æ³•è¿›è¡Œæœç´¢, **ä¸€æ—¦æœç´¢æ‰¾åˆ°åˆé€‚çš„è·¯å¾„ç­‰ç­‰ï¼Œåˆ™å¿…å®šå¾—åˆ°çš„ç»“æœå°±æ˜¯æœ€ä¼˜è§£**ï¼Œæ­¤æ—¶å¯ä»¥è¾ƒå¥½åœ°å‡å°‘æœç´¢çš„å¤æ‚åº¦ã€‚

> [!caution] å…³é”®:é™ç•Œå‡½æ•°çš„é€‰å–
> é™ç•Œå‡½æ•°çš„é€‰å–ä¹Ÿæ˜¯åˆ†æ”¯é™ç•Œæ³•ä¸­çš„æ ¸å¿ƒæ€æƒ³ä¹‹ä¸€, é™¤äº†èƒ½å¤Ÿä»¥å½“å‰æ‰¾åˆ°çš„æœ€ä¼˜å€¼è¿›è¡Œé™ç•Œä»¥å¤–, ä¹Ÿå¯ä»¥é‡‡ç”¨å…¶ä»–çš„é™ç•Œå‡½æ•°æ„é€ æ–¹å¼

## äºŒã€ç›¸å…³é—®é¢˜
### (1) å•æºæœ€çŸ­è·¯å¾„é—®é¢˜
Dijkstra ç®—æ³•å’Œ Floyd ç®—æ³•å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure & Algorithms/ğŸ›°ï¸Algorithms/ç¬¬å››ç«  è´ªå¿ƒç®—æ³•#(4) å›¾çš„æœ€å°ç”Ÿæˆæ ‘å’Œæœ€çŸ­è·¯å¾„é—®é¢˜|ç¬¬å››ç«  è´ªå¿ƒç®—æ³•]]
æ±‚è§£æŸä¸ªé¡¶ç‚¹ S åˆ°é¡¶ç‚¹ t ä¹‹é—´çš„æœ€çŸ­è·¯å¾„:
![[attachments/Pasted image 20240928150821.png]]
å…·ä½“èŠ‚ç‚¹ç¼–å·å¦‚ä¸‹ï¼Œ æ±‚è§£ä» s åˆ° t ä¹‹é—´çš„æœ€çŸ­è·¯å¾„:
![[Excalidraw/ç¬¬å…­ç«  åˆ†æ”¯é™ç•Œæ³•(BFS) 2024-09-28 11.43.11]]
 æœç´¢è¿‡ç¨‹ä¸­, é¦–å…ˆ**åˆ›å»ºä¸€ä¸ªæœ€å°å †(ä¼˜å…ˆé˜Ÿåˆ—)**ï¼Œç”¨äºè¡¨ç¤ºæ´»èŠ‚ç‚¹ä¼˜å…ˆé˜Ÿåˆ—, å…¶ä¸­lengthè¶Šå°,ä¼˜å…ˆçº§è¶Šé«˜. 
  5
 å¦‚å›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ä¸­ï¼Œå‰ªææ–¹æ³•ä¸»è¦æœ‰ä¸¤ä¸ª:
 1. æ ¹æ®æœ€çŸ­çš„è·¯é•¿è¿›è¡Œå‰ªæ : å³å¦‚æœå½“å‰çš„è·¯é•¿å°äºå·²ç»æœç´¢åˆ°çš„æœ€é•¿è·¯é•¿, åˆ™å°†å½“å‰è·¯å¾„å‰ªå»ã€‚
 2. æ ¹æ®èŠ‚ç‚¹çš„æ§åˆ¶å…³ç³»è¿›è¡Œå‰ªæ : æ¯æ¬¡åˆ°è¿‡ä¸€ä¸ªèŠ‚ç‚¹, åˆ™å¯ä»¥åˆ©ç”¨èŠ‚ç‚¹æœ¬èº«çš„ç©ºé—´, è®¡ç®—å‡ºåˆ°è¾¾è¯¥èŠ‚ç‚¹çš„æœ€å°è·¯é•¿, å¦‚æœå¦å¤–ä¸€æ¡åˆ†æ”¯åˆ°è¾¾è¯¥èŠ‚ç‚¹çš„è·¯é•¿å¤§äºè¿™ä¸ªå€¼, åˆ™å‰ªå»è¯¥è·¯é•¿ã€‚
 3. å¯¹äºæŸäº›æƒ…å†µ, å­˜åœ¨**æŸä¸ªèŠ‚ç‚¹å…ˆæœç´¢åˆ°, ä½†æ˜¯åæœç´¢å‡ºæ¯”å…¶åŸå…ˆè·¯å¾„æ›´çŸ­çš„è·¯å¾„çš„æƒ…å†µ**, æ­¤æ—¶<mark style="background: transparent; color: red">å¦‚æœç»§ç»­æŒ‰ç…§è¿™ä¸ªå¹¿åº¦ä¼˜å…ˆæœç´¢, åˆ™å¿…å°†å‡ºç°é‡å¤èŠ‚ç‚¹çš„æƒ…å†µ</mark>ã€‚æ­¤æ—¶éœ€è¦åšçš„ï¼Œæ–¹æ³•ä¸€æ˜¯åœæ­¢ä»¥å‰è¿™ä¸ªæ ‘çš„èŠ‚ç‚¹çš„å¹¿åº¦ä¼˜å…ˆæœç´¢, ç„¶åé‡æ–°æœç´¢ä¸€æ¬¡ã€‚ æ–¹æ³•äºŒæ˜¯æŒ‰ç…§æœç´¢å‡ºçš„è·¯å¾„é‡æ–°æ›´æ–°æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„è·ç¦»ã€‚ä½†æ˜¯**è¿™ä¼šå¯¼è‡´åŸå…ˆå·²ç»æœç´¢è¿‡å˜ä¸ºæ­»èŠ‚ç‚¹çš„éƒ¨åˆ†,éƒ½é‡æ–°å˜æˆæ´»èŠ‚ç‚¹, é‡æ–°æ›´æ–°**
 4. <b><mark style="background: transparent; color: blue">è§£å†³é—®é¢˜3çš„æ–¹æ³•æ˜¯åˆ©ç”¨ä¸€ä¸ªæ•°ç»„ p (pre_nodes)è®°å½•ä»æºåˆ°æ¯ä¸ªé¡¶ç‚¹çš„å‰é©±èŠ‚ç‚¹ï¼Œæ³¨æ„: è™½ç„¶è®°å½•äº†å‰é©±èŠ‚ç‚¹ï¼Œ ä½†æ˜¯æ³¨æ„è¿™æ˜¯ç”¨äºæ„é€ æœ€çŸ­è·¯å¾„çš„, è€Œä¸èƒ½å¤Ÿè§£å†³æ­»ç»“ç‚¹é‡æ–°æ›´æ–°çš„é—®é¢˜ã€‚å®é™…ä¸Šè¿˜æ˜¯éœ€è¦ç»§ç»­æœç´¢çš„</mark></b>ã€‚
 5. å®é™…ä¸Šåªéœ€ä¸€ä¸ªæ•°ç»„è®°å½•åŸç‚¹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»å’Œå‰é©±èŠ‚ç‚¹å³å¯ã€‚
 6. å¯¹äºå®é™…çš„æ±‚è§£ä¸­, å®é™…ä¸Š**å®Œå…¨å¯ä»¥é‡å¤åŠ èŠ‚ç‚¹ï¼Œ è¿™æ˜¯ç”±äºæœ€å°ä¼˜å…ˆé˜Ÿåˆ—çš„æ€§è´¨å¾—åˆ°çš„**ã€‚ç”±äºä¼˜å…ˆé˜Ÿåˆ—æ€§è´¨ï¼Œå¿…å°†å…ˆæœç´¢å®Œè·ç¦»å°çš„æ›´çŸ­çš„èŠ‚ç‚¹ä»¥æ›´æ–°å®Œæ¯•å­èŠ‚ç‚¹çš„è·ç¦»ï¼Œè€Œå‰é¢å³ä½¿æ·»åŠ è¿‡é‡å¤èŠ‚ç‚¹ï¼Œåœ¨æ­¤ä¹‹åä¹Ÿå°±ä¼šç«‹åˆ»è¢«è‡ªåŠ¨å‰ªæ‰äº†ã€‚

`````ad-note
title: C++ä¸­æœ€å¤§å †å’Œæœ€å°å †çš„åˆ›å»º
collapse: open
- C++ä¸­ä½¿ç”¨include<queue>ä¸­çš„ `prior_queue` ç±»ã€‚
- `prior_queue`åœ¨åˆ›å»ºåˆå§‹æ—¶é»˜è®¤æ˜¯æœ€å¤§å †, å³æœ‰: `prior_queue<int> a` é»˜è®¤åˆ›å»ºæœ€å¤§å †ã€‚
- å¯ä»¥é€šè¿‡æŒ‡å®šæ¯”è¾ƒå‡½æ•°ï¼Œåˆ›å»ºæœ€å°å †(å³é‡è®¾æ¯”è¾ƒ`less`å‡½æ•°ä¸º`std::greater`): `std::priority_queue<int, std::vector<int>, std::greater<int>> nodes;`
`````

ä¸‹é¢ä»£ç æ±‚è§£äº†0åˆ°è¾¾æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»:
```cpp title:åˆ†æ”¯é™ç•Œæ³•æ±‚è§£å•æºæœ€çŸ­è·ç¦»
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

#define MAX_DISTANCE  100000

using namespace std;

const int n = 11;

int neibhor_matrix[n][n] = {
    {0, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 3, 0, 7, 2, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 9, 2, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0},
    {0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

int dist[n];   /* è®°å½•åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·ç¦» */
int pre[n];    /* è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å‰é©±é¡¶ç‚¹ (ç”¨äºæ„é€ æœ€çŸ­è·¯å¾„) */
int best_dis;        /* record the best distance choice */

/* é»˜è®¤é‡‡ç”¨æœ€å¤§å †è¿›è¡Œå­˜å‚¨, è€Œæˆ‘ä»¬é‡‡ç”¨æœ€å°å †è¿›è¡Œå­˜å‚¨, æ‰€ä»¥éœ€è¦é‡è½½æ¯”è¾ƒå‡½æ•° */
std::priority_queue<int, std::vector<int>, std::greater<int>> nodes;    

/* é‡‡ç”¨åˆ†æ”¯é™ç•Œæ³•æ±‚è§£é¡¶ç‚¹ 0 åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ */
void branch_boundary() {
    dist[0] = 0;
    for (int i = 1; i < n; i++) dist[i] = MAX_DISTANCE;
    memset(pre, 0, sizeof(pre));
    while (!nodes.empty()) nodes.pop();
    nodes.push(0);    /* å–æºèŠ‚ç‚¹ä¸ºåˆå§‹æ‰©å±•èŠ‚ç‚¹ */
    while (!nodes.empty()) {
        int idx = nodes.top();
        nodes.pop();
        for (int i = 0; i < n; i++) {
            if (neibhor_matrix[idx][i] != 0 && dist[idx] + neibhor_matrix[idx][i] < dist[i]){
                dist[i] = dist[idx] + neibhor_matrix[idx][i];
                pre[i] = idx;
                nodes.push(i);   /*  ç›´æ¥push å’Œè®°å½•å‰é©±èŠ‚ç‚¹å³å¯ */
            }
        }
    }
}

int main()
{
    branch_boundary();
    for (int i = 0; i < n; i++) {
        cout << dist[i] << " ";
    }
    cout << endl;
    for (int i = 0; i < n; i++) {
        int p = i;
        do {
            cout << p << "<-";
            p = pre[p];
        } while (p != 0);
        cout << "0" << endl;
    }
    return 0;
}
```

è¾“å‡ºç»“æœå¦‚ä¸‹:
```cpp
0 2 3 4 9 4 5 12 7 6 8
0<-0
1<-0
2<-0
3<-0
4<-1<-0
5<-1<-0
6<-2<-0
7<-4<-1<-0
8<-5<-1<-0
9<-6<-2<-0
10<-9<-6<-2<-0
```

### (2) è£…è½½é—®é¢˜
è£…è½½é—®é¢˜å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure & Algorithms/ğŸ›°ï¸Algorithms/ç¬¬äº”ç«  å›æº¯æ³•(DFS)#(1) è£…è½½é—®é¢˜|ç¬¬äº”ç«  å›æº¯æ³•(DFS)]], å®é™…ä¸Šæ˜¯ä¸€ä¸ªå­é›†æ ‘ã€‚
è£…è½½é—®é¢˜çš„åˆ†æ”¯é™ç•Œæ³•å…³é”®æ˜¯å‰ªææœºåˆ¶ :
1. å½“å‰æ‰€è£…è½½çš„éƒ¨åˆ†å¤§äº capacity æ—¶, è¿›è¡Œå‰ªæ
2. é‡‡ç”¨çš„ä¼˜å…ˆé˜Ÿåˆ—ç”¨äºå­˜å‚¨æœ€å¤§è½½é‡é‡, æ¯æ¬¡ä»…éœ€è®°å½•ä¸€ä¸ª layer, ç„¶åæ¯æ¬¡æŠŠ layer é€’å¢, å¹¶å…¥é˜Ÿæ‰€æœ‰çš„æ´»èŠ‚ç‚¹å³å¯ã€‚
3. ç”±äºåªæœ‰è£…å’Œä¸è£…ä¹‹åˆ†, æ‰€ä»¥è£…çš„é€‰æ‹©ä¸€å®šä¼šè¾¾åˆ°æœ€å, å› æ­¤å¯ä»¥ç›´æ¥å‰ªå» 

æ³¨æ„ï¼šå¦‚æœé‡‡ç”¨ä¼˜å…ˆé˜Ÿåˆ—è¿›è¡Œ, ä¼šç”±äºå°ç«¯æ’å…¥, å¯¼è‡´å°ç«¯çš„ 0 åœ¨å‰ï¼Œ push å®Œæ¯•ä¹‹å, ç”±äºæ˜¯å°ç«¯å­˜å‚¨, åˆ™è¾ƒå°çš„æ€»æ˜¯åœ¨æœ€å‰ç«¯ã€‚ä»è€Œæ¯æ¬¡ top å–å‡ºç»“æœéƒ½æ˜¯0, å› æ­¤å¯ä»¥ç›´æ¥é‡‡å–é˜Ÿåˆ—çš„æ–¹å¼ã€‚å…·ä½“ä»£ç å¦‚ä¸‹:
```cpp 
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
int times = 0;
int max_loading(int n, int* w, int capacity) {
    int max_load = 0;
    int layer = 0;
    /* å»ºç«‹ pq æ˜¯ç”¨æ¥å­˜å‚¨è½½é‡é‡çš„ä¼˜å…ˆé˜Ÿåˆ—(å°ç«¯) */
    queue<int> q;
    q.push(0);   /* å½“å‰çš„é€‰æ‹©æ˜¯ capacity = 0 */
    for (layer = 0; layer < n; layer++) {
        int s = q.size();
        if (layer == n - 1) {
            for (int i = 0; i < s; i++) {
                times++;
                int cap = q.front();
                q.pop();
                int c = cap + w[layer] <= capacity ? cap + w[layer] : cap;
                max_load = max(c, max_load);
            }
        }
        else {
            for (int i = 0; i < s; i++) {
                int cap = q.front();
                q.pop();
                times++;
                if (cap + w[layer] <= capacity) {
                    q.push(cap + w[layer]);  /* load w[layer] situation */
                    q.push(cap);             /* not load w[layer] situation */
                }
                else {
                    q.push(cap);   /* not load w[layer] situation */
                }
            }
        }        
    }
    return max_load;
}

int main() {
    int n = 10;
    int w[10] = { 2, 5, 9, 4, 2, 4, 3, 1, 2, 3 };
    int capacity = 20;

    int max_load = max_loading(n, w, capacity);
    cout << "The maximum loading is: " << max_load << endl;
    cout << "total searched times : " << times << endl;
    return 0;
}
```

å¯ä»¥çœ‹å‡ºï¼Œå®é™…ä¸Šä¸Šè¿°ç®—æ³•æ²¡æœ‰å‡å°‘å¤šå°‘è®¡ç®—è¿‡ç¨‹çš„å¤æ‚åº¦(å°è¯•æ¬¡æ•°é«˜è¾¾800)ï¼Œä»…ä»…æ˜¯å¯¹å¤šå‡ºçš„éƒ¨åˆ†è¿›è¡Œäº†å‰ªæã€‚
é™¤äº†é‡‡ç”¨**å‰©ä½™é›†è£…ç®±é‡é‡**å‰ªæ(åŠ ä¸Šå‰©ä½™ä¹Ÿä¸å¤Ÿ)ä»¥å¤–, ä¹Ÿå¯ä»¥åœ¨æœç´¢å­æ ‘çš„è¿‡ç¨‹ä¸­ä¿å­˜å½“å‰æ„é€ çš„å­é›†æ ‘çš„è·¯å¾„ã€‚

`````ad-note
title: åŸºäºä¼˜å…ˆé˜Ÿåˆ—çš„ä¼˜åŒ–
collapse: open
åœ¨ä¼˜å…ˆé˜Ÿåˆ—ä¸­, é˜Ÿåˆ—çš„ä¼˜å…ˆçº§å¯ä»¥å®šä¹‰ä¸º**ä»æ ¹èŠ‚ç‚¹åˆ°èŠ‚ç‚¹  $x$ çš„è·¯å¾„ç›¸åº”çš„è½½é‡é‡åŠ ä¸Šå‰©ä½™é›†è£…ç®±çš„é‡é‡**, ç„¶åä»ä¼˜å…ˆçº§æœ€å¤§çš„æ´»èŠ‚ç‚¹ä¸­ï¼Œé€‰æ‹©ä¸‹ä¸€ä¸ªæ‰©å±•èŠ‚ç‚¹ã€‚
æ³¨æ„ï¼šä»¥èŠ‚ç‚¹ $x$ ä¸ºæ ¹èŠ‚ç‚¹çš„ å­æ ‘ä¸­ï¼Œæ‰€æœ‰èŠ‚ç‚¹è·¯å¾„è½½é‡é‡ä¸è¶…è¿‡ `x.totalweight` æ³¨æ„: æ­¤æ—¶åœ¨ä¼˜å…ˆé˜Ÿåˆ—å¼åˆ†æ”¯é™ç•Œæ³•ä¸­ï¼Œ **ä¸€æ—¦æœ‰ä¸€ä¸ªå¶èŠ‚ç‚¹æˆä¸ºå½“å‰æ‰©å±•èŠ‚ç‚¹(n+1å±‚èŠ‚ç‚¹)ï¼Œåˆ™å¯ä»¥æ–­è¨€è¯¥å¶èŠ‚ç‚¹ç›¸åº”çš„è§£å³ä¸ºæœ€ä¼˜è§£**ï¼Œ å¦åˆ™æ²¡æœ‰å¯¹åº”çš„æœ€ä¼˜è§£ã€‚ 

åŒæ—¶, æˆ‘ä»¬å°†æœ€ä¼˜è§£çš„å¯è¡Œè·¯å¾„ç”±å­é›†æ ‘ä¸­ä»è¯¥èŠ‚ç‚¹å¼€å§‹æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆé€æ­¥è¿›è¡Œæ„é€ ã€‚
`````

é¦–å…ˆï¼Œå®é™…è£…è½½æ—¶, æœ€ä¼˜è§£æ€»æ˜¯ä»"è£…å…¥"çš„åˆ†æ”¯äº§ç”Ÿçš„ï¼Œå› è€Œæˆ‘ä»¬æ£€æŸ¥æœ€ä¼˜è§£<mark style="background: transparent; color: red">ä»…éœ€è¦æ¯”è¾ƒ"è£…å…¥"åçš„é‡é‡å¤§å°å’Œæœ€ä¼˜è§£å³å¯ã€‚</mark>

> [!caution] æ„é€ æ–¹å¼
> åœ¨æ‰€æœ‰çš„é€‰æ‹©ä¸­, å¯ä»¥ä»¥<b><mark style="background: transparent; color: red">è¯¥æƒ…å†µçš„è½½é‡é‡ + å‰©ä½™é‡é‡</mark></b>ä½œä¸ºæƒé‡ï¼Œè¿™æ˜¯ç”±äº, æˆ‘ä»¬å¸Œæœ›å…ˆå°è¯•"æœ‰å¯èƒ½è¾¾åˆ°æœ€å¤§è½½é‡é‡"çš„éƒ¨åˆ†è¿›è¡Œä¼˜å…ˆå°è¯•ã€‚<b><mark style="background: transparent; color: blue">ç”±äºè¯¥æƒ…å†µè½½é‡ + å‰©ä½™é‡é‡ å°äº æœ€å¤§é‡é‡æ—¶</mark></b>, æ˜¾ç„¶æ˜¯å¾—ä¸åˆ°æœ€ä¼˜è§£çš„ï¼Œè€Œä¸€æ—¦æ‰€æœ‰çš„éƒ½æœç´¢å®Œæ¯•ï¼Œæ˜¾ç„¶å¾—åˆ°çš„å°±æ˜¯æœ€ä¼˜è§£ã€‚è€Œè£…ä¸æ»¡çš„æƒ…å†µå¿…ç„¶å‡ºç°å¦å¤–èƒ½è£…æ»¡æƒ…å†µè½½é‡ + å‰©ä½™é‡é‡ > è¯¥ç‚¹è½½é‡ + å‰©ä½™é‡é‡ã€‚ ç”±äºè¿™æ ·æœç´¢å¿…å°†å¾—åˆ°æœ€ä¼˜è§£çš„æ€§è´¨ï¼Œæˆ‘ä»¬ç”šè‡³ä¸éœ€è¦è®°å½•å’Œæ¯”è¾ƒç›¸åº”èŠ‚ç‚¹çš„é‡é‡å’Œæœ€å¤§é‡é‡æ¯”è¾ƒ;
> 
> éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œå¾—åˆ°æœ€ä¼˜å€¼æ—¶ï¼Œæˆ‘ä»¬ä¸çŸ¥é“æœ€ä¼˜çš„é‡é‡æ˜¯å“ªå‡ ä»¶è´§ç»„æˆçš„ï¼Œå› æ­¤æˆ‘ä»¬åœ¨æœç´¢è¿‡ç¨‹ä¸­**æ–¹æ³•ä¸€æ˜¯æ¯ä¸ªè§£ä¿ç•™ä¸€ä¸ªæ•°ç»„ï¼Œå³ä¿ç•™æ ¹èŠ‚åˆ°æ¯ä¸ªæ´»èŠ‚ç‚¹çš„è·¯å¾„**, ä½†æ˜¯è¿™æ ·å†…å­˜å¼€é”€æ¯”è¾ƒå¤§ï¼›æ–¹æ³•äºŒæ˜¯ä¿ç•™æ„é€ çš„è§£ç©ºé—´æ ‘ã€‚å³<mark style="background: transparent; color: red">åªè®°å½•çˆ¶èŠ‚ç‚¹çš„æ–¹æ³•, ç„¶åå‘æ ¹èŠ‚ç‚¹å›æº¯å¾—åˆ°è§£çš„ç»„æˆã€‚</mark>

æ ¹æ®ä¸Šè¿°æ€è·¯ï¼Œä¼˜åŒ–ä¹‹åçš„è£…è½½é—®é¢˜ç®—æ³•ä»£ç å¦‚ä¸‹:  
```cpp title:è£…è½½é—®é¢˜ç®—æ³•ä»£ç 
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int times = 0;

typedef struct cargo{
    char id;
    int weight;
}cargo;

typedef struct node {
    node* parent;
    cargo* cur;       /* å½“å‰æ˜¯å¦é€‰æ‹©è¯¥è´§ç‰©, ä¸é€‰åˆ™ä¸º nullptr */
    int layer;        /* å½“å‰å±‚æ•° */ 
    int weight;       /* å½“å‰é€‰æ‹©çš„é‡é‡å€¼ */
    int weight_left;  /* å‰©ä½™é‡é‡å€¼ */
    node(node* p, cargo* c, int layer, int w, int w_left){
        this->parent = p;
        this->cur = c;
        this->layer  = layer;
        this->weight = w;
        this->weight_left = w_left;
    }
}node;

/* æ¯”è¾ƒç›¸åº”é‡é‡å€¼ + å‰©ä½™é‡é‡å€¼, å¤§çš„ä¼˜å…ˆ, æ‰€ä»¥é‡‡ç”¨ < */
struct cmp_node{
    bool operator()(const node *a, const node *b) const {
        return a->weight + a->weight_left < b->weight + b->weight_left;
    }
};

node* max_loading(int n, cargo cargo_arr[], int capacity) {
    /* æŒ‰ç…§é‡é‡é€’å‡æ’åºè´§ç‰©ä¾¿äºå¿«é€Ÿæœç´¢å‡ºéœ€è¦çš„è§£ */
    cargo* cargos_new = new cargo[n];
    memcpy(cargos_new, cargo_arr, sizeof(cargo) * n);
    std::sort(cargos_new, cargos_new + n, [](cargo a, cargo b) {return a.weight > b.weight; }); 
    
    int max_load = 0;

    vector<int> left_weight_arr(n);  /* æŒ‰ç…§å±‚è®¡ç®—é€‰æ‹©æ¯ä¸ª cargo åçš„å‰©ä½™è´¨é‡ */
    int tmp = 0;
    for (int i = n - 1; i >= 0; i--) {
        tmp += cargos_new[i].weight;
        left_weight_arr[i] = tmp;
    }

    priority_queue<node*, std::vector<node*>, cmp_node> nodes;
    node* root = new node(nullptr, nullptr, -1, 0, left_weight_arr[0]);    /* åˆ›å»ºæ ¹èŠ‚ç‚¹, ä¸åŠ å…¥ä»»ä½•èŠ‚ç‚¹ (layerä¸º-1) */
    nodes.push(root);

    node *best_node = nullptr;

    while (!nodes.empty()) {
        node* cur_node = nodes.top();
        nodes.pop();
        times++;
        int layer = cur_node->layer + 1;
        if (layer == n - 1) { /* å‡ºç° n çº§èŠ‚ç‚¹, å³æ‰¾åˆ°æœ€ä¼˜è§£ */ 
            best_node = cur_node;
            break;
        }
        if (cur_node->weight + left_weight_arr[layer] < max_load) continue;    /* ç”¨äºå‰ªæ, å»æ‰ä¸å¯èƒ½èŠ‚ç‚¹ */
        if (cur_node->weight + cargos_new[layer].weight <= capacity) {
            node* new_node1 = new node(cur_node, &cargos_new[layer], layer , cur_node->weight + cargos_new[layer].weight, left_weight_arr[layer + 1]);
            nodes.push(new_node1);
            max_load = max(max_load, new_node1->weight);
        }
        node* new_node2 = new node(cur_node, nullptr, layer, cur_node->weight, left_weight_arr[layer + 1]);
        nodes.push(new_node2);
    }
    return best_node;
}

void show_cargo_node(node* root) {
    if (!root) {
        cout << "no solution node to show" << endl;
        return;
    }
    cout << "--------- show cargo node of layer : " << root->layer << " ----------------" << endl;
    cout << "weight of this layer: " << root->weight << endl;
    node* cur = root;
    while (cur && cur ->layer!= -1) {
        if (cur->cur != nullptr) {
            cout << "id " << cur->cur->id << ", weight : " << cur->cur->weight << endl;
        }
        cur = cur->parent;
    }
}

int main() {
    int n = 10;
    int w[10] = { 2, 5, 9, 4, 2, 4, 3, 1, 2, 3 };
    // int w[10] = { 14, 10, 11, 15, 7, 4, 7, 4, 7, 8 };
    int capacity = 20;
    /* construct the cargo array */
    cargo cargos[10]; 
    for (int i = 0; i < n; i++) {
        cargos[i].id = 'A' + i;
        cargos[i].weight = w[i]; 
    }

    node* best_load = max_loading(n, cargos, capacity);
    show_cargo_node(best_load);
    cout << "total searched times : " << times << endl;
    return 0;
}
```

ä¸Šè¿°ä»£ç æ‰§è¡Œç»“æœæ˜¯:
```cpp
--------- show cargo node of layer : 8 ----------------
weight of this layer: 20
id E, weight : 2
id A, weight : 2
id J, weight : 3
id F, weight : 4
id D, weight : 4
id B, weight : 5
total searched times : 109
```
ä»…ç”¨äº† 109 æ¬¡è§£ç©ºé—´æœç´¢, å¯ä»¥çœ‹å‡ºå¤§å¤§æé«˜äº†è§£ç©ºé—´çš„æœç´¢æ•ˆç‡ã€‚

### (3) å¸ƒçº¿é—®é¢˜
å¸ƒçº¿é—®é¢˜å®é™…ä¸Šæ˜¯æŒ‰ç…§æ­¥æ•°è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢çš„é—®é¢˜ã€‚
é¦–å…ˆåœ¨ä¸€ä¸ª $n \times n$ çš„æ–¹æ ¼ä¸Š, å…¶ä¸­ä¸å¯å¸ƒçº¿åŒºåŸŸé‡‡ç”¨ 1 æ ‡è®°, è€Œç¡®å®šä»ç‚¹  $A(x_1, y_1)$ åˆ°  $B(x_2, y_2)$ çš„æœ€çŸ­å¸ƒçº¿ã€‚

å–å¦‚ä¸‹çš„çŸ©é˜µ, å…¶ä¸­çº¢è‰²éƒ¨åˆ†ä¸ºä¸å¯å¸ƒçº¿åŒºåŸŸ; 
![[Excalidraw/ç¬¬å…­ç«  åˆ†æ”¯é™ç•Œæ³•(BFS) 2024-10-01 21.32.10|350]]


> [!caution] æ€æƒ³
>  éœ€è¦è¯´æ˜çš„æ˜¯, åœ¨å¸¦æœ‰é‡å¤æœç´¢é—®é¢˜çš„æƒ…å†µä¸‹,ä¸€ä¸ªé‡è¦æ–¹æ³•æ˜¯é‡‡ç”¨ä¸€ä¸ª steps æ•°ç»„, è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­æœç´¢åˆ°çš„æ­¥é•¿, åŒæ—¶ä¼šæ ¹æ®è·¯å¾„çŸ­è¿›é€‰æ‹©æƒé‡(ä¾‹å¦‚æœ€çŸ­è·¯å¾„åˆ™å»ºç«‹æœ€å°ä¼˜å…ˆé˜Ÿåˆ—), è¿™æ ·å°±å¯ä»¥é¿å…é‡å¤æœç´¢ï¼ˆå‡å°‘æœç´¢æ¬¡æ•°ï¼‰, åŒæ—¶æŒ‰ç…§çŸ­çš„æ–¹å¼è¿›è¡Œæœç´¢
>  

é—®é¢˜æ±‚è§£ä»£ç è¾ƒä¸ºç®€å•ï¼Œå…·ä½“å¦‚ä¸‹:
```cpp
#include<iostream> 
#include<algorithm>
#include<queue> 
#include<vector>

using namespace std;
const int n = 7;

int mat[n][n] = {
        {0, 0, 1, 0, 0, 0, 0},
        {0, 0, 1, 1, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0},
        {0, 0, 0, 1, 1, 0, 0},
        {1, 0, 0, 0, 1, 0, 0},
        {1, 1, 1, 0, 0, 0, 0},
        {1, 1, 1, 0, 0, 0, 0}
};
int steps[n][n];
int best_option[n][n];
const int fst[4] = { -1, 1, 0, 0 };
const int scd[4] = { 0, 0, -1, 1 };

/* å°†å„ä¸ªèŠ‚ç‚¹ä¸­, è·ç¦»å°çš„è¿›è¡Œå‰ç½® */
struct steps_cmp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) {
        return mat[a.first][a.second] > mat[b.first][b.second];
    }
};

/*  */
void bfs(int start_x, int start_y, int end_x, int end_y) { 

    // if (steps[i][j] > -1 && step > steps[i][j]) return;
    
    std::priority_queue<std::pair<int,int>, vector<std::pair<int, int>>, steps_cmp> q;
    q.push(std::make_pair(start_x, start_y));
    steps[start_x][start_y] = 0;

    /* boarden search */
    while (!q.empty()) {
        std::pair<int, int> node = q.top();
        q.pop();
        int xo = node.first;
        int yo = node.second;
        if (xo == end_x && yo == end_y) return;
        for (int i = 0; i < 4; i++) {
            int x = xo + fst[i];
            int y = yo + scd[i];
            if (x >= 0 && x < n && y >= 0 && y < n && mat[x][y] == 0) {
                if (steps[x][y] > -1 && steps[xo][yo] + 1 >= steps[x][y]) {
                    continue;
                }
                else {
                    steps[x][y] = steps[xo][yo] + 1;
                    best_option[x][y] = i;
                    q.push(std::make_pair(x, y));
                }
            }
        }
    }
}

/* ç”µè·¯å¸ƒçº¿é—®é¢˜ */
int main() {
    memset(steps, 0, sizeof(steps));
    memset(best_option, 0, sizeof(best_option));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            steps[i][j] = -1;
            best_option[i][j] = -1;
        }
    }
    int start_x = 2, start_y = 1;
    int end_x = 3, end_y = 5;

    bfs(start_x, start_y, end_x, end_y );
    cout << "minimum steps : " << steps[end_x][end_y] << endl;
    int x = end_x, y = end_y;
    if (steps[end_x][end_y] != -1) {
        while (x != start_x || y != start_y) {
            cout << "(" << x << "," << y << ")<-";
            int idx = best_option[x][y];
            if (idx < 0) break;
            x = x - fst[idx];
            y = y - scd[idx];
        }
        cout << x << "," << y << endl;
    }
    return 0;
}
```

### (4) æœ€å¤§å›¢é—®é¢˜
é—®é¢˜å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure & Algorithms/ğŸ›°ï¸Algorithms/ç¬¬äº”ç«  å›æº¯æ³•(DFS)#(5) æœ€å¤§å›¢é—®é¢˜|ç¬¬äº”ç«  å›æº¯æ³•(DFS)]] çš„ç›¸åŒé—®é¢˜, é‡‡ç”¨åˆ†æ”¯é™ç•Œæ–¹æ³•æ±‚è§£æœ€å¤§å›¢é—®é¢˜ã€‚<mark style="background: transparent; color: red">é‡‡ç”¨å­é›†æ ‘çš„æ–¹æ³•</mark>å¯¹æœ€å¤§å›¢é—®é¢˜è¿›è¡Œéå†å’Œæ±‚è§£ã€‚å› æ­¤å®é™…ä¸Šæ˜¯ç±»ä¼¼äºé›†è£…ç®±é—®é¢˜, å¯æŒ‰ç…§è¯¥é—®é¢˜çš„æ€è·¯è¿›è¡Œæ±‚è§£ã€‚

![[Excalidraw/ç¬¬äº”ç«  å›æº¯æ³•(DFS) 2024-09-23 19.37.58|500]]

```cpp
int adjacency_matrix[7][7] = {
    {0, 1, 1, 1, 0, 0, 1}, // connection for node 1
    {1, 0, 0, 0, 1, 0, 1}, // connection for node 2
    {1, 0, 0, 1, 0, 0, 1}, // connection for node 3
    {1, 0, 1, 0, 1, 0, 1}, // connection for node 4
    {0, 1, 0, 1, 0, 1, 1}, // connection for node 5
    {0, 0, 0, 0, 1, 0, 1}, // connection for node 6
    {1, 1, 1, 1, 1, 1, 0}  // connection for node 7
};
```

<b><mark style="background: transparent; color: blue">éœ€è¦æ³¨æ„</mark></b>: æˆ‘ä»¬ä¸é‡‡ç”¨æ¯ä¸€ä¸ªå‘é‡å­˜å‚¨å­é›†æ ‘éå†è¿‡ç¨‹ä¸­çš„é€‰æ‹©æ•°ç»„, è€Œæ˜¯ç›´æ¥é‡‡ç”¨æ ‘ç»“æ„è¿›è¡Œå­˜å‚¨, è¿™æ ·èƒ½å¤Ÿæ˜¾è‘—å‡å°‘å®é™…çš„å­˜å‚¨ç©ºé—´;

å…·ä½“ä»£ç å¦‚ä¸‹æ‰€ç¤º:
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std; 

const int n = 7;

/* æ±‚è§£æœ€å¤§å›¢é—®é¢˜çš„åˆ†æ”¯é™ç•Œæ–¹æ³• */
int adjacency_matrix[n][n] = {
    {0, 1, 1, 1, 0, 0, 1}, // connection for node 1
    {1, 0, 0, 0, 1, 0, 1}, // connection for node 2
    {1, 0, 0, 1, 0, 0, 1}, // connection for node 3
    {1, 0, 1, 0, 1, 0, 1}, // connection for node 4
    {0, 1, 0, 1, 0, 1, 1}, // connection for node 5
    {0, 0, 0, 0, 1, 0, 1}, // connection for node 6
    {1, 1, 1, 1, 1, 1, 0}  // connection for node 7
};

/* é‡‡ç”¨æ ‘ç»“æ„è¿›è¡Œå­˜å‚¨, è¿™ä¸ªæ˜¯ä¸ºäº†é¿å…æ¯ä¸ªè§£å­˜å‚¨ä¸€ä¸ªå‘é‡è€Œå¢åŠ å¤æ‚åº¦ */
typedef struct cnode {
    cnode* parent;
    int cur_idx;   /* å½“å‰æœç´¢åˆ°çš„å±‚ */
    int elem;           /* å½“å‰æœç´¢åˆ°çš„ä¸º 0 æˆ–è€… 1 (å…¶ä¸­1ä¸ºå­˜åœ¨é›†åˆä¸­) */
    int size;           /* å½“å‰å¾—åˆ°çš„æœ€å¤§å›¢å¤§å° */
    cnode(cnode* parent, int cur_idx, int elem, int size)  {
        this->parent = parent;
        this->cur_idx = cur_idx;
        this->elem = elem;
        this->size = size;
    }
}cnode;

struct cmp {
    bool operator()(const cnode *a, const cnode *b){
        /* int idx = *max_element(vec.begin(), vec.end()) + 1; */
        return a->size + (n-1) - a->cur_idx < b->size + (n-1) - b->cur_idx;     /* æŒ‰ç…§å½“å‰å›¢å¤§å° + å‰©ä½™å…ƒç´ ä¸ªæ•°æ’åº, å»ºç«‹å›¢ */
    }
};

/* æ±‚è§£æœ€å¤§å›¢é—®é¢˜çš„åˆ†æ”¯é™ç•Œæ–¹æ³• */
cnode* get_max_clique() {
    cnode* root = new cnode(NULL, -1, 0, 0);
    priority_queue<cnode*, vector<cnode*>, cmp> pq;
    pq.push(root);
    
    while (true) {
        cnode* node = pq.top();
        pq.pop();

        /* check if the node can be added into the max clique */
        int new_idx = node->cur_idx + 1;
        if (new_idx == n) return node;   /*  reach the last layer */

        bool flag = true;
        for (cnode* c = node; c->parent != NULL; c = c->parent) {
            /* æ£€æŸ¥å›¢å…¼å®¹æ€§ */
            if (c->elem == 1 && !adjacency_matrix[c->cur_idx][new_idx]) {
                flag = false;
            }
        }
        cnode *new_node1 = new cnode(node, new_idx, 0, node->size);
        pq.push(new_node1);

        if (flag) {
            cnode *new_node2 = new cnode(node, new_idx, 1, node->size + 1);
            pq.push(new_node2);
        }
    }
    return root;
}

int main() {
    cnode* node = get_max_clique();
    while (node->parent != NULL) {
        if (node->elem) {
            cout << node->cur_idx << " ";
        }
        node = node->parent;
    }
    return 0;
}
```

### (5) æ—…è¡Œå•†é—®é¢˜
å¯¹äºæ—…è¡Œå•†é—®é¢˜çš„åˆ†æ”¯é™ç•Œæ–¹æ³•, å®é™…ä¸Šæ˜¯æ’åˆ—æ ‘çš„è§£ç©ºé—´æœç´¢é—®é¢˜ã€‚ä¸€èˆ¬ä¼šä»¥æœ€çŸ­è·ç¦»ä¸ºæƒé‡å»ºç«‹ä¼˜å…ˆé˜Ÿåˆ—ã€‚

å¯¹äºæ’åˆ—æ ‘, ä¸€èˆ¬ä¹Ÿæœ‰ä¸¤ç§ä¸çš„å®ç°æ–¹å¼, ä¸€ç§æ˜¯**ä»…é‡‡ç”¨ä¼˜å…ˆé˜Ÿåˆ—å­˜å‚¨æ´»èŠ‚ç‚¹**, å¦ä¸€ç§æ˜¯é‡‡ç”¨ä¼˜å…ˆé˜Ÿåˆ—å­˜å‚¨æ´»èŠ‚ç‚¹, åŒæ—¶å­˜å‚¨å½“å‰æ„é€ å‡ºçš„éƒ¨åˆ†æ’åˆ—æ ‘ï¼Œæ­¤æ—¶å®¹æ˜“é€šè¿‡å›æº¯è·å–åˆ°è§£çš„å½¢æˆæ–¹å¼ã€‚

é¦–å…ˆ, æˆ‘ä»¬å€ŸåŠ© python äº§ç”ŸèŒƒå›´å†…çš„éœ€è¦çš„åŸå¸‚çš„ç‚¹: ç”Ÿæˆ 20 ä¸ªåŸå¸‚, ä½ç½®å¦‚ä¸‹: 
![[attachments/Pasted image 20241006000007.png|400]]

```python
import numpy as np  
import matplotlib.pyplot as plt  
  
x_range = np.array([0, 100], dtype=np.float32)  
y_range = np.array([0, 100], dtype=np.float32)  
  
city_num = 20  
citys = np.array([[np.random.rand() * (x_range[1] - x_range[0]) + x_range[0]  for i in range(city_num)],  
                 [np.random.rand() * (y_range[1] - y_range[0]) + y_range[0]  for i in range(city_num)]], dtype = np.float32)  
dist_mat = np.zeros((city_num, city_num), dtype=np.float32)  
for i in range(city_num):  
    for j in range(city_num):  
        dist = np.sqrt((citys[0][i] - citys[0][j])**2 + (citys[1][i] - citys[1][j])**2)  
        dist_mat[i][j] = dist  
for i in range(city_num):  
    print("{", end='')  
    for j in range(city_num):  
        print(f"{dist_mat[i][j]:.2f},",end='')  
    print("}")  
  
fig = plt.figure()  
ax = fig.add_subplot(111)  
ax.scatter(citys[0], citys[1], color='red')  
for i in range(citys.shape[1]):  
    city = citys[:, i]  
    ax.text(city[0], city[1]-0.01, f'{i+1}', fontsize=12, ha='center', va='bottom')  
plt.show()
```

æ­¤æ—¶, å½¢æˆæ’åˆ—æ ‘, å¹¶é‡‡ç”¨åˆ†æ”¯é™ç•Œæ–¹æ³•è¿›è¡Œæœç´¢, è€Œ<mark style="background: transparent; color: red">å¯¹äºæ’åˆ—æ ‘çš„æœç´¢çš„åˆ†æ”¯é™ç•Œç®—æ³•</mark>, å…³é”®æ˜¯é‡‡ç”¨ä½•ç§æ–¹æ³•è¿›è¡Œä¼˜å…ˆæœç´¢ã€‚
å¦‚æœæˆ‘ä»¬ä»¥å½“å‰çš„è·ç¦»ä¸ºæƒé‡å»ºç«‹å°æ ¹å †, <mark style="background: transparent; color: red">å½“æœ‰æ»¡èŠ‚ç‚¹çš„æƒ…å†µè¢«å¼¹å‡ºæ—¶, åˆ™è¿™ç§æƒ…å†µä¸€å®šæ˜¯æœ€ä¼˜çš„ã€‚</mark>å› ä¸º**å‡è®¾æœ‰å…¶ä»–è§£æ¯”å½“å‰è§£çš„è·ç¦»å°, åˆ™åŠ æˆæ»¡èŠ‚ç‚¹çš„æƒ…å†µå, è·ç¦»ä¸€å®šæ›´å°ä¸”æ˜¯æ’åœ¨å‰é¢çš„**, æ˜¾ç„¶ä¼šæ¯”å½“å‰è·ç¦»æ›´é•¿çš„å…ˆå¼¹å‡ºã€‚

æ­¤å¤–, è¿˜æœ‰æ›´å¤šåŸºäºæ­¤çš„ä¼˜åŒ–æ–¹æ³• : 
1. é¦–å…ˆ, é’ˆå¯¹æ¯ä¸ªé¡¶ç‚¹æ‰¾å‡ºæ¯ä¸ªé¡¶ç‚¹çš„æœ€å°è·ç¦»å‡ºè¾¹ï¼Œå¹¶é‡‡ç”¨ $ldist$ è¿›è¡Œè®°å½•, è€Œ rdist è®°å½• $x[s:n-1]$  ä¸­çš„<mark style="background: transparent; color: red">é¡¶ç‚¹æœ€å°å‡ºè¾¹è·ç¦»å’Œ</mark>ã€‚
2. å¦‚æœå‡ºç°æŸä¸ªé¡¶ç‚¹æ²¡æœ‰å‡ºè¾¹, åˆ™<mark style="background: transparent; color: red">ç®—æ³•å³åˆ»ç»“æŸ, æ˜¾ç„¶æ‰¾ä¸åˆ°å›è·¯</mark>

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

const int n = 20;

/* å®šä¹‰ A çš„é‚»æ¥çŸ©é˜µ */
float Dist[n][n] = {
{0.00,71.65,62.79,43.82,30.01,46.88,39.27,73.31,32.98,30.35,84.60,40.74,66.95,38.10,44.93,69.53,50.89,34.97,29.19,52.60,},
{71.65,0.00,35.36,34.45,41.77,79.43,76.31,81.59,53.78,49.49,14.49,32.70,87.82,79.78,80.09,11.70,25.59,74.53,97.95,35.68,},
{62.79,35.36,0.00,48.56,41.32,49.90,49.28,46.41,32.28,56.28,48.25,41.66,105.08,87.10,51.31,24.16,19.22,81.82,91.98,56.67,},
{43.82,34.45,48.56,0.00,17.39,70.57,64.70,84.99,42.85,15.84,44.21,7.67,57.15,45.36,70.07,38.59,29.34,40.08,66.12,10.83,},
{30.01,41.77,41.32,17.39,0.00,53.58,47.47,70.42,26.42,15.57,54.60,11.60,65.62,45.79,52.94,40.94,24.31,40.50,56.54,28.12,},
{46.88,79.43,49.90,70.57,53.58,0.00,7.61,29.46,28.02,65.82,93.84,63.47,112.12,84.60,2.61,70.76,54.08,80.87,69.13,81.40,},
{39.27,76.31,49.28,64.70,47.47,7.61,0.00,36.07,23.15,59.00,90.79,57.86,104.69,77.02,5.87,68.43,50.73,73.34,61.98,75.52,},
{73.31,81.59,46.41,84.99,70.42,29.46,36.07,0.00,44.94,85.19,94.66,77.32,134.51,109.26,32.05,70.57,60.05,104.90,97.95,95.25,},
{32.98,53.78,32.28,42.85,26.42,28.02,23.15,44.94,0.00,40.42,68.25,35.58,89.58,65.20,27.88,46.96,28.28,60.55,61.65,53.65,},
{30.35,49.49,56.28,15.84,15.57,65.82,59.00,85.19,40.42,0.00,59.98,17.30,50.08,31.68,64.77,51.83,38.12,26.28,50.38,22.58,},
{84.60,14.49,48.25,44.21,54.60,93.84,90.79,94.66,68.25,59.98,0.00,44.38,92.07,88.40,94.53,24.14,40.08,83.37,109.76,42.12,},
{40.74,32.70,41.66,7.67,11.60,63.47,57.86,77.32,35.58,17.30,44.38,0.00,63.49,48.78,63.10,34.55,22.55,43.39,65.47,18.18,},
{66.95,87.82,105.08,57.15,65.62,112.12,104.69,134.51,89.58,50.08,92.07,63.49,0.00,29.95,110.55,94.74,86.04,32.03,63.75,52.27,},
{38.10,79.78,87.10,45.36,45.79,84.60,77.02,109.26,65.20,31.68,88.40,48.78,29.95,0.00,82.79,83.28,69.59,5.40,35.45,46.57,},
{44.93,80.09,51.31,70.07,52.94,2.61,5.87,32.05,27.88,64.77,94.53,63.10,110.55,82.79,0.00,71.68,54.62,79.16,66.70,80.90,},
{69.53,11.70,24.16,38.59,40.94,70.76,68.43,70.57,46.96,51.83,24.14,34.55,94.74,83.28,71.68,0.00,19.32,77.90,97.34,42.68,},
{50.89,25.59,19.22,29.34,24.31,54.08,50.73,60.05,28.28,38.12,40.08,22.55,86.04,69.59,54.62,19.32,0.00,64.22,79.34,37.69,},
{34.97,74.53,81.82,40.08,40.50,80.87,73.34,104.90,60.55,26.28,83.37,43.39,32.03,5.40,79.16,77.90,64.22,0.00,36.57,41.73,},
{29.19,97.95,91.98,66.12,56.54,69.13,61.98,97.95,61.65,50.38,109.76,65.47,63.75,35.45,66.70,97.34,79.34,36.57,0.00,72.16,},
{52.60,35.68,56.67,10.83,28.12,81.40,75.52,95.25,53.65,22.58,42.12,18.18,52.27,46.57,80.90,42.68,37.69,41.73,72.16,0.00,},
};

typedef struct tree_node {
    float cur_dist;
    int cur_idx;    /* stop when cur_idx = 0 */
    tree_node* parent;
    //vector<int> node_ava_nxt;    vector<int> node_ava_nxt

    tree_node(float cur_dist, int cur_idx, tree_node* parent) {
        this->cur_dist = cur_dist;
        this->cur_idx = cur_idx;
        this->parent = parent;
        // this->node_ava_nxt = node_ava_nxt;
    } 
}tree_node;

/* sort each dist in node and return the index needed */
void get_sorted_idx(int n, int** sorted_idx) {
    for (int i = 0; i < n; i++) {
        std::vector<std::pair<float, int>>  distances;
        for (int j = 0; j < n; j++) {
            distances.push_back(std::make_pair(Dist[i][j], j));
        }
        std::sort(distances.begin(), distances.end());
        for (int j = 0; j < n; j++) {
            sorted_idx[i][j] = distances[j].second;
        }
    }
}

vector<int> get_available_nodes(tree_node* cur_node, int** sorted_idx, int n) {
    vector<int> ava_nodes;
    for (int i = 0; i < n; i++) {
        ava_nodes.push_back(sorted_idx[cur_node->cur_idx][i]);
    }
    tree_node* t = cur_node;
    while (t!= NULL) {
        auto it = std::find(ava_nodes.begin(), ava_nodes.end(), t->cur_idx);
        if (it != ava_nodes.end()) {
            ava_nodes.erase(it);
        }
        t = t->parent;
    }
    return ava_nodes;
}

struct cmp {
    // sort from small to large 
    bool operator()(tree_node* a, tree_node* b) {
        return a->cur_dist > b->cur_dist;
    }
};

tree_node* traveling_problem(int n) {
    int** sorted_idx = new int*[n];
    for (int i = 0; i < n; i++) 
        sorted_idx[i] = new int[n];
    get_sorted_idx(n, sorted_idx);

    tree_node* root = new tree_node(0, 0, NULL);   /* start from node 0 */
    priority_queue<tree_node*, vector<tree_node*>, cmp> pq;
    pq.push(root);
    
    while (!pq.empty()) {
        tree_node* cur_node = pq.top();
        pq.pop();
        if (cur_node->cur_idx == 0 && cur_node->parent != NULL) {
            return cur_node;
        }
        /* note : if we need to search all the path, must add "else" after remove "return" above */
        vector<int> ava_nodes = get_available_nodes(cur_node, sorted_idx, n);
        if (ava_nodes.size() == 0) {
            float new_dist = cur_node->cur_dist + Dist[cur_node->cur_idx][0];   /* return to 0 to form a loop */
            tree_node* new_node = new tree_node(new_dist, 0, cur_node);
            pq.push(new_node);
        }
        else {
            for (int idx : ava_nodes) {
                float new_dist = cur_node->cur_dist + Dist[cur_node->cur_idx][idx];
                tree_node* new_node = new tree_node(new_dist, idx, cur_node);
                pq.push(new_node);
            }
        }
    }
    return NULL;
}

const int n_srh = 10; /* only calculate the search range */

int main() {
    tree_node *cur_node =  traveling_problem(n_srh);
    if (cur_node != NULL) {
        cout << "find available distance loop : " << cur_node->cur_dist << endl;
        while (cur_node != NULL) {
            cout << cur_node->cur_idx ;
            if (cur_node->parent != NULL) 
                cout << "->";
            cur_node = cur_node->parent;
        } 
    }
    else {
        cout << "no available loop" << endl;
    }
    return 0;
}
```

åœ¨è®¾å®šè§„æ¨¡ä¸º10æ—¶,æ‰¾åˆ°çš„å›è·¯ä¸º 0->8->6->5->7->2->1->3->9->4->0 (270.84)
![[attachments/Pasted image 20241006234801.png|400]]


### (6) ç”µè·¯æ¿æ’åˆ—é—®é¢˜
ç”µè·¯æ¿æ’åˆ—é—®é¢˜å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure & Algorithms/ğŸ›°ï¸Algorithms/ç¬¬äº”ç«  å›æº¯æ³•(DFS)#(8) ç”µè·¯æ¿æ’åˆ—é—®é¢˜|å›æº¯æ³•]], å³åˆ—ä¸¾å…¨éƒ¨ç”µè·¯æ¿æ’åˆ—çš„é—®é¢˜ã€‚
æ˜¾ç„¶, å½“å‰é¢çš„æ’åˆ—å·²ç»ç¡®å®šæ—¶, æœ€å¤§å€¼å°±å·²ç»ç¡®å®šäº†, å› æ­¤æˆ‘ä»¬ä»å½“å‰æ’åˆ—ä¸­, æŒ‰ç…§å¯†åº¦æœ€å°è¿›è¡Œä»å°åˆ°å¤§å»ºç«‹æœ€å°å †, è€ŒèŠ‚ç‚¹è®°å½•å½“å‰çš„æœ€å°å¯†åº¦å³å¯ã€‚

å›æº¯æ³•ä¸­, æˆ‘ä»¬é‡‡ç”¨é€’å½’å®ç°äº†æ’åˆ—æ ‘çš„éå†, è€Œéœ€è¦æ³¨æ„çš„æ˜¯ bestd(å½“å‰æœ€ä¼˜è§£å‚æ•°)ç”¨äºè¿›è¡Œå‰ªæã€‚å¦‚æœå½“å‰æ‰©å±•èŠ‚ç‚¹çš„ cur_dens ä¸å°äº bestd (å› ä¸º<mark style="background: transparent; color: red">æˆ‘ä»¬éœ€è¦è€ƒè™‘æœ€åä¸€å—ç”µè·¯æ¿çš„å¯†åº¦</mark>, æ‰€ä»¥å®é™…ä¸Šå’Œæ—…è¡Œå•†é—®é¢˜ç±»ä¼¼çš„, æˆ‘ä»¬**å¯ä»¥é‡‡ç”¨æœ€å¤§çš„å¸¦æœ‰å…¨éƒ¨èŠ‚ç‚¹çš„æ’åˆ—å‡ºé˜Ÿæ—¶ï¼Œåˆ™ç›´æ¥æ‰¾åˆ°æœ€ä¼˜çš„è§£ï¼Œè€Œå¯†åº¦åœ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹äº§ç”Ÿæ—¶å°±å·²ç»ç¡®å®šäº†,å¯ä»¥ç”¨äºå‰ªæ**)

éœ€è¦è¯´æ˜çš„æ˜¯, åœ¨æ’åˆ—æ ‘è¿›éå†æ—¶, <b><mark style="background: transparent; color: blue">ç›¸å¯¹äºå›æº¯æ³•, æ¯ä¸ªèŠ‚ç‚¹éƒ½è¦è®°å½•å½“å‰çš„å„ä¸ªæ¿å‰©ä½™çš„çº¿å¤´æ•°é‡</mark></b>ï¼Œ å› æ­¤<mark style="background: transparent; color: red">å¯¹äºç”µè·¯æ¿æ’åˆ—é—®é¢˜, åˆ†æ”¯é™ç•Œæ³•éœ€è¦æ›´å¤šçš„ç©ºé—´æ¶ˆè€—</mark>.

ä¸‹é¢ç»™å‡ºäº†ä¸€ä¸ªç®€å•ç¤ºä¾‹, æ²¡æœ‰åŠ æœ«å°¾çš„è®°å½•å’Œå‰ªæ:
```cpp title:ç”µè·¯æ¿æ’åˆ—é—®é¢˜,åˆ†æ”¯é™ç•Œæ–¹æ³•
#include <iostream>
#include <array>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

const int n = 8;
const int m = 5;
int circuit_boards[n];       /* ç”µè·¯æ¿çš„æ’åˆ—æ•°ç»„ */
int best_circuit_boards[n];  /* ç”µè·¯æ¿æ’åˆ—æ•°ç»„çš„æœ€ä½³ç»“æœ */
int wire_nums[n - 1];        /* æ¯ä¸ªåŒºé—´ä¹‹é—´çš„è¿çº¿æ•°é‡ */
int best_wire_nums[n - 1];   /* ç”µè·¯æ¿åŒºé—´ä¹‹é—´çš„è¿çº¿æ•°é‡çš„æœ€ä½³ç»“æœ */

// int conn_tot[m];             /* è®°å½•æ¯ä¸ªæ–¹æ³•æ€»æ•°é‡çš„å…¨å±€å˜é‡ */
const std::array<std::vector<int>, m> circuit_conn = { {
    {3,4,5},
    {0, 1},
    {0, 2},
    {2, 5},
    {6, 7},
} };

int** init_conn_matrix(array<vector<int>, m> conn) {
    /* æ–°å»ºä¸€ä¸ªçŸ©é˜µ, å­˜å‚¨æ¯ä¸ªè¿æ¥å—æ˜¯å¦æœ‰èŠ‚ç‚¹, å³è¿æ¥å— */
    int** conn_mat = new int* [m];   /* block m */
    for (int i = 0; i < m; i++) {
        conn_mat[i] = new int[n];    /* index n */
        /* å°†æ‰€æœ‰å…ƒç´ è®¾ç½®ä¸º0 */
        for (int j = 0; j < n; j++) {
            conn_mat[i][j] = 0;
        }
    }
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < circuit_conn[i].size(); j++) {
            conn_mat[i][circuit_conn[i][j]] = 1;
        }
    }
    return conn_mat;
}
int conn_tot[m];

typedef struct node {
    int density;
    int idx;
    node* parent;
    int size; /* å½“å‰æ’åˆ—çš„é•¿åº¦ */
    int conn_left[m];
    node(int density, int idx, node* parent, int size) {
        this->density = density;
        this->idx = idx;
        this->parent = parent;
        this->size = size;
        for (int i = 0; i < m; i++) {
            conn_left[i] = circuit_conn[i].size();
        }
    }
}node;

struct cmp {
    bool operator()(const node* a,const node* b) {
        return a->density > b->density; /* å°é¡¶å † */
    }
};

node* circuit_board_problem(int n) {
    int** conn_matrix = init_conn_matrix(circuit_conn);
    priority_queue<node*, vector<node*>, cmp> pq;

    int min_res_find = m; /* åˆå§‹åŒ–æœ€å¤§ç»“æœ */ 
    /* åˆå§‹åŒ– conn_tot æ•°ç»„ */
    for (int i = 0; i < m; i++) {
        conn_tot[i] = circuit_conn[i].size();
    }

    for (int i = 0; i < n; i++) {
        node* cur_node = new node(0, i, nullptr, 1);
        for (int j = 0; j < m; j++) {
            cur_node->conn_left[j] -= conn_matrix[j][i];
        }
        pq.push(cur_node);
    }

    while (!pq.empty()) {
        node* cur_node = pq.top();
        pq.pop();
        /* æ’åˆ—æ ‘éå† -> æ‰¾åˆ°ç»“æœåˆ™æœ€ä¼˜ */
        if (cur_node->size == n) {
            return cur_node;
        }
        /* æšä¸¾ä¸‹ä¸€å—æ¿ */
        
        for (int i = 0; i < n; i++) {
            /* ä»æ ‘ä¸­æœç´¢ä¹‹å‰çš„èŠ‚ç‚¹ */
            node* t = cur_node;
            while (t != nullptr) {
                if (t->idx == i) {
                    break;
                }
                t = t->parent;
            }
            if (t!=nullptr) continue;  /* å¦‚æœå·²ç»å­˜åœ¨, åˆ™è·³è¿‡ */ 
            
            node* new_node = new node(0, i, cur_node, 0);  /* å¤åˆ¶å½“å‰èŠ‚ç‚¹ */
            /* å¤åˆ¶ parent çš„ conn_left */
            for (int k = 0; k < m; k++) {
                new_node->conn_left[k] = cur_node->conn_left[k];
            }
            // memcpy(new_node->conn_left, cur_node->conn_left, m *  sizeof(int));
            
            /* è®¡ç®—å½“å‰èŠ‚ç‚¹éƒ¨åˆ†çš„è¿çº¿æ•°é‡ */
            int sum = 0;
            for (int j = 0; j < m; j++) {
                if (new_node->conn_left[j] < conn_tot[j] && new_node->conn_left[j] > 0) {
                    sum += 1;
                }
                new_node->conn_left[j] -= conn_matrix[j][i];    /* æ›´æ–°å½“å‰èŠ‚ç‚¹ */
            }
            new_node->density = max(sum, cur_node->density);  /* æ³¨æ„è¿™é‡Œè¦å’Œ cur_node-> density è¿›è¡Œæ¯”è¾ƒ, ä»¥ç»§æ‰¿å‰é¢çš„ */
            new_node->size = cur_node->size + 1;
            pq.push(new_node);
        }
    }
    return nullptr;
}

int main() {
    node* node = circuit_board_problem(n);
    if (node == nullptr) {
        cout << "No solution" << endl;
    }
    else {
        cout << "Solution: " << node->density << endl;
    }
    while (node != nullptr) {
        cout << node->idx << " ";
        node = node->parent;
    }
    return 0;
}
```
ç»“æœä¸º:
```c
6 7 4 3 5 2 0 1 
```
ä»ç„¶æ˜¯æœ€ä¼˜çš„ç»“æœ(æ˜¾ç„¶å°±æ­¤é¢˜æ•ˆç‡ä¸å¦‚å›æº¯æ³•å¿«)

### (7) æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦é—®é¢˜
é—®é¢˜å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure & Algorithms/ğŸ›°ï¸Algorithms/ç¬¬äº”ç«  å›æº¯æ³•(DFS)#(2) æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦é—®é¢˜|æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦é—®é¢˜]], å®é™…ä¸Šä¹Ÿæ˜¯æ’åˆ—æ ‘çš„éå†é—®é¢˜ã€‚
é‡‡ç”¨**åˆ†æ”¯é™ç•Œæ³•è¦æ±‚å¾—åˆ°çš„ç»“æœéœ€è¦å…·æœ‰å±€éƒ¨æœ€ä¼˜æ€§è´¨**ï¼Œè€Œå…³é”®æ˜¯<b><mark style="background: transparent; color: blue">å¦‚ä½•ç¡®ä¿åªè¦æœç´¢åˆ°å¶èŠ‚ç‚¹, åˆ™æ‰€å¾—åˆ°çš„è¯¥ç»“æ„å°±æ˜¯æœ€ä¼˜çš„</mark></b>ã€‚

ç”±äºæ’åˆ—æ ‘éå†æ—¶, ä¼šå…ˆå°†æ‰€æœ‰æœªå‰ªæ, çš„ç¬¬3å±‚èŠ‚ç‚¹åŠ å…¥, å†æŒ‰ç…§å¤§å°å…ˆå»é™¤ç¬¬2å±‚, ç„¶åå»é™¤ç¬¬3å±‚, åˆ™æœ‰é•¿åº¦ä¸º 3 çš„æ’åˆ—é¦–å…ˆå‡ºé˜Ÿæ—¶ï¼Œ å³ä¸ºæœ€ä¼˜è§£ã€‚

> [!caution] æ ¸å¿ƒ
> æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦é—®é¢˜çš„æ ¸å¿ƒæ˜¯<b><mark style="background: transparent; color: red">é€‰å–é™ç•Œå‡½æ•°</mark></b>, åœ¨æœ¬æ–¹æ³•ä¸­, **å–äº†æ¯æä¸Šçš„ä¸¤ç§ç‰¹æ®Šæƒ…å†µ, å¾—åˆ°è¯¥æä¸Šçš„å­æ ‘çš„å®Œæˆæ—¶é—´å’Œçš„ä¸‹ç•Œ**ã€‚è€Œå‰ªææ—¶, <mark style="background: transparent; color: red">åªè¦è¿™ä¸ªä¸‹ç•Œ >= å½“å‰æ‰¾åˆ°çš„æœ€ä¼˜è§£ï¼Œåˆ™è¿›è¡Œå‰ªæ</mark>

æ’åˆ—æ ‘çš„**åŸºæœ¬éå†æ€è·¯æ˜¯é‡‡ç”¨ä¼˜å…ˆé˜Ÿåˆ—**ï¼Œå®é™…ä¸Šéå¸¸å¥½ç†è§£ï¼Œ ç”±äºåœ¨ä¸¤ä¸ªèŠ‚ç‚¹æ—¶ï¼Œ æœ€ä¼˜è§£çš„å‰ 2 çš„èŠ‚ç‚¹å¿…ç„¶ä¼šæ¯”å…¶ä»–éæœ€ä¼˜è§£çš„ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹å…ˆå…¥é˜Ÿå¹¶ä¸”å¾—åˆ°æœ€ä¼˜è§£ã€‚

```cpp title:æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦,åˆ†æ”¯é™ç•Œæ³•
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

/*
* æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦é—®é¢˜,é‡‡ç”¨æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦ç®—æ³•,å³ä¼˜å…ˆçº§è°ƒåº¦ç®—æ³• 
* åŸºäºåˆ†æ”¯é™ç•Œæ³•(å¹¿åº¦ä¼˜å…ˆæœç´¢) 
*/

typedef struct task {
    char id;
    int time1;
    int time2;
    task(int id, int time1, int time2) {
        this->id = id;
        this->time1 = time1;
        this->time2 = time2;
    };
}task;

int get_min_time(vector<task> seq) {
    int time1_tot = 0;
    int time2_tot = 0;
    int res = 0;
    for (int i = 0; i < seq.size(); i++) {
        time1_tot += seq[i].time1;   // ç¬¬i ä¸ªä»»åŠ¡çš„ 1 çš„å®Œæˆæ—¶é—´(ç›´æ¥è®¡å…¥, å¯ç´§å¯†æ’åˆ—)
        // è®¡ç®—ç¬¬ i ä¸ªä»»åŠ¡ 2 çš„å®Œæˆæ—¶é—´, å¯èƒ½ç”±äºå‰ä¸€ä¸ªä»»åŠ¡ 2 çš„å®Œæˆæ—¶é—´è€Œå»¶å 
        time2_tot = max(time2_tot, time1_tot) + seq[i].time2; 
        // åˆå¹¶åˆå§‹æƒ…å†µä¸‹,  time2_tot = 0
        res += time2_tot;
    }
    return res;
}

vector<task> tasks_g; // å…¨å±€å˜é‡, å­˜å‚¨æ‰€æœ‰ä»»åŠ¡

// ç”±äº prior_queue é»˜è®¤æ˜¯å°æ ¹å †, å› æ­¤éœ€è¦è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°, ç”¨å‘é‡æ„é€ å³å¯
struct cmp {
    bool operator()(vector<int> a, vector<int> b) {
        vector<task> ta;
        vector<task> tb;
        for (int i = 0; i < a.size(); i++) {
            ta.push_back(tasks_g[a[i]]);
        }
        for (int i = 0; i < b.size(); i++) {
            tb.push_back(tasks_g[b[i]]);
        }
        return get_min_time(ta) > get_min_time(tb);
    }
};

void get_best_dispatch() {
    int n = tasks_g.size();
    priority_queue<vector<int>, vector<vector<int>>, cmp> q;   //  vector<vector<int> æ˜¯å®¹å™¨ 
    for (int i = 0; i < n; i++) {
        vector<int> vec = vector<int>(1, i);
        q.push(vec);   // å°†æ‰€æœ‰çš„å•ä¸ªä»»åŠ¡ç¼–å·å‹å…¥é˜Ÿåˆ—  
    }

    while (!q.empty()) {
        vector<int> vec_best = q.top();
        q.pop();
        if (vec_best.size() == n) {
            cout << "best sequence :" << endl;
            for (int i = 0; i < vec_best.size(); i++) {
                cout << tasks_g[vec_best[i]].id << " ";
            }
            vector<task> t;
            for (int i = 0; i < vec_best.size(); i++) {
                t.push_back(tasks_g[vec_best[i]]);
            }
            cout << "best time : " << get_min_time(t) << endl;
            return;
        }
        else if (vec_best.size() < n) {
            // å¦‚æœèŠ‚ç‚¹ä¸ªæ•° < 3, åˆ™éå†æ‰€æœ‰å¯ä»¥åŠ å…¥çš„ä»»åŠ¡å…¥é˜Ÿ 
            for (int i = 0; i < n; i++) {
                if (find(vec_best.begin(), vec_best.end(), i) == vec_best.end()) {
                    vector<int> new_vec = vec_best; // æ·±æ‹·è´ä¸€ä»½
                    new_vec.push_back(i);
                    q.push(new_vec); 
                }
            }
        }
        else {
            throw exception("error");
        }
    }
}

int main() {
    task task1 = task('A', 2, 1);
    task task2 = task('B', 3, 1);
    task task3 = task('C', 2, 3);
    
    tasks_g.push_back(task1);
    tasks_g.push_back(task2);
    tasks_g.push_back(task3);
    
    // å®é™…ä¸Šæ˜¯éå†æ’åˆ—æ ‘çš„é—®é¢˜, å› æ­¤éœ€è¦ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—æ¥å­˜å‚¨ä¸­é—´ç»“æœ
    get_best_dispatch();

    return 0;
}
```
è¾“å‡º ACB ä¸ºæœ€ä½³çš„é€‰æ‹©ã€‚


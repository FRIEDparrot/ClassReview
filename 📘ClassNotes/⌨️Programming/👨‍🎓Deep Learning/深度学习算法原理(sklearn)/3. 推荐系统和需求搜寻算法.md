## 一、需求搜寻算法简介 
推荐系统的部分需要对于需求的深入理解，如果仅基于传统的搜索引擎算法，关键赓续哟啊的字查询信息难以定位需求。而实际上用户一般更需要的是符合个人偏好的结果。

一般的推荐系统的主要功能包括 : 
1. **打包销售(Cross Selling)**:即在推荐某些产品时, 也会同时推荐一同购买的产品
2. **协同过滤**: 主要是定位用户的购买需求。基于模糊关键字从列表中明确需求。此外也包括看过此商品之后购买的其它商品。反映了隐式需求(曾经浏览过某页面的用户所购买的产品)。
3. 用户商品评论列表的抽和汇总分析, 用于评估产品质量的分布水平。

推荐系统的主要算法包含 : 
1. 基于人口统计学的推荐机制 : 根据用户的基本信息获取相关程度, 并根据相似用户喜好的的其他物品推荐给当前用户。
2. 基于协同过滤的推荐机制 : 主要分为<b><mark style="background: transparent; color: blue">基于用户的推荐和基于项目的推荐</mark></b>。
3. 基于隐语义的推荐模型 : 其中, **目前精度最高的算法是 SVD 隐语义模型**。

一般在训练阶段, 属于 CPU 密集型任务, 而在分类或者预测阶段属于 IO 密集型任务。 一般不使用脚本语言进行设计。

协同过滤的模以及算法包含: 
1. 数据处理与 UI 矩阵 
2. UserCF 和 ItemCF 推荐模型
3. KMeans 相似性计算 
4. SVD 相似性计算  

### (1) 物品数据的 KMeans 聚类
KMeans 聚类参考 [[📘ClassNotes/⌨️Programming/👨‍🎓Deep Learning/深度学习算法原理(sklearn)/补充知识/4.KNN算法和KMeans算法#二、K-Means算法(K均值算法)|KMeans算法]] , 并给出一个简单的 iris 数据集 KMeans 聚类代码:
```python
import sklearn  
from sklearn.datasets import load_iris  
from sklearn.cluster import KMeans  
from sklearn.preprocessing import StandardScaler  
from sklearn.model_selection import train_test_split  
import matplotlib.pyplot as plt  
  
iris = load_iris()  
  
iris_data = iris.data  
iris_target = iris.target  
  
X_train, X_test, y_train, y_test =  train_test_split(iris_data, iris_target, test_size=0.2, random_state=None)  
  
kms = KMeans(n_clusters=3)  
kms.fit(X_train, y_train)  
  
y_pred = kms.predict(iris_data)  
  
fig, axes = plt.subplots(2,1, figsize=(5,10))  
axes[0].scatter(iris_data[:,0], iris_data[:,1], c=iris_target)  
axes[0].set_title("real results")  
axes[1].scatter(iris_data[:,0], iris_data[:,1], c=y_pred)  
axes[1].set_title("KMeans results")  
plt.show()
```

KMeans 聚类结果如下:
![[attachments/Pasted image 20240914173557.png]]

### (2) 协同过滤 User CF 和 Item CF 原理
协同过滤(Collabrate Filtering, CF) 分为 User CF 和 Item CF 部分

首先需要建立用户偏好矩阵, 根据 KNN 算法，以距离或者夹角余弦为距离, 分别计算其到每一类用户的距离, 
![[Excalidraw/3. 推荐系统和需求搜寻算法 2024-09-14 18.03.57|550]]
User CF 即采用KNN等将用户(USER C)通过usr_vector 归类到某一类用户(A或B)中。并将该类用户没有买过的物品进行推荐
Item CF 即选取新用户(USER C)比较偏好的物品 (item E), 并通过分类获取与 item E 相似的物品 (通过item_vec可以找出如item A相似,则将item A 也推荐给 item E的用户)

### (3) SVD 原理和计算办法

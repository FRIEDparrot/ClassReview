Python 异步编程允许程序在等待耗时操作（如网络请求、文件读写）时执行其他任务，而不是被阻塞。下面我将首先介绍 asyncio 库的核心概念和工具，然后详细解释 async/await 语法的使用。 
## 一、asyncio 库介绍 
asyncio 是 Python 标准库中实现异步编程的核心模块，提供了运行和管理协程的基础设施。  
### 1. 核心概念

**事件循环（Event Loop）**：异步应用的核心，负责调度和运行协程、处理网络 I/O 事件、运行子进程等。

```python
import asyncio

# 获取事件循环
loop = asyncio.get_event_loop()

# Python 3.7+ 推荐使用 asyncio.run() 代替显式操作事件循环
# asyncio.run(main())
```
### 2. 常用 API 及示例
#### asyncio.run(coro, `*`, debug=False) 
启动事件循环并运行协程直到完成，然后关闭循环。这是运行异步程序的推荐方式（Python 3.7+）。
**参数** : 
- `coro`：要运行的协程对象
- `debug`：是否启用调试模式

```python
import asyncio

async def main():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

# 运行主协程
asyncio.run(main())
```

#### asyncio.create_task(coro, `*`, name=None)

将协程包装为一个 Task 并调度其执行。Task 是 Future 的子类，代表一个异步操作的最终结果。

**参数**：

- `coro`：要包装的协程
- `name`：任务名称（可选，方便调试）

```python
async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    # 创建两个任务
    task1 = asyncio.create_task(say_after(1, "hello"))
    task2 = asyncio.create_task(say_after(2, "world"))
    
    print(f"started at {asyncio.get_running_loop().time()}")
    
    # 等待两个任务完成
    await task1
    await task2
    
    print(f"finished at {asyncio.get_running_loop().time()}")
```

需要说明,  create_task 本身是一个异步方法， 因此创建一个异步任务让它在后台执行， 只需使用 : 
```python
asyncio.create_task(self.wait_for_close(TwoPC_DEFAULT_COMMIT_TIMEOUT)) 
```
需要说明。 如果不带 task 参数，编译器往往会误报需要 await,  而我们的目的是显示创建事务并自动运行， 因此可以采用 :
```python
if auto_close:
    _ = asyncio.create_task(self.wait_for_close(TwoPC_DEFAULT_COMMIT_TIMEOUT))
```
或者：
```python
if auto_close:
    task = asyncio.create_task(self.wait_for_close(TwoPC_DEFAULT_COMMIT_TIMEOUT))
    task.add_done_callback(lambda t: t.exception())  # 避免未捕获异常
``` 

#### asyncio.gather(`*aws`, return_exceptions=False)
并发运行传入的 awaitable 对象（通常是协程）并收集它们的结果。
**参数** : 
- `*aws`：一个或多个 awaitable 对象
- `return_exceptions`：如果为 True，异常会被视为成功的结果返回，而不是被传播。 
```python
import asyncio 
async def fetch_data(delay, name):
    await asyncio.sleep(delay)
    return f"{name} result after {delay}s"

async def main():
    # 并发运行三个协程
    results = await asyncio.gather(
        fetch_data(3, "A"),
        fetch_data(1, "B"),
        fetch_data(2, "C")
    )
    
    # 结果顺序与传入顺序一致，而不是完成顺序
    print(results)  # ['A result after 3s', 'B result after 1s', 'C result after 2s']

if __name__ == "__main__":
    asyncio.run(main())
```

#### asyncio.wait_for(aw, timeout)

等待协程完成，如果超过指定的超时时间，则取消协程并抛出 TimeoutError。

**参数**：

- `aw`：awaitable 对象
- `timeout`：超时时间（秒）

```python
async def eternity():
    await asyncio.sleep(3600)
    print('yay!')

async def main():
    try:
        # 等待，但不超过 5 秒
        await asyncio.wait_for(eternity(), timeout=5)
    except asyncio.TimeoutError:
        print('timeout!')
```

#### `asyncio.wait` 的返回值

`asyncio.wait` 返回一个**元组**：
```python
done, pending = await asyncio.wait(...)
```
- `done`: **已完成**的任务集合 (`set[asyncio.Task]`)，无论是**成功**还是**异常结束**，都会放入 `done` 集合。
- `pending`: **未完成**的任务集合 (`set[asyncio.Task]`)，如果任务在 `timeout` 内未完成，则它们会被放入 `pending`。

如果 `timeout` 过期：
- **已经完成的任务**会进入 `done` 集合。
- **未完成的任务**会进入 `pending` 集合。

示例：
```python
import asyncio

async def task1():
    await asyncio.sleep(2)
    return "task1 done"

async def task2():
    await asyncio.sleep(10)
    return "task2 done"

async def main():
    t1 = asyncio.create_task(task1())
    t2 = asyncio.create_task(task2())

    done, pending = await asyncio.wait([t1, t2], timeout=5)

    print("Done tasks:", [t.result() for t in done if t.done()])
    print("Pending tasks:", pending)

asyncio.run(main())
```
**输出**：
```shell
Done tasks: ['task1 done']
Pending tasks: {<Task pending name='Task-2' coro=<task2()>>}
```
> `task1` 在 2 秒内完成并进入 `done`，但 `task2` 需要 10 秒，它在 `timeout=5` 后仍未完成，因此进入 `pending`。 

#### asyncio.sleep(delay, result=None)

协程休眠指定的秒数。可选地，指定一个值作为协程的结果返回。

**参数**：

- `delay`：休眠时间（秒）
- `result`：休眠结束后返回的值（可选）

```python
async def say_after(delay, what):
    result = await asyncio.sleep(delay, what)  # 休眠并返回值
    print(f"After {delay}s: {result}")
    return result

async def main():
    result = await say_after(1, "hello")
    print(f"Result was: {result}")  # Result was: hello
```

## 二、async/await 语法详解

### 1. async def - 定义异步函数

`async def` 用于定义协程函数，调用它会返回一个协程对象而不是直接执行函数体。

```python
async def my_coroutine():
    print("This is a coroutine")
    return "Done"

# 调用不会执行函数体，而是返回协程对象
coro = my_coroutine()
print(coro)  # <coroutine object my_coroutine at 0x...>

# 要执行协程，可以使用 await 或者事件循环
result = asyncio.run(coro)
print(result)  # Done
```

### 2. await - 等待协程完成

`await` 表达式用于暂停当前协程的执行，直到 awaitable 对象完成。只能在 `async def` 定义的函数中使用。

await 可用于以下对象：

- 协程（coroutine）
- Task 对象
- Future 对象
- 实现了 `__await__()` 的对象

```python
async def nested():
    return 42

async def main():
    # 直接等待协程
    result1 = await nested()
    print(result1)  # 42
    
    # 等待任务
    task = asyncio.create_task(nested())
    result2 = await task
    print(result2)  # 42
```

### 3. 异步上下文管理器（async with）

使用 `async with` 语句进入和退出异步上下文管理器。上下文管理器需要定义 `__aenter__` 和 `__aexit__` 方法。

```python
class AsyncContextManager:
    async def __aenter__(self):
        print("Entering context")
        await asyncio.sleep(1)
        return "context value"
        
    async def __aexit__(self, exc_type, exc_value, traceback):
        print("Exiting context")
        await asyncio.sleep(1)

async def main():
    async with AsyncContextManager() as value:
        print(f"Inside context with value: {value}")
```

### 4. 异步迭代器（async for）

使用 `async for` 遍历异步迭代器。异步迭代器需要定义 `__aiter__` 和 `__anext__` 方法。

```python
class AsyncCounter:
    def __init__(self, limit):
        self.limit = limit
        self.counter = 0
        
    def __aiter__(self):
        return self
        
    async def __anext__(self):
        if self.counter < self.limit:
            self.counter += 1
            await asyncio.sleep(0.1)  # 模拟异步操作
            return self.counter
        else:
            raise StopAsyncIteration

async def main():
    async for number in AsyncCounter(5):
        print(number)  # 依次打印 1, 2, 3, 4, 5
```

## 三、实际应用示例

### 1. 异步网络请求

```python
import asyncio
import aiohttp  # 需要安装: pip install aiohttp

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = [
        'https://python.org',
        'https://github.com',
        'https://stackoverflow.com'
    ]
    
    # 创建一个会话
    async with aiohttp.ClientSession() as session:
        # 并发请求所有网址
        tasks = [fetch(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        
        # 打印每个网页的大小
        for url, html in zip(urls, results):
            print(f"{url}: {len(html)} characters")

# 运行主协程
asyncio.run(main())
```

### 2. 异步文件操作

```python
import asyncio
import aiofiles  # 需要安装: pip install aiofiles

async def read_file(filename):
    async with aiofiles.open(filename, mode='r') as f:
        return await f.read()

async def write_file(filename, content):
    async with aiofiles.open(filename, mode='w') as f:
        await f.write(content)

async def main():
    # 并发读取多个文件
    file_contents = await asyncio.gather(
        read_file('file1.txt'),
        read_file('file2.txt'),
        read_file('file3.txt')
    )
    
    # 合并内容
    combined = '\n'.join(file_contents)
    
    # 异步写入新文件
    await write_file('combined.txt', combined)
    print("Files combined successfully")

# 运行主协程
asyncio.run(main())
```

## 四、异步编程的优缺点

### 优点：

1. **提高 I/O 密集型应用性能**：可以在等待 I/O 操作时执行其他任务
2. **更好的并发控制**：比线程更轻量，避免了线程间同步问题
3. **简洁的同步语法**：`async/await` 使异步代码看起来像同步代码
4. **可扩展性**：可以处理数千个并发连接

### 缺点：

1. **不适合 CPU 密集型任务**：不会真正并行执行（仍在单线程中）
2. **调试复杂性**：跟踪异步控制流比同步代码更困难
3. **生态系统兼容性**：某些库可能不支持异步操作
4. **学习曲线**：理解事件循环和协程需要时间

## 五、最佳实践

1. **异步所有或不异步**：一旦选择异步方式，尽量在整个应用中保持一致
2. **避免阻塞**：不要在协程中使用阻塞调用（如 `time.sleep()`）
3. **正确处理异常**：使用 `try/except` 捕获和处理异步操作中的异常
4. **合理分组任务**：使用 `asyncio.gather()` 将相关任务组合在一起
5. **设置超时**：为长时间运行的协程设置超时，避免无限等待

通过深入理解 asyncio 库和 async/await 语法，你可以开发出高效、可伸缩的异步应用程序，特别是在处理大量网络请求或文件操作时。



## 二、常用函数
1. `asyncio.run_coroutine_threadsafe` 函数用法 

**使用场景**
• 主线程或其他线程需要与**后台运行事件循环的线程**交互。
• 例如：GUI 主线程需将任务提交到异步网络请求的后台线程。
```python
asyncio.run_coroutine_threadsafe(coro, loop)
```
• **参数**：
  • `coro`: 要提交的协程对象。
  • `loop`: 目标事件循环（必须在其他线程中运行）。
• **返回值**：
  • `concurrent.futures.Future`：用于获取结果或添加回调。

以下是一个简单示例 :  
1. **在子线程中启动事件循环**
   ```python
   import asyncio
   from threading import Thread

   def run_event_loop(loop):
       asyncio.set_event_loop(loop)
       loop.run_forever()  # 启动事件循环

   # 创建子线程运行事件循环
   loop = asyncio.new_event_loop()
   t = Thread(target=run_event_loop, args=(loop,), daemon=True)
   t.start()
   ```

2. **提交协程到子线程的事件循环**
   ```python
   async def my_coroutine():
       await asyncio.sleep(1)
       return "Done"

   # 在主线程或其他线程中提交协程
   future = asyncio.run_coroutine_threadsafe(my_coroutine(), loop)
   ```

3. **处理结果或异常**
   • **阻塞等待结果**（可能阻塞当前线程）：
     ```python
     try:
         result = future.result(timeout=2)  # 设置超时
         print("Result:", result)
     except asyncio.TimeoutError:
         print("Timeout!")
     except Exception as e:
         print("Error:", e)
     ```
   • **非阻塞回调处理**（推荐）：
     ```python
     def callback(future):
         try:
             result = future.result()
             print("Result:", result)
         except Exception as e:
             print("Error:", e)

     future.add_done_callback(callback)  # 回调在事件循环线程执行
     ```


`loop.call_soon_threadsafe()` is the correct method to schedule a regular function call (like `event.set()`) to be executed in the event loop from another thread. It ensures thread safety when interacting with the event loop.  


## 事件循环 
### 1. 事件循环 (Event Loop)
事件循环是 `asyncio` 的核心机制，负责调度和执行异步任务。它管理着所有的协程、任务、回调函数以及 I/O 操作。每个线程在同一时间只能有一个事件循环。

通过如下方法绑定 
```python
self.loop = asyncio.new_event_loop()
asyncio.set_event_loop(self.loop) 
self.loop_thread = threading.Thread(self.loop.run_forever(), daemon=True)
```




📌 **`loop.call_soon_threadsafe(callback, *args)` 的作用** : 
- 它用于**从另一个线程**安全地提交任务到 `asyncio` 事件循环中执行。
- 适用于 `asyncio` 事件循环**在另一个线程中运行**，但你想要从**主线程**或其他**非事件循环线程**触发回调。
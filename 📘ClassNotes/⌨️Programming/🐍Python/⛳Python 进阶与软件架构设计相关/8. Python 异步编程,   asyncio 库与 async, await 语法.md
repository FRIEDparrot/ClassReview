Python å¼‚æ­¥ç¼–ç¨‹å…è®¸ç¨‹åºåœ¨ç­‰å¾…è€—æ—¶æ“ä½œï¼ˆå¦‚ç½‘ç»œè¯·æ±‚ã€æ–‡ä»¶è¯»å†™ï¼‰æ—¶æ‰§è¡Œå…¶ä»–ä»»åŠ¡ï¼Œè€Œä¸æ˜¯è¢«é˜»å¡ã€‚ä¸‹é¢æˆ‘å°†é¦–å…ˆä»‹ç» asyncio åº“çš„æ ¸å¿ƒæ¦‚å¿µå’Œå·¥å…·ï¼Œç„¶åè¯¦ç»†è§£é‡Š async/await è¯­æ³•çš„ä½¿ç”¨ã€‚ 
## ä¸€ã€asyncio åº“ä»‹ç» 
asyncio æ˜¯ Python æ ‡å‡†åº“ä¸­å®ç°å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒæ¨¡å—ï¼Œæä¾›äº†è¿è¡Œå’Œç®¡ç†åç¨‹çš„åŸºç¡€è®¾æ–½ã€‚  
### 1. æ ¸å¿ƒæ¦‚å¿µ

**äº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰**ï¼šå¼‚æ­¥åº”ç”¨çš„æ ¸å¿ƒï¼Œè´Ÿè´£è°ƒåº¦å’Œè¿è¡Œåç¨‹ã€å¤„ç†ç½‘ç»œ I/O äº‹ä»¶ã€è¿è¡Œå­è¿›ç¨‹ç­‰ã€‚

```python
import asyncio

# è·å–äº‹ä»¶å¾ªç¯
loop = asyncio.get_event_loop()

# Python 3.7+ æ¨èä½¿ç”¨ asyncio.run() ä»£æ›¿æ˜¾å¼æ“ä½œäº‹ä»¶å¾ªç¯
# asyncio.run(main())
```
### 2. å¸¸ç”¨ API åŠç¤ºä¾‹
#### asyncio.run(coro, `*`, debug=False) 
å¯åŠ¨äº‹ä»¶å¾ªç¯å¹¶è¿è¡Œåç¨‹ç›´åˆ°å®Œæˆï¼Œç„¶åå…³é—­å¾ªç¯ã€‚è¿™æ˜¯è¿è¡Œå¼‚æ­¥ç¨‹åºçš„æ¨èæ–¹å¼ï¼ˆPython 3.7+ï¼‰ã€‚
**å‚æ•°** : 
- `coro`ï¼šè¦è¿è¡Œçš„åç¨‹å¯¹è±¡
- `debug`ï¼šæ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼

```python
import asyncio

async def main():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

# è¿è¡Œä¸»åç¨‹
asyncio.run(main())
```

#### asyncio.create_task(coro, `*`, name=None)

å°†åç¨‹åŒ…è£…ä¸ºä¸€ä¸ª Task å¹¶è°ƒåº¦å…¶æ‰§è¡Œã€‚Task æ˜¯ Future çš„å­ç±»ï¼Œä»£è¡¨ä¸€ä¸ªå¼‚æ­¥æ“ä½œçš„æœ€ç»ˆç»“æœã€‚

**å‚æ•°**ï¼š

- `coro`ï¼šè¦åŒ…è£…çš„åç¨‹
- `name`ï¼šä»»åŠ¡åç§°ï¼ˆå¯é€‰ï¼Œæ–¹ä¾¿è°ƒè¯•ï¼‰

```python
async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    # åˆ›å»ºä¸¤ä¸ªä»»åŠ¡
    task1 = asyncio.create_task(say_after(1, "hello"))
    task2 = asyncio.create_task(say_after(2, "world"))
    
    print(f"started at {asyncio.get_running_loop().time()}")
    
    # ç­‰å¾…ä¸¤ä¸ªä»»åŠ¡å®Œæˆ
    await task1
    await task2
    
    print(f"finished at {asyncio.get_running_loop().time()}")
```

éœ€è¦è¯´æ˜,  create_task æœ¬èº«æ˜¯ä¸€ä¸ªå¼‚æ­¥æ–¹æ³•ï¼Œ å› æ­¤åˆ›å»ºä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡è®©å®ƒåœ¨åå°æ‰§è¡Œï¼Œ åªéœ€ä½¿ç”¨ : 
```python
asyncio.create_task(self.wait_for_close(TwoPC_DEFAULT_COMMIT_TIMEOUT)) 
```
éœ€è¦è¯´æ˜ã€‚ å¦‚æœä¸å¸¦ task å‚æ•°ï¼Œç¼–è¯‘å™¨å¾€å¾€ä¼šè¯¯æŠ¥éœ€è¦ await,  è€Œæˆ‘ä»¬çš„ç›®çš„æ˜¯æ˜¾ç¤ºåˆ›å»ºäº‹åŠ¡å¹¶è‡ªåŠ¨è¿è¡Œï¼Œ å› æ­¤å¯ä»¥é‡‡ç”¨ :
```python
if auto_close:
    _ = asyncio.create_task(self.wait_for_close(TwoPC_DEFAULT_COMMIT_TIMEOUT))
```
æˆ–è€…ï¼š
```python
if auto_close:
    task = asyncio.create_task(self.wait_for_close(TwoPC_DEFAULT_COMMIT_TIMEOUT))
    task.add_done_callback(lambda t: t.exception())  # é¿å…æœªæ•è·å¼‚å¸¸
``` 

#### asyncio.gather(`*aws`, return_exceptions=False)
å¹¶å‘è¿è¡Œä¼ å…¥çš„ awaitable å¯¹è±¡ï¼ˆé€šå¸¸æ˜¯åç¨‹ï¼‰å¹¶æ”¶é›†å®ƒä»¬çš„ç»“æœã€‚
**å‚æ•°** : 
- `*aws`ï¼šä¸€ä¸ªæˆ–å¤šä¸ª awaitable å¯¹è±¡
- `return_exceptions`ï¼šå¦‚æœä¸º Trueï¼Œå¼‚å¸¸ä¼šè¢«è§†ä¸ºæˆåŠŸçš„ç»“æœè¿”å›ï¼Œè€Œä¸æ˜¯è¢«ä¼ æ’­ã€‚ 
```python
import asyncio 
async def fetch_data(delay, name):
    await asyncio.sleep(delay)
    return f"{name} result after {delay}s"

async def main():
    # å¹¶å‘è¿è¡Œä¸‰ä¸ªåç¨‹
    results = await asyncio.gather(
        fetch_data(3, "A"),
        fetch_data(1, "B"),
        fetch_data(2, "C")
    )
    
    # ç»“æœé¡ºåºä¸ä¼ å…¥é¡ºåºä¸€è‡´ï¼Œè€Œä¸æ˜¯å®Œæˆé¡ºåº
    print(results)  # ['A result after 3s', 'B result after 1s', 'C result after 2s']

if __name__ == "__main__":
    asyncio.run(main())
```

#### asyncio.wait_for(aw, timeout)

ç­‰å¾…åç¨‹å®Œæˆï¼Œå¦‚æœè¶…è¿‡æŒ‡å®šçš„è¶…æ—¶æ—¶é—´ï¼Œåˆ™å–æ¶ˆåç¨‹å¹¶æŠ›å‡º TimeoutErrorã€‚

**å‚æ•°**ï¼š

- `aw`ï¼šawaitable å¯¹è±¡
- `timeout`ï¼šè¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰

```python
async def eternity():
    await asyncio.sleep(3600)
    print('yay!')

async def main():
    try:
        # ç­‰å¾…ï¼Œä½†ä¸è¶…è¿‡ 5 ç§’
        await asyncio.wait_for(eternity(), timeout=5)
    except asyncio.TimeoutError:
        print('timeout!')
```

#### `asyncio.wait` çš„è¿”å›å€¼

`asyncio.wait` è¿”å›ä¸€ä¸ª**å…ƒç»„**ï¼š
```python
done, pending = await asyncio.wait(...)
```
- `done`: **å·²å®Œæˆ**çš„ä»»åŠ¡é›†åˆ (`set[asyncio.Task]`)ï¼Œæ— è®ºæ˜¯**æˆåŠŸ**è¿˜æ˜¯**å¼‚å¸¸ç»“æŸ**ï¼Œéƒ½ä¼šæ”¾å…¥ `done` é›†åˆã€‚
- `pending`: **æœªå®Œæˆ**çš„ä»»åŠ¡é›†åˆ (`set[asyncio.Task]`)ï¼Œå¦‚æœä»»åŠ¡åœ¨ `timeout` å†…æœªå®Œæˆï¼Œåˆ™å®ƒä»¬ä¼šè¢«æ”¾å…¥ `pending`ã€‚

å¦‚æœ `timeout` è¿‡æœŸï¼š
- **å·²ç»å®Œæˆçš„ä»»åŠ¡**ä¼šè¿›å…¥ `done` é›†åˆã€‚
- **æœªå®Œæˆçš„ä»»åŠ¡**ä¼šè¿›å…¥ `pending` é›†åˆã€‚

ç¤ºä¾‹ï¼š
```python
import asyncio

async def task1():
    await asyncio.sleep(2)
    return "task1 done"

async def task2():
    await asyncio.sleep(10)
    return "task2 done"

async def main():
    t1 = asyncio.create_task(task1())
    t2 = asyncio.create_task(task2())

    done, pending = await asyncio.wait([t1, t2], timeout=5)

    print("Done tasks:", [t.result() for t in done if t.done()])
    print("Pending tasks:", pending)

asyncio.run(main())
```
**è¾“å‡º**ï¼š
```shell
Done tasks: ['task1 done']
Pending tasks: {<Task pending name='Task-2' coro=<task2()>>}
```
> `task1` åœ¨ 2 ç§’å†…å®Œæˆå¹¶è¿›å…¥ `done`ï¼Œä½† `task2` éœ€è¦ 10 ç§’ï¼Œå®ƒåœ¨ `timeout=5` åä»æœªå®Œæˆï¼Œå› æ­¤è¿›å…¥ `pending`ã€‚ 

#### asyncio.sleep(delay, result=None)

åç¨‹ä¼‘çœ æŒ‡å®šçš„ç§’æ•°ã€‚å¯é€‰åœ°ï¼ŒæŒ‡å®šä¸€ä¸ªå€¼ä½œä¸ºåç¨‹çš„ç»“æœè¿”å›ã€‚

**å‚æ•°**ï¼š

- `delay`ï¼šä¼‘çœ æ—¶é—´ï¼ˆç§’ï¼‰
- `result`ï¼šä¼‘çœ ç»“æŸåè¿”å›çš„å€¼ï¼ˆå¯é€‰ï¼‰

```python
async def say_after(delay, what):
    result = await asyncio.sleep(delay, what)  # ä¼‘çœ å¹¶è¿”å›å€¼
    print(f"After {delay}s: {result}")
    return result

async def main():
    result = await say_after(1, "hello")
    print(f"Result was: {result}")  # Result was: hello
```

## äºŒã€async/await è¯­æ³•è¯¦è§£

### 1. async def - å®šä¹‰å¼‚æ­¥å‡½æ•°

`async def` ç”¨äºå®šä¹‰åç¨‹å‡½æ•°ï¼Œè°ƒç”¨å®ƒä¼šè¿”å›ä¸€ä¸ªåç¨‹å¯¹è±¡è€Œä¸æ˜¯ç›´æ¥æ‰§è¡Œå‡½æ•°ä½“ã€‚

```python
async def my_coroutine():
    print("This is a coroutine")
    return "Done"

# è°ƒç”¨ä¸ä¼šæ‰§è¡Œå‡½æ•°ä½“ï¼Œè€Œæ˜¯è¿”å›åç¨‹å¯¹è±¡
coro = my_coroutine()
print(coro)  # <coroutine object my_coroutine at 0x...>

# è¦æ‰§è¡Œåç¨‹ï¼Œå¯ä»¥ä½¿ç”¨ await æˆ–è€…äº‹ä»¶å¾ªç¯
result = asyncio.run(coro)
print(result)  # Done
```

### 2. await - ç­‰å¾…åç¨‹å®Œæˆ

`await` è¡¨è¾¾å¼ç”¨äºæš‚åœå½“å‰åç¨‹çš„æ‰§è¡Œï¼Œç›´åˆ° awaitable å¯¹è±¡å®Œæˆã€‚åªèƒ½åœ¨ `async def` å®šä¹‰çš„å‡½æ•°ä¸­ä½¿ç”¨ã€‚

await å¯ç”¨äºä»¥ä¸‹å¯¹è±¡ï¼š

- åç¨‹ï¼ˆcoroutineï¼‰
- Task å¯¹è±¡
- Future å¯¹è±¡
- å®ç°äº† `__await__()` çš„å¯¹è±¡

```python
async def nested():
    return 42

async def main():
    # ç›´æ¥ç­‰å¾…åç¨‹
    result1 = await nested()
    print(result1)  # 42
    
    # ç­‰å¾…ä»»åŠ¡
    task = asyncio.create_task(nested())
    result2 = await task
    print(result2)  # 42
```

### 3. å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼ˆasync withï¼‰

ä½¿ç”¨ `async with` è¯­å¥è¿›å…¥å’Œé€€å‡ºå¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ã€‚ä¸Šä¸‹æ–‡ç®¡ç†å™¨éœ€è¦å®šä¹‰ `__aenter__` å’Œ `__aexit__` æ–¹æ³•ã€‚

```python
class AsyncContextManager:
    async def __aenter__(self):
        print("Entering context")
        await asyncio.sleep(1)
        return "context value"
        
    async def __aexit__(self, exc_type, exc_value, traceback):
        print("Exiting context")
        await asyncio.sleep(1)

async def main():
    async with AsyncContextManager() as value:
        print(f"Inside context with value: {value}")
```

### 4. å¼‚æ­¥è¿­ä»£å™¨ï¼ˆasync forï¼‰

ä½¿ç”¨ `async for` éå†å¼‚æ­¥è¿­ä»£å™¨ã€‚å¼‚æ­¥è¿­ä»£å™¨éœ€è¦å®šä¹‰ `__aiter__` å’Œ `__anext__` æ–¹æ³•ã€‚

```python
class AsyncCounter:
    def __init__(self, limit):
        self.limit = limit
        self.counter = 0
        
    def __aiter__(self):
        return self
        
    async def __anext__(self):
        if self.counter < self.limit:
            self.counter += 1
            await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
            return self.counter
        else:
            raise StopAsyncIteration

async def main():
    async for number in AsyncCounter(5):
        print(number)  # ä¾æ¬¡æ‰“å° 1, 2, 3, 4, 5
```

## ä¸‰ã€å®é™…åº”ç”¨ç¤ºä¾‹

### 1. å¼‚æ­¥ç½‘ç»œè¯·æ±‚

```python
import asyncio
import aiohttp  # éœ€è¦å®‰è£…: pip install aiohttp

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = [
        'https://python.org',
        'https://github.com',
        'https://stackoverflow.com'
    ]
    
    # åˆ›å»ºä¸€ä¸ªä¼šè¯
    async with aiohttp.ClientSession() as session:
        # å¹¶å‘è¯·æ±‚æ‰€æœ‰ç½‘å€
        tasks = [fetch(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        
        # æ‰“å°æ¯ä¸ªç½‘é¡µçš„å¤§å°
        for url, html in zip(urls, results):
            print(f"{url}: {len(html)} characters")

# è¿è¡Œä¸»åç¨‹
asyncio.run(main())
```

### 2. å¼‚æ­¥æ–‡ä»¶æ“ä½œ

```python
import asyncio
import aiofiles  # éœ€è¦å®‰è£…: pip install aiofiles

async def read_file(filename):
    async with aiofiles.open(filename, mode='r') as f:
        return await f.read()

async def write_file(filename, content):
    async with aiofiles.open(filename, mode='w') as f:
        await f.write(content)

async def main():
    # å¹¶å‘è¯»å–å¤šä¸ªæ–‡ä»¶
    file_contents = await asyncio.gather(
        read_file('file1.txt'),
        read_file('file2.txt'),
        read_file('file3.txt')
    )
    
    # åˆå¹¶å†…å®¹
    combined = '\n'.join(file_contents)
    
    # å¼‚æ­¥å†™å…¥æ–°æ–‡ä»¶
    await write_file('combined.txt', combined)
    print("Files combined successfully")

# è¿è¡Œä¸»åç¨‹
asyncio.run(main())
```

## å››ã€å¼‚æ­¥ç¼–ç¨‹çš„ä¼˜ç¼ºç‚¹

### ä¼˜ç‚¹ï¼š

1. **æé«˜ I/O å¯†é›†å‹åº”ç”¨æ€§èƒ½**ï¼šå¯ä»¥åœ¨ç­‰å¾… I/O æ“ä½œæ—¶æ‰§è¡Œå…¶ä»–ä»»åŠ¡
2. **æ›´å¥½çš„å¹¶å‘æ§åˆ¶**ï¼šæ¯”çº¿ç¨‹æ›´è½»é‡ï¼Œé¿å…äº†çº¿ç¨‹é—´åŒæ­¥é—®é¢˜
3. **ç®€æ´çš„åŒæ­¥è¯­æ³•**ï¼š`async/await` ä½¿å¼‚æ­¥ä»£ç çœ‹èµ·æ¥åƒåŒæ­¥ä»£ç 
4. **å¯æ‰©å±•æ€§**ï¼šå¯ä»¥å¤„ç†æ•°åƒä¸ªå¹¶å‘è¿æ¥

### ç¼ºç‚¹ï¼š

1. **ä¸é€‚åˆ CPU å¯†é›†å‹ä»»åŠ¡**ï¼šä¸ä¼šçœŸæ­£å¹¶è¡Œæ‰§è¡Œï¼ˆä»åœ¨å•çº¿ç¨‹ä¸­ï¼‰
2. **è°ƒè¯•å¤æ‚æ€§**ï¼šè·Ÿè¸ªå¼‚æ­¥æ§åˆ¶æµæ¯”åŒæ­¥ä»£ç æ›´å›°éš¾
3. **ç”Ÿæ€ç³»ç»Ÿå…¼å®¹æ€§**ï¼šæŸäº›åº“å¯èƒ½ä¸æ”¯æŒå¼‚æ­¥æ“ä½œ
4. **å­¦ä¹ æ›²çº¿**ï¼šç†è§£äº‹ä»¶å¾ªç¯å’Œåç¨‹éœ€è¦æ—¶é—´

## äº”ã€æœ€ä½³å®è·µ

1. **å¼‚æ­¥æ‰€æœ‰æˆ–ä¸å¼‚æ­¥**ï¼šä¸€æ—¦é€‰æ‹©å¼‚æ­¥æ–¹å¼ï¼Œå°½é‡åœ¨æ•´ä¸ªåº”ç”¨ä¸­ä¿æŒä¸€è‡´
2. **é¿å…é˜»å¡**ï¼šä¸è¦åœ¨åç¨‹ä¸­ä½¿ç”¨é˜»å¡è°ƒç”¨ï¼ˆå¦‚ `time.sleep()`ï¼‰
3. **æ­£ç¡®å¤„ç†å¼‚å¸¸**ï¼šä½¿ç”¨ `try/except` æ•è·å’Œå¤„ç†å¼‚æ­¥æ“ä½œä¸­çš„å¼‚å¸¸
4. **åˆç†åˆ†ç»„ä»»åŠ¡**ï¼šä½¿ç”¨ `asyncio.gather()` å°†ç›¸å…³ä»»åŠ¡ç»„åˆåœ¨ä¸€èµ·
5. **è®¾ç½®è¶…æ—¶**ï¼šä¸ºé•¿æ—¶é—´è¿è¡Œçš„åç¨‹è®¾ç½®è¶…æ—¶ï¼Œé¿å…æ— é™ç­‰å¾…

é€šè¿‡æ·±å…¥ç†è§£ asyncio åº“å’Œ async/await è¯­æ³•ï¼Œä½ å¯ä»¥å¼€å‘å‡ºé«˜æ•ˆã€å¯ä¼¸ç¼©çš„å¼‚æ­¥åº”ç”¨ç¨‹åºï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†å¤§é‡ç½‘ç»œè¯·æ±‚æˆ–æ–‡ä»¶æ“ä½œæ—¶ã€‚



## äºŒã€å¸¸ç”¨å‡½æ•°
1. `asyncio.run_coroutine_threadsafe` å‡½æ•°ç”¨æ³• 

**ä½¿ç”¨åœºæ™¯**
â€¢ ä¸»çº¿ç¨‹æˆ–å…¶ä»–çº¿ç¨‹éœ€è¦ä¸**åå°è¿è¡Œäº‹ä»¶å¾ªç¯çš„çº¿ç¨‹**äº¤äº’ã€‚
â€¢ ä¾‹å¦‚ï¼šGUI ä¸»çº¿ç¨‹éœ€å°†ä»»åŠ¡æäº¤åˆ°å¼‚æ­¥ç½‘ç»œè¯·æ±‚çš„åå°çº¿ç¨‹ã€‚
```python
asyncio.run_coroutine_threadsafe(coro, loop)
```
â€¢ **å‚æ•°**ï¼š
  â€¢ `coro`: è¦æäº¤çš„åç¨‹å¯¹è±¡ã€‚
  â€¢ `loop`: ç›®æ ‡äº‹ä»¶å¾ªç¯ï¼ˆå¿…é¡»åœ¨å…¶ä»–çº¿ç¨‹ä¸­è¿è¡Œï¼‰ã€‚
â€¢ **è¿”å›å€¼**ï¼š
  â€¢ `concurrent.futures.Future`ï¼šç”¨äºè·å–ç»“æœæˆ–æ·»åŠ å›è°ƒã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•ç¤ºä¾‹ :  
1. **åœ¨å­çº¿ç¨‹ä¸­å¯åŠ¨äº‹ä»¶å¾ªç¯**
   ```python
   import asyncio
   from threading import Thread

   def run_event_loop(loop):
       asyncio.set_event_loop(loop)
       loop.run_forever()  # å¯åŠ¨äº‹ä»¶å¾ªç¯

   # åˆ›å»ºå­çº¿ç¨‹è¿è¡Œäº‹ä»¶å¾ªç¯
   loop = asyncio.new_event_loop()
   t = Thread(target=run_event_loop, args=(loop,), daemon=True)
   t.start()
   ```

2. **æäº¤åç¨‹åˆ°å­çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯**
   ```python
   async def my_coroutine():
       await asyncio.sleep(1)
       return "Done"

   # åœ¨ä¸»çº¿ç¨‹æˆ–å…¶ä»–çº¿ç¨‹ä¸­æäº¤åç¨‹
   future = asyncio.run_coroutine_threadsafe(my_coroutine(), loop)
   ```

3. **å¤„ç†ç»“æœæˆ–å¼‚å¸¸**
   â€¢ **é˜»å¡ç­‰å¾…ç»“æœ**ï¼ˆå¯èƒ½é˜»å¡å½“å‰çº¿ç¨‹ï¼‰ï¼š
     ```python
     try:
         result = future.result(timeout=2)  # è®¾ç½®è¶…æ—¶
         print("Result:", result)
     except asyncio.TimeoutError:
         print("Timeout!")
     except Exception as e:
         print("Error:", e)
     ```
   â€¢ **éé˜»å¡å›è°ƒå¤„ç†**ï¼ˆæ¨èï¼‰ï¼š
     ```python
     def callback(future):
         try:
             result = future.result()
             print("Result:", result)
         except Exception as e:
             print("Error:", e)

     future.add_done_callback(callback)  # å›è°ƒåœ¨äº‹ä»¶å¾ªç¯çº¿ç¨‹æ‰§è¡Œ
     ```


`loop.call_soon_threadsafe()` is the correct method to schedule a regular function call (like `event.set()`) to be executed in the event loop from another thread. It ensures thread safety when interacting with the event loop.  


## äº‹ä»¶å¾ªç¯ 
### 1. äº‹ä»¶å¾ªç¯ (Event Loop)
äº‹ä»¶å¾ªç¯æ˜¯Â `asyncio`Â çš„æ ¸å¿ƒæœºåˆ¶ï¼Œè´Ÿè´£è°ƒåº¦å’Œæ‰§è¡Œå¼‚æ­¥ä»»åŠ¡ã€‚å®ƒç®¡ç†ç€æ‰€æœ‰çš„åç¨‹ã€ä»»åŠ¡ã€å›è°ƒå‡½æ•°ä»¥åŠ I/O æ“ä½œã€‚æ¯ä¸ªçº¿ç¨‹åœ¨åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªäº‹ä»¶å¾ªç¯ã€‚

é€šè¿‡å¦‚ä¸‹æ–¹æ³•ç»‘å®š 
```python
self.loop = asyncio.new_event_loop()
asyncio.set_event_loop(self.loop) 
self.loop_thread = threading.Thread(self.loop.run_forever(), daemon=True)
```




ğŸ“Œ **`loop.call_soon_threadsafe(callback, *args)` çš„ä½œç”¨** : 
- å®ƒç”¨äº**ä»å¦ä¸€ä¸ªçº¿ç¨‹**å®‰å…¨åœ°æäº¤ä»»åŠ¡åˆ° `asyncio` äº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œã€‚
- é€‚ç”¨äº `asyncio` äº‹ä»¶å¾ªç¯**åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­è¿è¡Œ**ï¼Œä½†ä½ æƒ³è¦ä»**ä¸»çº¿ç¨‹**æˆ–å…¶ä»–**éäº‹ä»¶å¾ªç¯çº¿ç¨‹**è§¦å‘å›è°ƒã€‚
## ä¸€ã€Pickel åº“çš„ä½¿ç”¨
ä¿å­˜çŸ©é˜µå¯¹è±¡å¯ä»¥é‡‡ç”¨ pickel åº“, æ”¯æŒçŸ©é˜µå¯¹è±¡è¯»å†™; ä¾‹å¦‚å°†çŸ©é˜µä¿å­˜åœ¨ 1.txt ä¸­, ç„¶åè¯»å–å‡º, æ–¹æ³•å¦‚ä¸‹:
```python
import pickle  
import numpy as np  
import re  
  
a = np.mat([[1,2,3], [4,5,6], [7,8,9]])  
  
with open("1.txt", "wb") as fp:  
    pickle.dump(a, fp)  
  
with open("1.txt", "rb") as fp:  
    readmat = pickle.load(fp)  
    print(readmat)
```

å…¶ä¸­, <mark style="background: transparent; color: red">ä¿å­˜ä»»æ„çš„æ•°æ®åªéœ€è¦ä¸¤å¥ä»£ç </mark>:
```python 
with open("1.txt","w") as  fp:
	pickel.dump(a,fp)  # ä¿å­˜æ•°æ®
	pickel.load(fp)       # è¯»å–æ•°æ®
```

json æ–‡ä»¶ä¹Ÿæ˜¯å¯ä»¥é‡‡ç”¨ import json -> json.dump ä¿å­˜

## äºŒã€å¸¸ç”¨çš„æ•°æ®ç»“æ„å’Œåº“å‡½æ•°
Python æä¾›çš„æœ€åŸºæœ¬çš„å®¹å™¨ç»“æ„åŒ…æ‹¬ list, dict, set(é›†åˆ), tuple(å…ƒç»„)å››ç§, å…¶ä¸­ tuple æ˜¯åªè¯»çš„.
### (1) Python ä¸­çš„æ ‘ç»“æ„
Python é‡‡ç”¨ dict å­—å…¸å‹æ•°æ®ç»“æ„å®ç°å­˜å‚¨, è€Œæ ‘ç»“æ„ä¸€èˆ¬ç”¨äºåˆ†ç±»æ ‘ç­‰ç­‰ç®—æ³•, å½“å¯è§†åŒ–å†³ç­–æ ‘ç­‰ç­‰æ—¶, å¯ä»¥é‡‡ç”¨treelib åº“: https://treelib.readthedocs.io/en/latest/  

å¦å¤–å°†åŸå§‹çš„æ–‡ä»¶çš„ç¬¬ 930 è¡Œ dataloader.py çš„ print(self.reader) åé¢çš„ encode å»æ‰, å°±å¯ä»¥æ­£å¸¸æ˜¾ç¤ºäº†: 
```python 
print(self._reader)   # print(self._reader.encode("utf-8"))
```

æµ‹è¯•ä»£ç å¦‚ä¸‹(ä¹Ÿå¯ä»¥å°†æ ‘å†™ä¸ºjsonæ–‡ä»¶):
```python 
# -*- coding: utf-8 -*-
import numpy as np
from treelib import Node, Tree  
  
tree = Tree()  
tree.create_node("Harry", "harry")  # root node  
tree.create_node("Jane", "jane", parent="harry")  
tree.create_node("Bill", "bill", parent="harry")  
tree.create_node("Diane", "diane", parent="jane")  
tree.create_node("Mary", "mary", parent="diane")  
tree.create_node("Mark", "mark", parent="jane")  
  
tree.show(line_type='ascii-em')
js = tree.to_json()  
print(js)  
  
print(','.join([tree[node].tag for node in \  
            tree.expand_tree(mode=Tree.DEPTH)]))
```
ç»“æœå¦‚ä¸‹:
```python
Harry
â• â•â• Bill
â•šâ•â• Jane
    â• â•â• Diane
    â•‘   â•šâ•â• Mary
    â•šâ•â• Mark
```

å¦å¤–, é€šè¿‡ `treelib`Â ä¸­çš„Â `from_map`Â æ–¹æ³•ï¼Œå¯ä»¥<mark style="background: transparent; color: red">ç”¨æ¥ä»ä¸€ä¸ªæ˜ å°„ï¼ˆå¦‚å­—å…¸ï¼‰åˆ›å»ºæ ‘ç»“æ„</mark>ã€‚
```python
from treelib import Tree  
  
# å®šä¹‰ä¸€ä¸ªæ˜ å°„ï¼Œé”®æ˜¯èŠ‚ç‚¹æ ‡è¯†ç¬¦ï¼Œå€¼æ˜¯çˆ¶èŠ‚ç‚¹æ ‡è¯†ç¬¦  
node_map = {  
    'root': None,  
    'child1': 'root',  
    'child2': 'root',  
    'grandchild1': 'child1',  
    'grandchild2': 'child1'  
}  
  
tree = Tree.from_map(node_map)  
tree.show()
```
å³å¯åˆ›å»ºç”± json å¯¹è±¡ç”Ÿæˆå¯¹åº”çš„æ ‘ã€‚
å¤æ‚æ“ä½œå¯ä»¥å‚è€ƒ [treelibä½¿ç”¨](https://blog.csdn.net/u012856866/article/details/137236189)

éœ€è¦è¯´æ˜çš„æ˜¯, åœ¨ä¸åŒä¸»åˆ†æ”¯ä¸‹ä¸èƒ½æœ‰ä¸åŒçš„å‘½å, å¦åˆ™å½“ child1 ä¸‹æœ‰ä¸€ä¸ª grandchild1 ä¸” child2 ä¸‹æœ‰ä¸€ä¸ªgrandchild1æ—¶, åˆ™éœ€è¦ä»¥çˆ¶èŠ‚ç‚¹åŠ å…¥è¿›è¡Œå‘½å, å› æ­¤å¯ä»¥é‡‡ç”¨å¦‚ä¸‹çš„è„šæœ¬:

dict_to_map.py:
```python title:ç”±jsonç»“æ„çš„å†³ç­–æ ‘å¯¹è±¡ç”Ÿæˆ
import copy  
from treelib import Tree  
  
def dict2map(dic):  
    if not isinstance(dic, dict):  
        raise TypeError("input should be dict")  
    map = {}  
    _dict2map_cb(dic if len(dic) <= 1 else {'root':dic}, map, parent = [])  
    return map  
  
def _dict2map_cb(dic, map, parent=[]):  
    """  
    Create map object in treelib by dict    :param dic: Python dict    :param map: Use {} as map    :param node_name: If None, use the first key of dic as root                      but when multiple items in json, pass "root"    :param parent: Parent node array    :return:  
    """    for key, val in dic.items():  
        node_name_new = '-'.join(parent)  
        root_name = '-'.join(parent + [key])  
        if isinstance(val, dict):  
            map[root_name] = node_name_new if parent!=[] else None   # when root node,use None  
            _dict2map_cb(val, map, parent=parent + [key])  
        else:            map[root_name + " : " + str(val)] = node_name_new if parent!=[] else None  
  
if __name__ == "__main__":  
    a = {"hello": {"word": 2}}  
    b = {'decision 0': {'target 1': 256, 'decision 3': {'target 0': 128, 'target 1': 256}, 'decision 2': {'target 0': 256, 'target 1': 128}}}  
    c = {'hi': {"w": 3}, 'this':{'e':4}}  
    Tree.from_map(dict2map(a)).show()  
    Tree.from_map(dict2map(b)).show(line_type="ascii-em")  
    Tree.from_map(dict2map(c)).show(line_type="ascii-em")
```


### (2) å›¾å’Œç½‘ç»œç»“æ„çš„å¯è§†åŒ–æ–¹æ¡ˆ
ä¸€èˆ¬è€Œè¨€, å›¾å’Œç½‘ç»œç»“æ„æ˜¯ä½¿ç”¨ dict + list è¿›è¡Œå­˜å‚¨çš„: 
å¦‚ `node = {'node name': "node1"}, arc = {'arc1' : list[node1, node2]}` ç±»ä¼¼ç»“æ„
ä¸€èˆ¬æ˜¯é€šè¿‡[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸŒ³Data Structure & Algorithms/ã€½ï¸ Data Structure/ç¬¬ä¸ƒç«  å›¾|é‚»æ¥çŸ©é˜µæ–¹æ¡ˆ]]è¿›è¡Œå­˜å‚¨ã€‚å¹¶ä¸”åˆ©ç”¨åŸºæœ¬å®Œå…¨ä¸€è‡´çš„æ–¹æ¡ˆè¿›è¡Œå­˜å‚¨ã€‚

### Bunch å¯¹è±¡çš„ä½¿ç”¨
Bunch æ˜¯ä¸€ç§**æ•°æ®ç»“æ„ç±»å‹**, æä¾›äº†ä¸€ä¸ª key, value  çš„å¯¹è±¡å½¢å¼, ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹
```python 
from sklearn.datasets._base import Bunch 
import pickle

bunch = Bunch(file_name = [],  path_dir = [], target = [])  
  
bunch.file_name.extend(path_list)  
for path in path_list:  
    print(path)  
    bunch.path_dir.append(path)  
  
print(bunch)
# {'file_name': ['UserManual_Bayesian.html', 'UserManual_Inference.html', 'UserManual_Input.html', 'UserManual_Kriging.html'], 'path_dir': ['UserManual_Bayesian.html', 'UserManual_Inference.html', 'UserManual_Input.html', 'UserManual_Kriging.html'], 'target': []}

# å½“ä¿å­˜åˆ°æŸä¸ªæ–‡ä»¶ä¸­æ—¶, åªéœ€è°ƒç”¨ pickle çš„ dump æ–¹æ³•: 
with open("result.txt", "wb") as fp:  
    pickle.dump(bunch,fp)
```
å…¶ä¸­å…ƒç´ å…è®¸æ˜¯ä¸åŒçš„æ•°æ®ç±»å‹, åˆ†åˆ«è°ƒç”¨å„è‡ªçš„æ–¹æ³•ã€‚


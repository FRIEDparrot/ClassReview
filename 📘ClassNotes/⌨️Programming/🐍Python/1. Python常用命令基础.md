## 一、Scipy 常用操作
scipy.stats 是常用的概率统计的分布函数库:
```python
from scipy.stats import norm       # 正态分布
from scipy.stats import uniform   # 均匀分布

norm.cdf(x) # 返回正态密度 
norm.pdf(x) # 返回正态分布概率密度
uniform.cdf(1)
uniform.pdf(1)
```

稀疏矩阵 svd 分解和求秩:
```python
import numpy as np
from scipy.sparse import csc_matrix
from scipy.sparse.linalg import svds

# 创建一个稀疏矩阵
row = np.array([0, 2, 2, 0, 1, 2, 0])
col = np.array([0, 0, 1, 2, 2, 2, 0])
data = np.array([1, 2, 3, 4, 5, 6, 5])
sp_A = csc_matrix((data, (row, col)), shape=(3, 3), dtype=float)

# 使用奇异值分解求解稀疏矩阵的秩
u, s, vt = svds(sp_A, k=min(sp_A.shape)-1)
rank = np.sum(s > 1e-10)  # 设定一个阈值来判断奇异值是否为零

print("稀疏矩阵的秩:", rank)
```

## 二、numpy 常用操作
### 1. 矩阵操作
numpy 矩阵索引方法: 如果是取行,则直接采用`[[1,2,3,4,5]]`, 如果是取第二维或者第三维, 则采用 `[:,[1,2,3,4,5]]` , 示例如下: 
```python 
data =   self.train_data.data[tar_range][:, dec_range] 
```
零矩阵 np.zeros
单位对角矩阵 eye  
随机矩阵 np.random.rand((3,3))
转换列表为矩阵 np.mat 
矩阵求和 np.sum  (可以选择axis, keep_dims = True) 保证前后维数相同
某个向量或者矩阵中的最大值: m.max() , np.max(m) 
按元素乘积(一般的 * 是按矩阵做矩阵乘法) np.multiply 
按元素施加函数 np.ufunc  
向量点乘(按元素相乘) np.dot 
对角矩阵 np.diag
返回排序后的下标 np.argsort()
返回**所有的独立元素** np.unique()
替换某些符合要求的元素 cls_prop = np.where(cls_prop == 0,1e-10, cls_prop)
删除array中某个下标的元素 `a = np.delete(a, [1,2])`  
填充对角线元素(常常用于对角线置一或者置零): `np.fill_diagnoal` 
矩阵按找元素除 : 一般 `/` 和 np.divide 等效, 但 `np.divide` 提供了更多的参数选项，例如 `out` 参数可以指定输出数组，`where` 参数可以指定条件掩码等。

np.where : 获取下标
np.isin : 一个数组中的元素是否在另一个数组中, 示例代码如下:
```python 
target = np.array([0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0])
left_tar_idx = [0, 1]
# 获取包含在 left_tar_idx 中的下标
indices = np.where(np.isin(target, left_tar_idx))[0]
```
np.cumsum()  # 累计求和  
np.cumpod()  # 累计乘积

```python
# 矩阵转置 
m = np.mat([1,2,3,4], dtype=np.float32)  
m.transpose()
m.T # 得到结果相同
```
统计非零元素的个数: 采用nonzero返回数组或者矩阵**非零元素的下标**(注意返回的是元组, 和维数是相同的)
```python
idx_zero = np.nonzero(A)  # 返回的部分为所有的非零下标, len(idx_zero)为非零元素个数:
idx_zero = (array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2, 0, 1], dtype=int64))
#  其中 A[2][2] = 0 , 因此  idx_zero[0] 为
```

### 2. 概率论相关
均值: np.mean 
方差: $\sigma$ = np.std 
均方差: np.var () (实际上是与平均值差的乘积)
计算两个向量的相关系数:
```python 
x = [1,2,3]
y = [4,5,6]
np.corrcoef(x,y)
```

### 3. np.linalg 线性代数矩阵库相关
#### 1. 常用矩阵操作
线性代数库集成了包括求解行列式和矩阵求逆等等内容。 
**import numpy.linalg as la** : 
lmbda, v = la.eig(A) # 求解**特征值和特征向量**(概念和一般公式参考[[📘ClassNotes/📐Mathmatics/📏linear algebra/第五章 矩阵的相似变换|矩阵的相似变换]]
la.det(a)  # 求行列式 
la.inv(a)   # 矩阵求逆
la.norm(b);  la.norm(A) # 取向量的模或者长度, 进行规范化; 等同于 np.sqrt(np.sum(np.multiply(A,A))) 
la.matrix_rank(A) # 矩阵求秩

求解矩阵方程: la.solve()
$$A x = b$$
```python
A = np.mat([[1,2,3], [4,10,6],[7,3,2]])
b = np.mat([10, 20, 30]).T
la.inv(A) * b 
# 也可以采用下述方法求解
la.solve(A,b)
```

#### 2. 矩阵的分解 (SVD 和 QR 分解)
U,S, VT = la.svd(A) # 奇异值SVD分解(参考[[📘ClassNotes/⌨️Programming/👨‍🎓Deep Learning/👨‍🎓深度学习算法原理(sklearn)/3. 推荐系统和需求搜寻算法(CF,PCA,SVD)#(3) 一般矩阵的 SVD 分解及其证明|一般矩阵的 SVD 分解及其证明]])  
```python
from numpy.linalg import svd
fromm numpy.linalg import qr 
U, s, V = svd(matrix)
Q, R = qr(matrix)
```


## 三、pandas 数据分析常用操作
### 1. 取行或者取列
取某几行或者某几列:
```python
features = data.iloc[0:2]                    # 取某几行
features = data[data.columns[0:2]]  # 取某几列
features.shape[1]         # 获取某些方向上的尺寸
data_tensor = torch.tensor(data.values)  # 转换pd.dataframe 到 torch.tensor
```


### 2. 转换 pandas 数据到torch张量
在 torch 中最为常用的是 torch.utils.data 包,
```python
from torch.utils.data import dataloader
```
在 pytorch 中, unsqueeze 用于增加张量的维数, 例如将一个一维张量转换为二维, 则使用:
```
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it 
```

最为简单的小批量依次输出的方法如下, 需要注意 `data_tensor = torch.tensor(data.values, dtype=torch.float32) ` 将 DataFrame 转换为 float32 数据类型, 如果默认, 则是double 数据类型，会产生问题

```python 
import deeplearning_util_functions  
import pandas as pd  
import torch  
from torch.utils.data import DataLoader, TensorDataset  
  
# Boston housing problem  
data = pd.read_csv("../datasheets/housing.csv")  
data_tensor = torch.tensor(data.values, dtype=torch.float32)  # note from 
  
features = data_tensor[:, 0:3]  #  
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it  to keep 2 dims
n = features.shape[0] 

# create the linear regression minibatch stochastic gradient descent  
w = torch.ones(n)  
b = torch.zeros(n)  
  
X = features  
Y = targets  
  
DataLoader1 = DataLoader(torch.cat((X,Y), 1),batch_size=20,shuffle=True)
for minibatch in DataLoader1:  
    print(minibatch)
```

### 3. 迭代器对象和next() 函数用法
`next()` 用于迭代器中获取下一个元素, 如果达到末尾则抛出 StopIteration 异常 
```python 
# 获取下一个元素
numbers = [1, 2, 3, 4, 5]
numbers_iter = iter(numbers)
print(next(numbers_iter))  # 输出：1
print(next(numbers_iter))  # 输出：2
```

如果是迭代器对象, 则必须实现 `__iter__()` 和 `__next__()` 两个方法
- `__iter__()`方法：返回迭代器对象本身。
- `__next__()`方法：返回迭代器对象的下一个数据元素，如果没有元素可迭代，则抛出`StopIteration`异常。例如定义 MyIterator 迭代器对象 
```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        result = self.data[self.index]
        self.index += 1
        return result
numbers = [1, 2, 3, 4, 5] 
my_iter = MyIterator(numbers) 

for num in my_iter:  
	print(num)   # 实际上是从next 迭代器方法中获取到的num对象
```

## 四、Python 官方库用法整理
列出某个目录下的文件 `dir(tensorflow)` 
获取encoding 函数:
isinstance(value, dict)

### (1) 最常见使用
#### 1) print格式控制和进制转换
```python
x = 1
y = 2
print(f'x = {x:.3f}, z = {x+y:.3f}')  # 直接嵌入式格式控制 
print('score:{:.3f}\n'.format(score))  # 采用字符串的 .format 控制 
```

其中第二个显示 z = 3.00, 即通过string 中的 f 实现了格式控制;
进制转换常用函数
```python
bin()
oct()
int()
hex()
```
当其他数字转换成另外的进制时, 加上0b,0o, 无前缀, oh即可
int('10110001',2) -> 177,  int(0b10110001)
bin(0xbe) # 对于使用其他进制

','.split 和 .splitlines() 方法,可以返回列表式的迭代对象。

利用Python的广播机制, 可以将 下面的整个部分缩写为一句:
```python
# cnt_mat = np.mat(np.zeros((targets.size, decisions.size))) # number of samples of each class for each decision attribute 
# for c in range(targets.size):  
#     for d in range(decisions.size):  
#         tar = targets[c]  
#         dec = decisions[d]  
#         cnt_mat[c,d] = np.sum(counts_arr[(decision_arr == dec) & (target_arr == tar)])

# 正确的简介写法如下 : 
cnt_mat = np.array([  
    [np.sum(counts_arr[(decision_arr == dec) & (target_arr == tar)]) for dec in decisions]  
    for tar in targets  
])
```

#### 2) 数据类型和基本运算
```python title:检查器
hasattr(X, "ndim")   # 检查某个类对象是否具有某种属性: hasattr
isinstance(X, list)    #  检查某个对象是否是某个类:isinstance 
```
列表拼接直接使用 + 进行  `b =  a + item` 

python 自带了复数类型和 bytes 数据类型, 采用 j 表示复数 
```python
b =  1 + 2j
type(b)   # complex 
b.conjugate()   # 共轭 
b.imag()
b.real()              # 实部
d, m = divmod(3, 2)    # 返回 x/y , x%y

c = bytes(12)   # bytes 数据类
bytes("你好",encoding="utf-8")
```

在 python 中, C 语言的整除(%)采用 `//` 进行,  同时接受 `nan` 和 `inf`, 定义 0\*\*0 = 1 例如: 
``` python 
5.2 // 2  #  2
d = float("inf") ;  - d
d = float("nan")
```

```python
math.trunc(x);   # 取整数部分
round(x, n);    # 取 n 位小数部分 
math.floor  | math.ceil()
```


#### 3) 列表操作和下标遍历指定 
```python
x[i]
x[i:j]
x[i:j:k]   # 从 x 开始 每隔 j 取一个取到 k  
s = ['a','b','c']
# 常见的函数如下: 
s.count('a') 
s.index('b')   # 第一个下标
s.index('b', 1,2)  # 在某个范围内的第一个下标
s.append()  #  添加元素 
s.extend()   #  直接添加带有元素的列表 
s.insert(4,'d')   # 插入元素 
s.pop()   | s.pop(e)   # e 可以指定元素
s.remove(x)
s.reverse()     # 倒序 
s.clear() 
s.copy()  
sorted(s)   # 排序 
```

### (2) Python 中的函数定义
#### 1) 指定函数输入和返回类型 
不使用的参数可以采用 _ 代替, 如 `_ = plt.show()` 
在函数编写时, 可以指定输入的格式类型, 具体方法如下:
```python 
def set_axis(axes:matplotlib.axes.Axes, xlabel:str, ylabel:str, xlim, ylim, xscale, yscale, legend):  
    axes.set_xlabel(xlabel);    axes.set_ylabel(ylabel)  
    axes.set_title(title);
```

方法是在 def 后加上 `-> 类型` 指定返回类型, 如果没有返回类型, 则认为是 None.
```python
class A:
	def __init__(self) -> None:
		A.name = "wreg"
		pass
	def sum(a:int, b:int) -> int:
		return a + b
```

如果是返回多个指定类型的参数, 则可以使用:
```python
def generate_sample(self, W, b) -> tuple [int, int]:
    # 你的代码
    return X, y
```

#### 2) 自定义迭代器和迭代类型
基本的方法是使用 yield 进行迭代返回, 
```python
def get_dataloader():
	indics = list(range(0, 100))
	batch_indices =   torch.tensor( indices[i : i + self.batch_size] )  # if batch size = 10,  return the first 10 element at first. 
	yield self.x[batch_indices], self.y[batch_indices]

# 使用方法如下:
X,y = next(iter(data.get_dataloader()))
```

```python
iter_dict = iter(dic.items())
next(iter_dict) 
```

#### 3) 类中函数的私有化
在 Python 中，可以通过在函数名前加上双下划线 `__` 来将其定义为私有方法。私有方法只能在类的内部访问，不能在类的外部直接调用。


### (3) 常用的关键字
yield 关键字 : 作用是保存当前程序执行状态, 虽然可以理解为 return 操作, 但是yield执行时还保存了当前的执行内容, 再一次调用这个函数时，他会找到你在此函数中的yield关键字，然后从yield的下一句开始执行。
```python
def generator():
    for i in range(10):
        yield i * i   # 需要单个逐一返回 
gen = generator()
print(gen)
```

例如读取大型文本文件的方案:
```python
with open("file.txt", "rb") as f:
	while(True):
		line = f.readline()
		if  content == "":  # 判断文件末尾
			break
		yield content
```

[assert 用法](https://blog.csdn.net/qq_42269354/article/details/89476880) 即后面布尔必须为真,如果为假则触发异常。

map 函数: map 是一个内置函数, 用于将一个函数应用到可迭代对象的每个元素上。如图所示:
```python
def square(x):
    return x * x

numbers = [1, 2, 3, 4, 5]
squared_numbers = map(square, numbers)
print(list(squared_numbers))  # 输出: [1, 4, 9, 16, 25]
```

### (4) Collections 容器类
collection 提供了包括双端队列(deque)等多种数据类型
```python
from colloection import namedtuple,deque
```
参考 [python 官方文档](https://docs.python.org/3/library/collections.html)

```python
def forward(self, input: Tensor, target: Tensor) -> Tensor: return F.mse_loss(input, target, reduction=self.reduction)	
```

### (5) Python 继承的使用
下面讲解了继承 torch.nn.Module 类的方法, 首先需要在类名后面括号加上继承的类, 并且使用 super() 调用父类的 \_\_init\_\_()函数 
```python
import torch  
import numpy as np  
import time  
import torch.nn as nn  
from deeplearning_util_functions import plot_figure  
from matplotlib import pyplot as plt  
  
class Regression_Module(nn.Module):   # if class is in bracket, it will inherit this class  
    def __init__(self, learning_rate:float=0.001) :  
        # for the  method inherit from other method: use:  
        super().__init__()  # inherit the  init method of the parent  
  
        self.learning_rate = learning_rate  
        self.wrapper('learning_rate', 0.2)  
        print(self.learning_rate)  
        print(self.cpu())  
        print(torch.cpu.current_device())  
    def wrapper(self, attr:str, value):  
        setattr(self, attr, value)  
        assert hasattr(self, 'learning_rate') # refer to https://blog.csdn.net/qq_42269354/article/details/89476880  
    def __call__(self, *args, **kwargs):  
        print("executing the method")  
  
a = Regression_Module(0.01)   # create a new class  
a()  # call the __call__ method
```

需要说明, python 允许将一个类像一个实例一样调用, 实际上是调用了其中的 `__call__` 方法
```python
assert hasattr(u.name, '__call__')    # 判断是否可以调用
u()   # 调用其中的 __call__ 方法
```

### (6) html 和 xml 的解析方法 
常见的 html 去除 html 标签, 可以采用 lxml 库
```python
from lxml import etree, html  
  
file_path = "html/UserManual_Bayesian.html"  
  
with open(file_path, 'rb') as fp:  
    contents =  fp.read()  
    text_doc = html.document_fromstring(contents)  # parse the file  
    print(text_doc.text_content())
```

如果是提取 html 中的纯文本内容, 则采用 BeautifulSoup
```python
from bs4 import BeautifulSoup
with open("./html/" + file, "rb") as f:  
    contents = f.read()  
    text_content = BeautifulSoup(contents, parser="html.parser", features='lxml').get_text()
```

## 五、os 库常用操作

```python
file_list = os.listdir(dir1)
for path in file_list:
	print(path)

os.path.exists(dir) 
os.makedir(dir) 
```

执行shell指令
```python
import subprocess  
print(subprocess.run("ls /", shell=True).stdout)
```


```python 
import importlib  
import sys  
  
importlib.reload(sys)  
print(sys.getdefaultencoding())
```
## ä¸€ã€Scipy å¸¸ç”¨æ“ä½œ
scipy.stats æ˜¯å¸¸ç”¨çš„æ¦‚ç‡ç»Ÿè®¡çš„åˆ†å¸ƒå‡½æ•°åº“:
```python
from scipy.stats import norm       # æ­£æ€åˆ†å¸ƒ
from scipy.stats import uniform   # å‡åŒ€åˆ†å¸ƒ

norm.cdf(x) # è¿”å›æ­£æ€å¯†åº¦ 
norm.pdf(x) # è¿”å›æ­£æ€åˆ†å¸ƒæ¦‚ç‡å¯†åº¦
uniform.cdf(1)
uniform.pdf(1)
```

ç¨€ç–çŸ©é˜µ svd åˆ†è§£å’Œæ±‚ç§©:
```python
import numpy as np
from scipy.sparse import csc_matrix
from scipy.sparse.linalg import svds

# åˆ›å»ºä¸€ä¸ªç¨€ç–çŸ©é˜µ
row = np.array([0, 2, 2, 0, 1, 2, 0])
col = np.array([0, 0, 1, 2, 2, 2, 0])
data = np.array([1, 2, 3, 4, 5, 6, 5])
sp_A = csc_matrix((data, (row, col)), shape=(3, 3), dtype=float)

# ä½¿ç”¨å¥‡å¼‚å€¼åˆ†è§£æ±‚è§£ç¨€ç–çŸ©é˜µçš„ç§©
u, s, vt = svds(sp_A, k=min(sp_A.shape)-1)
rank = np.sum(s > 1e-10)  # è®¾å®šä¸€ä¸ªé˜ˆå€¼æ¥åˆ¤æ–­å¥‡å¼‚å€¼æ˜¯å¦ä¸ºé›¶

print("ç¨€ç–çŸ©é˜µçš„ç§©:", rank)
```

## äºŒã€numpy å¸¸ç”¨æ“ä½œ
### 1. çŸ©é˜µæ“ä½œ
numpy çŸ©é˜µç´¢å¼•æ–¹æ³•: å¦‚æœæ˜¯å–è¡Œ,åˆ™ç›´æ¥é‡‡ç”¨`[[1,2,3,4,5]]`, å¦‚æœæ˜¯å–ç¬¬äºŒç»´æˆ–è€…ç¬¬ä¸‰ç»´, åˆ™é‡‡ç”¨ `[:,[1,2,3,4,5]]` , ç¤ºä¾‹å¦‚ä¸‹: 
```python 
data =   self.train_data.data[tar_range][:, dec_range] 
```
é›¶çŸ©é˜µ np.zeros
å•ä½å¯¹è§’çŸ©é˜µ eye  
éšæœºçŸ©é˜µ np.random.rand((3,3))
è½¬æ¢åˆ—è¡¨ä¸ºçŸ©é˜µ np.mat 
çŸ©é˜µæ±‚å’Œ np.sum  (å¯ä»¥é€‰æ‹©axis, keep_dims = True) ä¿è¯å‰åç»´æ•°ç›¸åŒ
æŸä¸ªå‘é‡æˆ–è€…çŸ©é˜µä¸­çš„æœ€å¤§å€¼: m.max() , np.max(m) 
æŒ‰å…ƒç´ ä¹˜ç§¯(ä¸€èˆ¬çš„ * æ˜¯æŒ‰çŸ©é˜µåšçŸ©é˜µä¹˜æ³•) np.multiply 
æŒ‰å…ƒç´ æ–½åŠ å‡½æ•° np.ufunc  
å‘é‡ç‚¹ä¹˜(æŒ‰å…ƒç´ ç›¸ä¹˜) np.dot 
å¯¹è§’çŸ©é˜µ np.diag
è¿”å›æ’åºåçš„ä¸‹æ ‡ np.argsort()
è¿”å›**æ‰€æœ‰çš„ç‹¬ç«‹å…ƒç´ ** np.unique()
æ›¿æ¢æŸäº›ç¬¦åˆè¦æ±‚çš„å…ƒç´  cls_prop = np.where(cls_prop == 0,1e-10, cls_prop)
åˆ é™¤arrayä¸­æŸä¸ªä¸‹æ ‡çš„å…ƒç´  `a = np.delete(a, [1,2])`  
å¡«å……å¯¹è§’çº¿å…ƒç´ (å¸¸å¸¸ç”¨äºå¯¹è§’çº¿ç½®ä¸€æˆ–è€…ç½®é›¶): `np.fill_diagnoal` 
çŸ©é˜µæŒ‰æ‰¾å…ƒç´ é™¤ : ä¸€èˆ¬ `/` å’Œ np.divide ç­‰æ•ˆ, ä½† `np.divide`Â æä¾›äº†æ›´å¤šçš„å‚æ•°é€‰é¡¹ï¼Œä¾‹å¦‚Â `out`Â å‚æ•°å¯ä»¥æŒ‡å®šè¾“å‡ºæ•°ç»„ï¼Œ`where`Â å‚æ•°å¯ä»¥æŒ‡å®šæ¡ä»¶æ©ç ç­‰ã€‚

np.where : è·å–ä¸‹æ ‡
np.isin : ä¸€ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ æ˜¯å¦åœ¨å¦ä¸€ä¸ªæ•°ç»„ä¸­, ç¤ºä¾‹ä»£ç å¦‚ä¸‹:
```python 
target = np.array([0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0])
left_tar_idx = [0, 1]
# è·å–åŒ…å«åœ¨ left_tar_idx ä¸­çš„ä¸‹æ ‡
indices = np.where(np.isin(target, left_tar_idx))[0]
```
np.cumsum()  # ç´¯è®¡æ±‚å’Œ  
np.cumpod()  # ç´¯è®¡ä¹˜ç§¯

```python
# çŸ©é˜µè½¬ç½® 
m = np.mat([1,2,3,4], dtype=np.float32)  
m.transpose()
m.T # å¾—åˆ°ç»“æœç›¸åŒ
```
ç»Ÿè®¡éé›¶å…ƒç´ çš„ä¸ªæ•°: é‡‡ç”¨nonzeroè¿”å›æ•°ç»„æˆ–è€…çŸ©é˜µ**éé›¶å…ƒç´ çš„ä¸‹æ ‡**(æ³¨æ„è¿”å›çš„æ˜¯å…ƒç»„, å’Œç»´æ•°æ˜¯ç›¸åŒçš„)
```python
idx_zero = np.nonzero(A)  # è¿”å›çš„éƒ¨åˆ†ä¸ºæ‰€æœ‰çš„éé›¶ä¸‹æ ‡, len(idx_zero)ä¸ºéé›¶å…ƒç´ ä¸ªæ•°:
idx_zero = (array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2, 0, 1], dtype=int64))
#  å…¶ä¸­ A[2][2] = 0 , å› æ­¤  idx_zero[0] ä¸º
```

### 2. æ¦‚ç‡è®ºç›¸å…³
å‡å€¼: np.mean 
æ–¹å·®: $\sigma$ = np.std 
å‡æ–¹å·®: np.var () (å®é™…ä¸Šæ˜¯ä¸å¹³å‡å€¼å·®çš„ä¹˜ç§¯)
è®¡ç®—ä¸¤ä¸ªå‘é‡çš„ç›¸å…³ç³»æ•°:
```python 
x = [1,2,3]
y = [4,5,6]
np.corrcoef(x,y)
```

### 3. np.linalg çº¿æ€§ä»£æ•°çŸ©é˜µåº“ç›¸å…³
#### 1. å¸¸ç”¨çŸ©é˜µæ“ä½œ
çº¿æ€§ä»£æ•°åº“é›†æˆäº†åŒ…æ‹¬æ±‚è§£è¡Œåˆ—å¼å’ŒçŸ©é˜µæ±‚é€†ç­‰ç­‰å†…å®¹ã€‚ 
**import numpy.linalg as la** : 
lmbda, v = la.eig(A) # æ±‚è§£**ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡**(æ¦‚å¿µå’Œä¸€èˆ¬å…¬å¼å‚è€ƒ[[ğŸ“˜ClassNotes/ğŸ“Mathmatics/ğŸ“linear algebra/ç¬¬äº”ç«  çŸ©é˜µçš„ç›¸ä¼¼å˜æ¢|çŸ©é˜µçš„ç›¸ä¼¼å˜æ¢]]
la.det(a)  # æ±‚è¡Œåˆ—å¼ 
la.inv(a)   # çŸ©é˜µæ±‚é€†
la.norm(b);  la.norm(A) # å–å‘é‡çš„æ¨¡æˆ–è€…é•¿åº¦, è¿›è¡Œè§„èŒƒåŒ–; ç­‰åŒäº np.sqrt(np.sum(np.multiply(A,A))) 
la.matrix_rank(A) # çŸ©é˜µæ±‚ç§©

æ±‚è§£çŸ©é˜µæ–¹ç¨‹: la.solve()
$$A x = b$$
```python
A = np.mat([[1,2,3], [4,10,6],[7,3,2]])
b = np.mat([10, 20, 30]).T
la.inv(A) * b 
# ä¹Ÿå¯ä»¥é‡‡ç”¨ä¸‹è¿°æ–¹æ³•æ±‚è§£
la.solve(A,b)
```

#### 2. çŸ©é˜µçš„åˆ†è§£ (SVD å’Œ QR åˆ†è§£)
U,S, VT = la.svd(A) # å¥‡å¼‚å€¼SVDåˆ†è§£(å‚è€ƒ[[ğŸ“˜ClassNotes/âŒ¨ï¸Programming/ğŸ‘¨â€ğŸ“Deep Learning/ğŸ‘¨â€ğŸ“æ·±åº¦å­¦ä¹ ç®—æ³•åŸç†(sklearn)/3. æ¨èç³»ç»Ÿå’Œéœ€æ±‚æœå¯»ç®—æ³•(CF,PCA,SVD)#(3) ä¸€èˆ¬çŸ©é˜µçš„ SVD åˆ†è§£åŠå…¶è¯æ˜|ä¸€èˆ¬çŸ©é˜µçš„ SVD åˆ†è§£åŠå…¶è¯æ˜]])  
```python
from numpy.linalg import svd
fromm numpy.linalg import qr 
U, s, V = svd(matrix)
Q, R = qr(matrix)
```


## ä¸‰ã€pandas æ•°æ®åˆ†æå¸¸ç”¨æ“ä½œ
### 1. å–è¡Œæˆ–è€…å–åˆ—
å–æŸå‡ è¡Œæˆ–è€…æŸå‡ åˆ—:
```python
features = data.iloc[0:2]                    # å–æŸå‡ è¡Œ
features = data[data.columns[0:2]]  # å–æŸå‡ åˆ—
features.shape[1]         # è·å–æŸäº›æ–¹å‘ä¸Šçš„å°ºå¯¸
data_tensor = torch.tensor(data.values)  # è½¬æ¢pd.dataframe åˆ° torch.tensor
```


### 2. è½¬æ¢ pandas æ•°æ®åˆ°torchå¼ é‡
åœ¨ torch ä¸­æœ€ä¸ºå¸¸ç”¨çš„æ˜¯ torch.utils.data åŒ…,
```python
from torch.utils.data import dataloader
```
åœ¨ pytorch ä¸­, unsqueeze ç”¨äºå¢åŠ å¼ é‡çš„ç»´æ•°, ä¾‹å¦‚å°†ä¸€ä¸ªä¸€ç»´å¼ é‡è½¬æ¢ä¸ºäºŒç»´, åˆ™ä½¿ç”¨:
```
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it 
```

æœ€ä¸ºç®€å•çš„å°æ‰¹é‡ä¾æ¬¡è¾“å‡ºçš„æ–¹æ³•å¦‚ä¸‹, éœ€è¦æ³¨æ„ `data_tensor = torch.tensor(data.values, dtype=torch.float32) ` å°† DataFrame è½¬æ¢ä¸º float32 æ•°æ®ç±»å‹, å¦‚æœé»˜è®¤, åˆ™æ˜¯double æ•°æ®ç±»å‹ï¼Œä¼šäº§ç”Ÿé—®é¢˜

```python 
import deeplearning_util_functions  
import pandas as pd  
import torch  
from torch.utils.data import DataLoader, TensorDataset  
  
# Boston housing problem  
data = pd.read_csv("../datasheets/housing.csv")  
data_tensor = torch.tensor(data.values, dtype=torch.float32)  # note from 
  
features = data_tensor[:, 0:3]  #  
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it  to keep 2 dims
n = features.shape[0] 

# create the linear regression minibatch stochastic gradient descent  
w = torch.ones(n)  
b = torch.zeros(n)  
  
X = features  
Y = targets  
  
DataLoader1 = DataLoader(torch.cat((X,Y), 1),batch_size=20,shuffle=True)
for minibatch in DataLoader1:  
    print(minibatch)
```

### 3. è¿­ä»£å™¨å¯¹è±¡å’Œnext() å‡½æ•°ç”¨æ³•
`next()` ç”¨äºè¿­ä»£å™¨ä¸­è·å–ä¸‹ä¸€ä¸ªå…ƒç´ , å¦‚æœè¾¾åˆ°æœ«å°¾åˆ™æŠ›å‡º StopIteration å¼‚å¸¸ 
```python 
# è·å–ä¸‹ä¸€ä¸ªå…ƒç´ 
numbers = [1, 2, 3, 4, 5]
numbers_iter = iter(numbers)
print(next(numbers_iter))  # è¾“å‡ºï¼š1
print(next(numbers_iter))  # è¾“å‡ºï¼š2
```

å¦‚æœæ˜¯è¿­ä»£å™¨å¯¹è±¡, åˆ™å¿…é¡»å®ç° `__iter__()` å’Œ `__next__()` ä¸¤ä¸ªæ–¹æ³•
- `__iter__()`æ–¹æ³•ï¼šè¿”å›è¿­ä»£å™¨å¯¹è±¡æœ¬èº«ã€‚
- `__next__()`æ–¹æ³•ï¼šè¿”å›è¿­ä»£å™¨å¯¹è±¡çš„ä¸‹ä¸€ä¸ªæ•°æ®å…ƒç´ ï¼Œå¦‚æœæ²¡æœ‰å…ƒç´ å¯è¿­ä»£ï¼Œåˆ™æŠ›å‡º`StopIteration`å¼‚å¸¸ã€‚ä¾‹å¦‚å®šä¹‰ MyIterator è¿­ä»£å™¨å¯¹è±¡ 
```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        result = self.data[self.index]
        self.index += 1
        return result
numbers = [1, 2, 3, 4, 5] 
my_iter = MyIterator(numbers) 

for num in my_iter:  
	print(num)   # å®é™…ä¸Šæ˜¯ä»next è¿­ä»£å™¨æ–¹æ³•ä¸­è·å–åˆ°çš„numå¯¹è±¡
```

## å››ã€Python å®˜æ–¹åº“ç”¨æ³•æ•´ç†
åˆ—å‡ºæŸä¸ªç›®å½•ä¸‹çš„æ–‡ä»¶ `dir(tensorflow)` 
è·å–encoding å‡½æ•°:
isinstance(value, dict)

### (1) æœ€å¸¸è§ä½¿ç”¨
#### 1) printæ ¼å¼æ§åˆ¶å’Œè¿›åˆ¶è½¬æ¢
```python
x = 1
y = 2
print(f'x = {x:.3f}, z = {x+y:.3f}')  # ç›´æ¥åµŒå…¥å¼æ ¼å¼æ§åˆ¶ 
print('score:{:.3f}\n'.format(score))  # é‡‡ç”¨å­—ç¬¦ä¸²çš„ .format æ§åˆ¶ 
```

å…¶ä¸­ç¬¬äºŒä¸ªæ˜¾ç¤º z = 3.00, å³é€šè¿‡string ä¸­çš„ f å®ç°äº†æ ¼å¼æ§åˆ¶;
è¿›åˆ¶è½¬æ¢å¸¸ç”¨å‡½æ•°
```python
bin()
oct()
int()
hex()
```
å½“å…¶ä»–æ•°å­—è½¬æ¢æˆå¦å¤–çš„è¿›åˆ¶æ—¶, åŠ ä¸Š0b,0o, æ— å‰ç¼€, ohå³å¯
int('10110001',2) -> 177,  int(0b10110001)
bin(0xbe) # å¯¹äºä½¿ç”¨å…¶ä»–è¿›åˆ¶

','.split å’Œ .splitlines() æ–¹æ³•,å¯ä»¥è¿”å›åˆ—è¡¨å¼çš„è¿­ä»£å¯¹è±¡ã€‚

åˆ©ç”¨Pythonçš„å¹¿æ’­æœºåˆ¶, å¯ä»¥å°† ä¸‹é¢çš„æ•´ä¸ªéƒ¨åˆ†ç¼©å†™ä¸ºä¸€å¥:
```python
# cnt_mat = np.mat(np.zeros((targets.size, decisions.size))) # number of samples of each class for each decision attribute 
# for c in range(targets.size):  
#     for d in range(decisions.size):  
#         tar = targets[c]  
#         dec = decisions[d]  
#         cnt_mat[c,d] = np.sum(counts_arr[(decision_arr == dec) & (target_arr == tar)])

# æ­£ç¡®çš„ç®€ä»‹å†™æ³•å¦‚ä¸‹ : 
cnt_mat = np.array([  
    [np.sum(counts_arr[(decision_arr == dec) & (target_arr == tar)]) for dec in decisions]  
    for tar in targets  
])
```

#### 2) æ•°æ®ç±»å‹å’ŒåŸºæœ¬è¿ç®—
```python title:æ£€æŸ¥å™¨
hasattr(X, "ndim")   # æ£€æŸ¥æŸä¸ªç±»å¯¹è±¡æ˜¯å¦å…·æœ‰æŸç§å±æ€§: hasattr
isinstance(X, list)    #  æ£€æŸ¥æŸä¸ªå¯¹è±¡æ˜¯å¦æ˜¯æŸä¸ªç±»:isinstance 
```
åˆ—è¡¨æ‹¼æ¥ç›´æ¥ä½¿ç”¨ + è¿›è¡Œ  `b =  a + item` 

python è‡ªå¸¦äº†å¤æ•°ç±»å‹å’Œ bytes æ•°æ®ç±»å‹, é‡‡ç”¨ j è¡¨ç¤ºå¤æ•° 
```python
b =  1 + 2j
type(b)   # complex 
b.conjugate()   # å…±è½­ 
b.imag()
b.real()              # å®éƒ¨
d, m = divmod(3, 2)    # è¿”å› x/y , x%y

c = bytes(12)   # bytes æ•°æ®ç±»
bytes("ä½ å¥½",encoding="utf-8")
```

åœ¨ python ä¸­, C è¯­è¨€çš„æ•´é™¤(%)é‡‡ç”¨ `//` è¿›è¡Œ,  åŒæ—¶æ¥å— `nan` å’Œ `inf`, å®šä¹‰ 0\*\*0 = 1 ä¾‹å¦‚: 
``` python 
5.2 // 2  #  2
d = float("inf") ;  - d
d = float("nan")
```

```python
math.trunc(x);   # å–æ•´æ•°éƒ¨åˆ†
round(x, n);    # å– n ä½å°æ•°éƒ¨åˆ† 
math.floor  | math.ceil()
```


#### 3) åˆ—è¡¨æ“ä½œå’Œä¸‹æ ‡éå†æŒ‡å®š 
```python
x[i]
x[i:j]
x[i:j:k]   # ä» x å¼€å§‹ æ¯éš” j å–ä¸€ä¸ªå–åˆ° k  
s = ['a','b','c']
# å¸¸è§çš„å‡½æ•°å¦‚ä¸‹: 
s.count('a') 
s.index('b')   # ç¬¬ä¸€ä¸ªä¸‹æ ‡
s.index('b', 1,2)  # åœ¨æŸä¸ªèŒƒå›´å†…çš„ç¬¬ä¸€ä¸ªä¸‹æ ‡
s.append()  #  æ·»åŠ å…ƒç´  
s.extend()   #  ç›´æ¥æ·»åŠ å¸¦æœ‰å…ƒç´ çš„åˆ—è¡¨ 
s.insert(4,'d')   # æ’å…¥å…ƒç´  
s.pop()   | s.pop(e)   # e å¯ä»¥æŒ‡å®šå…ƒç´ 
s.remove(x)
s.reverse()     # å€’åº 
s.clear() 
s.copy()  
sorted(s)   # æ’åº 
```

### (2) Python ä¸­çš„å‡½æ•°å®šä¹‰
#### 1) æŒ‡å®šå‡½æ•°è¾“å…¥å’Œè¿”å›ç±»å‹ 
ä¸ä½¿ç”¨çš„å‚æ•°å¯ä»¥é‡‡ç”¨ _ ä»£æ›¿, å¦‚ `_ = plt.show()` 
åœ¨å‡½æ•°ç¼–å†™æ—¶, å¯ä»¥æŒ‡å®šè¾“å…¥çš„æ ¼å¼ç±»å‹, å…·ä½“æ–¹æ³•å¦‚ä¸‹:
```python 
def set_axis(axes:matplotlib.axes.Axes, xlabel:str, ylabel:str, xlim, ylim, xscale, yscale, legend):  
    axes.set_xlabel(xlabel);    axes.set_ylabel(ylabel)  
    axes.set_title(title);
```

æ–¹æ³•æ˜¯åœ¨ def ååŠ ä¸Š `-> ç±»å‹` æŒ‡å®šè¿”å›ç±»å‹, å¦‚æœæ²¡æœ‰è¿”å›ç±»å‹, åˆ™è®¤ä¸ºæ˜¯ None.
```python
class A:
	def __init__(self) -> None:
		A.name = "wreg"
		pass
	def sum(a:int, b:int) -> int:
		return a + b
```

å¦‚æœæ˜¯è¿”å›å¤šä¸ªæŒ‡å®šç±»å‹çš„å‚æ•°, åˆ™å¯ä»¥ä½¿ç”¨:
```python
def generate_sample(self, W, b) -> tuple [int, int]:
    # ä½ çš„ä»£ç 
    return X, y
```

#### 2) è‡ªå®šä¹‰è¿­ä»£å™¨å’Œè¿­ä»£ç±»å‹
åŸºæœ¬çš„æ–¹æ³•æ˜¯ä½¿ç”¨ yield è¿›è¡Œè¿­ä»£è¿”å›, 
```python
def get_dataloader():
	indics = list(range(0, 100))
	batch_indices =   torch.tensor( indices[i : i + self.batch_size] )  # if batch size = 10,  return the first 10 element at first. 
	yield self.x[batch_indices], self.y[batch_indices]

# ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹:
X,y = next(iter(data.get_dataloader()))
```

```python
iter_dict = iter(dic.items())
next(iter_dict) 
```

#### 3) ç±»ä¸­å‡½æ•°çš„ç§æœ‰åŒ–
åœ¨ Python ä¸­ï¼Œå¯ä»¥é€šè¿‡åœ¨å‡½æ•°åå‰åŠ ä¸ŠåŒä¸‹åˆ’çº¿Â `__`Â æ¥å°†å…¶å®šä¹‰ä¸ºç§æœ‰æ–¹æ³•ã€‚ç§æœ‰æ–¹æ³•åªèƒ½åœ¨ç±»çš„å†…éƒ¨è®¿é—®ï¼Œä¸èƒ½åœ¨ç±»çš„å¤–éƒ¨ç›´æ¥è°ƒç”¨ã€‚


### (3) å¸¸ç”¨çš„å…³é”®å­—
yield å…³é”®å­— : ä½œç”¨æ˜¯ä¿å­˜å½“å‰ç¨‹åºæ‰§è¡ŒçŠ¶æ€, è™½ç„¶å¯ä»¥ç†è§£ä¸º return æ“ä½œ, ä½†æ˜¯yieldæ‰§è¡Œæ—¶è¿˜ä¿å­˜äº†å½“å‰çš„æ‰§è¡Œå†…å®¹, å†ä¸€æ¬¡è°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶ï¼Œä»–ä¼šæ‰¾åˆ°ä½ åœ¨æ­¤å‡½æ•°ä¸­çš„yieldå…³é”®å­—ï¼Œç„¶åä»yieldçš„ä¸‹ä¸€å¥å¼€å§‹æ‰§è¡Œã€‚
```python
def generator():
    for i in range(10):
        yield i * i   # éœ€è¦å•ä¸ªé€ä¸€è¿”å› 
gen = generator()
print(gen)
```

ä¾‹å¦‚è¯»å–å¤§å‹æ–‡æœ¬æ–‡ä»¶çš„æ–¹æ¡ˆ:
```python
with open("file.txt", "rb") as f:
	while(True):
		line = f.readline()
		if  content == "":  # åˆ¤æ–­æ–‡ä»¶æœ«å°¾
			break
		yield content
```

[assert ç”¨æ³•](https://blog.csdn.net/qq_42269354/article/details/89476880) å³åé¢å¸ƒå°”å¿…é¡»ä¸ºçœŸ,å¦‚æœä¸ºå‡åˆ™è§¦å‘å¼‚å¸¸ã€‚

map å‡½æ•°: map æ˜¯ä¸€ä¸ªå†…ç½®å‡½æ•°, ç”¨äºå°†ä¸€ä¸ªå‡½æ•°åº”ç”¨åˆ°å¯è¿­ä»£å¯¹è±¡çš„æ¯ä¸ªå…ƒç´ ä¸Šã€‚å¦‚å›¾æ‰€ç¤º:
```python
def square(x):
    return x * x

numbers = [1, 2, 3, 4, 5]
squared_numbers = map(square, numbers)
print(list(squared_numbers))  # è¾“å‡º: [1, 4, 9, 16, 25]
```

### (4) Collections å®¹å™¨ç±»
collection æä¾›äº†åŒ…æ‹¬åŒç«¯é˜Ÿåˆ—(deque)ç­‰å¤šç§æ•°æ®ç±»å‹
```python
from colloection import namedtuple,deque
```
å‚è€ƒ [python å®˜æ–¹æ–‡æ¡£](https://docs.python.org/3/library/collections.html)

```python
def forward(self, input: Tensor, target: Tensor) -> Tensor: return F.mse_loss(input, target, reduction=self.reduction)	
```

### (5) Python ç»§æ‰¿çš„ä½¿ç”¨
ä¸‹é¢è®²è§£äº†ç»§æ‰¿ torch.nn.Module ç±»çš„æ–¹æ³•, é¦–å…ˆéœ€è¦åœ¨ç±»ååé¢æ‹¬å·åŠ ä¸Šç»§æ‰¿çš„ç±», å¹¶ä¸”ä½¿ç”¨ super() è°ƒç”¨çˆ¶ç±»çš„ \_\_init\_\_()å‡½æ•° 
```python
import torch  
import numpy as np  
import time  
import torch.nn as nn  
from deeplearning_util_functions import plot_figure  
from matplotlib import pyplot as plt  
  
class Regression_Module(nn.Module):   # if class is in bracket, it will inherit this class  
    def __init__(self, learning_rate:float=0.001) :  
        # for the  method inherit from other method: use:  
        super().__init__()  # inherit the  init method of the parent  
  
        self.learning_rate = learning_rate  
        self.wrapper('learning_rate', 0.2)  
        print(self.learning_rate)  
        print(self.cpu())  
        print(torch.cpu.current_device())  
    def wrapper(self, attr:str, value):  
        setattr(self, attr, value)  
        assert hasattr(self, 'learning_rate') # refer to https://blog.csdn.net/qq_42269354/article/details/89476880  
    def __call__(self, *args, **kwargs):  
        print("executing the method")  
  
a = Regression_Module(0.01)   # create a new class  
a()  # call the __call__ method
```

éœ€è¦è¯´æ˜, python å…è®¸å°†ä¸€ä¸ªç±»åƒä¸€ä¸ªå®ä¾‹ä¸€æ ·è°ƒç”¨, å®é™…ä¸Šæ˜¯è°ƒç”¨äº†å…¶ä¸­çš„ `__call__` æ–¹æ³•
```python
assert hasattr(u.name, '__call__')    # åˆ¤æ–­æ˜¯å¦å¯ä»¥è°ƒç”¨
u()   # è°ƒç”¨å…¶ä¸­çš„ __call__ æ–¹æ³•
```

### (6) html å’Œ xml çš„è§£ææ–¹æ³• 
å¸¸è§çš„ html å»é™¤ html æ ‡ç­¾, å¯ä»¥é‡‡ç”¨ lxml åº“
```python
from lxml import etree, html  
  
file_path = "html/UserManual_Bayesian.html"  
  
with open(file_path, 'rb') as fp:  
    contents =  fp.read()  
    text_doc = html.document_fromstring(contents)  # parse the file  
    print(text_doc.text_content())
```

å¦‚æœæ˜¯æå– html ä¸­çš„çº¯æ–‡æœ¬å†…å®¹, åˆ™é‡‡ç”¨ BeautifulSoup
```python
from bs4 import BeautifulSoup
with open("./html/" + file, "rb") as f:  
    contents = f.read()  
    text_content = BeautifulSoup(contents, parser="html.parser", features='lxml').get_text()
```

## äº”ã€os åº“å¸¸ç”¨æ“ä½œ

```python
file_list = os.listdir(dir1)
for path in file_list:
	print(path)

os.path.exists(dir) 
os.makedir(dir) 
```

æ‰§è¡ŒshellæŒ‡ä»¤
```python
import subprocess  
print(subprocess.run("ls /", shell=True).stdout)
```


```python 
import importlib  
import sys  
  
importlib.reload(sys)  
print(sys.getdefaultencoding())
```
## ä¸€ã€Scipy å¸¸ç”¨æ“ä½œ
scipy.stats æ˜¯å¸¸ç”¨çš„æ¦‚ç‡ç»Ÿè®¡çš„åˆ†å¸ƒå‡½æ•°åº“:
```python
from scipy.stats import norm       # æ­£æ€åˆ†å¸ƒ
from scipy.stats import uniform   # å‡åŒ€åˆ†å¸ƒ

norm.cdf(x) # è¿”å›æ­£æ€å¯†åº¦ 
norm.pdf(x) # è¿”å›æ­£æ€åˆ†å¸ƒæ¦‚ç‡å¯†åº¦
uniform.cdf(1)
uniform.pdf(1)
```



## äºŒã€numpy å¸¸ç”¨æ“ä½œ
### 1. çŸ©é˜µæ“ä½œ
é›¶çŸ©é˜µ np.zeros
å•ä½å¯¹è§’çŸ©é˜µ eye
éšæœºçŸ©é˜µ np.random.rand((3,3))
è½¬æ¢åˆ—è¡¨ä¸ºçŸ©é˜µ np.mat 
çŸ©é˜µæ±‚å’Œ np.sum 
æŒ‰å…ƒç´ ä¹˜ç§¯(ä¸€èˆ¬çš„ * æ˜¯æŒ‰çŸ©é˜µåšçŸ©é˜µä¹˜æ³•) np.multiply 
æŒ‰å…ƒç´ æ–½åŠ å‡½æ•° np.ufunc  
å‘é‡ç‚¹ä¹˜(æŒ‰å…ƒç´ ç›¸ä¹˜) np.dot 
å¯¹è§’çŸ©é˜µ np.diag

```python
np.cumsum()  # ç´¯è®¡æ±‚å’Œ  
np.cumpod()  # ç´¯è®¡ä¹˜ç§¯
```

```python
# çŸ©é˜µè½¬ç½® 
m = np.mat([1,2,3,4], dtype=np.float32)  
m.transpose()
m.T # å¾—åˆ°ç»“æœç›¸åŒ
```

æŸä¸ªå‘é‡æˆ–è€…çŸ©é˜µä¸­çš„æœ€å¤§å€¼:
```python
m.max()
```

ç»Ÿè®¡éé›¶å…ƒç´ çš„ä¸ªæ•°: é‡‡ç”¨nonzeroè¿”å›æ•°ç»„æˆ–è€…çŸ©é˜µ**éé›¶å…ƒç´ çš„ä¸‹æ ‡** 
```python
idx_zero = np.nonzero(A)
```
ä¸Šè¿°è¿”å›çš„éƒ¨åˆ†ä¸ºæ‰€æœ‰çš„éé›¶ä¸‹æ ‡, len(idx_zero)ä¸ºéé›¶å…ƒç´ ä¸ªæ•°:
```python
idx_zero = (array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2, 0, 1], dtype=int64))
#  å…¶ä¸­ A[2][2] = 0 , å› æ­¤  idx_zero[0] ä¸º
```

### 2. æ¦‚ç‡è®ºç›¸å…³
å‡å€¼: np.mean 
æ–¹å·®: $\sigma$ = np.std 
å‡æ–¹å·®: np.var () (å®é™…ä¸Šæ˜¯ä¸å¹³å‡å€¼å·®çš„ä¹˜ç§¯) 

è®¡ç®—ä¸¤ä¸ªå‘é‡çš„ç›¸å…³ç³»æ•°:
```python 
x = [1,2,3]
y = [4,5,6]
np.corrcoef(x,y)
```


### 3. np.linalg çº¿æ€§ä»£æ•°åº“
çº¿æ€§ä»£æ•°åº“é›†æˆäº†åŒ…æ‹¬æ±‚è§£è¡Œåˆ—å¼å’ŒçŸ©é˜µæ±‚é€†ç­‰ç­‰å†…å®¹ã€‚
```c
import numpy.linalg as la

la.det(a)  # æ±‚è¡Œåˆ—å¼ 
la.inv(a)   # çŸ©é˜µæ±‚é€†
la.matrix_rank(A) # çŸ©é˜µæ±‚ç§© 
```
æ±‚è§£çŸ©é˜µæ–¹ç¨‹:
$$A x = b$$
```c
A = np.mat([[1,2,3], [4,10,6],[7,3,2]])
b = np.mat([10, 20, 30]).T
la.inv(A) * b 
# ä¹Ÿå¯ä»¥é‡‡ç”¨ä¸‹è¿°æ–¹æ³•æ±‚è§£
la.solve(A,b)
```

å–å‘é‡çš„æ¨¡æˆ–è€…é•¿åº¦, è¿›è¡Œè§„èŒƒåŒ–
```python
la.norm(b)   
la.norm(A)   # ç­‰åŒäº np.sqrt(np.sum(np.multiply(A,A))) 
```

æ±‚è§£**ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡**(æ¦‚å¿µå’Œä¸€èˆ¬å…¬å¼å‚è€ƒ[[ğŸ“˜ClassNotes/ğŸ“Mathmatics/ğŸ“linear algebra/ç¬¬äº”ç«  çŸ©é˜µçš„ç›¸ä¼¼å˜æ¢|çŸ©é˜µçš„ç›¸ä¼¼å˜æ¢]]): é‡‡ç”¨numpy.linalg ä¸­çš„ eig å¯ä»¥ç›´æ¥æ±‚è§£:
```python
import numpy as np  
import numpy.linalg as la
A = np.mat([[8,1,6],[3,5,7],[4,9,2]], dtype=np.float32)  
lmbda, v = la.eig(A)
```



## ä¸‰ã€pandas æ•°æ®åˆ†æå¸¸ç”¨æ“ä½œ
### 1. å–è¡Œæˆ–è€…å–åˆ—
å–æŸå‡ è¡Œæˆ–è€…æŸå‡ åˆ—:
```python
features = data.iloc[0:2]                    # å–æŸå‡ è¡Œ
features = data[data.columns[0:2]]  # å–æŸå‡ åˆ—
features.shape[1]         # è·å–æŸäº›æ–¹å‘ä¸Šçš„å°ºå¯¸
data_tensor = torch.tensor(data.values)  # è½¬æ¢pd.dataframe åˆ° torch.tensor
```


### 2. è½¬æ¢ pandas æ•°æ®åˆ°torchå¼ é‡
åœ¨ torch ä¸­æœ€ä¸ºå¸¸ç”¨çš„æ˜¯ torch.utils.data åŒ…,
```python
from torch.utils.data import dataloader
```
åœ¨ pytorch ä¸­, unsqueeze ç”¨äºå¢åŠ å¼ é‡çš„ç»´æ•°, ä¾‹å¦‚å°†ä¸€ä¸ªä¸€ç»´å¼ é‡è½¬æ¢ä¸ºäºŒç»´, åˆ™ä½¿ç”¨:
```
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it 
```

æœ€ä¸ºç®€å•çš„å°æ‰¹é‡ä¾æ¬¡è¾“å‡ºçš„æ–¹æ³•å¦‚ä¸‹, éœ€è¦æ³¨æ„ `data_tensor = torch.tensor(data.values, dtype=torch.float32) ` å°† DataFrame è½¬æ¢ä¸º float32 æ•°æ®ç±»å‹, å¦‚æœé»˜è®¤, åˆ™æ˜¯double æ•°æ®ç±»å‹ï¼Œä¼šäº§ç”Ÿé—®é¢˜

```python 
import deeplearning_util_functions  
import pandas as pd  
import torch  
from torch.utils.data import DataLoader, TensorDataset  
  
# Boston housing problem  
data = pd.read_csv("../datasheets/housing.csv")  
data_tensor = torch.tensor(data.values, dtype=torch.float32)  # note from 
  
features = data_tensor[:, 0:3]  #  
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it  to keep 2 dims
n = features.shape[0] 

# create the linear regression minibatch stochastic gradient descent  
w = torch.ones(n)  
b = torch.zeros(n)  
  
X = features  
Y = targets  
  
DataLoader1 = DataLoader(torch.cat((X,Y), 1),batch_size=20,shuffle=True)
for minibatch in DataLoader1:  
    print(minibatch)
```

### 3. è¿­ä»£å™¨å¯¹è±¡å’Œnext() å‡½æ•°ç”¨æ³•
`next()` ç”¨äºè¿­ä»£å™¨ä¸­è·å–ä¸‹ä¸€ä¸ªå…ƒç´ , å¦‚æœè¾¾åˆ°æœ«å°¾åˆ™æŠ›å‡º StopIteration å¼‚å¸¸ 
```python 
# è·å–ä¸‹ä¸€ä¸ªå…ƒç´ 
numbers = [1, 2, 3, 4, 5]
numbers_iter = iter(numbers)
print(next(numbers_iter))  # è¾“å‡ºï¼š1
print(next(numbers_iter))  # è¾“å‡ºï¼š2
```

å¦‚æœæ˜¯è¿­ä»£å™¨å¯¹è±¡, åˆ™å¿…é¡»å®ç° `__iter__()` å’Œ `__next__()` ä¸¤ä¸ªæ–¹æ³•
- `__iter__()`æ–¹æ³•ï¼šè¿”å›è¿­ä»£å™¨å¯¹è±¡æœ¬èº«ã€‚
- `__next__()`æ–¹æ³•ï¼šè¿”å›è¿­ä»£å™¨å¯¹è±¡çš„ä¸‹ä¸€ä¸ªæ•°æ®å…ƒç´ ï¼Œå¦‚æœæ²¡æœ‰å…ƒç´ å¯è¿­ä»£ï¼Œåˆ™æŠ›å‡º`StopIteration`å¼‚å¸¸ã€‚ä¾‹å¦‚å®šä¹‰ MyIterator è¿­ä»£å™¨å¯¹è±¡ 
```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        result = self.data[self.index]
        self.index += 1
        return result
numbers = [1, 2, 3, 4, 5] 
my_iter = MyIterator(numbers) 

for num in my_iter:  
	print(num)   # å®é™…ä¸Šæ˜¯ä»next è¿­ä»£å™¨æ–¹æ³•ä¸­è·å–åˆ°çš„numå¯¹è±¡
```

## å››ã€Python å®˜æ–¹åº“ç”¨æ³•æ•´ç†
åˆ—å‡ºæŸä¸ªç›®å½•ä¸‹çš„æ–‡ä»¶ `dir(tensorflow)` 
è·å–encoding å‡½æ•°:
```python 
import importlib  
import sys  
  
importlib.reload(sys)  
print(sys.getdefaultencoding())
```
### (1) printæ ¼å¼æ§åˆ¶å’Œè¿›åˆ¶è½¬æ¢
```python
x = 1
y = 2
print(f'x = {x:.3f}, z = {x+y:.3f}')
```
å…¶ä¸­ç¬¬äºŒä¸ªæ˜¾ç¤º z = 3.00, å³é€šè¿‡string ä¸­çš„ f å®ç°äº†æ ¼å¼æ§åˆ¶;
è¿›åˆ¶è½¬æ¢å¸¸ç”¨å‡½æ•°
```python
bin()
oct()
int()
hex()
```
å½“å…¶ä»–æ•°å­—è½¬æ¢æˆå¦å¤–çš„è¿›åˆ¶æ—¶, åŠ ä¸Š0b,0o, æ— å‰ç¼€, ohå³å¯
int('10110001',2) -> 177,  int(0b10110001)
bin(0xbe) # å¯¹äºä½¿ç”¨å…¶ä»–è¿›åˆ¶

### (2) Python ä¸­çš„å‡½æ•°å®šä¹‰
#### 1)æŒ‡å®šå‡½æ•°è¾“å…¥ç±»å‹
åœ¨å‡½æ•°ç¼–å†™æ—¶, å¯ä»¥æŒ‡å®šè¾“å…¥çš„æ ¼å¼ç±»å‹, å…·ä½“æ–¹æ³•å¦‚ä¸‹:

```python 
def set_axis(axes:matplotlib.axes.Axes, xlabel:str, ylabel:str, xlim, ylim, xscale, yscale, legend):  
    axes.set_xlabel(xlabel);    axes.set_ylabel(ylabel)  
    axes.set_title(title);
```

æ£€æŸ¥æŸä¸ªç±»å¯¹è±¡æ˜¯å¦å…·æœ‰æŸç§å±æ€§: hasattr
```python
hasattr(X, "ndim")
```

æ£€æŸ¥æŸä¸ªå¯¹è±¡æ˜¯å¦æ˜¯æŸä¸ªç±»:isinstance 
```python 
isinstance(X, list)
```

#### 2) æŒ‡å®šå‡½æ•°è¿”å›ç±»å‹
æ–¹æ³•æ˜¯åœ¨ def ååŠ ä¸Š `-> ç±»å‹` æŒ‡å®šè¿”å›ç±»å‹, å¦‚æœæ²¡æœ‰è¿”å›ç±»å‹, åˆ™è®¤ä¸ºæ˜¯ None.
```python
class A:
	def __init__(self) -> None:
		A.name = "wreg"
		pass
	def sum(a:int, b:int) -> int:
		return a + b
```

å¦‚æœæ˜¯è¿”å›å¤šä¸ªæŒ‡å®šç±»å‹çš„å‚æ•°, åˆ™å¯ä»¥ä½¿ç”¨:
```python
def generate_sample(self, W, b) -> tuple [int, int]:
    # ä½ çš„ä»£ç 
    return X, y
```

#### 3) å‡½æ•°ä¸­è‡ªå®šä¹‰è¿­ä»£å™¨çš„æ–¹æ³•
åŸºæœ¬çš„æ–¹æ³•æ˜¯ä½¿ç”¨ yield è¿›è¡Œè¿­ä»£è¿”å›, 
```python
def get_dataloader():
	indics = list(range(0, 100))
	batch_indices =   torch.tensor( indices[i : i + self.batch_size] )  # if batch size = 10,  return the first 10 element at first. 
	yield self.x[batch_indices], self.y[batch_indices]

# ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹:
X,y = next(iter(data.get_dataloader()))
```
### (3) å¸¸ç”¨çš„å…³é”®å­—
yield å…³é”®å­— : ä½œç”¨æ˜¯ä¿å­˜å½“å‰ç¨‹åºæ‰§è¡ŒçŠ¶æ€, è™½ç„¶å¯ä»¥ç†è§£ä¸º return æ“ä½œ, ä½†æ˜¯yieldæ‰§è¡Œæ—¶è¿˜ä¿å­˜äº†å½“å‰çš„æ‰§è¡Œå†…å®¹, å†ä¸€æ¬¡è°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶ï¼Œä»–ä¼šæ‰¾åˆ°ä½ åœ¨æ­¤å‡½æ•°ä¸­çš„yieldå…³é”®å­—ï¼Œç„¶åä»yieldçš„ä¸‹ä¸€å¥å¼€å§‹æ‰§è¡Œã€‚
```python
def generator():
    for i in range(10):
        yield i * i   # éœ€è¦å•ä¸ªé€ä¸€è¿”å› 
gen = generator()
print(gen)
```

ä¾‹å¦‚è¯»å–å¤§å‹æ–‡æœ¬æ–‡ä»¶çš„æ–¹æ¡ˆ:
```python
with open("file.txt", "rb") as f:
	while(True):
		line = f.readline()
		if  content == "":  # åˆ¤æ–­æ–‡ä»¶æœ«å°¾
			break
		yield content
```

[assert ç”¨æ³•](https://blog.csdn.net/qq_42269354/article/details/89476880) å³åé¢å¸ƒå°”å¿…é¡»ä¸ºçœŸ,å¦‚æœä¸ºå‡åˆ™è§¦å‘å¼‚å¸¸ã€‚

map å‡½æ•°: map æ˜¯ä¸€ä¸ªå†…ç½®å‡½æ•°, ç”¨äºå°†ä¸€ä¸ªå‡½æ•°åº”ç”¨åˆ°å¯è¿­ä»£å¯¹è±¡çš„æ¯ä¸ªå…ƒç´ ä¸Šã€‚å¦‚å›¾æ‰€ç¤º:
```python
def square(x):
    return x * x

numbers = [1, 2, 3, 4, 5]
squared_numbers = map(square, numbers)
print(list(squared_numbers))  # è¾“å‡º: [1, 4, 9, 16, 25]
```

### (4) Collections å®¹å™¨ç±»
collection æä¾›äº†åŒ…æ‹¬åŒç«¯é˜Ÿåˆ—(deque)ç­‰å¤šç§æ•°æ®ç±»å‹
```python
from colloection import namedtuple,deque
```
å‚è€ƒ [python å®˜æ–¹æ–‡æ¡£](https://docs.python.org/3/library/collections.html)

```python
def forward(self, input: Tensor, target: Tensor) -> Tensor: return F.mse_loss(input, target, reduction=self.reduction)	
```

### (5) Python ç»§æ‰¿çš„ä½¿ç”¨
ä¸‹é¢è®²è§£äº†ç»§æ‰¿ torch.nn.Module ç±»çš„æ–¹æ³•, é¦–å…ˆéœ€è¦åœ¨ç±»ååé¢æ‹¬å·åŠ ä¸Šç»§æ‰¿çš„ç±», å¹¶ä¸”ä½¿ç”¨ super() è°ƒç”¨çˆ¶ç±»çš„ \_\_init\_\_()å‡½æ•° 
```python
import torch  
import numpy as np  
import time  
import torch.nn as nn  
from deeplearning_util_functions import plot_figure  
from matplotlib import pyplot as plt  
  
class Regression_Module(nn.Module):   # if class is in bracket, it will inherit this class  
    def __init__(self, learning_rate:float=0.001) :  
        # for the  method inherit from other method: use:  
        super().__init__()  # inherit the  init method of the parent  
  
        self.learning_rate = learning_rate  
        self.wrapper('learning_rate', 0.2)  
        print(self.learning_rate)  
        print(self.cpu())  
        print(torch.cpu.current_device())  
    def wrapper(self, attr:str, value):  
        setattr(self, attr, value)  
        assert hasattr(self, 'learning_rate') # refer to https://blog.csdn.net/qq_42269354/article/details/89476880  
    def __call__(self, *args, **kwargs):  
        print("executing the method")  
  
a = Regression_Module(0.01)   # create a new class  
a()  # call the __call__ method
```

éœ€è¦è¯´æ˜, python å…è®¸å°†ä¸€ä¸ªç±»åƒä¸€ä¸ªå®ä¾‹ä¸€æ ·è°ƒç”¨, å®é™…ä¸Šæ˜¯è°ƒç”¨äº†å…¶ä¸­çš„ `__call__` æ–¹æ³•
```python
assert hasattr(u.name, '__call__')    # åˆ¤æ–­æ˜¯å¦å¯ä»¥è°ƒç”¨
u()   # è°ƒç”¨å…¶ä¸­çš„ __call__ æ–¹æ³•
```

### (6) html å’Œ xml çš„è§£ææ–¹æ³• 
å¸¸è§çš„ html å»é™¤ html æ ‡ç­¾, å¯ä»¥é‡‡ç”¨ lxml åº“
```python
from lxml import etree, html  
  
file_path = "html/UserManual_Bayesian.html"  
  
with open(file_path, 'rb') as fp:  
    contents =  fp.read()  
    text_doc = html.document_fromstring(contents)  # parse the file  
    print(text_doc.text_content())
```

## äº”ã€re å’Œ os åº“å¸¸ç”¨æ“ä½œ

```python
file_list = os.listdir(dir1)
for path in file_list:
	print(path)

os.path.exists(dir) 
os.makedir(dir) 
```




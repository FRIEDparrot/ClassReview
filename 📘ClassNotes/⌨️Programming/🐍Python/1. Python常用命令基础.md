## 一、Scipy 常用操作
scipy.stats 是常用的概率统计的分布函数库:
```python
from scipy.stats import norm       # 正态分布
from scipy.stats import uniform   # 均匀分布

norm.cdf(x) # 返回正态密度 
norm.pdf(x) # 返回正态分布概率密度
uniform.cdf(1)
uniform.pdf(1)
```



## 二、numpy 常用操作
### 1. 矩阵操作
零矩阵 np.zeros
单位对角矩阵 eye
随机矩阵 np.random.rand((3,3))
转换列表为矩阵 np.mat 
矩阵求和 np.sum 
按元素乘积(一般的 * 是按矩阵做矩阵乘法) np.multiply 
按元素施加函数 np.ufunc  
向量点乘(按元素相乘) np.dot 
对角矩阵 np.diag

```python
np.cumsum()  # 累计求和  
np.cumpod()  # 累计乘积
```

```python
# 矩阵转置 
m = np.mat([1,2,3,4], dtype=np.float32)  
m.transpose()
m.T # 得到结果相同
```

某个向量或者矩阵中的最大值:
```python
m.max()
```

统计非零元素的个数: 采用nonzero返回数组或者矩阵**非零元素的下标** 
```python
idx_zero = np.nonzero(A)
```
上述返回的部分为所有的非零下标, len(idx_zero)为非零元素个数:
```python
idx_zero = (array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2, 0, 1], dtype=int64))
#  其中 A[2][2] = 0 , 因此  idx_zero[0] 为
```

### 2. 概率论相关
均值: np.mean 
方差: $\sigma$ = np.std 
均方差: np.var () (实际上是与平均值差的乘积) 

计算两个向量的相关系数:
```python 
x = [1,2,3]
y = [4,5,6]
np.corrcoef(x,y)
```


### 3. np.linalg 线性代数库
线性代数库集成了包括求解行列式和矩阵求逆等等内容。
```c
import numpy.linalg as la

la.det(a)  # 求行列式 
la.inv(a)   # 矩阵求逆
la.matrix_rank(A) # 矩阵求秩 
```
求解矩阵方程:
$$A x = b$$
```c
A = np.mat([[1,2,3], [4,10,6],[7,3,2]])
b = np.mat([10, 20, 30]).T
la.inv(A) * b 
# 也可以采用下述方法求解
la.solve(A,b)
```

取向量的模或者长度, 进行规范化
```python
la.norm(b)   
la.norm(A)   # 等同于 np.sqrt(np.sum(np.multiply(A,A))) 
```

求解**特征值和特征向量**(概念和一般公式参考[[📘ClassNotes/📐Mathmatics/📏linear algebra/第五章 矩阵的相似变换|矩阵的相似变换]]): 采用numpy.linalg 中的 eig 可以直接求解:
```python
import numpy as np  
import numpy.linalg as la
A = np.mat([[8,1,6],[3,5,7],[4,9,2]], dtype=np.float32)  
lmbda, v = la.eig(A)
```



## 三、pandas 数据分析常用操作
### 1. 取行或者取列
取某几行或者某几列:
```python
features = data.iloc[0:2]                    # 取某几行
features = data[data.columns[0:2]]  # 取某几列
features.shape[1]         # 获取某些方向上的尺寸
data_tensor = torch.tensor(data.values)  # 转换pd.dataframe 到 torch.tensor
```


### 2. 转换 pandas 数据到torch张量
在 torch 中最为常用的是 torch.utils.data 包,
```python
from torch.utils.data import dataloader
```
在 pytorch 中, unsqueeze 用于增加张量的维数, 例如将一个一维张量转换为二维, 则使用:
```
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it 
```

最为简单的小批量依次输出的方法如下, 需要注意 `data_tensor = torch.tensor(data.values, dtype=torch.float32) ` 将 DataFrame 转换为 float32 数据类型, 如果默认, 则是double 数据类型，会产生问题

```python 
import deeplearning_util_functions  
import pandas as pd  
import torch  
from torch.utils.data import DataLoader, TensorDataset  
  
# Boston housing problem  
data = pd.read_csv("../datasheets/housing.csv")  
data_tensor = torch.tensor(data.values, dtype=torch.float32)  # note from 
  
features = data_tensor[:, 0:3]  #  
targets  = data_tensor[:,3].unsqueeze(1)   # add a dimension to it  to keep 2 dims
n = features.shape[0] 

# create the linear regression minibatch stochastic gradient descent  
w = torch.ones(n)  
b = torch.zeros(n)  
  
X = features  
Y = targets  
  
DataLoader1 = DataLoader(torch.cat((X,Y), 1),batch_size=20,shuffle=True)
for minibatch in DataLoader1:  
    print(minibatch)
```

### 3. 迭代器对象和next() 函数用法
`next()` 用于迭代器中获取下一个元素, 如果达到末尾则抛出 StopIteration 异常 
```python 
# 获取下一个元素
numbers = [1, 2, 3, 4, 5]
numbers_iter = iter(numbers)
print(next(numbers_iter))  # 输出：1
print(next(numbers_iter))  # 输出：2
```

如果是迭代器对象, 则必须实现 `__iter__()` 和 `__next__()` 两个方法
- `__iter__()`方法：返回迭代器对象本身。
- `__next__()`方法：返回迭代器对象的下一个数据元素，如果没有元素可迭代，则抛出`StopIteration`异常。例如定义 MyIterator 迭代器对象 
```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        result = self.data[self.index]
        self.index += 1
        return result
numbers = [1, 2, 3, 4, 5] 
my_iter = MyIterator(numbers) 

for num in my_iter:  
	print(num)   # 实际上是从next 迭代器方法中获取到的num对象
```

## 四、Python 官方库用法整理
列出某个目录下的文件 `dir(tensorflow)` 
获取encoding 函数:
```python 
import importlib  
import sys  
  
importlib.reload(sys)  
print(sys.getdefaultencoding())
```
### (1) print格式控制和进制转换
```python
x = 1
y = 2
print(f'x = {x:.3f}, z = {x+y:.3f}')
```
其中第二个显示 z = 3.00, 即通过string 中的 f 实现了格式控制;
进制转换常用函数
```python
bin()
oct()
int()
hex()
```
当其他数字转换成另外的进制时, 加上0b,0o, 无前缀, oh即可
int('10110001',2) -> 177,  int(0b10110001)
bin(0xbe) # 对于使用其他进制

### (2) Python 中的函数定义
#### 1)指定函数输入类型
在函数编写时, 可以指定输入的格式类型, 具体方法如下:

```python 
def set_axis(axes:matplotlib.axes.Axes, xlabel:str, ylabel:str, xlim, ylim, xscale, yscale, legend):  
    axes.set_xlabel(xlabel);    axes.set_ylabel(ylabel)  
    axes.set_title(title);
```

检查某个类对象是否具有某种属性: hasattr
```python
hasattr(X, "ndim")
```

检查某个对象是否是某个类:isinstance 
```python 
isinstance(X, list)
```

#### 2) 指定函数返回类型
方法是在 def 后加上 `-> 类型` 指定返回类型, 如果没有返回类型, 则认为是 None.
```python
class A:
	def __init__(self) -> None:
		A.name = "wreg"
		pass
	def sum(a:int, b:int) -> int:
		return a + b
```

如果是返回多个指定类型的参数, 则可以使用:
```python
def generate_sample(self, W, b) -> tuple [int, int]:
    # 你的代码
    return X, y
```

#### 3) 函数中自定义迭代器的方法
基本的方法是使用 yield 进行迭代返回, 
```python
def get_dataloader():
	indics = list(range(0, 100))
	batch_indices =   torch.tensor( indices[i : i + self.batch_size] )  # if batch size = 10,  return the first 10 element at first. 
	yield self.x[batch_indices], self.y[batch_indices]

# 使用方法如下:
X,y = next(iter(data.get_dataloader()))
```
### (3) 常用的关键字
yield 关键字 : 作用是保存当前程序执行状态, 虽然可以理解为 return 操作, 但是yield执行时还保存了当前的执行内容, 再一次调用这个函数时，他会找到你在此函数中的yield关键字，然后从yield的下一句开始执行。
```python
def generator():
    for i in range(10):
        yield i * i   # 需要单个逐一返回 
gen = generator()
print(gen)
```

例如读取大型文本文件的方案:
```python
with open("file.txt", "rb") as f:
	while(True):
		line = f.readline()
		if  content == "":  # 判断文件末尾
			break
		yield content
```

[assert 用法](https://blog.csdn.net/qq_42269354/article/details/89476880) 即后面布尔必须为真,如果为假则触发异常。

map 函数: map 是一个内置函数, 用于将一个函数应用到可迭代对象的每个元素上。如图所示:
```python
def square(x):
    return x * x

numbers = [1, 2, 3, 4, 5]
squared_numbers = map(square, numbers)
print(list(squared_numbers))  # 输出: [1, 4, 9, 16, 25]
```

### (4) Collections 容器类
collection 提供了包括双端队列(deque)等多种数据类型
```python
from colloection import namedtuple,deque
```
参考 [python 官方文档](https://docs.python.org/3/library/collections.html)

```python
def forward(self, input: Tensor, target: Tensor) -> Tensor: return F.mse_loss(input, target, reduction=self.reduction)	
```

### (5) Python 继承的使用
下面讲解了继承 torch.nn.Module 类的方法, 首先需要在类名后面括号加上继承的类, 并且使用 super() 调用父类的 \_\_init\_\_()函数 
```python
import torch  
import numpy as np  
import time  
import torch.nn as nn  
from deeplearning_util_functions import plot_figure  
from matplotlib import pyplot as plt  
  
class Regression_Module(nn.Module):   # if class is in bracket, it will inherit this class  
    def __init__(self, learning_rate:float=0.001) :  
        # for the  method inherit from other method: use:  
        super().__init__()  # inherit the  init method of the parent  
  
        self.learning_rate = learning_rate  
        self.wrapper('learning_rate', 0.2)  
        print(self.learning_rate)  
        print(self.cpu())  
        print(torch.cpu.current_device())  
    def wrapper(self, attr:str, value):  
        setattr(self, attr, value)  
        assert hasattr(self, 'learning_rate') # refer to https://blog.csdn.net/qq_42269354/article/details/89476880  
    def __call__(self, *args, **kwargs):  
        print("executing the method")  
  
a = Regression_Module(0.01)   # create a new class  
a()  # call the __call__ method
```

需要说明, python 允许将一个类像一个实例一样调用, 实际上是调用了其中的 `__call__` 方法
```python
assert hasattr(u.name, '__call__')    # 判断是否可以调用
u()   # 调用其中的 __call__ 方法
```

### (6) html 和 xml 的解析方法 
常见的 html 去除 html 标签, 可以采用 lxml 库
```python
from lxml import etree, html  
  
file_path = "html/UserManual_Bayesian.html"  
  
with open(file_path, 'rb') as fp:  
    contents =  fp.read()  
    text_doc = html.document_fromstring(contents)  # parse the file  
    print(text_doc.text_content())
```

## 五、re 和 os 库常用操作

```python
file_list = os.listdir(dir1)
for path in file_list:
	print(path)

os.path.exists(dir) 
os.makedir(dir) 
```




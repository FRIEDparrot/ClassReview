# 聊聊汇编

我最近才发现，我之前的学习大部分时间都在`忙学`，什么意思呢？这知识它就是不进脑子里儿阿。

造成此种现象的原因我分析了一下：

* 假装学习，其实我根本没有在学习，我只是给人一种"我在学习"的假象，其实真正的思绪早就跑到天涯海北去了，最终到头来只能感动自己，浪费了时间，还误以为自己能有所提高。然后重新看一遍发现仍旧什么都不会，使自己变的烦躁并且否定自己。
* 学习效率低，在学到某一章节的时候明明字自己都认识，但是连起来读就是不明白，造成这种现象的原因一般有，**没有理解相关的前置知识**，这是很重要的一点，也是在学习的路径上大家需要特别注意的一点，如果你觉得读起来很费劲，那么你一定是相关前置知识没有理解，也就是知识储备量不够，你需要"回炉重造"。还有一个原因是不做相关的练习，**知识没有落地的实践，那么它终究不是你的东西**，最近的我深刻认识到了这一点。
* 经常性的遗忘，这个没有好办法，随着年龄的不断增长，接收和容纳新知识的速度会越来越慢，所以知识需要不断回顾，要对你的大脑形成长久且循环的刺激，而且刺激的频率一定要很高，你的大脑才会接受它！

* 学习时间太长，我发现我最近只要是在高效学习的情况下，一般一个小时就到达阈值了，什么意思呢？就是学了一个小时后，再接纳新知识就会变的很慢，我目前还不清楚这是我个人原因还是如何。所以在专注过后，一定需要喝杯水或者在家里溜达一下放松放松才可，这个情况不管是在凌晨，还是白天以及晚上都是这样。

本人最近的学习重心还是放在了计算机基础理论知识上的学习，这个东西好像泥潭一样，暂时抽不出来身了，因为随着知识的不断积累和扩展，我发现自己的知识库存仍旧异常渺小，前方就好似 `DOS` 提示符一样，**异常简单，却异常深邃**。

但是不管再怎么深邃，计算机总是围绕着一个主轴马达在驱动，对于各种包括但不限于的 C、Java 等语言来说，汇编就是它的底层，学了汇编之后，你会明白很多东西，比如最基础的赋值语句、算数运算语句，程序调用是如何实现的，各种逻辑控制语句之 do ... while 、while 、for 、switch 是咋搞的，指针是啥东西等等。万变不离其宗说的就是这个意思。

这里面一个最需要打基础的一本书就是王爽的《汇编语言》，基于 intel x86 汇编来写的，这里面只是列出了一些比较常用的指令来进行介绍，实际上 x86 架构汇编指令还有很多。如果仅限于学习的话，这本书足够支撑你往底层继续学习的信心和储备了。

然后我就满怀信心的去看哈工大李治军老师讲的 OS 了，前几集看的还是很顺利，因为涉及的都是一些操作系统基础知识，这些我还是很 OK 的，毕竟当时咱也是把 《现代操作系统》都撸过一遍并且把文章写出来的 boy ，但是后面涉及到 bootsect.s 、setup.s 、head.s 的时候，我就有点懵逼了，怎么这个汇编跟我学的汇编总是有那么一点不一样呢？你说 mov 指令把它也是 mov ，但怎么就，就 。。。。。！@#￥%我这汇编学了个寂寞吗？

后来才知道，李治军老师讲的这个 OS 其实大部分都是基于《Linux 内核完全注释》这本书，我转念一想，那我可以把这本书看完了再通过视频巩固一下对不对？

说时迟那时快，我赶紧下了个 PDF 版本开始看起来，赵炯博士写的这本书可真是让人大开眼界！

原来汇编也分为很多种

* AT&T 汇编
* intel 汇编
* 嵌入式汇编
* 。。。。。。

王爽老师的那本《汇编语言》是基于 intel 的 x86 汇编来写成的，而 Linus 写的 Linux 内核是基于 AT&T 汇编写的，这两种语法格式很不一样，有如下这些区别：

* AT&T 语法中立即数前面要加 `$` 符号；寄存器名称前面要加 `%` 符号，绝对跳转调用操作数前要加 `*` 号，而 Intel 语法则没有这些限制。

```assembly
# AT&T
movl $0x4050,%eax
movb $-17,(%rsp)
jmp *.L4(,%rdi,8)

# intel x86
mov ax,12
mov bx,ax
jmp short s
```

* AT&T 语法与 Intel 语法的所使用的源和目的操作数是相反的，AT&T 的源和目的操作数是从左到右为 **源,目的**，例如 intel 语句 add eax,4 ，对应 AT&T 的 addl $4, %eax。
* AT&T 语法中操作数的长度由最后一位操作码来决定，比如 movb、movw、movl 分别表示传输 1 个字节、两个字节、四个字节，而 intel 使用的是 byte ptr、word ptr、dword ptr 来分别表示。
* AT&T 和 intel 的跳转和返回指令也不一样。
* AT&T 不提供对多代码段程序的支持，UNIX 类操作系统要求所有的代码都在一个段中。

对于早期的 Linux 内核来说，虽然使用的汇编是 AT&T ，但是它的编译方式有两种，一种是由 `as86` 汇编器汇编，一种是由 `Gun as`汇编器汇编，不过 as86 汇编器只用于编译 Linux 内核中的 boot/bootsect.s 和实模式下的设置程序 boot/setup.s ，内核其他的汇编器均由 Gun as 来完成。

AT&T 汇编语言还用在了《csapp》这本书中，现在看来，csapp 的难以程度相较于 Linux 内核来说，还是小多了。如果你有一点 C 语言基础并且把王爽老师的《汇编语言》看完的话，慢慢研究《csapp》问题不大，至少我就是这么做的。

如果想要看懂赵炯博士《Linux 内核完全注释》的话，需要有下面这些知识作为基础：

1. 基本的 C 语言和 Intel CPU 汇编语言知识，C 语言直接看写 C 语言的大佬丹尼斯里奇写的 《􏽵The C Programming Language􏽶》，Intel CPU 汇编知识直接看王爽老师写的 《汇编语言》即可，MASM 就是用的 intel 汇编。
2. 一些嵌入式汇编语言的知识，可以参考 GUN gcc 编译器手册。
3. 需要 x86 处理器结构和编程的相关资料，看 intel 的《INTEL 80386 PROGRAMMER'S REFERENCE MANUAL》
4. 一些 UNIX 内核的基本了解，可以看看 M.J.Bach 的 《UNIX 操作系统设计》。
5. 操作系统的相关前置知识，由于 Linux 是基于 MINIX 来写的，所以可以看看 Tanenbaum 的 《操作系统：设计与实现》。

嗯。。。。。。最近还是要按照自己的这个路线走了，学计算机就是挺头秃的。
## 一、时变可靠性的定义
### (1) 可靠性与可靠域定义
时变结构的功能函数一般有以下三种参数，基本形式如下:
$$Z(t) = g(X, Y(t), t)$$
其中$X$是随机变量， Y为随机过程, t为时间。可能不含其中Y或者t函数, 但是Y,t至少含有其一。

对于时变可靠性问题中, 我们考虑$[t_0, t_s]$之内的情况, 对于其中任意给定的时刻$t^{*}$如果有$Z(t^{*}) \leq  0$， 则认为结构是失效的。其失效域和安全域可以表示为:
$$F = \left\{ Z(t) \leq  0 , \exists  t \in  [t_{0}, t_{s}] \right\}\tag{10.1.1.1}$$
$$S= \left\{ Z (t) > 0, \forall  t \in [t_{0}, t_{s}] \right\}\tag{10.1.1.2}$$
### (2) EOLE模型展开方法概述
我们使用EOLE (Expansion Optimial Linear Estimation)模型进行展开, 其展开过程为:
首先, 取步长为$\frac{t_{s} - t_{0}}{N}$, 展开式为:
$$\Large \boxed{Y_{j}(t) = \mu_{Y_{j}}+ \sigma_{Y_{j}}^{2}  \sum^{r}_{k=1} \frac{\xi_{jk}}{\sqrt{\lambda_{jk}} } \varphi_{jk}^{T} \rho_{Y_{j}}(t)}$$
其中, 右侧 $k = 1,2, ... r$, 记**所有的随机过程共有m个**, 对应的<mark style="background: transparent; color: red">标准正态向量</mark>分别为$\xi = (\xi_{1}^{T}, \xi_{2}^{T}, \dots \xi_{m}^{T})$，r 为<mark style="background: transparent; color: red">随机展开过程中的截断阶数</mark>，我们在实际截断时，取随机过程Y协方差矩阵的特征值为$\lambda_{jk}$,其中取大的r个截断为 $\lambda_{j1}, \lambda_{j2},\dots \lambda_{jr}$, 而对应的 $\xi$ 和 $\rho_{Y}$ 也做相应的截断。

其中 $\rho_{Y_{j}} (t) = \left(\rho_{Y_{j}} (t, t_{0}), \rho_{Y_{j}} (t, t_{1}), \dots  \rho_{Y_{j}} (t, t_{N}) \right)$为相关系数向量。$\xi$ 为独立正态随机变量, 且**基于 $Y_j(t)$展开对应的独立标准正态向量**为 $\xi_{j} =  (\xi_{j1},  \xi_{j2}, \dots  \xi_{jr})^{T}$(列向量), 而我们可以将所有的m个随机过程中的列向量排成矩阵， 则变为:
$$\xi = (\xi_{1}, \xi_{2}, \dots  \xi_{m})$$


### (3) 时变可靠性分析的MCS方法
首先， 根据x的概率密度, 产生**样本矩阵S**, 其中S的第i行代表时间为$i$的样本;
$$x = \left[\begin{matrix}
\vec{x}_{1}   \\  \vec{x}_{2}  \\  \vdots   \\  \vec{x}_{N}
\end{matrix}\right] \qquad   t = \left[\begin{matrix}
t_{1}  \\  t_{2} \\  \vdots   \\  t_{n}
\end{matrix}\right]$$
定义矩阵$B$, 其中由$S$矩阵的第i行和离散时刻向量T组成, 即`B(i,:) = [xp(i,:), t(i,:) ]`,   代入矩阵B的每一行，计算是否失效。
时变可靠性的失效概率计算和方差计算仍然与传统的相同
$$P_{f} (t_{0}, t_{s})=  \frac{\sum^{n}_{i=1}I_{F} (x_{i})}{N}$$
$$\text{cov} (P_{f}(t_{0}, t_{s})) = \sqrt{\frac{1 - P_{f}}{(N-1 ) P_{f}}}$$
显然我们需要双层循环调用 $N * N_t$ 次模型求解问题, 但是，由于时变中每一次的 $x_i$都应该是相同的, 所以抽样次数仅为num_MCS，而调用模型次数为num_MCS * length(t); 
```matlab fold title:MCS方法求解示例代码
%% %%%%%%%%%%%%%% 时变功能函数的MCS求解 %%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%% 考虑以下的时变功能函数, 时间观察域 0:5 %%%%%%%%
clear, clc;
% t = (0:0.01:5);
% mu_ = [3.5, 3.5];    sigma_d = [0.3, 0.3]; sigma_ = diag(sigma_d.^2);
% g = @(x, t) x(:,1).^2 .* x(:,2) - 5 .* x(:,1) .* t + (x(:,2) + 1) .* t.^2 - 20;

%% %%%%%%%%%% 四连杆机构的可靠性分析 %%%%%%%%%%%%%%%%%%%%%%%%%%%
mu_ = [53, 122, 66.5,  100]; sigma_d = [0.1, 0.1, 0.1, 0.1]; sigma_ = diag(sigma_d.^2);

t = deg2rad(95.5:0.6:155.5);
D = @(x,t) -2 .* x(:,1) .* x(:,3) .*sin(t);
E = @(x,t) 2 * x(:,3) .*((x(:,4) - x(:,1) .* cos(t)));
F = @(x,t) x(:,2).^2 - x(:,1).^2 - x(:,3).^2 - x(:,4).^2 + 2 .* x(:,1) .* x(:,4) .* cos(t);
g = @(x,t) deg2rad(0.8) - abs((deg2rad(76) + deg2rad(60) .* sin(3./4.* (t - deg2rad(95.5))) -2.* atan((D(x,t) + sqrt(D(x,t).^2 + E(x,t).^2 - F(x,t).^2))./(E(x,t)+ F(x,t)))));

num_MCS = 2^16;
pf = time_MCS(mu_, sigma_, g, t, num_MCS);

function Pf = time_MCS(mu_, sigma_, g, t, num_MCS)
    if (size(t, 1) == 1)
        t_new = t';
    end
	xp = lhsnorm(mu_, sigma_, num_MCS , "on");
	If = zeros(num_MCS, 1);
	for i = 1:num_MCS
		yp = g(xp(i,:), t_new);  % 投影到整个t部分
		if ~isempty(find(yp < 0, 1))
			If(i,:) = 1;
		end
		if mod(i, 100) == 0
			sprintf("epoch: %d", i)
		end
	end
	Pf = sum(If) ./ num_MCS;
end
```

## 二、时变可靠性分析的跨越率方法
### (1) 跨越率方法求解时变可靠性原理
考虑(10.1.1.1), 得到:
$$P_{f}(t_{0}, t_{s}) = P\left\{\{ g(X, t_{0})\leq 0\} \cup  \{ N^{+}(t_{0}, t_{s}) > 0\}   \right\}$$
其中$\{ g(X, t_{0})\leq 0\}$表示初始时刻失效,而$\{ N^{+}(t_{0}, t_{s}) > 0\}$表示跨越次数。即跨越次数范围内不能有失效点存在, 即<b><mark style="background: transparent; color: blue">之后的跨越次数只能为0</mark></b>。
参考[[📘ClassNotes/👨‍🔧Mechanics/🖥️Computational_Mechanics/✈️航空发动机可靠性分析/推导部分/跨越率方法有关定理推导过程.pdf|跨越率方法有关定理推导过程.pdf]], 有不等式:
$$\max P_{f}(\tau, \tau)\leq P_{f}(t_{0}, t_{0}) + P \{ N^{+}(t_{0}, t_{s}) > 0\} $$
此时定义跨越率为:
$$\Large \boxed{\nu^{+} (\tau) = \lim_{\Delta  \tau\rightarrow 0,\Delta \tau > 0} \frac{P\left\{ N^{+}(\tau, \tau + \Delta  \tau = 1) \right\}}{\Delta \tau}}$$
我们假设跨越次数服从[[📘ClassNotes/📐Mathmatics/🎣Probability Theory/第二章 随机变量及其分布#3. 泊松分布|泊松分布]], 参考[[📘ClassNotes/👨‍🔧Mechanics/🖥️Computational_Mechanics/✈️航空发动机可靠性分析/推导部分/跨越率方法有关定理推导过程.pdf|跨越率方法有关定理推导过程.pdf]], 时变失效概率的计算表达式可以计算为:
$$P_{f}(t_{0}, t_{s}) = 1- R(t_{0}, t_{s}) =  1 - (1 - P_{f}(t_{0}, t_{0}) \exp \left[-  \int_{t_{0}}^{t_{s}} \nu^{+} (\tau) dt \right])$$
需要说明的是，**实际编程中，$\nu^{+}(\tau)$ 是未知的。其求解是跨越率法的关键步骤**， 往往使用MCS方法或者直接方法求解。

### (2) 求解跨越率的直接方法
基本思路如下:
1. 首先， 根据时不变一次可靠性分析方法求解时刻 $\tau$ 和 $\tau + \Delta  \tau$ 对应的可靠度指标并记为$\beta (\tau)$, 此时, $-\beta(\tau)$ 是 $\left\{ g(X,\tau) > 0 \right\}$的可靠度指标, 而$\beta(\tau + \Delta  \tau)$是$\left\{ g(X, \tau + \Delta \tau)\leq  0\right\}$的指标。
2. 计算$g(X, \tau)$与$g(X, \tau + \Delta \tau)$的相关系数$\rho (\tau, \tau + \Delta \tau)$, 并可以计算为:
$$\rho_{G} (\tau, \tau + \Delta  \tau) = - \alpha(\tau) \alpha(\tau + \Delta \tau)$$
其中, $\alpha(\tau) = \frac{U^*(\tau)}{\beta(\tau)}$, 并有$\alpha(\tau+\Delta \tau) = \frac{U^{*}(\tau + \Delta \tau)}{\beta(\tau + \Delta \tau)}$ 分别为<b><mark style="background: transparent; color: blue">标准正态空间中</mark></b>**坐标原点指向设计点的单位方向向量**, 其中$U$为标准正态空间设计点向量, **而$\beta$是相应标准正态设计点与原点的距离** 
> [!caution] 说明
> 在用AFSOM求解出设计点之后, 需要**投影到标准正态空间**(x- mu)/sigma，然后再进行后面的求解

![[Excalidraw/第十章 时变可靠性分析的方法 2024-04-18 12.35.02|300]]
此时,可以使用下面的表达式求解$v^+(\tau)$:
$$\large\boxed{v^{+} (\tau) =   \frac{\Phi_{2}(\beta(\tau), - \beta(\tau + \Delta  \tau)   \quad ;\quad   \rho_{G} (\tau, \tau+ \Delta  \tau ))}{\Delta  \tau}}$$
其中$\Phi_{2}$为**二元正态累计分布函数**,其中上式表达为$\tau + \Delta\tau \geq 0$的与$\tau$时小于0的面分别的可靠度指标分布, **实际上是以(0,0)为均值, 以$\rho_G$为协方差在$\beta(\tau), - \beta(\tau + \Delta \tau)$处计算出的二元正态分布值**，其中, 协防差矩阵是
$$R = \left[\begin{matrix}
1 & \rho_{G}   \\   \rho_{G} & 1
\end{matrix}\right]\qquad  \rho_{G} =  - \cos (\alpha_{1}, \alpha_{2}) \approx -1$$
由于两个$\alpha$相互接近, 显然获得的是一个比较接近于-1的值。

`````ad-note
title: 补充: 多元正态累计分布函数和密度函数
collapse: close 
参考[en.wikipedia.org/wiki/Multivariate_normal_distribution](https://en.wikipedia.org/wiki/Multivariate_normal_distribution), 得到多元正态累计分布函数图像， 而在MATLAB中只需使用`mvncdf`即可求解对应的分布密度。
![[attachments/Pasted image 20240419150722.png]]
一个常用的示例如下:
```matlab 
mu = [1 -1];   Sigma = [.9 .4; .4 .3];  %指定均值和方差矩阵
[X1,X2] = meshgrid(linspace(-1,3,25)',linspace(-3,1,25)');   % X1,X2均为 25 * 25 矩阵
X = [X1(:), X2(:)];   % 需要注意的是这个索引, 这个是将X1,X2排成列向量然后拼接成625 * 2 的列向量
p = mvncdf(X,mu,Sigma);
Z = reshape(p,25,25);
surf(X1,X2,Z)
```
`````

一个示例代码如下:
```matlab title:使用跨越率方法计算时变失效概率与可靠性
clear, clc;
t = (0:0.1:5)';
mu_ = [3.5, 3.5]; sigma_d = [0.3, 0.3]; sigma_ = diag(sigma_d.^2);
g = @(x, t) x(:,1).^2 .* x(:,2) - 5 .* x(:,1) .* t + (x(:,2) + 1) .* t.^2 - 20; 

% 先计算初始的beta0的值
x0 = (AFOSM_solu(mu_, sigma_, @(x)g(x, 0)) - mu_)./sigma_d;
beta0 = sqrt(sum(x0 .* x0, 2));

cross_rate = zeros(length(t) -1, 1);  % 跨越率
for i = 1:length(t) - 1
	% 使用AFOSM方法求解两个相邻的t点对应的设计点 
	x_i1 = AFOSM_solu(mu_, sigma_, @(x)g(x, t(i)));
	x_i2 = AFOSM_solu(mu_, sigma_, @(x)g(x, t(i+1)));
    
	% 先将设计点以mu为中心进行规范化
    x_new1 = (x_i1 - mu_)./ sigma_d;
    x_new2 = (x_i2 - mu_)./ sigma_d;

    beta_   = [sqrt(sum(x_new1.^2, 2)), sqrt(sum(x_new2.^2, 2))]; % 计算长度
    alpha_  = [x_new1 ./ beta_(1); x_new2./beta_(2)];              % 计算单位化向量
	
    rho = -sum(alpha_(1,:) .* alpha_(2,:), 2);  % 使用两个向量点乘负值作为相关系数
    R = [1,rho;rho,1]; % 协方差矩阵
	cross_rate(i) = mvncdf([beta_(1), - beta_(2)],[0, 0], R);
end
Pf = 1 - (1-normcdf(-beta0)).* exp(-sum(cross_rate).* 0.1);
```

## 三、时变可靠性分析的极值方法
### (1) 极值方法求解时变可靠性的原理
对于时变问题，功能函数中的$Z(t) = g(X,t)$可以看成概率空间中的$R^n$下的随机变量$X$和时间观察域$t = [t_0, t_s]$中的参数$t$的一个多元函数。
此时, 输入变量$X \in R^{n}$,**固定在某个实现值$x^*$时**, $Z(t) = g(x^{*}, t)$ 为关于时间的一元函数。并将此函数称为功能$Z(t) = g(x^*, t)$的样本函数。显然$\min g(x^{*}, t) < 0$则结构失效。

时变失效域的表达式为:
$$F = \left\{\min_{t \in [t_{0}, t_{s}]} g(X, t) \leq 0 \right\}$$
此时，时间区间$[t_0,t_s]$内, 时变失效概率 $P_{f}$ 可以表示为下式:
$$\boxed {P_{f}(t_{0}, t_{s}) = P\{ F\} =P\left\{\min_{t \in [t_{0}, t_{s}]} g(X, t) \leq 0 \right\}\tag{10.3.1.1}}$$
因此只需求解时变功能函数g(x,t)关于t的极小值, **即可将时变可靠性分析问题转化为时不变可靠性问题**。上式即为<mark style="background: transparent; color: red">时变可靠性分析的极值法</mark>。

往往先通过共轭梯度法， 最速下降法或者[[📘ClassNotes/⌨️Programming/👨‍🎓Deep Learning/🌟深度学习优化算法合集/2. 遗传优化算法(GA)|遗传算法]]，[[📘ClassNotes/⌨️Programming/👨‍🎓Deep Learning/🌟深度学习优化算法合集/1. 模拟退火算法(SA)|模拟退火算法]]等等求解**时域上的最小值**;只需通过求解极小值点和取其中最小的点获取即可。

**实际上, 对于极值MCS方法，只是将每一组样本判断时间观察域上极值与0的关系, 与MCS方法完全相同**, 而且还多了步骤， 因此直接使用前面讲的MCS方法代码进行替代即可。

### (2) 时变可靠性分析的包络函数方法
首先，考虑不包含随机过程的时变问题, 则时变功能函数为:
$$Z(t) = g(X,t), \qquad t \in  [t_{0}, t_{s}]$$
对于$Z(t)$的包络面可以使用如下的方程进行获取，而<b><mark style="background: transparent; color: blue">时变失效概率也等效转换为时不变失效概率</mark></b>:
$$\Large G(x) =  \begin{cases}
g(x,t) = 0 \\ 
\frac{\partial g(x,t)}{\partial t} = 0
\end{cases}$$
即 G(x) < 0 对应的概率即为时变失效概率;

取时间观察域内的功能函数g(x,t), 其在$x$处的均值点为 $\mu_{X} = \left\{ \mu_{X1}, \mu_{X2}, \dots \mu_{Xn} \right\}$, 则在对应部分进行一阶泰勒展开，则有:
$$g(x,t) = g(\mu_{X}, t) + \left(\left. \frac{\partial g}{\partial x_{1}}\right|_{\mu_{X}}, \dots \left.\frac{\partial g}{\partial x_{n}} \right|_{\mu_{X}}\right)^{T} (x - \mu_{X})$$
其中$x,\mu_{X}$等均为列向量

此时, 我们取 $u_{i} = \frac{x_{i} - \mu_{Xi}}{\sigma_{Xi}}$,并将 $x_{i} = \mu_{X_{i}} + \sigma_{Xi}u_{i}$ 进行代入,得到:
$$\Large \boxed{g(x,t) \approx L(u,t)  = g(\mu_{X}, t) + b^{T}(t) u}\tag{10.3.2.1}$$
其中向量b为:
$$b = \left\{ \left. \frac{\partial g}{\partial u_{1}}\right|_{\mu_{X}}, \dots \left.\frac{\partial g}{\partial u_{n}} \right|_{\mu_{X}} \right\} \rightarrow b_{i} = \sigma_{Xi} \frac{\partial g(x,t)}{\partial x_{i}}$$
显然, 我们将时变函数$g(x,t)$转换成了时变函数$L(u,t)$, 此时, L(u,t)函数可以通过类似方法获取:
$$\begin{cases}
L(u,t) = g(\mu_{X}, t) + b^{T}(t) u  = 0  \\
L '(u,t) =\frac{\partial g(\mu_{X}, t)}{\partial t}  + b'^{T} (t) u = 0
\end{cases}
$$
其中$\left. b'_i (t) = \frac{\partial^{2} g(x,t)}{\partial x\partial t} \right|_{\mu_{X}}$, 




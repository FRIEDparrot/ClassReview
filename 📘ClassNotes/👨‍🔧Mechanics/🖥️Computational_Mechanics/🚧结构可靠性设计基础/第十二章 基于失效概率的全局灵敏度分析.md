## 一、基于失效概率的全局灵敏度指标
### (1) 全局灵敏度计算方案
首先取 Y = g(X) 为结构功能函数， 且联合概率密度函数为 $f_X(x)$, 此时对于星湖独立的输入变量，可以将联合概率密度函数表示为:
$$P\left\{ F \right\} = \int_{F}f_{X}(x) dx  = \int_{R^{n}} I_{F} (x) f_{X}(x)dx = E[I_{F} (x)]$$
参考[[📘ClassNotes/📐Mathmatics/🎣Probability Theory/第一章 随机事件及其概率#六、条件概率, 全概率公式与贝叶斯公式|条件概率, 全概率公式与贝叶斯公式]],**我们考虑$X_{i}$固定时**, 结构的**条件失效概率**为$P\left\{ F|X_{i} \right\}$,则有: 
$$P\left\{ F|X_{i}\right\} = \int_{R^{n}} I_{F}(x|X_{i})  f_{X_{\sim i}} (x_{\sim i})dx = E_{X_{\sim i}} [I_{F}  (X|X_{i})]$$
其中, 由于$X_i$已经确定, 只需其余变量输入, 而$f_{X\sim i}(x_{\sim i})$为对应的联合概率密度函数:
$$X_{\sim i} =  \left\{ X_{1}, X_{2}, X_{i-1}, X_{i+1}\dots  X_{n} \right\}$$
此时, 我们以输入变量$X_i$固定时**对于结构失效概率的影响**可以通过$P\left\{ F \right\}$和$P\left\{F|X_i\right\}$的**差的绝对值**表示, 并记为$s(X_i)$,即有:
$$\Large\boxed{s(X_{i}) = |P\{F\} - P\{F|X_{i}\}|}\tag{12.1.1.1}$$
此时, $X_i$是**具有概率密度函数$f_{X_{i}}(x_{i})$的随机变量**, 而上式就变成了变量$X_{i}$的函数。
**此时我们可以使用$s(X_i)$的期望表示分布区域内随机取值对结构失效概率的平均影响**, 则有:
$$E_{X_{i}} [s(X_{i})]   = \int s(x_{i})  f_{X_{i}}(x_{i})dx_{i}$$
因此我们<b><mark style="background: transparent; color: blue">取一半的期望定义为全局灵敏度指标</mark></b>:
$$\Large \boxed{\delta_{i}^{P\{F\}} = \frac{1}{2} E_{X_{i}} [s(X_{i})]}\tag{12.1.1.2}$$
另外,我们如果是考虑一组输入变量$X_I = (X_{i_{1}}, X_{i_{2}}, X_{i_{r}})$对于**结构失效概率的全局联合影响**，则定义
$$\large \boxed{\delta_{i_{1}, i_{2}, \dots i_{r}} = \frac{1}{2} E_{X_{i1} X_{i2}\dots } [s(X_{i1}, X_{i2}, \dots X_{ir})]}\tag{12.1.1.3}$$
为多变量的输入不确定性的灵敏度。其中每一项可以计算为:
$$\boxed {E_{X_{i1}, X_{i2}, \dots X_{ir}} [s(X_{i1}, X_{i2}, \dots X_{ir})] = \int\left| P\{ F \} - P\{ F|x_{i1} x_{i2} \dots x_{ir} \}\right|  f_{X_{i1} X_{i2}, \dots X_{ir}}(x_{i1}x_{i2}, \dots x_{ir}) dx_{1}dx_{2}\dots  dx_{ir}}$$
全局灵敏度为取各个差的绝对值的加权平均, 实际上是使用$\left|P(x) - \overline{P}(x) \right|$进行定义的一个**类似方差的定义例子**。
> [!abstract] 补充
> 全局灵敏度具有如下性质：
> 1. $\delta_i^{P\{F \}}\geq 0$, 且$\delta_{i}^{P\{ F\}} = 0$表示对结构的失效概率没有影响。
> 2. 对于多个变量, 若有$\delta_{i,j} = \delta_{i}$, 则$X_{j}$对结构失效概率没有影响
> 3. $\delta_{i}^{P\{ F\}}\leq \delta_{i,j}^{P\{F\}} \leq \delta_{i}^{P\{ F\}} + \delta_{j|i}^{P\{F \}}$
> 4. $\delta_{\max}^{P\{F\}} = \delta_{1,2,\dots n}^{P\{F\}}$

> [!danger] 公式推导
> 按照过程没有推导出3左侧和4公式, 应当谨慎使用

### (2) 估计全局灵敏度的MCS算法
首先根据输入变量 X 的联合概率密度函数$f_{X}(x)$进行随机抽样生成一组样本点。
$$\hat{P} \{ F \} = \frac{1}{N} \sum^{n}_{j=1} I_{F} (x^{(j)})$$
之后, **根据$X_{i}$的概率密度函数$f_{X_{i}}(x_{i})$产生一组$x_i$的样本**$\left\{ x_i^{(1)}，x_i^{(2)}, \dots x_{i}^{(N_c)} \right\}$, 此时针对$X_i$的每一个样本 $x_i^{(j)}$, 根据 $X_{\sim i} = \left\{ X_{1}, \dots X_{i-1}, X_{i+1} \dots X_{n} \right\}^{T}$的联合概率密度函数, 产生其他样本，并根据下式估计条件失效概率密度:
$$\boxed{\hat{P}_{f} \left\{ F| X_{i}=  x_{i}^{(j)} \right\} = \frac{1}{N} \sum^{N }_{k=1} I_{F} (x_{1}^{(k)}, \dots x_{i-1}^{(k)}, x_{i}^{(j)}, x_{i+1}^{(k)}\dots x_{n}^{(k)})}\tag{12.1.2.1}$$
其中$j = 1, 2, \dots N_{c}$为抽取的$x_i$的样本点。
而每一次估计的$\delta_{i}^{P\{F\}}$是根据获取条件概率均值(12.1.1.2)公式获取, 即有:
$$\Large \boxed {\hat{\delta}_{i} ^{P\left\{ F\right\}} = \frac{1}{2} \times  \frac{1}{N_{c}}\sum^{N_{c}}_{i=1} \left| \hat{P}\{F \} - \hat{P}\{F  |X_{i} =  x_{i}^{(j)} \} \right|}\tag{12.1.2.2}$$
之后, 只需对于每个变量重复上述方法即可。
```matlab title:关键代码如下
sensitivity_g(i) = 0.5 * mean(abs(Pf_i- Pf)); %% 重点是这一句, 求解的是减去Pf后的均值而不是先求均值
```

```matlab title:示例代码
%% %%%%%%%%%%%%%% 求解以下功能函数的全局灵敏度, 其中每个变量相互独立且服从(-\pi, \pi)上的均匀分布
clear, clc;
n = 3;
x_min =  -pi * ones(1, n); x_max = pi * ones(1,n);   % 定义均匀分布的最值选取
g = @(x) sin(x(:,1)) + 5 .* sin(x(:,2)).^2 + 0.1 .* x(:,3).^4 .* sin(x(:,1));

num_MCS = 5e3;
% xp  = qrandstream('sobol',n,'Skip', 1e3, 'Leap',1e2);
% xp(i,:) = unifinv (x(:,i), x_min(i), x_max(i))
xp = rand(num_MCS ,n) .* (x_max - x_min) + x_min;   % histogram(xp(:,3),20);

% 估计失效概率
Pf = size(find(g(xp) < 0), 1)/num_MCS;

%% %%%%%%%%%%%%%%%%%%%%%%%% 全局灵敏度分析 %%%%%%%%%%%%%%%%%%%%
num_GRE = 1000;      % Global Reliability Evaluation

% 在全局灵敏度分析中， 直接利用MCS分析中的样本进行修改列后进行分析即可
sensitivity_g = zeros(1, n);

for i = 1:n
    x_i = rand(num_GRE,1).* (x_max(i) - x_min(i)) + x_min(i);  % 在取值范围内进行随机抽样
    Pf_i = zeros(num_GRE,1);
    xp_pre =  rand(num_MCS ,n) .* (x_max - x_min) + x_min;  % 也可以取原先的xp,  xp_pre = xp;
    for j = 1:num_GRE
        xp_pre(:,i) = x_i(j);
        Pf_i(j,:) = size(find(g(xp_pre) < 0), 1)/num_MCS;
    end
    sensitivity_g(i) = 0.5 * mean(abs(Pf_i- Pf));  %% 重点是这一句, 求解的是减去Pf后的均值而不是先求均值
end
```

### (3) 
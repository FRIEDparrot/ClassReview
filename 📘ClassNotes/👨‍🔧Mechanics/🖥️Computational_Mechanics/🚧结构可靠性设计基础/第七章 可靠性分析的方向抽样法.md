## 一、方向抽样法的概念
### (1) 基本概念
我们考虑独立标准正态空间内的, 对于$n$维输入变量的平方和， 服从自由度为$n$ 的$\chi^{2}$ 分布。 因此利用该性质，  可以**通过矢径方向的随机抽样和矢径方向上的插值或者非线性方程求解完成**。这种方法称为方向抽样法。 

针对高度非线性极限状态面，直角坐标系模拟方法效率较低。针对方向抽样方法，考虑**在独立标准正态空间中的极坐标下进行抽样**。由于是利用插值或者求解非线性方程代替一维抽样，从而达到**使得变量空间维数降一维**的目的;

在独立标准正态空间中, 取**直角坐标系下的任意随机向量$X = \left\{ X_1, X_2, \dots X_n \right\}^{T}$ 则**任意随机向量可以表示为;
$$X = RA$$
其中$A$为$X$对应的方向向量, $R$为极半径;
> [!NOTE] 说明
> 实际计算中，我们通过求解非线性方程等方法确定每个点对应的极半径;

![[Excalidraw/第六章 可靠性分析的线抽样方法 2024-04-11 20.27.29|300]]
极坐标系下， 我们改写失效概率计算公式为:
$$P_{f} = \int_{g(x) \leq 0} f_{X}(x) dx =  \int_{A} \int_{g(ra)\leq 0} \varphi_{RA}(r,a) drda$$
其中$\vec{a}$为方向向量(上式中省去向量符号)。

由于显然 $R, A$ 对概率密度的影响是相关的; 因此我们以$r$下条件概率和$f_{A}(x)$(单位方向向量$A$的概率密度函数)的乘积来表示。其中， 由于是单位化向量， 所以A服从单位球面上的均匀分布。上式改写为:
$$P_{f} = \int_{A}\left\{ \int_{R>r}\varphi_{R|A}(r)\cdot f_{A}(a) \right\}drda = \int_{A}\left\{ \int_{R>r}\varphi_{R|A}(r)\space da\right\} f_{A}(a) dr$$
需要说明的是， **其中$R > r(a)$定义了方向向量$A = a$的失效域**; 而我们实际计算时, 使用自由度为$n$的$\chi^{2}$分布的分布函数求解获取 $\varphi$ 在失效域的积分值, 只需利用下式:
$$\Large\boxed{P_{f} = E_{A} [1 - F_{\chi^{2}(n)}[r^{2}(a)]] = \frac{1}{N}\sum^{N}_{j=1}\left[1 - F_{\chi^{2}(n)}(r^{2}(a_{j})) \right]}$$
其中$E_{A}[\cdot ]$为概率密度函数为$f_A(a)$时的数学期望, 而$F$ 表示失效域; 对不同的点, 失效域表示如下:
![[Excalidraw/第七章 可靠性分析的方抽样法 2024-04-11 20.57.44]]
### (2) 收敛性分析
1. 数学期望:
由于样本和总体独立同分布，因此显然有:
$$E[\hat{P}_{f}] = \frac{1}{N}\sum^{N}_{j=1}[1 - F_{\chi^{2}(n)}(r^{2}(a_{j}))] = P_{f}\tag{7.1.2.1}$$
2. 方差:
使用样本方差代替母体方差, 得到:
$$V[\hat{P}_{f}] = \frac{1}{(N -1) N} \left[ \sum^{N}_{j=1} \left( 1- F_{\chi^{2}(n)}(r^{2}(a_{j}) \right)^{2}  -  N \hat{P}_{f}^{2}\right]$$
另外如果使用$S^{2}(x) = \sum^{n}_{i=1} (X - \overline{X})^{2}$, 也可以表达为:
$$V[\hat{P}_{f}] =  \frac{1}{N (N-1)} \sum^{N}_{j=1} \left[ 1- F_{\chi^{2}(n)} (r^{2}(a_{j}))  - P_{f} \right]^{2}\tag{7.1.2.2}$$
变异系数计算容易，略去

### (3) 基本抽样与计算过程
在二维空间中, 我们可以通过**生成均匀分布的** $\theta$ (不是抽取)来生成方向不同的样本点。由于样本点坐标的计算公式为:
$$\begin{cases}
x = \cos \varphi  \cos \theta  \\
y = \sin \varphi \cos \theta   \\
z =  \sin \theta
\end{cases}$$
显然, 对于 $\theta$ 不同, 对应的是一系列的等纬度圆,  如下图: 则此时只需要再均匀抽取$\varphi$， 即可生成对应样本点。
![[Excalidraw/第七章 可靠性分析的方向抽样法 2024-04-14 10.17.12|300]]

> [!important] 注意
> 方向抽样实际上就是利用多维度抽样情况下可以将三自由度化为两个自由度, 从而进行两个方向上的抽样。使得变量的维数减少一维

```matlab title:生成$\phi,theta$分布向量的示例
num_DIV = 80;
%%% 计算产生的样本点部分
theta_ = (0: 2 * pi/num_DIV : 2 * pi)';
phi_   = (0: 2 * pi/num_DIV : 2 * pi)';
l = length(theta_) * length(phi_);
% 注意: theta 必须同一放在后面一个, 否则 reshape 后会导致theta不对应
x = reshape(cos(phi_)*  cos(theta_)', [l, 1]);  
y = reshape(sin(phi_) * cos(theta_)', [l, 1]);
z = reshape(ones(length(phi_), 1) * sin(theta_)', [l, 1]);
rp = [x, y, z];
clear x y z 
% 测试: plot3(x,y, z,'.')
```
生成样本点如下图:
![[attachments/Pasted image 20240414110729.png|300]]
但是， 需要指出的是，抽取到的点实际上是不均匀的, 由于我们所希望的是在单位周长上进行均匀分布的, 即单位圆弧上部分应该得到均匀分布的样本, 但是这个代码却是**抽取的两边更加密集，中间更为稀疏的样本, 即样本点更多地出现在圆的两侧, 因此必然导致结果出现错误**。

解决方法是先计算出弧长, 再抽取样本点:

首先假设将球面展开, 其表面积为 $4 \pi R^{2}$, 由于是均匀分布的, 设大致的总抽样点个数为 num_DS; 则分段的数量可以计算如下:

首先，我们不需要取从0-2pi分布的$\theta$, 而是抽取$-\pi/2 \sim \pi/2$分布的 $\theta$ 值, 设将0-pi 分为 nums 段, 则为了保证均匀性, 则周向部分的

我们先取一个从分布的$\theta$, 设我们要取的 $\theta$ 有nums + 1个值($-\pi/2 \sim \pi/2$), 而纬线划分为2 * nums段, 显然, $\theta$ 角处对应均布的点有 $nums \times  \cos\theta$ 个;

则当从下向上取总的点个数为:
$$\sum^{nums}_{i=0}  2(nums - 1) \times \sin \left( i * \frac{\pi}{nums}\right)$$
在nums较多时,总的点数计算为:(x_0 = nums)
$$num_{DS} \approx \int_{x = 0}^{x_{0}} 2 (x_{0} - 1) \cdot  \sin\left(\frac{x}{x_{0}} \pi \right)dx = \frac{4}{\pi}(x_{0}^{2}- x_{0})$$
![[Excalidraw/第七章 可靠性分析的方向抽样法 2024-04-14 14.43.56|500]]
此时先求解此方程, 取其正解为初始解(为了方便,省去x0, 则$num_{DS} \approx \frac{4}{\pi} x_{0}^2$

因此我们给出如下的代码
```matlab title:生成球面上完全均布的样本点
num_DS = 5e3;
%%%%%%%%%%% 计算产生的样本点部分(由于生成均匀分布较难，所以比较慢) %%%%%%%%%%%%%%%%%%%
nums_theta = round(sqrt(num_DS /4 * pi));   % 纬线方向上
theta_arr = (- pi/2 : pi/nums_theta : pi/2)';  % 生成对应的 theta_ 取值范围 (num_theta + 1个点)
xp = [];
for i = 1:length(theta_arr)
	nums_phi = round(2 * nums_theta *  cos(theta_arr(i)));
	if (nums_phi == 0)
		nums_phi = 1;
		phi_ = 0;    % 两个端点的部分, 仅生成一个点;
	else
		phi_ = (0: 2 * pi/(nums_phi): 2 * pi * (1 - 1/nums_phi))';  % 最后一个是避免重复产生点, 长度为 nums_phi
	end
	theta_ = theta_arr(i) * ones(nums_phi, 1);   % 生成同纬度的均布圆
	xpp = [cos(theta_) .* cos(phi_), cos(theta_) .* sin(phi_), sin(theta_)];
	xp = [xp; xpp];   % 拼接出 xp 数组
end
% 注意: theta_ 必须同一放在后面一个, 否则 reshape 后会导致theta不对应
clear theta_ phi_ xpp theta_arr
```

根据上述的点，只需调用写好的DS_Solu封装函数即可进行求解:
```matlab
%% %%%%%%%%%%%%%%%%%%%%% 方向抽样方法测试程序 %%%%%%%%%%%%%%%%%%%%%%%  
clear, clc;
%% %%%%%%%% 功能函数 g(X) = exp(0.2 X1 + 6.2 ) - exp(0.47 X2 + 5.0); %%%%%%%% 
mu_ = [0, 0];
sigma_d = [1, 1];
sigma_ = diag(sigma_d.^2);
g = @(x) exp(0.2 .* x(:,1) + 6.2) - exp(0.47.* x(:,2) + 5.0);
%% %%%%%%%% 三维函数 -15 X1  + X2^2 - 3 X2 + X3^2 + 5 X3 + 40 %%%%%%%%%%%%%%%
% mu_ = [0, 0, 0];
% sigma_d = [1, 1, 1];
% sigma_ = diag(sigma_d.^2);
% g = @(x) -15 .* x(:,1) + x(:,2).^2 - 3.* x(:,2) + x(:,3).^2 + 5 * x(:,3) + 40;
%% %%%%%%%% 
% mu_ = [500,   1000,  2.9e7];
% sigma_d = [100, 100, 1.45e6];
% sigma_ = diag(sigma_d.^2);
% w = 2.4484;
% t = 3.8884;
% L = 100;
% g = @(x) 2.2 - 4.* L.^3 ./(x(:,3) .* w .* t) .* sqrt((x(:,1)./w.^2).^2 +(x(:,2)./t.^2).^2);
%% 进行DS求解 %%%%
num_DS = 5e3;
Pf = DS_solu(mu_, sigma_, {g}, 4e3);
% Pf1: 0.009401055013147
% Pf2: 0.004232322777316
% Pf3: 0.002710422059556
```

## 二、多失效模式下的方向抽样方法
### (1) 多失效模式情况下的失效概率求解的方向抽样法
取结构共有 $l$ 个失效模式, 且每个失效模式对应的功能函数分别为 $g_{i}(X)$, 则采用方向抽样方法对串联系统的失效概率估算, 显然有关系:
$$\hat{P}_{f}^{(s)} = \frac{1}{N} \sum^{N}_{j=1} \left[ 1-  F_{\chi^{2}}\left(\min_{i =1}^{l}  (r_{i}(a_{j}))^{2}\right)\right]$$
其中，显然系统失效模式在单位矢量$a_j$上对应的坐标原点到失效面的距离为(并联将概率密度的min改为max即可):
$$r^{(s)}(\alpha_{j}) = \begin{cases}
\min_{i=1}^{l}  (r_{i}^{(s)}(a_{j})) \qquad \text{Series}  \\
\max_{i=1}^{l} (r_{i}^{(s)} (a_{j})) \qquad \text{Parallel}\\
\end{cases}$$
其中重要的是 $r^{(s)} (a_j)$ 的计算部分, 然后取其中的最小值为最终的结果。

需要说明的是， 当前DS_solu支持了多失效模式的算法，只需直接调用DS_solu解决即可。
```matlab title:多失效模式的方向抽样方法
% clear, clc;
% mu_ = [0, 0];
% sigma_d = [1, 1];
% sigma_ = diag(sigma_d.^2);
% g1 = @(x) exp(0.2 * x(:,1) + 6.2) - exp(0.47 * x(:,2) + 5) + 70;
% g2 = @(x) exp(0.4 * x(:,1) + 7) - exp(0.3 * x(:,2) + 5.5) - 20;
% num_DS = 3e3;
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% 7.5 %%%%%%%%%%%%%%%%%%%%%% 
clear, clc;
mu_ = [20000, 12, 9.82e-4, 0.04, 3.35e8, 1.34e7];
sigma_d = [1400, 0.12, 5.982e-5, 0.0048, 4.02e7, 1.608e6];
sigma_ = diag(sigma_d.^2);

g1 = @(x) x(:,6) .* x(:,4) - 1.185 .* x(:,1) .* x(:,2);
g2 = @(x) x(:,5) .* x(:,3) - 0.75  .* x(:,1) .* x(:,2);

%% %%%%%%%%% 最简调用只需使用这个即可 %%%%%%%%%%%%%%%%%%%%%% 
num_DS = 1e4;
Pf = DS_solu(mu_, sigma_, {g1, g2}, num_DS, 0);   % 最后一个参数0是串联模式，其余并联模式
```

### (2) 相关变量的求解
仅给出示例代码:
```matlab
%% %%%%%%%%%%%%%%%%% 7.6 相关变量的求解 %%%%%%%%%%%%%%%%%%%%%% 
mu_ = [2, 3, 10];
sigma_d = [1, 5, 2];
rho_ = [1,  0.5, 0.6; 0.5, 1, 0.2; 0.6, 0.2, 1];
sigma_ = sigma_d' * sigma_d .* rho_;

g = @(x) x(:,1) + 2 * x(:,2) - x(:,3)  + 5;

%% %%%%%%%%% 最简调用只需使用这个即可 %%%%%%%%%%%%%%%%%%%%%% 
num_DS = 3e3;
[Pf] = DS_solu(mu_, sigma_, {g}, num_DS);
[Pf2] = MCS_solu(mu_,sigma_, g);
```


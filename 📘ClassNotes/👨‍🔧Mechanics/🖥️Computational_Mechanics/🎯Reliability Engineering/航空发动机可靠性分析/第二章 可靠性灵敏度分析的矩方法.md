---
~
---
## 一、一次二阶矩方法(FOSM) 
### (1) 均值 FOSM 可靠性分析方法
#### 1. 线性函数情况
我们考虑功能函数 $Y = g(X)$是输入变量$X = (X_1, X_2, \dots X_n)^T$的函数, 并记$Y< 0$为失效, 则根据概率论基本原理, 当功能函数为输入变量线性函数且服从正态分布时，对应的功能函数也服从正态分布。

设功能函数$Y = g(X)$是服从整天分布的输入的随机变量$X$函数, 此时有: 
$$Y = g(X) = a_{0} + \sum^{n}_{i=1} a_{i} X_{i}$$
容易获取出均值与方差关系为(参考[[📘ClassNotes/📐Mathmatics/🎣Probability Theory/补充部分/方差的性质证明.pdf|方差的性质证明]]以及[[📘ClassNotes/📐Mathmatics/🎣Probability Theory/第四章 随机变量的数字特征#三、协方差及其相关系数|协方差及其相关系数]]) : 
$$\mu_{g} = a_{0} + \sum^{n}_{i=1} a_{i} \mu_{Xi}\qquad \sigma_{g}^{2} = \sum^{n}_{i=1} a_{i}^{2} \sigma_{Xi}^{2} + \sum^{n}_{i=1} \sum^{n}_{j=1(j\neq i)}  a_{i} a_{j}\space  \text{Cov}(X_{i}, X_{j})$$
其中i = j 时显然协方差为0, 此时， 正态变量经过线性组合之后， 仍然服从正态分布。 
此时， 记均值$\mu_g$和标准差$\sigma_g$的比值记为<mark style="background: transparent; color: red">可靠度指标</mark>$\beta$, 则:
$$\beta = \frac{\mu_{g}}{\sigma_{g}} = \frac{a_{0} + \sum^{n}_{i=1}a_{i} \mu_{Xi}}{\sqrt{\sum^{n}_{i=1} a_{i}^{2} \sigma_{Xi}^{2} + \sum^{n}_{i=1} \sum^{n}_{j=1(j\neq i)}  a_{i} a_{j}\space  \text{Cov}(X_{i}, X_{j})}}$$
此时, 一次二阶矩方法的失效概率$P_f$和可靠度$P_r$为: 
$$P_{f} = P\left\{ Y\leq 0 \right\} = P\left\{ \frac{Y - \mu_{g}}{\sigma_{g}} \leq  -\beta\right\} = \Phi (- \beta )$$
$$P_{r} = P\{Y > 0 \} = P \left\{\frac{Y - \mu_{g}}{\sigma_{g}} > - \beta \right\} \overset{转换< \beta }{\rightarrow} = \Phi (\beta )$$
![[Excalidraw/第二章 可靠性灵敏度分析的矩方法 2024-01-24 11.18.50|450]]
#### 2. 非线性功能函数情况
对于非线性函数，则在相应的均值点处展开为泰勒级数，可以取
$$Y = g(X_{1},X_{2}, \dots ,X_{n}) \approx g(\mu_{X1}, \mu_{X2} , \dots \mu_{Xn}) + \sum^{n}_{i=1} \left.\frac{\partial g}{\partial X_{i}} \right|_{\mu_{X}} (X_{i} - \mu_{Xi})$$
显然得到: 
$$\beta  = \frac{\mu_{g}}{\sigma_{g}} = \frac{g(\mu_{X1}, \mu_{X2}, \dots  \mu_{Xn})}{\sqrt{\sum^{n}_{i=1} \left(\left.\frac{\partial g}{\partial X_{i}} \right|_{\mu_{X}}\right)^{2} \sigma_{i}^{2} + \sum^{n}_{i=1} \sum^{n}_{j=1(j\neq i)} \left.\left(\frac{\partial g}{\partial X_{i}}\right)\left(\frac{\partial g}{\partial X_{j}} \right) \right|_{\mu_{X}} Cov(X_{i}, X_{j}) }}$$
此时仍然满足:
$$P_{r} = \Phi(\beta) \qquad  P_{f} = \Phi(-\beta)$$
### (2) 均值FOSM可靠性灵敏度分析方法
#### 1. 定义
根据上述方法, <mark style="background: transparent; color: red">可靠性灵敏度</mark>定义为失效概率对于均值, 方差和协方差的偏导数, 即有: 
$$\frac{\partial P_{f}}{\partial \mu_{Xi}} = \frac{\partial P_{f}}{\partial \beta}\frac{\partial \beta }{\partial \mu_{Xi}} \quad \frac{\partial P_{f}}{\partial \sigma_{Xi}} = \frac{\partial P_{f}}{\partial \beta}\frac{\partial \beta }{\partial \sigma_{Xi}}\quad \frac{\partial P_{f}}{\partial \rho_{Xi,Xj}} = \frac{\partial P_{f}}{\partial \beta}\frac{\partial \beta }{\partial \rho_{Xi,Xj}}\tag{2.2.1}$$
此时, 根据公式[[📘ClassNotes/📐Mathmatics/🎣Probability Theory/第二章 随机变量及其分布#3. 正态分布|正态分布公式]], 有
$$P_{f} = \Phi(- \beta) = 1 - \Phi (\beta) = 1- \frac{1}{\sqrt{2\pi}} \int_{-\infty}^{\beta} e^{- \frac{t^{2}}{2}}dt$$
获得关于可靠度指标的结果: 
$$\boxed {\frac{\partial P_{f}}{\partial \beta} = -\frac{1}{\sqrt{2\pi}}  e^{- \frac{\beta ^{2}}{2}} = -\frac{1}{\sqrt{2\pi}} \exp \left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right)} \tag{2.2.2}$$
#### 2. 输入变量独立时的可靠性灵敏度计算 
根据$\beta$的定义式, 有: 
$$\beta = \frac{\mu_{g}}{\sigma_{g}} = \frac{a_{0} + \sum^{n}_{i=1}a_{i} \mu_{i}}{\sqrt{\sum^{n}_{i=1} a_{i}^{2} \sigma_{Xi}^{2} + \sum^{n}_{i=1} \sum^{n}_{j=1(j\neq i)}  a_{i} a_{j}\space  \text{Cov}(X_{i}, X_{j})}} \overset{不相关}{\rightarrow } = \frac{a_{0} + \sum^{n}_{i=1} a_{i} \mu_{i}}{\sqrt{\sum^{n}_{i=1} a_{i}^{2} \sigma_{Xi}^{2}}}$$
$$\frac{\partial \beta}{\partial \mu_{Xi}} = \frac{a_{i}}{\sqrt{\sum^{n}_{i=1} a_{i}^{2} \sigma_{i}^{2}}} = \frac{a_{i}}{\sigma_{g}}, \qquad\frac{\partial \beta}{\partial \sigma_{Xi}} = -\frac{\mu_{g}}{\sigma_{g}^{2}} \times  \frac{1}{2 \sigma_{g}} \times 2a_{i}^{2} \sigma_{Xi} = - \frac{\mu_{g}  a_{i}^{2} \sigma_{Xi}}{\sigma_{g}^{3}}$$
代入2.2.1式得到<mark style="background: transparent; color: red">独立变量的线性均值灵敏度公式和方差灵敏度公式</mark>如下: 
$$\boxed{\frac{\partial P_{f}}{\partial \mu_{Xi}} =- \frac{a_{i}}{\sqrt{2\pi } \sigma_{g}} \exp \left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right)\qquad  \frac{\partial P_{f}}{\partial \sigma_{Xi}} =  \frac{\mu_{g}a_{i}^{2} \sigma_{Xi}}{\sqrt{2\pi }\sigma_{g}^{3}} \exp \left(- \frac{\mu_{g}^{2}}{2\sigma_{g}^{2}}\right)}$$
其中对于独立<mark style="background: transparent; color: red">非线性</mark>时, 只需将替换$a_i$为$\left.\frac{\partial g}{\partial X_i} \right|_{\mu X}$即可。

#### 3. 输入变量相关时的可靠性灵敏度计算 
首先， 如果**功能函数是线性的**，则可靠性灵敏度计算如下:  
在线性的情况下, 仍然满足:
$$\beta = \frac{\mu_{g}}{\sigma_{g}} = \frac{a_{0} + \sum^{n}_{i=1}a_{i} \mu_{Xi}}{\sqrt{\sum^{n}_{i=1} a_{i}^{2} \sigma_{Xi}^{2} + \sum^{n}_{i=1} \sum^{n}_{j=1(j\neq i)}  a_{i} a_{j}\space  \text{Cov}(X_{i}, X_{j})}}$$
因此容易计算出对$\mu_{g}, \sigma_{g}, \rho_{X_{i},X_{j}}$的偏导数, 同时利用协方差的定义: 
$$\boxed{\rho_{XY} = \frac{\text{Cov}(X,Y)}{\sqrt{D(X)} \sqrt{D(Y)}}}$$
因此在求解方差时需要考虑, 经过计算得到:
$$\frac{\partial \beta}{\partial \mu_{X_{i}}} = \frac{a_{i}}{\sigma_{g}} \qquad \frac{\partial \beta}{\partial \sigma_{Xi}} = - \frac{\mu_{g} }{\sigma_{g}^{3}} \left(a_{i}^{2} \sigma_{Xi}^{2} +\sum^{n}_{j=1, j \neq i}  a_{i}a_{j}\rho_{X_{i}, X_{j}} \sigma_{Xj}\right)\qquad \frac{\partial \beta}{\partial \rho_{Xi, Xj}} = - \frac{ \mu_{g}}{2 \sigma_{g}^{3}}\left(a_{i}a_{j} \sigma_{Xi} \sigma_{Xj}\right)$$
因而有<mark style="background: transparent; color: red">关于均值， 方差和协方差的可靠性灵敏度计算为</mark>:
$$\begin{cases}
\frac{\partial P_{f}}{\partial \mu_{Xi}} = - \frac{a_{i}}{\sqrt{2 \pi }\sigma_{g}}\exp \left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right)  \\
\frac{\partial P_{f}}{\partial \sigma_{Xi}} = \frac{\mu_{g}}{\sqrt{2\pi }\sigma_{g}^{3}}\left(a_{i}^{2} \sigma_{Xi}^{2} +\sum^{n}_{j=1, j \neq i}  a_{i}a_{j}\rho_{X_{i}, X_{j}} \sigma_{Xj}\right) \exp \left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right) \\
\frac{\partial P_{f}}{\partial \rho_{Xi,Xj}} = \frac{\mu_{g}}{2\sqrt{2\pi }\sigma_{g}^{3}} \left(a_{i}a_{j} \sigma_{Xi} \sigma_{Xj}\right) \exp\left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right)
\end{cases}$$
此时如果为非线性方程, 则做如下替换(其中$Y = g(X_{1}, \dots X_{n})\approx g(\mu_{X1}, \mu_{X2}, \dots \mu_{Xn})$) 即可: 
$$a_{i} = \left. \frac{\partial g}{\partial X_{i}} \right|_{\mu_{X}} \qquad a_{j} = \left. \frac{\partial g}{\partial X_{j}} \right|_{\mu_{X}}$$

给出简单的 matlab 示例代码: 
```erlang
clear,clc
%%%%%% 
% 某内压圆筒型容器材料为15MnV, 随机变量取为内径D, 内压强P, 壁厚t与屈服强度sigma_s
% 这些随机变量独立且均服从正态分布, 参数在下面给出
D_mu = 460; D_sig = 7;
P_mu = 20;  P_sig = 2.4;
t_mu = 19;  t_sig = 0.8;
sigma_s_mu = 392; sigma_s_sig = 31.4 ; 


syms s p d t ss ps ds ts
g(s,p,d,t) = s - p * d/(2 * t);

% ------- derivates for function g------- 
g_s_ = subs(diff(g(s,p,d,t),s), [s,p,d,t],[sigma_s_mu, P_mu, D_mu, t_mu]);
g_p_ = subs(diff(g(s,p,d,t),p), [s,p,d,t],[sigma_s_mu, P_mu, D_mu, t_mu]);
g_d_ = subs(diff(g(s,p,d,t),d), [s,p,d,t],[sigma_s_mu, P_mu, D_mu, t_mu]);
g_t_ = subs(diff(g(s,p,d,t),t), [s,p,d,t],[sigma_s_mu, P_mu, D_mu, t_mu]);


mu_g = g(s,p,d,t);
sigma_g = sqrt(g_s_^2 * ss^2 + g_p_^2 * ps^2 + g_d_^2 * ds^2 + g_t_^2 * ts^2);

mu_g_var = vpa(subs(mu_g,[s,p,d,t], [sigma_s_mu,P_mu, D_mu,t_mu]));
sigma_g_var = vpa(subs(sigma_g,[ss,ps,ds,ts], [sigma_s_sig,P_sig, D_sig,t_sig]));

beta = mu_g/sigma_g;
beta_var = subs(beta,[s,p,d,t, ss,ps,ds,ts], [sigma_s_mu,P_mu, D_mu,t_mu, sigma_s_sig,P_sig, D_sig,t_sig]);

sprintf("mu_g: %f, sigma_g: %f",mu_g_var,sigma_g_var)
sprintf("beta: %f , Pf :%f", beta_var, normcdf(-beta_var))

beta_t_ = diff(beta,t);
beta_d_ = diff(beta, d);
beta_p_ = diff(beta, p);
beta_s_ = diff(beta, s);

Pf_beta_ = -1/sqrt(2 * pi) * exp(-mu_g^2/(2 * sigma_g^2));


sen_s = subs(beta_s_ * Pf_beta_, [s,p,d,t, ss,ps,ds,ts], [sigma_s_mu,P_mu, D_mu,t_mu, sigma_s_sig,P_sig, D_sig,t_sig] );
sen_p = subs(beta_p_ * Pf_beta_, [s,p,d,t, ss,ps,ds,ts], [sigma_s_mu,P_mu, D_mu,t_mu, sigma_s_sig,P_sig, D_sig,t_sig] );
sen_d = subs(beta_d_ * Pf_beta_, [s,p,d,t, ss,ps,ds,ts], [sigma_s_mu,P_mu, D_mu,t_mu, sigma_s_sig,P_sig, D_sig,t_sig] );
sen_t = subs(beta_t_ * Pf_beta_, [s,p,d,t, ss,ps,ds,ts], [sigma_s_mu,P_mu, D_mu,t_mu, sigma_s_sig,P_sig, D_sig,t_sig] );
% 输出每一个均值敏感度 -> 方差灵敏度分析略去
sprintf("sense: %0.8f, %0.8f, %0.8f, %0.8f", sen_d, sen_p, sen_t, sen_s)
```

```erlang
ans = 
    "mu_g: 149.894737, sigma_g: 44.130540"
ans = 
    "beta: 3.396621 , Pf :0.000341"
ans = 
    "sense: 0.00001487, 0.00034191, -0.00035990, -0.00002824"
```

### (3) 改进 FOSM 可靠性分析方法
#### 1. 线性功能函数 
Advanced FOSM method 为改进的一次二阶矩方法, 也是通过类似方法将非线性功能函数进行线性展开, 并使用线性功能函数的失效概率近似原始非线性功能函数的失效概率。针对于非线性功能函数,  其失效域中的最可能失效的点是不能有限得知的, 需要使用寻优和迭代的方法。

首先我们设功能函数 Y = g(X) 为如下形式的线性函数 : 
$$Y = g(X) = a_{0} + \sum^{n}_{i=1} a_{i} X_{i}$$
此时, 要求改进一次二阶矩方法的分析结果和均值一次二阶矩的可靠性分析结果完全一致。首先, <mark style="background: transparent; color: red">将正态输入变量进行标准化</mark>, 取$Z_i$为正态化输入变量, 即有:
$$Z_{i}  = \frac{X_{i} - \mu_{Xi}}{\sigma_{Xi}}$$
此时, 代入即可得到使用标准正态分布表征的极限状态方程: 
$$Y' = a_{0} +\sum^{n}_{i=1}  a_{i} (\sigma_{Xi} Z_{i}+ \mu_{Xi}) = 0 $$
此时移项并同除 $\sqrt{\sum^{n}_{i=1} a_{i}^{2} \sigma_{Xi}^{2}}$, 得到<mark style="background: transparent; color: red">标准型的法线方程</mark>: 
$$\frac{\sum^{n}_{i=1} a_{i} \sigma_{Xi} }{\sqrt{\sum^{n}_{i=1} a_{i}^{2}\sigma_{Xi}^{2}}}Z_{i} = - \frac{a_{0} + \sum^{n}_{i=1} a_{i} \mu_{Xi}}{\sqrt{\sum^{n}_{i=1} a_{i}^{2}\sigma_{Xi}^{2}}} = - \beta$$
其中$\beta$ 为可靠度指标, 此时两边同时取负号, 则有<mark style="background: transparent; color: red">在标准正态空间中的极限状态方程</mark>: 
$$\boxed{\sum^{n}_{i=1} \lambda_{i}  Z_{i} = \beta\qquad  \lambda_{i} = - \frac{ a_{i} \sigma_{Xi} }{\sqrt{\sum^{n}_{i=1} a_{i}^{2}\sigma_{Xi}^{2}}}}$$
其几何意义如下图所示: 其中, $P(z_1^*, z_2^*)$为<mark style="background: transparent; color: red">设计点</mark>, 对于标准正态 $Z$ 空间, <mark style="background: transparent; color: red">设计点是极限方程的失效域中对失效概率贡献最大的点</mark>, 也称之为<mark style="background: transparent; color: red">最有可能失效点</mark>(MPP)。

由于失效的方程是 
$$\sum^{n}_{i=1}  \lambda_{i} Z_{i} = \beta\quad  \overset{仅考虑两个变量}{\rightarrow}\quad  \lambda_{1}Z_{1} + \lambda_{2} Z_{2} - \beta = 0$$
显然直线上的任何点均满足$\lambda_1 z_1^* + \lambda_2 z_2^* = \beta$,  因此过原点向极限状态方程作垂线, 根据[[📘ClassNotes/📐Mathmatics/📈Advanced Mathematics/第八章 向量代数和空间解析几何#(1) 空间直线的一般式方程|直线的一般式方程]]物理意义, 则法向量为 $\vec{n}(\lambda_1, \lambda_2)$ , 而显然满足: $\lambda_1^2 + \lambda_2^2 = 1$(推广后也成立), 显然有:
$$\boxed{\lambda_1  = \cos \theta_1, \lambda_2 = \cos \theta_{2}}$$
![[Excalidraw/第二章 可靠性灵敏度分析的矩方法 2024-01-25 16.11.03|400]]
此时根据[[📘ClassNotes/📐Mathmatics/📈Advanced Mathematics/👆重要定理/空间几何位置关系总结|点到平面距离公式]]可以计算出<b><mark style="background: transparent; color: blue">原点到直线的垂线距离</mark></b>即为<mark style="background: transparent; color: red">可靠度的几何意义</mark>: 
$$d = \frac{\beta}{\sqrt{\lambda_{1}^{2} + \lambda_{2}^{2}}} =  \beta$$
在实际求解中， 应当先求取设计点$P(z_1^*, z_2^*, \dots z_n^*)$, 经过反变换之后可以求得对应的$X$空间设计点坐标。 同时, 可以解出对应的$z_{1}^{*}, z_{2}^{*}$, 只需用$\frac{z_{1}^{*}}{z_{2}^{*}} = \frac{\lambda_{1}}{\lambda_{2}}$, 容易求解出:
$$\boxed{z_{1}^{*} =  \lambda_{1}\beta,\qquad z_{2}^{*} =  \lambda_{2}\beta }$$
#### 2. 非线性功能函数
仍然将非线性的功能函数进行展开并取其中的线性部分: 
$$Y = g(X_{1}, X_{2},\dots X_{n})\approx g(x_{1}^{*}, \dots x_{n}^{*}) + \sum^{n}_{i=1} \left. \frac{\partial g}{\partial x_{i}} \right|_{P^{*}}(X_{i}- x_{i}^{*})$$
此时由于$P^*$对应的$g  (X_1, X_2, \dots  X_n) = 0$在失效边界上, 因而有 $g(x_1^*, x_2^*, \dots x_n^*) = 0$, 代入上式则有<mark style="background: transparent; color: red">功能函数的线性近似</mark>:
$$\boxed{\left. \sum^{n}_{i=1} \frac{\partial g}{\partial x_{i}} \right|_{P^{*}}  (X_{i} - x_{i}^{*})= 0}$$
此时直接按照[[#(1) 均值 FOSM 可靠性分析方法]]进行线性求解即可, 其中$a_{0} = -\sum^{n}_{i=1} \dots x_{i}^{*}$
代入公式即得到: 
$$\beta = \frac{\left. \sum^{n}_{i=1} \frac{\partial g}{\partial x_{i}} \right|_{P^{*}}  (\mu_{Xi} - x_{i}^{*})}{\sqrt{\sum^{n}_{i=1} a_{i}^{2}\sigma_{Xi}^{2} + \sum^{n}_{i=1}  \sum^{n}_{j=1(j \neq i)} a_{i}a_{j} \text{Cov} (X_{i}, X_{j})}}$$
对应地， 有失效概率为:
$$P_{f} = \Phi(-\beta)$$
此时可靠度指标以及对应设计点的几何意义如下图:
![[Excalidraw/第二章 可靠性灵敏度分析的矩方法 2024-01-25 18.30.40|350]]
此时, 仍然有: 
$$\boxed{\Large z_{i}^{*} = \lambda_{i} \beta\qquad  \lambda_{i} = - \frac{\left. \frac{\partial g}{\partial X_{i}} \right|_{P^{*}}\sigma_{Xi}}{\left[\sum^{n}_{i=1}\left( \left. \frac{\partial g}{\partial X}\right|_{P^{*}}\right)^{2}  \sigma_{Xi}^{2}\right]^{\frac{1}{2}}} = \cos \theta_{i}}\tag{2.3.3}$$
此时, 将标准正态$Z$空间的设计点$P^{*}(z_{1}^{*}, z_{2}^{*}\dots z_{n}^{*})$, 变换到$P^{*}(x_{1}^{*}, x_{2}^{*}, \dots x_{n}^{*})$空间, 从而得到设计点$P^{*}$<mark style="background: transparent; color: red">在X坐标系下的坐标</mark>:
$$\boxed{x_{i}^{*} = \mu_{Xi} + \sigma_{Xi} z_{i}^{*} =  \mu_{Xi} + \sigma_{Xi}\lambda_{i} \beta \tag{2.3.4}}$$
由于$P^*(x_1^*, x_2^*, \dots x_n^* )$在**失效边界上**, 则有:
$$g(x_1^*, x_2^*, \dots x_n^*)=0$$

> [!summary] 改进一次二阶矩的迭代求解方法
> - 假定设计点坐标$P^*(x_{1}^{*}, x_{2}^{*}, \dots x_{n}^{*})$等的初始值部分(可以取$\mu_{X}$的值)为初始值。另外可以设第一次解出的$\beta$ 初始值为0;
> - 利用假设的初始值,  将式2.3.4代入$g(X) = 0$中, 可以解出$\beta$的初始值。
> - 将$\beta$ 值继续代入2.3.4并重复迭代获取最终的$\beta$值
>  需要说明的是, 设置初始值为0, 每一次的值均从$g(x^{*}) = 0$中解出; 而迭代过程每一次又将beta代回计算x, 通过更改后的点经过$\lambda$公式(2.3.3) 重新计算获取新的lambda值再进行迭代得到最终结果的。 


> [!NOTE] 补充
> 说明: 
> - 对于线性情况， 求解的结果与FOSM方法相同, 此时只需迭代一次即可得到结果，且不论迭代多少次得到结果均相同
> 
> 缺点: 
> 1. 不能反映功能函数对失效概率的影响
> 2. 对于功能函数在非线性程度比较大的情况下, 迭代算法受到初始点影响较大, 导致陷入局部最优解;
> 3. 对于极限状态方程的表达式有解析的要求， 对于隐函数表达的极限状态方程， 难以求解导数。 

### (4) 改进FOSM 可靠性灵敏度分析方法 
改进的 FOSM 可靠性灵敏度分析方法: 利用在设计点的展开表达式 : 
$$Y = g(x_{1}^{*}, x_{2}^{*}, \dots x_{n}^{*}) + \sum^{n}_{i=1} \left. \frac{\partial g}{\partial X_{i}}  \right|_{P^{*}} (X_{i} - x_{i}^{*})$$
其中, = g(X)也可以使用下式表达 :
$$c_{0} = g(x_{1}^{*}, x_{2}^{*}, \dots x_{n}^{*}) - \sum^{n}_{i=1} \left. \frac{\partial g}{\partial X_{i}} \right|_{P^{*}} x_{i}^{*} \qquad g(X) = c_{0} + \sum^{n}_{i=1}c_{i} X_{i}\qquad c_{i} =  \left.  \frac{\partial g}{\partial X_{i}} \right|_{P^{*}}$$
显然在设计点$g (x_{1}^{*}, x_{2}^{*}, \dots x_{n}^{*}) = 0$, 则有: 
$$\beta = \frac{\mu_{g}}{\sigma_{g}} = \frac{\sum^{n}_{i=1} \left. \frac{\partial g}{\partial X_{i}}\right|_{P^{*}} (\mu_{Xi} - x_{i}^{*})}{\sqrt{\sum^{n}_{i=1} \left(\left. \frac{\partial g}{\partial X_{i}} \right|_{P^{*}} \right)^{2} \sigma _{Xi}^{2}}} = \frac{\sum^{n}_{i=1} c_{i} (\mu_{Xi} - x_{i})}{\sqrt{ \sum^{n}_{i=1}  c_{i}^{2} \sigma_{Xi}^{2}}} \tag{2. 4. 1}$$
并有$P_f  = \Phi(-\beta)$, 其中, 显然有:
$$\mu_{g} = c_{0} + \sum^{n}_{i=1}  c_{i} \mu_{Xi} \qquad  \sigma_{g} = \sum^{n}_{i=1} \left(\left. \frac{\partial g}{\partial X_{i}} \right|_{P^{*}} \right)^{2} \sigma _{Xi}^{2}$$
显然有
$$\begin{cases}
\frac{\partial P_{f}}{\partial \mu_{Xi}} = - \frac{c_{i}}{\sqrt{2 \pi }\sigma_{g}}\exp \left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right) \\
\frac{\partial P_{f}}{\partial \sigma_{Xi}} = \frac{\mu_{g}}{\sqrt{2\pi }\sigma_{g}^{3}}\left(c_{i}^{2} \sigma_{Xi}^{2} +\sum^{n}_{j=1, j \neq i}  c_{i}c_{j}\rho_{X_{i}, X_{j}} \sigma_{Xj}\right) \exp \left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right) \\
\frac{\partial P_{f}}{\partial \rho_{Xi,Xj}} = \frac{\mu_{g}}{2\sqrt{2\pi }\sigma_{g}^{3}} \left(c_{i}c_{j} \sigma_{Xi} \sigma_{Xj}\right) \exp\left(- \frac{\mu_{g}^{2}}{2 \sigma_{g}^{2}}\right)
\end{cases}$$
根据上述方法求解可靠度指标$\beta$之后, 即可通过上式获取输入变量相关下的可靠性灵敏度。 

> [!NOTE] 说明
> 对于求解的精度, 一般而言，功能函数非线性程度越小， 获得的解精度越高。而当非线性程度大时, 获得的解可能错误。 

上面一题可以使用如下的代码进行迭代求解: 
```erlang
g_t_var = subs(g_t_, [s,p,d,t],[sigma_s_mu, P_mu, D_mu, t_mu]);

% ------- mu_g , sigma_g -------------------
mu_g = g(s,p,d,t);
sigma_g = sqrt(g_s_^2 * ss^2 + g_p_^2 * ps^2 + g_d_^2 * ds^2 + g_t_^2 * ts^2);


% use the formula for lambda 
lambda_s_ = -(diff(g(s,p,d,t), s) * sigma_s_sig)/sigma_g;
lambda_p_ = -(diff(g(s,p,d,t), p) * P_sig)/sigma_g;
lambda_d_ = -(diff(g(s,p,d,t), d) * D_sig)/sigma_g;
lambda_t_ = -(diff(g(s,p,d,t), t) * t_sig)/sigma_g;

mu_values = [sigma_s_mu, P_mu, D_mu, t_mu];
sigma_values = [sigma_s_sig, P_sig, D_sig, t_sig];

lambda_s_var = subs(lambda_s_,[s,p,d,t, ss,ps,ds,ts], ...
    [mu_values(1),mu_values(2), mu_values(3),mu_values(4), sigma_s_sig,P_sig, D_sig,t_sig]);
lambda_p_var = subs(lambda_p_,[s,p,d,t, ss,ps,ds,ts], ...
    [mu_values(1),mu_values(2), mu_values(3),mu_values(4), sigma_s_sig,P_sig, D_sig,t_sig]);
lambda_d_var = subs(lambda_d_,[s,p,d,t, ss,ps,ds,ts], ...
    [mu_values(1),mu_values(2), mu_values(3),mu_values(4), sigma_s_sig,P_sig, D_sig,t_sig]);
lambda_t_var = subs(lambda_t_,[s,p,d,t, ss,ps,ds,ts], ...
    [mu_values(1),mu_values(2), mu_values(3),mu_values(4), sigma_s_sig,P_sig, D_sig,t_sig]);
sprintf("lambda_init: %f, %f, %f, %f", lambda_s_var, lambda_p_var, lambda_d_var,lambda_t_var)
lambda_values = [lambda_s_var, lambda_p_var, lambda_d_var, lambda_t_var]; 

syms b_test
Xi = mu_values;  % 初始值

beta_fst = 0;
for epoch = 1:1000
    if epoch == 1 
        beta_chk = beta_fst; % 使用0作为res1
    else
        beta_chk = beta_sec; % 上一次结果作为迭代结果检查res1
        Xi = mu_values + sigma_values .* lambda_values * beta_sec;  % 重新计算设计点
        % 利用设计点获取新的lambda值
        lambda_s_var = subs(lambda_s_,[s,p,d,t, ss,ps,ds,ts], ...
            [Xi(1), Xi(2),Xi(3), Xi(4), sigma_s_sig,P_sig, D_sig,t_sig]);
        lambda_p_var = subs(lambda_p_,[s,p,d,t, ss,ps,ds,ts], ...
            [Xi(1), Xi(2),Xi(3), Xi(4), sigma_s_sig,P_sig, D_sig,t_sig]);
        lambda_d_var = subs(lambda_d_,[s,p,d,t, ss,ps,ds,ts], ...
            [Xi(1), Xi(2),Xi(3), Xi(4), sigma_s_sig,P_sig, D_sig,t_sig]);
        lambda_t_var = subs(lambda_t_,[s,p,d,t, ss,ps,ds,ts], ...
            [Xi(1), Xi(2),Xi(3), Xi(4), sigma_s_sig,P_sig, D_sig,t_sig]);
        lambda_values = [lambda_s_var, lambda_p_var, lambda_d_var, lambda_t_var]; % 更新lambda_values值
    end
    % 注意: 保留6位有效数字, 避免精度过高导致无法计算
    x_res = vpa(mu_values + sigma_values  .* lambda_values * b_test, 6); % 每一次都要重新计算 x_res
    beta_sec = vpa(min(solve(g(x_res(1), x_res(2), x_res(3), x_res(4)) == 0, b_test)), 6);
    sprintf("epoch: %d, res1: %f, res2 : %f",epoch, vpa(beta_chk,6), vpa(beta_sec,6))
    if (abs(beta_chk - beta_sec))<0.001
        break;
    end
end
sprintf("design point: %f, %f, %f, %f", Xi(1), Xi(2), Xi(3), Xi(4))
```

结果如下:
```erlang 
ans =     "epoch: 1, res1: 0.000000, res2 : 3.335089"
ans =     "epoch: 2, res1: 3.335089, res2 : 3.324230"
ans =     "epoch: 3, res1: 3.324230, res2 : 3.324148"
ans =     "design point: 320.634706, 25.238194, 462.437569, 18.199978"
```
[Flask 官方文档](https://flask.palletsprojects.com/en/stable/): Flask 是一个<mark style="background: transparent; color: red">基于 Werkzeug 和 Jinja2  的后端框架</mark>, 类似的 Django 等都是属于后端框架类型. 

我们往往<b><mark style="background: transparent; color: orange">可以使用 Flask 提供的路由和视图功能来接受 HTTP 请求</mark></b>，返回 JSON 数据。Vue.js 可以通过 Axios 或 Fetch API 从 Flask 后端获取这些数据。这种方式通常用于构建单页面应用（SPA）

首先对于 linux 主机上的 python 环境创建, 可以采用:
```sh
python3 -m venv myvenv
cd myvenv
source ./bin/activate
deactivate   #  退出虚拟环境
```

## 一、 Flask 开发基础
### (1) 基本 Flask 框架与装饰器的使用
首先, 对于最小的 Flask 框架程序如下:
```python
#coding = utf-8  
from flask import Flask  
  
app = Flask(__name__)  
  
@app.route('/')  
def hello_world():  
    return 'Hello World!'  
  
if __name__ == '__main__':  
    app.run(host='0.0.0.0', port=8080)
```

代码中，`@app.route('/')` 是一个 **装饰器** 的使用。参考[[📘ClassNotes/⌨️Programming/🐍Python/⛳Python 进阶与软件架构设计相关/2. Python 闭包函数, 装饰器|2. Python 闭包函数, 装饰器]]

### (2) Config 相关基本配置
参考 [flask.Config](https://flask.palletsprojects.com/en/stable/api/#flask.Config)  部分，可以通过 from_pyfile, from_object 等等方法   
一般而言, 可以从 app.config 进行 app 的相关配置, 其中 app.config 是 flask.config.Config 的实例。

```python
app = Flask(__name__);
app.config['DEBUG'] = True;   #  这个是配置的方法1 
app.debug = True;
app.config.update(   # 更新配置方法, 利用 config.update 进行 
	DEBUG = True,
	SECRET_KEY = '...',
)
app.config.from_object("settings");  # 通过配置文件加载

import settings
app.config.from_object(settings);  # 相关 api, 略去

app.config.from_pyfile('yourconfig.cfg');   # 自定义一个 config.json 文件进行配置
app.config.from_envvar('YOURAPPLICATION_SETTINGS');   # 通过环境变量配置, 实际上要求是文件路径  export YOURAPPLICATION_SETTINGS='/path/to/config/file'
```

另外也可以使用 app.debug 进行配置, 具体可以参考[flash.config.ConfigAttribute](https://flask.palletsprojects.com/en/stable/config/), 包含 DEBUG, TESTING 等等, 实际上和 `app.config['DEBUG']` 是等价的。

如果需要从 toml 或者 json 中读取配置,  则采用:
```python
import json
app.config.from_file("config.json", load=json.load)

import tomllib
app.config.from_file("config.toml", load=tomllib.load, text=False)

from_mapping(_mapping=None_, _**kwargs_)

app.config['IMAGE_STORE_TYPE'] = 'fs'
app.config['IMAGE_STORE_PATH'] = '/var/app/images'
app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'

# 获取其中某个 NAMESPACE 下的配置 
image_store_config = app.config.get_namespace('IMAGE_STORE_')  
{    # 其中得到 image_store_config 部分类似如下: 
    'type': 'fs',
    'path': '/var/app/images',
    'base_url': 'http://img.website.com'
}
```

### (3) 动态路由规则
Flask 的路由规则是基于 Werkzeug 的路由模块, 需要保证唯一的 url, 例如, 结尾带 `/` 的部分和不带的部分应该是相同的,  因此都会被重定向到带有 / 的路由中. 例如 `/projects` 被重定向到 `/projects/` 部分;

#### 1. Flask 中的动态路由转换器
在 Flask 中，**特殊字段标记**和**转换器**功能可以用于构建动态路由(dynamic url)，这使得 URL 更加灵活和功能强大。以下是对 Flask 路由转换器的讲解以及特殊字段标记的详解。

对于复合同种规则的 url, 可以抽象为一个 url 模式, 往往用于不同文章等 id 的索引部分, 具体如下:
```python
@app.route('/item1/1/')
@app.route('/item1/2/')
@app.route('/item1/3/')
# 上述方法可以采用: 
@app.route('/item/<id>')  # 将其中 id 匹配到的部分，会作为参数映射到相应的路由
def item(id):
	return '{id}'.format(id)
```
<b><mark style="background: transparent; color: orange">转换器语法</mark></b>为 `@app.route('/path/<converter:variable_name>/')`, 其中:
- **`converter`**: 转换器名称，定义变量的类型或规则。
- **`variable_name`**: 变量名，可以在视图函数中使用。
支持的转换器类型如下:

| 转换器名称      | 描述                                    | 示例                         |
| ---------- | ------------------------------------- | -------------------------- |
| **string** | 默认类型，匹配任意不包含斜杠 `/` 的文本。               | `/user/<string:username>/` |
| **int**    | 匹配正整数，视图函数中会将值转换为 `int` 类型。           | `/order/<int:order_id>/`   |
| **float**  | 匹配浮点数，视图函数中会将值转换为 `float` 类型。         | `/price/<float:amount>/`   |
| **path**   | 匹配任意文本（包括斜杠 `/`），适合处理路径。              | `/file/<path:filepath>/`   |
| **uuid**   | 匹配有效的 UUID 字符串，视图函数中会将值转换为 `UUID` 对象。 | `/user/<uuid:user_id>/`    |
通过如下的多个方法定义, 实际上就可以实现通过用户访问不同的路由，实际传递出不同的参数, 进而通过访问后端数据库加载出对应的界面。 
```python
#  any 的使用示例(接受一组可接受的值) 
@app.route('/<any(a, b, c):page_name>/')
def handle_page(page_name):
    return f"Page: {page_name}"
#- 路由 `/home/` 匹配，`page_name` 的值为 `"home"`。
#- 路由 `/about/` 匹配，`page_name` 的值为 `"about"`。
#- 路由 `/contact/` 匹配，`page_name` 的值为 `"contact"`。

# 路由 `/file/uploads/images/` 匹配，`filepath` 的值为 `"uploads/images"`
@app.route('/file/<path:filepath>/')
def file(filepath):
    return f"File Path: {filepath}"

@app.route('/order/<int:order_id>/')
def order(order_id):
    return f"Order ID: {order_id}"
# 路由 `/order/123/` 匹配，`order_id` 的值为 `123`（整数）。

@app.route('/user/<uuid:user_id>/')
def user(user_id):
    return f"User ID: {user_id}"
#路由 `/user/550e8400-e29b-41d4-a716-446655440000/` 匹配，`user_id` 的值为 `UUID('550e8400-e29b-41d4-a716-446655440000')`。

@app.route('/user/<string:username>/')
def user_profile(username):
    return f"User: {username}"
# 路由 `/user/john/` 匹配，`username` 的值为 `"john"`。
```

需要说明:
1. **顺序匹配**  
   Flask <mark style="background: transparent; color: red">按注册路由的顺序进行匹配</mark>。<b><mark style="background: transparent; color: orange">动态路由可能会被更具体的路由覆盖</mark></b>。
   ```python
   @app.route('/user/<int:id>/')
   @app.route('/user/all/')
   ```
   访问 `/user/all/` 会优先匹配第二个路由。
2. **默认类型为 `string`**  
   如果未指定转换器，则变量默认类型为 `string`。
3. **捕获未匹配的路由** 
   使用转换器时，如果 URL 不符合规则，Flask 会返回 404 错误。

例如也可以如下方法, 结合多个转换器:
```python
@app.route('/blog/<int:year>/<string:title>/')
def blog(year, title):
    return f"Blog {year}: {title}"
```
- 路由 `/blog/2024/python-tutorial/` 匹配：
- `year` 为 `2024`（整数）。
- `title` 为 `"python-tutorial"`。

#### 2. 自定义路由转换器 
对于搜索关键词等等方面, 我们往往需要采用 search = "topic1+topic2"进行分割路由, 或者 & 分割路由; 

首先自定义理由转换器需要继承自 werkzeug.routing 的 BaseConverter 部分, 同时<mark style="background: transparent; color: red">需要设置 to_python 和 to_url 两个方法</mark>; 其中可以按需进行实现  (如果对参数进行特殊解析, 验证等等, 则必须对 to_python 进行定义, 如果需要对路由参数进行特殊的序列化或格式化（如拼接字符串、转义字符等），则必须定义 to_url)
```python
import typing as t
from werkzeug.routing import BaseConverter

class dynamic_router(BaseConverter):  
    def __init__(self, url_map, sep):  
        super(dynamic_router, self).__init__(url_map)  
        # self.regex = reg   # The Regulation  of the URL  
        self.separator = sep  
	# 用户访问路由时，Flask 会调用该方法，将 URL 参数转化后传递给视图函数。
	def to_python(self, value):
	    return value.split(self.separator)  # 分割字符串成列表
	# 使用 Flask 的 `url_for()` 函数生成 URL 时调用 
    def to_url(self, values: t.Any) -> str:  
        return self.separator.join( BaseConverter.to_url(value) for value in values)  

app.url_map.converters['dynamic'] = dynamic_router   # 直接在 Flask 应用的 `url_map.converters` 字典中注册了一个自定义的 URL 转换器 `dynamic_router`，并将其名称设为 `'dynamic'`
# app.add_url_rule('/<dynamic:dynamic>', view_func=hello_world)   直接在 Flask 应用的 `url_map.converters` 字典中注册了一个自定义的 URL 转换器 `dynamic_router`，并将其名称设为 `'dynamic'`, 
# 第二句实际上创建了一个具体的路由，如 `/value1,value2/`，并将请求分派给 `hello_world`。
```

一个更加完整的实现示例如下所示:
```python
from flask import Flask, url_for
from werkzeug.routing import BaseConverter

class DynamicListConverter(BaseConverter):
    def __init__(self, url_map, separator=','):
        super(DynamicListConverter, self).__init__(url_map)
        self.separator = separator

    def to_python(self, value):
        # 将 URL 中的值解析为列表
        return value.split(self.separator)

    def to_url(self, values):
        # 将列表转换为 URL 可用的字符串
        return self.separator.join(map(str, values))

app = Flask(__name__)
app.url_map.converters['list'] = DynamicListConverter

@app.route('/items/<list:values>/')
def show_items(values):
    return f"Values: {values}"   # 用于访问时解析分隔符分割的 url 部分

@app.route('/generate_url/')
def generate_url():
    url = url_for('show_items', values=[1, 2, 3])   # url_for 调用 to_url 方法, 根据参数生成 url 
    return f"Generated URL: {url}"

if __name__ == "__main__":
    app.run(debug=True)
```

#### 3.  路由和静态文件管理
对于一般 web 应用, 往往会提供静态文件服务, 主要包含 css 样式文件, JavaScript 脚本文件, 图片和字体等等静态资源文件等等; 对于 Flask 也支持静态文件访问, <mark style="background: transparent; color: red">首先需要在项目下创建 /static 目录</mark>, 并采用 `/static` 开头访问， 但是一般更多采用 Nginx 和 Web 服务器等等管理静态文件。

实际上默认的静态文件夹是 /static , 也可以在 app 中指定:

常见的其他有 templatefolder = ./template 等等

```python
app = Flask(__name__, static_folder = '/temp')   
url_for('static', filename='style.css')
# 此时可以通过访问 localhost:xxx/static/style.css 直接访问静态文件目录, url_for 也是生成这个路径
```

### (4) Http 方法, url 构造，跳转和重定向
#### 1. Http 方法简介
HTTP 方法包括如下几种(幂等表示相同数据，参数下， 执行一或者多次效果是相同的):
1. GET : 用于获取资源 (是幂等的)
2. HEAD : 想获取信息
3. POST 创建一个新的资源 
4. PUT : 完整地替换资源或者创建资源(有副作用, 但是是幂等的)
5. DELETE: 删除资源, 有副作用 , 但是是幂等的, 
6. OPTIONS : 获取资源支持的所有 HTTP 方法  
7. PATCH :  局部更新,  修改某个已有的资源

默认情况下, 路由仅回应 GET 请求, 而通过 app.route 传递 methods参数可以改变该行为:
```python 
@app.route('/login', methods=['GET','POST'])
```
其中如果存在 GET, 也会自动添加 HEAD 方法, 从 Flask 0.6 开始也实现了 OPTIONS  的自动处理.

请求头数据可以采用 request.headers.get 进行获取.

#### 2. 采用 url_for 构造 url
```python
from flask import Flask,url_for 
app = Flask(__name__)
@app.route('/item/1')
def item(id):
	pass  
	
with app.test_request_context():
	print(url_for('item', id='1'))     # 产生 /item/1/?id  = 1
	print(url_for('item', id=2,next ='/'))  # 产生 /item   
```

需要说明, 对于url 构建, 一般选用采用 url_for 构建的方案, 而不采用转义字符串方案, 并自动转义特殊字符以及 Unicode 数据等等。更加方便. <mark style="background: transparent; color: red">需要说明,  一般 url_for 内的部分会拼接起来, 而如果是请求, 则会用  ? 拼接起来</mark>

#### 3. flask 中的重定向
在 flask 中, 通过 flask.redirect 进行重定向, 默认重定向是 302  
```python
flask.redirect(location);   # 实际上默认状态码是 302
flask.redirect(location, code=303)  # 可指定状态码(301, 303,305,307)
```

例如, 指定多个路由和进行重定向设置:
```python
#coding = utf-8  
import typing as t  
from flask import Flask, request, abort, redirect, url_for  
import urllib  
from werkzeug.routing import BaseConverter  
  
app = Flask(__name__)  
  
@app.route('/hello')  
def hello_world():  
    name = request.args.get('name')   # 获取请求中 name 部分 的值 (实际上是在)  
    if name is None:  
        name = 'Guest'  
    print("get name:", name)  
    return f'Hello World,{name}'  
  
# 访问 http://127.0.0.1:8080/people?name=123 -> 重定向到 hello world 并传递请求参数  
@app.route('/people')  
def people():  
    _name = request.args.get('name')   # 获取请求中 name 部分 的值 (实际上是在)  
    return redirect(url_for('hello_world', name=_name))   # 构造请求并重定向(其中name会作为 request 参数直接被  request get 到)  
    # url_for 可以指定一个其他的函数进行重定向(如果是在 url_for 中指定, 则类似于传入参数 name = _name)

@app.route('/secret')  
def secret():  
    abort(404)   # 弹出 404 Not Found 界面  

@app.route('login', method=['GET', 'POST'])  
def login():  
    if request.method == 'POST':  
        user_id = request.form.get('user_id')    # 调用 request.form.get 获取表单数据  
        user_agent = request.headers.get('User-Agent')  # 调用 request.headers.get 获取请求头数据 (注意: 请求头数据是大小写不敏感的)  
        return f'user: {user_id}'  
    else:  
        abort(404)  
    return 'login'
  
if __name__ == '__main__':  
    app.run(host='0.0.0.0', port=8080)
```

也可以这样, 但是此时 name 会作为参数进行传递, 而不是作为请求参数添加进去(如果有则传参, 没有则作为 request 拼接)
```python
@app.route('/hello/<name>')
def hello_world(name):
    return f'Hello, {name}!'
@app.route('/redirect-to-hello')
def redirect_to_hello():
    return redirect(url_for('hello_world', name='Alice'))
```

#### 4. HTTP 中的 Request 请求和 Response 响应对象
对于 Request 部分,  最多用的方法有 GET 和 POST, 其中使用浏览器访问, 默认采用的请求方法是 GET 而不是  POST,  即访问页面默认采用 GET 访问。
```python
@app.route('/testlink', methods=['GET','POST'])  
def testlink():
	if request.method == 
```
但是, 当采用提交表单的情况下， 发送的是 POST 请求. 

Response 响应详解
对于视图函数(上面所定义 app.route 部分等等), 会转换为一个响应对象, 并从视图直接返回.
1. Return a **String**
When a view function returns a string, Flask automatically treats it as the response body, which is sent back to the client as the content of the response 
```python
@app.route('/') 
def hello_world(): 
	return 'Hello, World!'
```
(This is equivalent to returning `Response('Hello, World!')`, where Flask sets the status code to `200 OK` by default.)

2. Returning a **Tuple**
When a view function returns a tuple, Flask interprets the tuple in a specific way. The tuple can contain:

- The **response body** (such as a string or a list of headers),
- The **status code** (optional),
- The **headers** (optional).
The typical structure of the tuple is:
```python
@app.route('/custom_response_with_headers')
def custom_response_with_headers():
    return 'Custom Response', 200, {'X-Custom-Header': 'Some value'}
```

- Explanation of the Tuple Return Type
**First element** (`return_value`): The body of the response. This can be a string, HTML content, or JSON data, among other things.
**Second element** (optional, `status_code`): The HTTP status code of the response. If not provided, Flask defaults to `200 OK`.
**Third element** (optional, `headers`): A dictionary of headers you want to add to the response.

3. **JSON objects** (Flask will automatically convert them to a JSON response):
  ```python
  from flask import jsonify
  @app.route('/json')
  def json_response():
      return jsonify({'message': 'Hello, JSON!'})
  ```

4. **Response objects** (you can directly create a `Response` object for more control):
  ```python
  from flask import Response
  @app.route('/custom_response_object')
  def custom_response_object():
      return Response('Custom Response Body', status=200, headers={'X-Custom': 'Header'})
  ```

一般如果不是字符串或者元组, Flask 会假设是一个合法的 WSGI 应用程序, 并通过 Response.force_type(rv, request.environ) 进行转换为请求对象. 

另外, 可以采用 make_response  的方法 
```python
from flask import  make_response, 

@app.errorhandler(404)
def not_found(err):
	resp = make_response(
		render_template("eroor.html", 404)
	)
	return resp
```


```python
from flask import Flask, jsonify, request

app = Flask(__name__)

# Sample data to return in JSON format
data = {
    'message': 'Welcome to Flask!',
    'status': 'success',
    'items': [
        {'id': 1, 'name': 'Item 1'},
        {'id': 2, 'name': 'Item 2'},
        {'id': 3, 'name': 'Item 3'}
    ]
}

# Endpoint that returns a JSON response
# curl http://127.0.0.1:5000/api/data  -> get the reponse 
@app.route('/api/data', methods=['GET'])
def get_data():
    return jsonify(data)

# Endpoint that receives JSON and returns a response
# curl -X POST -H "Content-Type: application/json" -d '{"user": "Alice", "action": "login"}' http://127.0.0.1:5000/api/data  
@app.route('/api/data', methods=['POST'])
def post_data():
    # Get the JSON data sent in the request body
    received_data = request.get_json()
    
    # Process data (here, just echoing it back for demonstration)
    return jsonify({
        'message': 'Data received',
        'received_data': received_data
    }), 200  # HTTP 200 OK

if __name__ == '__main__':
    app.run(debug=True)
```

由于 request 的上下文在服务器上开始时会消失来保证性能, 
如果需要在 streamed_responses 中访问某个  request.args, 必须指定 streamed_with_context 装饰器, 具体如下:
```python
from flask import stream_with_context, request, Response

@app.route('/stream')
def streamed_response():
    @stream_with_context
    def generate():
        yield 'Hello '
        yield request.args['name']
        yield '!'
    return Response(generate())
```

### (5) Flask 核心依赖部分
#### 1. WSGI 工具 Werkzeug 
Flask 是一个<mark style="background: transparent; color: red">基于 Werkzeug 和 Jinja2 的微框架</mark>。
- Werkzeug 提供了 Flask 的 WSGI (Web Server Gateway Interface) 工具，包括请求、响应处理和路由机制。
- Flask 中许多底层功能都是通过 Werkzeug 实现的，例如：
  - 请求和响应对象 (`Request` 和 `Response`)
  - URL 路由匹配
  - 异常处理和调试器
  - 中间件支持
WerkZeug 是一个 WSGI (Web Server Gateway Interface) 网络应用程序库, 提供了底层 HTTP 功能和工具。提供以下的功能 : 
  - 请求/响应封装
  - URL 路由解析
  - HTTP 中间件
#### 2. 模板系统 Jinja2 
最常用的第三方模板系统是 Jinja2 和  Mako, 而 Flask 以
对于 jinja2 部分,  可以采用如下进行模板渲染 
```python
from jinja2 import Template, Environment  
  
template = Template("Hello, {{name}}!")  
print(template.render(name="123"))  
  
# 也可以采用下面部分进行实现:  
env = Environment()  
template = env.from_string("Hello, {{name}}!")  
template.render(namee="123")  

# 其中, Environment()是jinja2的模板环境, from_string()则是从字符串中创建模板, render()则是渲染模板  
# Environment 实例用于存储配置和全局对象, 以及处理全局变量和过滤器等
# 以下面一个模板为例, 采用 template 
template  = env.get_template("./hello.html")
template.render(name="123")   # 会自动替换其中的数据
```

对于 Vue 和响应 Flask 框架的结合, 我们一般采用统一返回 Json 数据的方法' 
**后端返回 JSON 数据**：
- 使用 `jsonify()` 将数据结构转换为 JSON 格式返回。
**前端通过 Axios 请求 API**:
Axios 库是用于发起 请求的 HTTP库 
- `axios.get()` 获取数据。
- `axios.post()` 提交数据。

其中主要的几种渲染标识符:
1.  `{# ... #}`  模板注释 
2. `{% ... %}`  执行 for 等循环语句 
3. `{{ ... }}`  表达式的结果输出到模板上

例如 
```html
<div>
<ul id ="nav-bar">
	{% for item in items %}
		<li> <a href="{{item.href}}">{{item.caption}}</a></li>
	{% endfor%}
</ul>
</div>
```

此外,  通过  `{% block blk1 %}` `{% endblock %}`  代码块可以定义出可以在子模板重载的模板。例如如下的内容 : 
```html title:base.html
<!DOCTYPE html>  
<html lang="zh">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>{% block title %}默认标题{% endblock %}</title>  
</head>  
<body>  
    <header>  
        <h1>我的网站</h1>  
    </header>  
    
    <main>  
        {% block content %}  
        <p>这是默认内容。</p>  
        {% endblock %}  
    </main>  
    
    <footer>  
        <p>版权所有 &copy; 2024</p>  
    </footer>  
</body>  
</html>
```

其中默认标题和默认内容可以进行重载， 示例代码如下: 
```html   title:index.html
{% extends "base.html" %}  

{% block title %}  
主页  
{% endblock %}  

{% block content %}  
    <h2>欢迎来到我的主页！</h2>  
    <p>这里是一些关于我的信息。</p>  
{% endblock %}
```
需要说明的是, 实际上如果前端采用 Vue 框架, 则可以很方便地进行重载
另外还有如下关键字， 均可以采用嵌入 Html 的 Python 语句 :
```python
{{ super() }}  #   表示先使用父类中的内容,  再基于此添加 CSS 样式 
{{% set a = 1 %}}   # 赋值语句
{{import 'header.html'}}  #   包含一个模板 ， 添加对应内容 
```

```html
{% macro hello(name) %}     # 定义宏模板
{endmacro} 

{% import  'base.html' as macro %} 
{% from 'base.html import  hello' %} 
```

## 二、Flask 视图类型
### (1) 即插视图和标准视图
标准视图必须继承自 flask.views.View, 同时<mark style="background: transparent; color: red">需要进行实现 dispatch_request</mark>, 用于解包对应的 request, 并返回相应的界面

在 Python 的 Flask 或类似框架中，当你使用 `**context` 解包字典传递参数到 `render_template` 时，`context` 中的每一个键值对都会作为模板中的变量可用。
```python
import flask  
from flask import Flask, request , render_template, abort  
from flask.views import View  
  
app =  Flask(__name__, template_folder='./templates')
  
class ViewPort1(View):  
    def dispatch_request(self):  
        if request.method == 'GET':  
            context = {  
                'name': 'John',  
                'age': 30  
            }  
            return self.render_template("Hello World", context)  
        else:  
            abort(404)  
  
    def render_template(self, template_name, context):  
        return render_template(self.get_template_name(), **context)  
  
    def get_template_name(self):  
        return 'view1.html'  
  
app.add_url_rule('/view1', view_func=ViewPort1.as_view('view1'))

if __name__ == "__main__" :  
    app.run(host='0.0.0.0', port=9000, debug=True)
```

首先, <mark style="background: transparent; color: red">需要在项目下面建立 templates 文件夹</mark>, 上述方法会在访问 view1.html 时, 导航到 templates 文件夹下的 view1.html 文件, 同时传入对应的参数. 例如 `./templates` 下, 采用如下的 html 文件接受参数:
```html
<!DOCTYPE html>  
<html lang="en">  
	<head>  
	  <meta charset="UTF-8">  
	  <title>Title</title>
	</head>  
	<body>  
	<h1> {{name}} </h1>  
	<p> {{age}} </p>  
	</body>  
</html>
```
![[attachments/Pasted image 20241119094515.png|250]]
此外, 如果想在 Python 代码中访问 `context` 中的变量（例如在视图逻辑中），则可以直接使用字典的方法，比如:
```python
some_value = context.get('some_key')
```
另外也可以循环渲染:
```html
<ul>
	{% for item in items %}
		<li>Item: {{ item }}</li>
	{% endfor %}
</ul>
```
- `items` 会被用来生成一个列表，其中 `item` 是在 `for` 循环中访问每个元素。
### (2)  调度方法视图和 url 调度方法的类封装
 flaskview.MethodView 是一种基于类的视图  (Class-Based Views, CBV) ,  <b><mark style="background: transparent; color: orange">实际上是对于每个 Http 方法, 会执行不同的函数</mark></b>, 相应的, <b><mark style="background: transparent; color: orange">在继承 MethodView 所获得的调度方法视图中</mark></b>, 可以定义包括 `get`, `post`, `put`, `delete` 等等方法 (参考[[#1. Http 方法简介]]).

<b><mark style="background: transparent; color: orange">调度方法视图 MethodView 允许将路由处理逻辑组织到类中，而不是函数，从而更容易管理复杂的应用逻辑</mark></b>，尤其是需要处理多种 HTTP 方法时。 例如一个路由除了GET, POST 方法等等, <mark style="background: transparent; color: red">就不需要通过多个 if 判断方法，提高可读性</mark>，提供 RESTful 风格的路由支持

同时, `MethodView` 是基于类的，可以<mark style="background: transparent; color: red">利用类继承和组合来复用代码。也可以通过动态 URL 参数与类视图结合</mark>， 可以为特定方法添加装饰器或钩子，而不会干扰其他方法。例如 : 
```python
class UserAPI(MethodView):
    @require_auth
    def get(self):
        return "Protected GET"

    def post(self):
        return "Public POST"
```

例如**采用如下的调度方法视图**, 最简单的逻辑是 return jsonify, 而下面给出了一个比较完整的整体按照decorator 的验证用户名和密码的示例,  最终通过  `app.add_url_rule(view_func=viewfun.as_view())` 将这些方法绑定到路由部分。 

```python
from flask import Flask, request, render_template, jsonify, session, redirect, url_for, g, abort  
from flask.views import MethodView  

app = Flask(__name__)  
app.secret_key = 'your_secret_key'  # Required for session management  

# Mock user database
users = {
    "john": "password123",  
    # Username: Password  
}

# Simulate a logged-in user by setting g.user  
@app.before_request  
def load_user():  
    g.user = session.get('user')

# Decorator for user authentication  
def user_required(f):  
    def decorator(*args, **kwargs):  
        if not g.user:  
            return jsonify({"error": "User not logged in"}), 403  # Use 403 Forbidden for not authenticated  
        return f(*args, **kwargs)  
    return decorator  

class UserAPI(MethodView):
    decorators = [user_required]
    def get(self, user_name, user_age):  
        return jsonify({  
            'name': user_name,  
            'age': user_age  
        })

@app.route('/login', methods=['GET', 'POST'])
def login():  
    if request.method == 'POST':
        username = request.form['username']   #  实际上是获取 login.html 中的 username名字为 username 的 form 
        password = request.form['password']   #  获取表格中的 password 部分,

		# 检查对应的字典, 检查login密码是否在数据库中
        if username in users and users[username] == password:    
            session['user'] = username  # Save user in session  
            return redirect(url_for('user_api', user_name=username, user_age=30))  # Redirect to user API with example age  
        return "Invalid credentials", 401  
    return render_template('login.html')  # Render a login form  

@app.route('/logout')  
def logout():  
    session.pop('user', None)  # Remove user from session  
    return "Logged out", 200  

app.add_url_rule('/usr/<user_name>/<int:user_age>', view_func=UserAPI.as_view('user_api'))  

if __name__ == '__main__':  
    app.run(debug=True)
```

对应的 login.html 示例代码如下, 实际上需要返回 render_template 来渲染界面, 而实际上我们可以用前端 vue 框架传递数据到后端 flask 框架上进行实现。 
```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Login</title>  
</head>  
<body>  
    <h2>Login</h2>  
    <form method="POST">  
        <div>  
            <label for="username">Username:</label>  
            <input type="text" id="username" name="username" required>  
        </div>  
        <div>  
            <label for="password">Password:</label>  
            <input type="password" id="password" name="password" required>  
        </div>  
        <button type="submit">Login</button>  
    </form>  
</body>  
</html>
```
访问 http://127.0.0.1:5000/usr/1/2 时, 如果已经验证登录成功, 可以得到相应 json 数据.

需要说明的是, 对于基于类的 View 对象(即 class-based-views), 方法一是直接采用 add_url_rule 进行导航, 而不是采用修饰器 @ 语法进行 

### (3) 蓝图 BluePrint 
对于蓝图, 通常用于相同 url 前缀(如 user/:id, user/profile 等地址导航), 往往应用于网页应用的模块化, 从而使应用层次更加清晰. 
给出一个示例如下: 其中, 每个模块, 都会暴露全局变量 bp, 主程序通过 import 相应的模块, 并采用 register 调用其 bp 参数, 就可以将该部分封装为一个模块.
```python
from flask import Flask, request, render_template, Blueprint  
  
bp = Blueprint('blueprint_view',  
               __name__,  
               url_prefix='/user',  
               template_folder='../templates')  
  
@bp.route('/')   # http://127.0.0.1:5000/user/  
def index():  
    return 'User Blueprint Index page'
```

```python title:调用blueprint的主程序部分
from flask import Flask  
import blueprint_view  
  
app = Flask(__name__)  
app.register_blueprint(blueprint_view.bp)   # 注册 blueprint 蓝图到 app  
if __name__ == '__main__':  
    app.run(debug=True)
```
此时在 app 中访问对应的 /user 即可得到对应的 Index page 响应

```python
app.config['SERVER_NAME'] = '127.0.0.1:5000'
@app.url_processor
def get_site(endpoint, values):
	g.site =  values.pop('subdomain')

@app.route('/', subdomain='<subdomain>'
def index():
	return g.site

	
```

## 三、Flask 运行和命令行接口添加
### (1) 配置环境变量和 Flask 运行
首先, 需要设置  FLASK_APP 环境变量到 Flask 应用主文件夹, 此时，例如应用文件是 app.py (一般都采用app.py) 则: 
1. 在 Linux 或者 macOS 中: 设置环境变量:
```sh
export FLASK_APP=app.py
```
2. windows 中: 设置环境变量: 
```sh
set FLASK_APP=app.py
```
然后动过如下命令启动 flask shell: 
```sh
flask shell
```
可以通过如下命令运行 flask App  
```sh
flask run -h 127.0.0.1 -p  9000
```

### (2) Flask 命令行接口与 Python标准字符串模板的使用

需要说明的是, <b><mark style="background: transparent; color: orange">flask 的命令行是通过 click 实现的, 实际上 import click 即可flask 的命令行是通过 click 实现的, 实际上需要  import click, 然后采用 @app.cli.command("cmd name") 的方法为命令行接口添加命令:</mark></b>  

```python
import click
from flask import Flask
from flask.cli import with_appcontext

# 创建 Flask 应用
app = Flask(__name__)

# 自定义 CLI 命令
@app.cli.command("initdb", short_help="Initialize the database.")
@click.option('--msg', default="Database initialized.", help="Message to display after initialization.")
@click.option('--verbose', is_flag=True, help="Enable verbose output.")
@with_appcontext
def initdb(msg, verbose):
    """
    Initialize the database. This command sets up the database schema
    and optionally outputs a message.
    """
    # 模拟数据库初始化逻辑
    click.echo("Initializing the database...")

    if verbose:
        click.echo("Verbose mode is enabled. More details will be shown.")
    
    # 输出用户定义的消息
    click.echo(msg)


# 带参数的命令
@app.cli.command("adduser", short_help="Add a new user.")
@click.argument('username')  # 必须参数
@click.option('--email', default=None, help="The user's email address.")
@with_appcontext
def adduser(username, email):
    """
    Add a new user to the database. Requires a username and optionally an email address.
    """
    click.echo(f"Adding user '{username}' to the database.")
    if email:
        click.echo(f"Email: {email}")
    else:
        click.echo("No email provided.")

# `@app.cli.command`: 用于创建自定义命令。
# `click.argument`：定义必需的命令参数。
# `click.option`：定义可选参数或标志，支持默认值、帮助信息等。
#is_flag=True ：标识布尔标志（无参数时值为 `True`，否则为 `False`）-> 如果设置为 False , 则有参为 False 
# 多参数和装饰器的组合
@app.cli.command("config", short_help="Display or modify configuration settings.")
@click.argument('key')  # 必须参数
@click.argument('value', required=False)  # 可选参数
@click.option('--show', is_flag=True, help="Display the current value of a configuration key.") 
@with_appcontext
def config(key, value, show):
    """
    Display or update a configuration setting.
    """
    if show:
        click.echo(f"Current value for '{key}': [Simulated Value]")  # 模拟读取配置
    elif value:
        click.echo(f"Setting '{key}' to '{value}'.")
    else:
        click.echo("You must provide a value or use --show to display the current setting.")

if __name__ == "__main__":
    # 开发环境中运行应用
    app.run(debug=True)
```

此时可以采用 inidb 命令
```python
flask initdb --msg "message"
flask adduser JohnDoe --email john@example.com
flask config SECRET_KEY --show    # 显示某个配置键值 
flask config  SECRET_KEY 12345  # 采用 value 可选参数 (required = False) 
```

> [!caution] 关键字补充 
> 对于使用 app 关键字的部分, 需要加上 with_appcontext 装饰器, 

视图函数直接返回文本显然一般项目是不需要用到的，对于 HTML 代码部分,  我们可以采用 string.Template 提供的**标准字符串模板进行字符串部分替换等操作**。   但是就 Template 本身而言,  **不能够写控制语句, 并且无法继承重用**。
```python
from string import Template

s = Template('$This is a $duck')
s.safe_substitute(This ='That',duck='dog')
```
参考 Template 源码: 
```python
class Template:  
    """A string class for supporting $-substitutions."""  
  
    delimiter = '$'  
    # r'[a-z]' matches to non-ASCII letters when used with IGNORECASE, but  
    # without the ASCII flag.  We can't add re.ASCII to flags because of    # backward compatibility.  So we use the ?a local flag and [a-z] pattern.    # See https://bugs.python.org/issue31672    idpattern = r'(?a:[_a-z][_a-z0-9]*)'  
    braceidpattern = None  
    flags = _re.IGNORECASE
```
可以自定义如下的 template 类:
```python


# 重定义 Template 对象:
class MyTemplate(Template):
	deliminator ="#"
	idpattern = r'([a-z]+\.[a-z]+)'   # 必须符合模式才能够被替换
```

## 四、MySQL 数据库调用概述
### (1) mysql-connector 直接操作数据库
使用 `pip install mysql-connector-python` 可以使用 mysql  语句进行直接的操作。
```python
import mysql.connector  
  
databaseName = "web_users"  
  
conn = mysql.connector.connect(  
    host="localhost",  
    user="friedparrot",  
    password="12345",  
    database=databaseName  
)
# test conn success  
if conn.is_connected():  
    print("Connected to MySQL database")  
    cursor = conn.cursor()  
    result = cursor.execute(  
        """  
        SELECT * FROM table_test1;       
         """
	) # get current database  
    print(cursor.fetchall())  
    conn.close()
```

要从查询中获取结果，你需要调用 `fetchone()`、`fetchmany()` 或 `fetchall()`。

| 库                      | 特点                                | 适用场景                      |
| ---------------------- | --------------------------------- | ------------------------- |
| mysql-connector-python | 官方支持，稳定可靠，原生驱动，性能较高。              | 偏向需要直接操作数据库的开发者。          |
| PyMySQL                | 纯 Python 实现，无需 C 扩展，跨平台方便，社区支持活跃。 | 需要跨平台或避免依赖编译的场景。          |
| Flask-MySQLdb          | 轻量级 Flask 集成，简单易用，依赖 MySQLdb。     | 偏向轻量项目且熟悉 MySQLdb 驱动的开发者。 |
| SQLAlchemy             | 支持 ORM，提供高级查询能力和模型管理，适配多种数据库。     | 推荐用于中大型项目，尤其是复杂业务逻辑。      |

实际上,  我们更多采用以下常用的语句结构，使用如下的 try.... catch 结构 with 即可保证事务不执行成功即回滚， 执行成功则提交。
Mysql 中, InnoDB 引擎支持事务操作, 而 MyISAM 引擎不支持事务操作, 
```python
if conn.is_connected():
    print("Connected to MySQL database")
    try:
        with conn.cursor() as cursor:
            cursor.execute(
                """
                INSERT INTO table_test1 (name, value) VALUES ('NewName', 123);
                """
            )
            # 提交事务
            conn.commit()
            print("Data inserted successfully.")
    except Exception as e:
        # 如果发生异常，回滚事务
        conn.rollback()
        print(f"An error occurred: {e}")
    finally:
        conn.close()
```

### (2)  ORM 概念及SQLAlchemy框架基础 
ORM (Objective Relation Mapping), 即对象关系映射, 通过直接采用 Python-tutorialon 类的方法，将表映射成类， 可以不采用原生 SQL 语句的情况下, 将类和实例的操作转换为SQL 语句进行， 同时可以减少损耗和减轻复查询的负担。
**特点**：
- 将数据库表映射为类，记录映射为类的实例。
- 允许以对象操作的方式执行增删改查操作。
- 自动生成和优化 SQL 查询。
- 可移植性, 可以几乎无缝切换 SQLite  等等数据库,  能够实现多框架支持。

SQLAlchemy, Django ORM,Peewee  都是比较常用的 ORM 框架, SQLAlchemy 可在 ORM 模式和直接 SQL 模式之间自由切换。 示例代码如下 : 
```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

engine = create_engine('mysql+mysqlconnector://user:password@localhost/mydatabase')
Session = sessionmaker(bind=engine)
session = Session()

# 添加新用户
new_user = User(name="Alice")
session.add(new_user)
session.commit()
```

对于Sqlalchemy,  即使是采用原生的 sql, 结果也需要通过返回值获取， 而不需要执行 fetchone 或者 fetch all 等等。同时 flask 也提供了 Flask-SQLAlchemy  框架， 只需 `pip install Flask-SQLAlchemy` 即可。
```python
from sqlalchemy import create_engine

eng = create_engine("....")
with eng.connect() as conn: 
	res1 = conn.execute("test sentence1"); 
	print(res1)
```

##  五、Flask 日志和上下文
### (1) 慢查询日志记录方法 
 Flask 中的日志对象可以采用 `app.logger` 进行访问, 对于采用sqlarchemy 日志部分, 需要采用 `SQLARCHEMY _RECORD_QUERIES` 宏. 
 
 结合 python 标准库 logging 库,  采用 `app.logger.addHandler` 方法添加日志输出句柄,   常用的有 StreamingHandler(用于输出到控制台), FileHandler, NullHandler, RotatingFileHandler 等等。

对于  Logging 部分, 日志默认是输出到 控制台的, 但是如果希望让其全部输出到某个文件, 
通过 AddHamdler 可以将
```python
import logging  
import logging.config  
from logging.handlers import RotatingFileHandler  
import flask_sqlalchemy as fksql  
from flask import Flask, request, jsonify, Blueprint
```


需要说明, `logging.basicConfig` 的配置与 `RotatingFileHandler` 的配置可能存在冲突，导致日志只输出到控制台。因此需要 删除 baseConfig 相关配置

以下代码给出了一个访问 testlink 后请求数据库, 并且当执行时间 > 0.01s 时,  会将日志记录到 /logs/log_test.log 中 (其中通过从 `from sqlalchemy import event` 对应的 `event.listen` 方法,  进行查询前后的逻辑编写和输出到文件)

另外, 建议使用 app.logger.warning, 不用 logging .warning 
```python
import logging  
import logging.config  
import time  
from logging.handlers import RotatingFileHandler  
import flask_sqlalchemy  
from flask import Flask, request, jsonify, Blueprint  
from sqlalchemy import create_pool_from_url, create_engine, event  
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean, func, or_, and_  
from sqlalchemy.orm import sessionmaker, Session  
from flask_sqlalchemy import SQLAlchemy  
from sqlalchemy.ext.declarative import declarative_base  
  
# 创建 app, 并设置 Logging 信息  
app = Flask(__name__)  
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymsql//.....'  # 数据库 URL 配置  
app.config['DATABASE_QUERY_TIME_OUT'] = 0.01  
app.config['SQLALCHEMY_RECORD_QUERIES'] = True  
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False       # 关闭 sqlalchemy 的修改追踪功能  
  
db = SQLAlchemy(app)  # 创建 SQLAlchemy 的数据库对象 并绑定到 app  
# 进行 logging 配置, 配置日志输出等级和格式  
handler = RotatingFileHandler('./logs/log_test.log', maxBytes=5* 1024 * 1024, backupCount=10)  # 5MB maximum  
handler.setLevel(logging.INFO)   # 正常的部分会作为 info 进行输出  
handler.setFormatter(logging.Formatter('[%(levelname)s]:- %(asctime)s - %(message)s'))  
app.logger.addHandler(handler)   # 将 logger  绑定到 app.logger 部分  
logger = logging.getLogger()  
logger.addHandler(handler)  # 将全局 logger 重定向到文件  
logger.setLevel(logging.DEBUG)  # 全局日志输出到文件  
  
class UserInfo(db.Model):  
    __tablename__  = 'user-info'   # 指定表名字  
    id = db.Column(db.Integer, primary_key=True, name='id')    # 其中的  id 字段属性 (name 不指定则采用变量名代替)  
    name = db.Column(db.String, primary_key=True, name='name') # 其中的  name 字段属性  
    def __repr__(self):  
        # representation of the printf return value  
        return f"<UserInfo(name={self.name})>"  
  
# 事件处理器,  用于实现事件监听机制 , 在执行查询语句之前, 记录下开始时间  
def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):  
    context._query_start_time = time.time()  

def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):  
    total_time = time.time() - context._query_start_time # 计算查询时间  
    if total_time > app.config['DATABASE_QUERY_TIME_OUT']:  
        app.logger.warn(msg=f"Executing query: {statement}, spend time: {total_time}")
  
# 采用 app 的上下文, 获取 app 的数据库会话对象并建立 query
def init_database():  
    with app.app_context():  
        db.create_all()  # 创建数据库表  
        event.listen(db.engine, 'before_cursor_execute', before_cursor_execute)  # 监听在执行查询语句之前的操作  
        event.listen(db.engine, 'after_cursor_execute', after_cursor_execute)  # 监听在执行查询语句之后的操作  
        print("Database initialized")  
  
def get_user():  
    with app.app_context():  
        r = db.session.query(UserInfo).all()  # 查询所有数据, 即 select * from user-info        return r  

# 使用测试路由, 只要访问测试路由, 就会触发数据库查询  
@app.route('/testlink', methods=['GET','POST'])  
def testlink():  
    if request.method == 'GET':  
        res = {}  
        usrinfo = get_user()  
        for info in usrinfo:  
            print(f"{info.name} : {info.id}")  # 按照类访问对应的对象  
            res[info.name] = info.id  
        return res  
    else:  
        return "POST"  
  
# db.session.add(user)  
# db.session.commit()  
  
if __name__ == "__main__":  
    init_database()  
    app.run(debug=True)
```

生成如下的日志信息 : 
```python
[INFO]:- 2024-12-03 17:08:58,272 - [31m[1mWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.[0m  
 * Running on http://127.0.0.1:5000  
[INFO]:- 2024-12-03 17:08:58,273 - [33mPress CTRL+C to quit[0m  
[INFO]:- 2024-12-03 17:08:58,274 -  * Restarting with stat  
[WARNING]:- 2024-12-03 17:09:00,531 -  * Debugger is active!  
[INFO]:- 2024-12-03 17:09:00,538 -  * Debugger PIN: 623-640-508  
[INFO]:- 2024-12-03 17:09:20,546 - 127.0.0.1 - - [03/Dec/2024 17:09:20] "[33mGET / HTTP/1.1[0m" 404 -  
[WARNING]:- 2024-12-03 17:09:28,776 - Executing query: SELECT `user-info`.id AS `user-info_id`, `user-info`.name AS `user-info_name`   
FROM `user-info`, spend time: 0.18616557121276855  
[INFO]:- 2024-12-03 17:09:28,944 - 127.0.0.1 - - [03/Dec/2024 17:09:28] "GET /testlink HTTP/1.1" 200 -
```
### (2) Flask 中的 Context 上下文使用  
#### 1. Thread Local 概念
首先介绍<b><mark style="background: transparent; color: orange">本地线程(Thread Local) 的概念</mark></b>: 参考[[📘ClassNotes/⌨️Programming/🐍Python/⛳Python 进阶与软件架构设计相关/5. Python 多线程, 协程和异步编程|5. Python 多线程, 协程和异步编程]] 实际上不同线程状态不同, 相互独立。
由于  `using global variables in Python web applications is not thread safe;` 所以 werkzeug, 提供了一个独立的本地线程包 `werkzeug.local.Local` 类。 相对于 threading.local 部分 : 
1. 采用  `__storge__` 保存不同线程下的状态 
2. 提供了释放本地线程的 `release_local` 方法 
3. 优先选用 greenlet 获取 get_ident 函数 (<mark style="background: transparent; color: red">用于获得线程或协程的标识符</mark>),

此外， 提供了 LocalStack 和 LocalProxy部分,  提供栈结构和代理模式。 

其中,**`LocalStack`** 是一个线程安全的堆栈，允许不同线程各自拥有独立的数据，在 Flask 中，用于存储与请求相关的上下文。**`LocalProxy` 是一个代理对象，动态地从线程本地的 `LocalStack` 中获取对象**。==代理使得可以直接使用 `request` 等对象，而无需手动管理堆栈数据==。

#### 2. request 的线程隔离逻辑和参数访问
对于 flask 的 request 对象, 实际上是获取一个 `_request_ctx_stack` 的栈顶对象的 LocalProxy 实例， 背后依赖于 `werkzeug.local.LocalStack` 以实现线程隔离。它是通过将请求相关的数据存储在线程本地（thread-local）的堆栈中，从而确保每个线程的请求数据是互相独立的。Flask 的 `request`、`session` 等对象都基于 `LocalProxy`，极大地简化了请求处理逻辑。

因此,  网页的运行逻辑是  :  
1. 用户访问产生请求
2. 请求到来时，Flask 会将请求上下文（`RequestContext`）推入 `LocalStack` 为本地的堆栈部分。
3. 当视图函数中调用 `request` 时，通过 `LocalProxy` 从栈顶获取上下文数据。

在 Flask 的源码中，`_request_ctx_stack` 是核心组件，它管理 `RequestContext` 的栈。通过 `LocalProxy` 代理访问当前线程的 `RequestContext`，使得我们可以直接用 `request` 对象完成操作，  **在 Flask 的源码中，`_request_ctx_stack` 是核心组件，它管理 `RequestContext` 的栈**。通过 `LocalProxy` 代理访问当前线程的 `RequestContext`，使得我们可以直接用 `request` 对象完成操作而无需感知底层细节。

因此, 每个视图实际上不需要加入 request 参数, 而可以在视图函数中全局使用这个 request 部分 :
```python
from flask import request, Flask 
app = Flask(__name__)

@app.route('/test1')
def test1() : 
	name = request.args.get('name') 
```

给出如下的 LocalStack 和  LocalProxy 使用的相关代码讲解部分, 实际上  flask 自动地将请求 request 对应的部分进行入栈,    尽管不同的请求在不同线程中运行（或在异步框架中在不同协程中运行），栈仍然能够为每个线程管理各自的请求上下文。**这是因为`LocalStack`是特定于线程的，每个线程有自己独立的栈空间**。

至于使用栈的原因， 是由于**在Web框架中，每个请求可能会在多个层次上被处理  (例如，路由、视图、请求钩子等)。这会涉及到多个功能组件**，而栈结构恰好符合FFL（后进先出）特性，便于在请求处理过程中管理上下文的入栈和出栈。例如在身份验证中,  需要等待身份验证部分 (后进) 完成之后, 弹出对应的栈顶对象,  直到每一层都弹出完毕, 则请求结束。

```python
from flask import Flask, request
from werkzeug.local import LocalStack, LocalProxy

app = Flask(__name__)

# 模拟一个 LocalStack
_request_ctx_stack = LocalStack()

# 使用 LocalProxy 实现的 request 对象
request_proxy = LocalProxy(lambda: _request_ctx_stack.top)

@app.before_request
def push_request_context():
    """
    请求到来时，模拟 Flask 将请求上下文推入 LocalStack。
    """
    ctx = {"method": request.method, "path": request.path, "args": request.args}
    _request_ctx_stack.push(ctx)

@app.after_request
def pop_request_context(response):
    """
    请求完成后，清理栈顶对象。
    """
    _request_ctx_stack.pop()
    return response

@app.route('/hello', methods=['GET'])
def hello_world():
    """
    使用 request_proxy 访问请求数据。
    """
    method = request_proxy['method']  # 通过 LocalProxy 获取 method 参数 
    path = request_proxy['path']             # path 参数 
    name = request.args.get('name', 'World') # World 是默认参数, 如果没有获取到,  则采用 World 
    return f"Hello, {name}! You accessed {path} using {method}."

if __name__ == '__main__':
    app.run(debug=True)
```

#### 3. Flask 中的 Context 使用 
在 Flask 中有两个重要的上下文概念:  <b><mark style="background: transparent; color: orange">应用上下文</mark></b> (app.app_context() )  和<b><mark style="background: transparent; color: orange">请求上下文</mark></b> (request_context部分) 

使用 Context 是用于 缓存一些发生请求之前使用的资源的情况,  包括生成数据库链接和缓存部分对象等等。  

- **请求上下文（Request Context）**: 在Flask中，请求上下文包含了与当前请求相关的信息（例如：请求方法、请求路径、请求参数等）。Flask通过`request`对象来提供这些信息, 参考[Request Hooks](https://flask.palletsprojects.com/en/latest/reqcontext/#request-hooks) 部分。
- **应用上下文是在推入请求上下文的过程中生成的**,  而请求结束时也会将请求上下文弹出 

在 Flask 中, <b><mark style="background: transparent; color: orange">有4 个上下文变量</mark></b> : 
1. `flask.current_app` : 应用上下文，实际上是当前 app 的实例对象, 
2. `flask.g` : 应用上下文,  <mark style="background: transparent; color: red">在处理请求时 , 作为临时存储的对象</mark>。
3. `flask.session` :  请求上下文，存储了客户端的会话信息 
4. `flask.request` :  请求上下文，存储和封装了客户端发出的 HTTP 请求的内容 

所有的 request 必须在 request 的上下文中进行, 否则会产生 `RuntimeError: Working outside of request context.` 错误。

需要说明的是,  在 Flask 中，**`session` 对象主要用于在不同的请求之间存储用户的临时信息**。它是**基于客户端的存储机制**，默认使用 **签名的 Cookie** 来存储数据，这意味着**存储在 `session` 中的信息是安全的，只要你的密钥没有泄漏**。 

一般地, Flask 中的 session 一般用于存储:  
- **用户认证信息**：存储登录状态、用户 ID 或角色信息。
- **跨请求的临时数据**：如分页信息、购物车内容。
- **临时配置项**：如用户选择的语言偏好。

安全性 : 
- **签名的 Cookie**：`session` **使用 Flask 的 `SECRET_KEY` 对内容进行签名，防止被篡改。未签名的或伪造的内容会被拒绝**。
- **敏感信息**：不要直接在 `session` 中存储密码或信用卡号等敏感数据，改为存储其标识符（如用户 ID），实际数据应存储在服务器端数据库中。

```python
import flask  
from flask import Flask, request, render_template, redirect, url_for, session, flash, abort, Response  
from flask import request  
from werkzeug.local import LocalProxy, LocalStack  
from functools import partial  
from flask_sqlalchemy import SQLAlchemy  
  
_request_ctx_stack = LocalStack()  
  
request_proxy = LocalProxy(lambda: _request_ctx_stack.top.request)  

app = Flask(__name__, template_folder="./templates", static_folder="./static")
  
app.config.update({  
    "SQLALCHEMY_DATABASE_URI": "sqlite:///test.db",  
    "SQLALCHEMY_TRACK_MODIFICATIONS": False,  
    "SECRET_KEY": "secret_key"  
})  
  
db = SQLAlchemy()   # 创建了一个没有绑定到任何 Flask 应用上的 SQLAlchemy 实例  
db.init_app(app)    # 绑定 SQLAlchemy 实例到 Flask 应用上  


def get_current_user():  
    return session.get("user_id")  # 获取当前用户
	# 实际带数据库中, 我们一般采用 User.query.all() 获取对应结果。

@app.before_request  
def before_request():  
    g.user =  get_current_user()  
  
class User(db.Model):  
    name = db.Column(db.String(80), unique=True, nullable=False)  
    password = db.Column(db.String(80), nullable=False)  

@app.before_first_request()  
def create_tables():  
    db.drop_all()    # 删除所有表  
    db.create_all()  
  
    db.session.add_all([  
        User(name="admin", password="admin"),  
    ])  
    db.session.commit()   # 提交事务  

@app.context_processor()
def context_processor():
	return {'current_user': g.user}  # 在 context_processor 上下文处理中返回 current_user  

@app.teardown_appcontext():
def teardown(): 
	db.session.remove() 
	g.user = None  # 每次请求完毕之后, 重置 user 信息 

@app.errorhandler  
def page_not_found(e):  
    return render_template("404.html"), 404
```

其中:  我们可以采用  `g.user =  get_current_user()  ` ==获取对应的 flask 应用上下文, 而一般采用在 before_request 中对此进行数据的填充==。  
另外, app.context_processor 也可以为所有模板注入共享数据, 即认为是全局变量，并可以跨模板使用， 这样就可以直接在模板中使用对应的全局变量了(除了 g, session, request 和 current_app 以外, 注册其他类似的全局变量) 

此外, 可以采用  LocalProxy 创建当前线程的全局变量, 并在线程中进行使用 ; 
```python
from werkzeug.local import LocalProxy 
current_user = LocalProxy(get_current_user)   # 将函数执行结果的返回值存储为 LocalProxy 

@app.context_processor()
def context_processor():
	return {'current_user': g.current_user}    # 此时可以使用 current_user 变量而保证不被上下文污染 -> 同时访问的是函数返回的对象
```


对于在 网页页面读取源文件， 最简单的方法是采用 SharedDataMiddleWare 方法, 即: 
```python
from werkzeug import SharedDataMiddleWare 
```

对于短链接页,  尤其是在网页上存储文件时, 例如采用哈希值存储对应的文件，而由于哈希值太长,  支持采用短链接方法进行访问。
![400](https://i-blog.csdnimg.cn/direct/a86772d4993a48fc97dafb32efd2a9bc.png)
```python
import short_url 
```

å¦‚æœåœ¨VSCode ä¸­è¿›è¡Œæ‰“å¼€ç¨‹åºå¹¶ä¸”çƒ§å½•çš„è¯ï¼Œ è·¯å¾„ä¸­ä¸èƒ½æœ‰ä¸­æ–‡
å¯¼å…¥åå‡ºç°ä¹±ç ï¼Œ åˆ™é€‰æ‹©Encoding GB-2312ï¼Œ åˆ™å¯ä»¥æ­£å¸¸æ˜¾ç¤ºä¸­æ–‡
![[attachments/Pasted image 20240407204721.png]]
ç„¶åé€‰æ‹© Save With Encoding > UFT-8, åˆ™å†æ¬¡æ‰“å¼€ä½¿ç”¨UTF-8å³å¯æ­£å¸¸æ˜¾ç¤ºã€‚ 
ä¿®æ”¹Core ä¸­ä¸ºmd.s,å¹¶æ·»åŠ å®å®šä¹‰
![[attachments/Pasted image 20240407204951.png]]
åœ¨ æç¤ºç¼ºå°‘int çš„å‡½æ•°åŠ ä¸€ä¸ªvoidè¿”å›å€¼, ç„¶åæ›´æ”¹ä¸ºstlink å³å¯çƒ§å½•

ä¸‹å›¾æ˜¯ä¸€ä¸ªç¤ºä¾‹ç¨‹åºï¼Œ è€Œç›¸åº”åœ°å¯¹åº”çš„æ–¹æ³•æ˜¯å…ˆSetReigon, å†WriteDataè¿›å»çš„;
```cpp
void showimage(const unsigned char *p) //æ˜¾ç¤º40*40 QQå›¾ç‰‡
{
  	int i,j,k; 
	unsigned char picH,picL;
	dsp_single_colour(WHITE); //æ¸…å±  
	
	for(k=0;k<3;k++)
	{
	   	for(j=0;j<3;j++)
		{	
			Lcd_SetRegion(40*j,40*k,40*j+39,40*k+39);		//åæ ‡è®¾ç½®
		    for(i=0;i<40*40;i++)
			 {	
			 	picL=*(p+i*2);	//æ•°æ®ä½ä½åœ¨å‰
				picH=*(p+i*2+1);				
				LCD_WriteData_16Bit(picH<<8|picL);  						
			 }	
		 }
	}		
}
```


ä¸‹é¢çš„ç¨‹åºç»™å‡ºäº†ä¸åŒä¸¤ä¸ªæ–¹æ³•è¿›è¡Œå­—åº“ (ç›´æ¥ä½¿ç”¨SetRegionä¹‹åå±€éƒ¨å¡«å……å³å¯,  æ²¡å•¥éš¾åº¦)
```cpp æ±‰å­—å–æ¨¡ä¾‹ç¨‹
//é‡‡ç”¨è®¾ç½®çª—å£æ–¹æ³•å¡«å……å­—åº“æ•°æ®ï¼Œç›¸æ¯”Gui_DrawFont_GBK16æ›´å¿«é€Ÿ
void Fast_DrawFont_GBK16(uint x, uint y, uint fc, uint bc, uchar *s)
{
	unsigned char i,j;
	unsigned short k;
	uint HZnum;
	HZnum=sizeof(hz16)/sizeof(typFNT_GBK16);
	while(*s) 
	{	
		if((*s) >= 128) 
		{		
			for (k=0;k<HZnum;k++)    // HZnum : æ±‰å­—æ•°é‡
			{
			  if ((hz16[k].Index[0]==*(s))&&(hz16[k].Index[1]==*(s+1)))
				{ 	Lcd_SetRegion(x,y,x+16-1,y+16-1);
				    for(i=0;i<16*2;i++)
				    {
						for(j=0;j<8;j++)
				    	{
							if(hz16[k].Msk[i]&(0x80>>j))	LCD_WriteData_16Bit(fc);
							else 
							{
							if (fc!=bc) LCD_WriteData_16Bit(bc);
							}
						}
					}
				}
			}
		s+=2;x+=16;
		}
	}		
}		
		else
		s+=1; 
		
	}
}
//æ­¤æ–¹æ³•æç»˜æ±‰å­—è¾ƒæ…¢
void Gui_DrawFont_GBK16(uint x, uint y, uint fc, uint bc, uchar *s)
{
	unsigned char i,j;
	unsigned short k,x0;
	x0=x;

	while(*s) 
	{	
		if((*s) >= 128) 
		{		
			for (k=0;k<hz16_num;k++) 
			{
			  if ((hz16[k].Index[0]==*(s))&&(hz16[k].Index[1]==*(s+1)))
			  { 
				    for(i=0;i<16;i++)
				    {
						for(j=0;j<8;j++) 
							{
						    	if(hz16[k].Msk[i*2]&(0x80>>j))	PutPixel(x+j,y+i,fc);
								else {
									if (fc!=bc) PutPixel(x+j,y+i,bc);
								}
							}
						for(j=0;j<8;j++) 
							{
						    	if(hz16[k].Msk[i*2+1]&(0x80>>j))	PutPixel(x+j+8,y+i,fc);
								else 
								{
									if (fc!=bc) PutPixel(x+j+8,y+i,bc);
								}
							}
				    }
				}
			  }
			s+=2;x+=16;
		}
		else
		s+=1; 
		
	}
}
```


åŸºæœ¬çš„å¼•è„šå¦‚å›¾æ‰€ç¤º:
![[attachments/Pasted image 20240407212741.png]]
å‚è€ƒå¦‚å›¾, å¯ä»¥è¿˜åŸå‡ºå¯¹åº”çš„åŸç†å›¾éƒ¨åˆ†ã€‚ è€ŒLEDK, LEDAæ˜¯æ§åˆ¶å±å¹•çš„èƒŒå…‰éƒ¨åˆ†ã€‚å®é™…ä¸Šå¼•å‡ºçš„7ä¸ª åŒ…æ‹¬VCC, GND,    SCL, SDA, DC, RES, BLK (BLKå¯ä»¥è¿›è¡Œæ‚¬ç©º)
![[attachments/Pasted image 20240407213843.png|800]]
å…¶ä¸­å®é™…ä¸ŠSDAæ˜¯MOSI, BLKæ˜¯MISO, å› æ­¤ä½¿ç”¨çš„æ˜¯4-line 8-bit serial I/FII æ¨¡å¼çš„é€šä¿¡æ–¹æ³•(æ‰‹å†Œp33), å…¶ä¸­CSæ˜¯æ¥å…¥GNDçš„ï¼Œ é»˜è®¤ç›´æ¥å¼€å¯ç‰‡é€‰ä½¿èƒ½ã€‚ <mark style="background: transparent; color: red">å¯¹åº”çš„é€šä¿¡æ—¶åºéƒ¨åˆ†å‚è€ƒæ‰‹å†Œp44çš„å››çº¿éƒ¨åˆ†</mark>ï¼Œ 

DC æ˜¯å‘½ä»¤/æ•°æ®é€‰æ‹©ä½ ,  å³æ•°æ®æ‰‹å†Œä¸­ çš„ WRX ä½, å½“ä¸ºé«˜ç”µå¹³æ—¶ä¸ºæ•°æ®ï¼Œ ä½ç”µå¹³æ—¶ä¼ è¾“å‘½ä»¤;(p55)

é‡ç½®æ—¶åº: æ‹‰ä½RESè¶…è¿‡9us, åˆ™è‡ªåŠ¨é‡ç½®, å¦‚æœåœ¨5usä»¥å†…ï¼Œé‡ç½®ä¸è¢«æ¥æ”¶; åœ¨5-9usä¹‹é—´, åˆ™å¼€å§‹é‡ç½®, ä½†æ˜¯å¦‚æœä¹‹åçš„5msä¹‹å†…æ”¶åˆ°ç¡¬ä»¶é‡ç½®å–æ¶ˆ(HardWare Reset Cancel)ä¿¡å·ï¼Œ åˆ™å–æ¶ˆé‡ç½®;

å››çº¿é€šä¿¡çš„éƒ¨åˆ†å¦‚å›¾æ‰€ç¤º(CSXé»˜è®¤ä¸ºGND):
![[attachments/Pasted image 20240407224812.png|800]]
å¯¹åº”çš„ä¼ è¾“è‰²å½©æ–¹å¼å‚è€ƒ 160bit pixel  4Line Interface çš„å†™å…¥æ–¹æ³•: 
å®é™…ä¸Š 16 bit (5-6-5)æ˜¯åˆ†æˆä¸¤ä¸ªå­—èŠ‚ä¼ è¾“çš„ï¼Œé¢æ¯ä¸€æ¬¡åœ¨ä¼ è¾“é—´éš”ä¸­ï¼Œ ç´§å¯†ä¼ è¾“RGBçš„æ•°æ®(å‚è€ƒp105éƒ¨åˆ†)

å¦å¤–ï¼Œ St7789æä¾›äº† Normal Mode , Partial Mode , Idle Mode å’Œ Sleep Mode å¤šç§æ¨¡å¼ã€‚
å…·ä½“å‚è€ƒp138-p139 Power Flow Chart 

```cpp fold title:åˆå§‹åŒ–ä»£ç 
// OLED_CS_Clr();  //æ‰“å¼€ç‰‡é€‰ä½¿èƒ½ (ç‰‡é€‰æ‹‰ä½)
OLED_RST_Clr();
delay_ms(20);
OLED_RST_Set();   // è¿›è¡Œä¸€æ¬¡é‡ç½® (10us)
delay_ms(20);

// OLED_BLK_Set();
	
//************* Start Initial Sequence **********// 
LCD_WR_REG(0x36); 
LCD_WR_DATA8(0x00);

LCD_WR_REG(0x3A); 
LCD_WR_DATA8(0x05);

LCD_WR_REG(0xB2);
LCD_WR_DATA8(0x0C);
LCD_WR_DATA8(0x0C);
LCD_WR_DATA8(0x00);
LCD_WR_DATA8(0x33);
LCD_WR_DATA8(0x33);

LCD_WR_REG(0xB7); 
LCD_WR_DATA8(0x35);  

LCD_WR_REG(0xBB);
LCD_WR_DATA8(0x19);

LCD_WR_REG(0xC0);
LCD_WR_DATA8(0x2C);

LCD_WR_REG(0xC2);
LCD_WR_DATA8(0x01);

LCD_WR_REG(0xC3);
LCD_WR_DATA8(0x12);   

LCD_WR_REG(0xC4);
LCD_WR_DATA8(0x20);  

LCD_WR_REG(0xC6); 
LCD_WR_DATA8(0x0F);    

LCD_WR_REG(0xD0); 
LCD_WR_DATA8(0xA4);
LCD_WR_DATA8(0xA1);

LCD_WR_REG(0xE0);
LCD_WR_DATA8(0xD0);
LCD_WR_DATA8(0x04);
LCD_WR_DATA8(0x0D);
LCD_WR_DATA8(0x11);
LCD_WR_DATA8(0x13);
LCD_WR_DATA8(0x2B);
LCD_WR_DATA8(0x3F);
LCD_WR_DATA8(0x54);
LCD_WR_DATA8(0x4C);
LCD_WR_DATA8(0x18);
LCD_WR_DATA8(0x0D);
LCD_WR_DATA8(0x0B);
LCD_WR_DATA8(0x1F);
LCD_WR_DATA8(0x23);

LCD_WR_REG(0xE1);
LCD_WR_DATA8(0xD0);
LCD_WR_DATA8(0x04);
LCD_WR_DATA8(0x0C);
LCD_WR_DATA8(0x11);
LCD_WR_DATA8(0x13);
LCD_WR_DATA8(0x2C);
LCD_WR_DATA8(0x3F);
LCD_WR_DATA8(0x44);
LCD_WR_DATA8(0x51);
LCD_WR_DATA8(0x2F);
LCD_WR_DATA8(0x1F);
LCD_WR_DATA8(0x1F);
LCD_WR_DATA8(0x20);
LCD_WR_DATA8(0x23);

LCD_WR_REG(0x21); 

LCD_WR_REG(0x11); 
//Delay (120); 

LCD_WR_REG(0x29);
```

å‘½ä»¤åˆ—è¡¨å·²ç»åˆ—å‡ºå¦‚ä¸‹:
```cpp fold title:ST7789CommandDefinition
/* Command Table 1 */
#define ST7789Cmd_NOP                0x00    /* NOP */
#define ST7789Cmd_SWRESET            0x01    /* Software Reset */
#define ST7789Cmd_RDDID              0x04    /* Read Display ID */
#define ST7789Cmd_RDDST              0x09    /* Read Display Status */
#define ST7789Cmd_RDDPM              0x0A    /* Read Display Power Mode */
#define ST7789Cmd_RDDMADCTL          0x0B    /* Read Display MADCTL */
#define ST7789Cmd_RDDCOLMOD          0x0C    /* Read Display Pixel Format */
#define ST7789Cmd_RDDIM              0x0D    /* Read Display Image Mode */
#define ST7789Cmd_RDDSM              0x0E    /* Read Display Signal Mode */
#define ST7789Cmd_RDDSDR             0x0F    /* Read Display Self-Diagnostic Result */
#define ST7789Cmd_SLPIN              0x10    /* Sleep In */
#define ST7789Cmd_SLPOUT             0x11    /* Sleep Out */
#define ST7789Cmd_PTLON              0x12    /* Partial Display Mode On */
#define ST7789Cmd_NORON              0x13    /* Normal Display Mode On */
#define ST7789Cmd_INVOFF             0x20    /* Display Inversion Off */
#define ST7789Cmd_INVON              0x21    /* Display Inversion On */
#define ST7789Cmd_GAMSET             0x26    /* Gamma Set */
#define ST7789Cmd_DISPOFF            0x28    /* Display Off */
#define ST7789Cmd_DISPON             0x29    /* Display On */
#define ST7789Cmd_CASET              0x2A    /* Column Address Set */
#define ST7789Cmd_RASET              0x2B    /* Row Address Set */
#define ST7789Cmd_RAMWR              0x2C    /* Memory Write */
#define ST7789Cmd_RAMRD              0x2E    /* Memory Read */
#define ST7789Cmd_PTLAR              0x30    /* Partial Area */
#define ST7789Cmd_VSCRDEF            0x33    /* Vertical Scrolling Definition */
#define ST7789Cmd_TEOFF              0x34    /* Tearing Effect Line OFF */
#define ST7789Cmd_TEON               0x35    /* Tearing Effect Line On */
#define ST7789Cmd_MADCTL             0x36    /* Memory Data Access Control */
#define ST7789Cmd_VSCSAD             0x37    /* Vertical Scroll Start Address of RAM */
#define ST7789Cmd_IDMOFF             0x38    /* Idle Mode Off */
#define ST7789Cmd_IDMON              0x39    /* Idle Mode On */
#define ST7789Cmd_COLMOD             0x3A    /* Interface Pixel Format */
#define ST7789Cmd_WRMEMC             0x3C    /* Write Memory Continue */
#define ST7789Cmd_RDMEMC             0x3E    /* Read Memory Continue */
#define ST7789Cmd_STE                0x44    /* Set Tear Scanline */
#define ST7789Cmd_GSCAN              0x45    /* Get Scanline */
#define ST7789Cmd_WRDISBV            0x51    /* Write Display Brightness */
#define ST7789Cmd_RDDISBV            0x52    /* Read Display Brightness Value */
#define ST7789Cmd_WRTCTRLD           0x53    /* Write CTRL Display */
#define ST7789Cmd_RDCTRLD            0x54    /* Read CTRL Value Display */
#define ST7789Cmd_WRCACE             0x55    /* Write Content Adaptive Brightness Control and Color Enhancement */
#define ST7789Cmd_RDCABC             0x56    /* Read Content Adaptive Brightness Control */
#define ST7789Cmd_WRCABCMB           0x5E    /* Write CABC Minimum Brightness */
#define ST7789Cmd_RDCABCMB           0x5F    /* Read CABC Minimum Brightness */
#define ST7789Cmd_RDABCSRD           0x68    /* Read Automatic Brightness Control Self-Diagnostic Result */
#define ST7789Cmd_RDID1              0xDA    /* Read ID1 */
#define ST7789Cmd_RDID2              0xDB    /* Read ID2 */
#define ST7789Cmd_RDID3              0xDC    /* Read ID3 */

/* Command Table 2 */
#define ST7789Cmd_RAMCTRL            0xB0    /* RAM Control */
#define ST7789Cmd_RGBCTRL            0xB1    /* RGB Interface Control */
#define ST7789Cmd_PORCTRL            0xB2    /* Porch Setting */
#define ST7789Cmd_FRTCRL1            0xB3    /* Frame Rate Control 1 (In partial mode/ idle colors) */
#define ST7789Cmd_PARCTRL            0xB5    /* Partial Control */
#define ST7789Cmd_GCTRL              0xB7    /* Gate Control */
#define ST7789Cmd_GTADJ              0xB8    /* Gate On Timing Adjustment */
#define ST7789Cmd_DGMEN              0xBA    /* Digital Gamma Enable */
#define ST7789Cmd_VCOMS              0xBB    /* VCOM Setting */
#define ST7789Cmd_POWSAVE            0xBC    /* Power Saving Mode */
#define ST7789Cmd_DLP0FSAVE          0xBD    /* Display off power save */
#define ST7789Cmd_LCMCTRL            0xC0    /* LCM Control */
#define ST7789Cmd_IDSET              0xC1    /* ID Code Setting */
#define ST7789Cmd_VDVVRHEN           0xC2    /* VDV and VRH Command Enable */
#define ST7789Cmd_VRHS               0xC3    /* VRH Set */
#define ST7789Cmd_VDVS               0xC4    /* VDV Set */
#define ST7789Cmd_VCOMOFFSET         0xC5    /* VCOM Offset Set */
#define ST7789Cmd_FRCTRL2            0xC6    /* Frame Rate Control in Normal Mode */
#define ST7789Cmd_CABCTRL            0xC7    /* CABC Control */
#define ST7789Cmd_REGSEL1            0xC8    /* Register Value Selection 1 */
#define ST7789Cmd_REGSEL2            0xCA    /* Register Value Selection 2 */
#define ST7789Cmd_PWMFRSEL           0xCC    /* PWM Frequency Selection */
#define ST7789Cmd_PWCTRL1            0xD0    /* Power Control 1 */
#define ST7789Cmd_VAPVANEN           0xD2    /* Enable VAP/VAN signal output */
#define ST7789Cmd_CMD2EN             0xDF    /* Command 2 Enable */
#define ST7789Cmd_PVGAMCTRL          0xE0    /* Positive Voltage Gamma Control */
#define ST7789Cmd_NVGAMCTRL          0xE1    /* Negative Voltage Gamma Control */
#define ST7789Cmd_DGMLUTR            0xE2    /* Digital Gamma Look-up Table for Red */
#define ST7789Cmd_DGMLUTB            0xE3    /* Digital Gamma Look-up Table for Blue */
#define ST7789Cmd_GATECTRL           0xE4    /* Gate Control */
#define ST7789Cmd_SPI2EN             0xE7    /* SPI2 Enable */
#define ST7789Cmd_PWCTRL2            0xE8    /* Power Control 2 */
#define ST7789Cmd_EQCTRL             0xE9    /* Equalize time control */
#define ST7789Cmd_PROMCTRL           0xEC    /* Program Mode Control */
#define ST7789Cmd_PROMEN             0xFA    /* Program Mode Enable */
#define ST7789Cmd_NVMSET             0xFC    /* NV Setting */
#define ST7789Cmd_PROMACT            0xFE    /* Program action */
```


# äºŒã€é©±åŠ¨å‡½æ•°çš„ç¡¬ä»¶SPIç§»æ¤
æ¯”è¾ƒç®€å•çš„SPIè®¾ç½®ä¸­, **éœ€è¦è®¾ç½® CPOL = 1, CPHA = 1**, å³è®¾ç½®ä¸ºä¸è¿ç»­çš„é€šä¿¡æ¨¡å¼, ç§»æ¤SPI2ç¡¬ä»¶é€šä¿¡åˆ°TFTLCDå½©å±;

```cpp fold title:LCD_initä¸­åŠ å…¥ä»£ç 
GPIO_InitTypeDef  GPIO_InitStructure;
SPI_InitTypeDef   SPI2_InitStructure;

// Clock Cofiguration
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);

// GPIO Configuration 
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_15;  // SCL:PB13, SDA:PB15
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
GPIO_Init(GPIOB, &GPIO_InitStructure);

// ** PB12, PB13, PB15 and PB11(as DC) **
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11|GPIO_Pin_12;   // use PB11 as RST, PB12 as DC
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 // Push-Pull Output 
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 // 50MHz Speed
GPIO_Init(GPIOB, &GPIO_InitStructure);	  				 // Init GPIOB
GPIO_SetBits(GPIOB, GPIO_Pin_11|GPIO_Pin_12);

GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		 // input 
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    // é€Ÿåº¦50MHz
GPIO_Init(GPIOB, &GPIO_InitStructure);
GPIO_SetBits(GPIOB,GPIO_Pin_14);

/******** SPI Configurations **************************** */
SPI_StructInit(&SPI2_InitStructure);
SPI2_InitStructure.SPI_Mode = SPI_Mode_Master;
SPI2_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
SPI2_InitStructure.SPI_NSS = SPI_NSS_Soft;	  
SPI2_InitStructure.SPI_CPOL = SPI_CPOL_High;   // SCL is low when IDLE
SPI2_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;  // rising edge data
SPI2_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
SPI2_InitStructure.SPI_DataSize = SPI_DataSize_8b;
SPI2_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;

SPI_Init(SPI2, &SPI2_InitStructure);
SPI_Cmd(SPI2, ENABLE);
/********************************************/
```

å¯¹äºSPI_WriteBuså‡½æ•°ä¸­, åªéœ€è¦ç”¨ä¸¤å¥ç§»æ¤å³å¯(ç›´æ¥sendèƒ½å¤Ÿè·å¾—æå¿«çš„åˆ·æ–°æ•ˆç‡):
```cpp
void LCD_Writ_Bus(char dat)
{	
	// note that this while may not cause loop problem;
    while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET); // when TXE = 1, can 
    SPI_I2S_SendData(SPI2, dat);
    // while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET); // wait for SPI_DR = 1;
    // SPI_I2S_ClearFlag(SPI2, SPI_I2S_FLAG_RXNE);
    // return SPI_I2S_ReceiveData(SPI2);  // receive the data;
}
```

éœ€è¦è¯´æ˜çš„æ˜¯, è™½ç„¶è¿™æ ·æ˜¯å¯ä»¥çš„, ä½†æ˜¯æ•°æ®å‘é€ä»ç„¶æ˜¯ä¸è¿ç»­çš„, ä¸ºäº†èƒ½å¤Ÿè¿ç»­å‘é€æ•°æ®, æˆ‘ä»¬å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/ä¸‰ã€ä¸²å£ä¸é€šä¿¡åè®®/4. SPI é€šä¿¡åè®®ä¸W25Q64 FlashèŠ¯ç‰‡#1. è¿ç»­æ¨¡å¼çš„ä¼ è¾“æ—¶åº|4. SPI é€šä¿¡åè®®ä¸W25Q64 FlashèŠ¯ç‰‡]]ä¸­çš„è¿ç»­ä¼ è¾“

å‚è€ƒæ‰‹å†Œ, å¯¹äºå‰é¢çš„æ•°æ®ä¼ è¾“, æ˜¾ç„¶<mark style="background: transparent; color: red">ç¬¬ä¸€æ¬¡æ˜¯ç›´æ¥å…ˆå†™å…¥ä¸¤ä¸ªå­—èŠ‚çš„</mark>(è¿™æ˜¯ç”±äºTX bufferå’Œshift registerçš„è¿æ¥å…³ç³»), è€Œ<mark style="background: transparent; color: red">åé¢å¿…é¡»å¼ºåˆ¶ Wait Busy</mark>BUSY, ä»£ç å¦‚ä¸‹:
```cpp 
while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_BSY) == SET); Â // wait for busy flag
```

![[attachments/Pasted image 20240505133020.png|700]]
å¯¹äºTransmit Only Mode, <mark style="background: transparent; color: red">å®ç°çš„ä»£ç æ˜¯ç›¸å¯¹ç®€å•çš„</mark>, è€ŒTransmit-Receive Modeå®ç°å°±æ¯”è¾ƒéº»çƒ¦ã€‚
å› æ­¤æˆ‘ä»¬ä»…ä»…é€‰ç”¨Transmit Only mode



> [!NOTE] ä¸ºäº†æå‡é€Ÿåº¦çš„æ³¨æ„äº‹é¡¹
> åœ¨å‘é€å¤šä¸ª Data æ•°æ®æ—¶, æ¯ä¸€æ¬¡å‘é€å®Œæ¯•Dataä¹‹å‰éƒ½è°ƒç”¨OLED_DC_Set();
> å‘é€å®Œæ¯•åè°ƒç”¨ OLED_WaitBSY();æ¥ä¿è¯å‘é€åä¸‹ä¸€ä¸ªæŒ‡ä»¤èƒ½å¤Ÿæ­£ç¡®å‘é€ã€‚

```cpp title:ç¤ºä¾‹ä»£ç å¦‚ä¸‹(å…¶ä¸­WriteBusä»…ä»…ç­‰å¾…TXEç½®ä¸€)
LCD_WR_REG(0x2a);
OLED_DC_Set();
LCD_Writ_Bus(x1>>8);
LCD_Writ_Bus(x1); Â 
LCD_Writ_Bus(x2>>8);
LCD_Writ_Bus(x2);
LCD_WaitBSY();
```

# 彩屏及其显示方法简介
对于3.2寸的彩屏, 一般的分辨率可以达到320 x 480, 350x480, 小的可以达到220x176的分辨率. 可以用于显示彩色图片和文字等等, 可以搭配彩屏实现

TFTLCD彩屏 
TFTLCD : thin film transistor-liquid crystal display (模拟晶体管液晶显示)

TFT液晶(真彩液晶显示器)对于每个像素都使用了独立的薄膜晶体管， 且每个像素点都可以通过点脉冲进行独立控制, 每个节点都是相对独立的， 可以连续控制, 可以精确控制显示的色阶, 

常用的液晶显示接口有8,9,16, 18位接口等等。 常用的是16位或者8位; 本彩屏是16位的彩屏部分(DV)。并且<mark style="background: transparent; color: red">常用两种通信方式, 包括6800和8080并口模式(80模式)</mark>的彩屏控制。

常用的彩屏有2.0, 2.2, 2.4,  2.6, 2.8, 3.2, 3.5, 4.3, 7寸等等, 一般的2.6寸彩屏是240 $\times$ 400 的彩屏。
一般通过丝印名字选择彩屏的驱动程序

| 命名 |  | 本开发板数据 | 备注 |
| ---- | ---- | ---- | ---- |
| TFT |  | TFT |  |
| 2.6 | 表示2.0寸彩屏 | 2.0 |  |
| R61509V | 彩屏内部的驱动控制器型号 | S1D1910X | 常见的型号有: HX38(海信) ILI93, R615XX, LG45XX(LG公司), NT35XX, 需要相应的控制器手册。需要根据尺寸和型号设置不同的宏定义。 并选择不同的驱动  |
|  |  |  |  |

另外在彩屏上还会有触摸的功能, 触摸屏是通过触摸板检测AD芯片位置的(一般来说背面有较大的XPT2046芯片(本机上有ET2046, 但是仅在AD转换模块)) 

早期的触摸屏是电阻式的, 而目前的一般都是电容的。电容等等都是对于保护以及降压。 

**原厂一般提供管脚定义功能， 芯片数据手册和初始化代码**, 
X+，X-, Y+, X- 是一体化触摸彩屏的触摸管脚

通常的彩屏是3.3V 控制的， 需要将5V电源转为3.3V进行控制, 减少稳压芯片, 此处直接通过电阻降压将5V降为3.3V实现降压。

# 液晶模块显示的基本方法

定义控制IO管脚
初始化TFTLCD模块, 写入对应的命令初始值(包括写命令和写数据的函数) -> 往往厂家也会提供初始化代码。
然后将显示的内容写入到TFTLCD模块中。

- 需要说明的是, 有时使用纵向显示而有时使用横向显示， 此时需要参考数据手册， 查找对应更改显示方向的命令。只需要根据方向控制命令进行设置。
- 显示的步骤: 1. 设置坐标 `->` 操纵GRAM写入RAM指令(显示一个点) `->` 设置对应的坐标并写入数据。点亮对应的点。 

2.54mm的口, 做16位的部分是兼容不同的彩屏。 

如果没有触摸, 则与转换无关 

# 彩屏的基本控制
实际有效的是DB1-DB8共有8位， 以及DB10-DB17的8位, 分别对应P0管口和P1管口(DB0无效)
![[attachments/Pasted image 20240115202511.png]]

80接口有5条基本控制线和多条控制线(8位是8条, 而16位是16条), 具体有RST, CS, RS, RD, WR共5条。并且需要RST之后才能进行显示
![[attachments/Pasted image 20240115193415.png|600]]
对于RS, RD 等等, 都需要发送对应的命令控制对应的显示方向, 
使用RGB的不同搭配使得彩屏显示不同的颜色。 RGB和BGR的发送也需要使用发送命令进行控制。
对RD, WR的读写是分开使用的, 控制读写则设置为0, 取消为1。
占据的控制线包括 DB0- DB15 (至少有13-21个管脚, 比较占用IO口资源, 一般较为大型的项目才进行使用 ) 
我们通过51单片机的IO口模拟8080时序与彩屏进行通信。



# 彩屏通信时序介绍
![[attachments/Pasted image 20240115193828.png|700]]

首先使用片选信号CS进行拉低, **RS为低电平为命令, 而高电平为数据**。 
WR初始化为高电平, 当其跳变到低电平时, 切换到高电平完成写。
RD初始化也是高电平, 低电平时开始读取, 切换到高电平完成读。

# 软件编程的方法 

```c
// #define  TFT20_ILI93250 -> 对应相应的宏型号
// #define TFTLCD_DIR 0    // 0: 竖屏, 1 横屏, 其中默认为竖屏的方向

// 定义分辨率
#ifdef ..... // 例如2.0T FT20_HX8309 -> 176 x 220 的分辨率 


#define TFT_DATAPORTH P1
#define TFT_DATAPORTL P0

sbit TFT_CS = P2^7;
sbit TFT_RST = P3^3;
sbit TFT_WR  = P2^5;
sbit TFT_RD = P3^2;

//TFTLCD重要参数集
typedef struct  
{                                          
    u16 width;          //LCD 宽度
    u16 height;         //LCD 高度
    u16 id;             //LCD ID -> 彩屏控制器的id， 不是区分彩屏的类型 (如果都是18位数据口, 可以通过id区分彩屏)
    u8  dir;            //LCD 方向
}_tftlcd_data;


// LCD参数 -> 由于在.c文件中用到且在其他文件中也会使用到
extern _tftlcd_data tftlcd_data;    //管理LCD重要参数
//LCD的前端颜色和背景色    
extern u16  FRONT_COLOR;//前端颜色 默认红色    
extern u16  BACK_COLOR; //背景颜色.默认为白色
```

彩屏的显示方法是通过改变前景色显示不同的颜色。
在其中是通过十六进制值方法定义颜色的, 并一般使用RGB(565格式存储16位的数据)
```c
//画笔颜色
#define WHITE            0xFFFF
#define BLACK            0x0000  
#define BLUE             0x001F
#define BRED             0XF81F
#define GRED             0XFFE0
#define GBLUE            0X07FF
#define RED              0xF800
#define MAGENTA          0xF81F
#define GREEN            0x07E0
#define CYAN             0x7FFF
#define YELLOW           0xFFE0
#define BROWN            0XBC40 //棕色
#define BRRED            0XFC07 //棕红色
#define GRAY             0X8430 //灰色
```


字符的取模数据在FONT.H中, 使用方法参考51单片机开发攻略 p425之后的内容
对于汉字，是使用结构体进行定义的, 因而我们可以通过搜索其索引 Index 来访问内部的数据。 
```c
// ------------------  汉字字模的数据结构定义 ------------------------ //
struct  Cn32CharTypeDef                   // 汉字字模数据结构
{
    unsigned char  Index[2];            // 汉字内码索引,一个汉字占两个字节
    unsigned char   Msk[116];            // 点阵码数据(32*29/8)
};
```


# 图片的取模方法
首先图片要求是.bmp格式的图片
输出灰度是16位真彩
![[attachments/Pasted image 20240115232838.png]]
最大宽度和高度设置为原来图片的宽度和高度(而不是显示屏幕的)
设置完毕之后就可以保存为.c和.h文件了。 

加上的const 是为了将图片存储在flesh中而不是ram中, RAM比flesh少很多。
一个像素点要占据两个字节，常量存放在ROM中。

加code 和const 效果是一样的。 

选择存储器模式 `->` 最大 (有的模块会读取错误) `->` 由于DATA 默认存放在SDATA外面 `->` 仍然选择small, 并将数据存放在xdata 

```c
extern u16 xdata BACK_COLOR
```
xdata 可以缩小对应的data 的存放量。
DHT11 会受xdata 影响， 但彩屏不受影响。 

将不用的函数删去也可以减小对应的容量。

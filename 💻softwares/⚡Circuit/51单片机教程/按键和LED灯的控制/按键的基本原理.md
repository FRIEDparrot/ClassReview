# 独立按键基本原理

在独立按键模块中, 接到了**P30(RXD), P31(TXD), P32, P33**上。

参考[[💻softwares/⚡Circuit/Proteus/1.proteus界面简介和基本操作#二、接线原理|接线原理]], 输入口和输出口默认是高电平的, **将按键按下相当于将口接地置于低电平**。

寄存器可以实现读取高低电平的原理。
![[attachments/Pasted image 20231203115224.png|700]]

下面的代码定义的是**位寄存器** 
```c
/*------------------------------------------------
P2 Bit Registers
------------------------------------------------*/
sbit P2_0 = 0xA0;
sbit P2_1 = 0xA1;
sbit P2_2 = 0xA2;
sbit P2_3 = 0xA3;
sbit P2_4 = 0xA4;
sbit P2_5 = 0xA5;
sbit P2_6 = 0xA6;
sbit P2_7 = 0xA7;
```
**操作上述的数据**(8位数)只给0,1数据, 即可以**实现操作端口的高低电平状态**,
当整体传入一个P2时, 需要给定0xFF等等, 而仅操作一端口只需0,1, 例如`P2_0  = 0`操作P2为低电平。
![[attachments/Pasted image 20231203121756.png|600]]

因此只需要添加检测代码
```c
	while(1){
		if (P3_1 == 0){
			P2_6 = 1;
			P2_7 = 0;
		}
		else{
			P2_6 = 0;
			P2_7 = 1;
		}
	}
即通过控制按键1控制6,7的亮灭
```

需要注意按键顺序并不相同。

最简单的LED灯左右移动代码如下:
```c
void ShiftLEDleft(){
	bool pre = P2_0;
	P2_0 = P2_1;
	P2_1 = P2_2;
	P2_2 = P2_3;
	P2_3 = P2_4;
	P2_4 = P2_5;
	P2_5 = P2_6;
	P2_6 = P2_7;
	P2_7 = pre;
}

void ShiftLEDright(){
    bool pre = P2_7;
    P2_7 = P2_6;
	P2_6 = P2_5;
	P2_5 = P2_4;
	P2_4 = P2_3;
	P2_3 = P2_2;
	P2_2 = P2_1; 
	P2_1 = P2_0;
	P2_0 = pre;
}
```

C语言中, 对于多位的运算, 有:
```c
 & 按位与运算
 |  按位或运算
 ^ 按位异或运算 
 ~ 按位非运算
```

# 基本按钮操作
51单片机中使用类型sbit (single bit )来进行按钮的设置
一般点一次操作一次的方法如下
注意需要先Delay(10)来防抖
```c
sbit btn2 = P3^0;
if (!btn2) { // add the number when the button is pressed
			Delay(10);
			if (!btn2){
				num = 0; // return the num to zero 
				while (!btn2); // then do nothing until next press 
			}
		}
```

如果需要进行计时, 则可以使用如下的代码<mark style="background: transparent; color: red">检测按键的长按</mark>
```c
sbit btn1 = P3^1;
if (!btn1) {
			Delay(10);
			if(!btn1){
				unsigned int xms = 0;
					while(!btn1){  // count in the range 5000 
						Delay(1); 
						if (xms< 5000) xms ++;
					}
					if (xms < 600) {
						if (num < 255) num++;
					}
					else{
						if(num > 0) num--;
					}
					while(!btn1); // then do nothing until next press 
			}
		}
```


另外写一个用于循环移位的函数, 即将目前的数字算出移位之后的十进制数, 注意enum的用法: 
```c
enum Dir{
	left,
	right
};

int ShiftNum(int num, enum Dir d){
	int n = num;
	int n0, n1, n2, n3, n4, n5, n6, n7;
	int res = 0;

	n0 = n % 2;  n = n / 2;
	n1 = n % 2;  n = n / 2;
	n2 = n % 2;  n = n / 2;
	n3 = n % 2;  n = n / 2;
	n4 = n % 2;  n = n / 2;
	n5 = n % 2;  n = n / 2;
	n6 = n % 2;  n = n / 2;
	n7 = n % 2;  n = n / 2;

	if (d == left){
		res = n7 + n0 * 2 + n1 * 4 + n2 * 8 + n3 * 16 + n4 * 32 + n5 * 64 + n6 * 128;
	}
	else if (d == right){
		res = n1 + n2 * 2 + n3 * 4 + n4 * 8 + n5 * 16 + n6 * 32 + n7 * 64 + n0 * 128;
	}
	return res;
}

```


另外也可以使用功能LEDNum和循环移位的功能
也可以使用基本的量 0x01
```c
unsigned char LEDNum; 

... LEDNum++;  

0000 0001 = 0x01 << 0
0000 0010 = 0x01 << 1
0000 0100 = 0x01 << 2
// 相应地, 可以使用 0xFE点亮一个灯并让其左右移动
// 也可以
P2 = ~(0x01 << LEDNum)
```

# 防抖动的原因
由于当按钮按下时会有抖动的情况， 抖动过程之后才能得到稳定的低电平状态, 因此<mark style="background: transparent; color: red">为了防止抖动, </mark>可能会由于抖动导致多次触发, 且往往抖动是5-10ms的范围。


![[attachments/Pasted image 20231206013728.png|500]]


在独立按键中, P32 和 P33也可以作为**外部的中断按键** 
![[attachments/Pasted image 20231206014356.png]]


# 按键检测封装函数及其优化

```c
#include <regx52.h>

typedef unsigned char u8;
typedef unsigned int u16;
// 定义控制管脚 
sbit Key1 = P3^1 ; // 位定义
sbit Key2 = P3^0; 
sbit Key3 = P3^2; 
sbit Key4 = P3^3; 

// 定义按键按下的值
#define KEY1_PRESS 1
#define KEY2_PRESS 2
#define KEY3_PRESS 3
#define KEY4_PRESS  4
#define KEY_UNPRESS 5

// 检测按键的按一次状态时, 使用static关键字可以在局部函数退出之后，不销毁该变量的值
static u8 key = 1;
 
// 返回确定按下的按键返回值 
u8 key_scan(){
	if (Key1 == 0|| Key2 == 0 || Key 3 == 0 || K4 == 0 ){	
		// 消抖处理 ** 在消抖处理处可以进行优化, 
		delay(10);
		if (Key1 == 0) return KEY1_PRESS; 
		else if (Key2 == 0) return KEY2_PRESS;
		else if (Key3 == 0) return KEY3_PRESS;
		else if (Key 4 == 0) return KEY4_PRESS;
		else if (Key1 && Key2 && Key3 && Key4) return KEY_UNPRESS;
	}
// 如何进行优化: 四个按键同时判断消抖处理 
// 注意: 这个仅检测单次按键 
}

```
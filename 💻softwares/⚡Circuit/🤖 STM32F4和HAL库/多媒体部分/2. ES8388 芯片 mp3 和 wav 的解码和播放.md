## 一、ES8388 芯片简介
对于 ES8388 芯片支持 I2S 和 SAI 接口通信, 其中WM8978也支持I2S通信接口,  而VS1053 使用 SPI 进行通信。
对于 VS1053, 支持硬件 SPI 直接发送 wav 和 mp3数据解码, 而es8388 有更好的音质, 但是需要进行软件解码。

RIFF (Resource Interchange File Format), 支持MS ADPCM, CCITT , ALAW 等等多种压缩算法, 一般的采样率都是 44100 Hz, 能够存放高质量音频。
WAV 是经过压缩算法的 PCM(未压缩) 格式。

参考[[💻softwares/⚡Circuit/🎮STM32教程/五、扩展模块/stm32读取和播放SD卡中的音乐mp3和wav文件|stm32读取和播放SD卡中的音乐mp3和wav文件]] 以及 [[💻softwares/⚡Circuit/🎮STM32教程/六、语音识别模块教程讲解/STM32F103RET6的DAC模块和音频输出|DAC模块和音频输出]] 部分, 
重要的是采样率 sample rate 和采样位数 (16, 32)

我们实际上需要将 SPI3 复用为 I2S 输出给

第一, RIFF Chunk 
```c
typedef __PACKED_STRUCT
 {
  uint32_t ChunkID;   /* chunk id;这里固定为"RIFF",即 0X46464952 */
  uint32_t ChunkSize ;   /* 集合大小;文件总大小-8 */
  uint32_t Format;   /* 格式;WAVE,即 0X45564157 */
} ChunkRIFF ;
```

其二, FMT Chunk 
```c
typedef struct
{
  uint32_t   ChunkID;       /* 0 */ /* chunk id;这里固定为"fmt ",即 0X20746D66 */ 
  uint32_t   FileSize;      /* 4 */   /* 子集合大小(不包括 ID 和 Size) */  -> 一般为 8 
  uint32_t   FileFormat;    /* 8 */  /* 音频格式;0X01,表示线性 PCM;0X11 表示 IMA ADPCM */
  uint32_t   SubChunk1ID;   /* 12 */   /* 通道数量;1,表示单声道;2,表示双声道; */ 
  uint32_t   SubChunk1Size; /* 16*/  /* 采样率;0X1F40,表示 8Khz */ 
  uint16_t   AudioFormat;   /* 20 */   /* 字节速率=采样率*通道数*(ADC位数/8) */  -> 计算 bitrate 
  uint16_t   NbrChannels;   /* 22 */   /* 块对齐(字节)=通道数*(ADC位数/8) */ 
  uint32_t   SampleRate;    /* 24 */   /* 单个采样的位数;16位PCM,设置为16 */  
  
  uint32_t   ByteRate;      /* 28 */
  uint16_t   BlockAlign;    /* 32 */  
  uint16_t   BitPerSample;  /* 34 */  
  uint32_t   SubChunk2ID;   /* 36 */   
  uint32_t   SubChunk2Size; /* 40 */   
}WAVE_FormatTypeDef;
```

其三, 有一个可选的 FACT Chunk, 
```c
typedef __PACKED_STRUCT 
{ 
	uint32_t ChunkID; 			/* chunk id;这里固定为"fact",即 0X74636166; */ 
	uint32_t ChunkSize; 		/* 子集合大小(不包括 ID 和 Size);这里为:4 */ 
	uint32_t DataFactSize; 		/* 数据转换为PCM格式后的大小 */ 
}ChunkFACT; 					/* fact 块 */
```

最后是 DATA Chunk, 其 bit 位的形式是 : 
![[attachments/Pasted image 20240727104433.png]]
对于 24位量化, 是  低> 中> 高 进行播放的;
一般只需要获取到 wav 数据并**通过I2S送给 wm8978 即可**。

## 二、STM32F4 的 I2S 外设简介
### (1) STM32 I2S 外设简介
I2S (Inter IC Sound) 是一种音频数据传输指定的总线标准。是一种传输 PCM 编码音频数据流的外设, 支持<mark style="background: transparent; color: red">全双工, 半双工和主从模式</mark>, 而主模式是 STM32F4, WM8978 是从模式。
对于SPI1没有相关的I2S外设, 仅有 SPI2, SPI3 支持。
I2S最少有3根信号线: 
1. SCK/SCLK/BCLK(一个时钟传输1bit数据), 频率 = 声道数 * 采样频率 * 采样位数;  
2. LRCK (左右时钟, 帧时钟/WS), 用于声道选择; **其中 "1" 表示传输右声道的数据, "0" 表示传输左声道的数据**, 其有**频率 = 采样率**(一个周期中, 同时采样右声道和左声道的数据)
3. SDATA(1-2根串行数据线):  当一根时, 为半双工; 双线时为全双工; 
4. (optional) MCLK (系统时钟, 用于将系统时钟更好的同步, 频率 = 128或 256* samplerate), <mark style="background: transparent; color: red">本板使用 PC6(I2S2-MCK) 作为 I2S_MCLK 部分</mark>;
I2S 具有 Philips(I2S)标准, 左对齐 MSB 标准 和右对齐(LSB) 标准。
数据在跟随 LRCLK 传输, <mark style="background: transparent; color: red">在 BCLK 的第二个上升沿时， 传输 MSB 部分</mark>(首先需要等待一个周期)， 一般允许32 位数据传输, 如果数据不足, 则后面补 0; 

对于 ES8388 是一种双 ADC/DAC 通道, 放大器以及数组音效, 模拟混合增益功能的音频解码器。同时有数字音效,模拟混合等功能。
<mark style="background: transparent; color: red">DAC 信噪比为 96db, ADC 信噪比 95db, 支持左右声道音量独立调节, 支持主机和从机模式</mark>。

对于 STM32F4 的 I2S 部分, 支持全双工和半双工通信, 支持主从, 可编程8位线性预分频器， 实现 8-192kHz的精确采样。支持 16, 24, 32 位的数据格式。支持<b><mark style="background: transparent; color: blue">MSB对齐, LSB对齐, 飞利浦标准</mark></b>, 同时支持DMA传输，数据方向固定 MSB 在前,并且支持主时钟输出。
• Master clock may be output to drive an external audio component. Ratio is fixed at 256 × FS (where FS is the audio sampling frequency) -> 必须设置为 256 倍 Master Clock 时钟同步频率。

### (2) STM32 I2S 发生器时钟
对于 I2S 外设, 其时钟来自 I2S_CLK 部分, 一般采用 I2S CKIN 部分, 在时钟树中, I2S 时钟是来自于 /R 部分的 PLL2SCK, 也可以来自于 I2S_CKIN(外部提供);
![[attachments/Pasted image 20240727211914.png]]
而锁相环 PLL2CLK 部分是通过HSE (8MHz)其中 PLLCLK 是 168MHz, 即 8Mhz * 336 / M / P  ; (M = 8, P = 2)参考[[💻softwares/⚡Circuit/🤖 STM32F4和HAL库/基本内容/3. HAL库时钟初始化|3. HAL库时钟初始化]], 而 Q 一般设置为 7, 即 48 MHz 的频率， <mark style="background: transparent; color: red">其中有两个锁相环, 其中一般 PLL1SN 固定为336部分</mark> 

I2S 的时钟频率是: 
$$ I2S \space Clocks  =  8MHz * PLL2SN / 8(M)  / PLL2SR   $$
而参考p908 I2S 外设时钟生成结构框图得到:
![[attachments/Pasted image 20240727213224.png]]
I2SxCLK 需要根据 fs 配置分频系数。而设置采样率的方案如下: 
![[attachments/Pasted image 20240727213414.png]]
一般主模式下的时钟频率计算如上: 其中 fs 为频率;
对于左右声道, 每次传输2个数据, 则:
$$ Fs = \frac{I2SCLK}{32 * 2 * (2 * I2SDIV + ODD) * 4 } $$
其中 I2SDIV 和 ODD 均为分频系数, ODD = 0-1, I2SDIV = 2~255 , 而 R 取值范围2-7
因此
1. I2S Clk =  1MHz * PLL2SN/PLL2SR (t = 2-7), 范围48 Mhz- 168Mhz, 
2. Fs = I2SClk / (256 * (2 * I2SDIV +  ODD))
需要说明的是, 上述方法一般仅能得到具有误差的采样率,<mark style="background: transparent; color: red"> 而需要零误差的情况下, 会采用 I2S_CKIN 外部时钟</mark>, 能够得到最为精确的结果。 

一般而言, 按照不同的采样率, 其对应的最佳 PLLI2SN, PLLI2SR, I2SDIV, ODD 等组合如下所示:
![[attachments/Pasted image 20240727214618.png]]
注意: 仅有I2S停止时, 才能进行 SPI, I2S 的切换， 并设置 SPI_I2SCFG中的 I2SMOD =1
I2SE 位, 设置1时, 使能 I2S 外设, 必须设置完 I2SMOD 之后才能进行继续设置。

I2SSTD 设置 I2S 标准, CKPOL 设置空闲时的 CLK 电平为低电平。而预分频器寄存器设置8位的预分频。另外, SPI_CR2 用于使能 SPI 或者 I2S的 DMA 请求, 用于使能发送缓冲区的 DMA 请求。

### (3) ES8388 说明
根据 ES8388 电路连线图, 框图和引脚图如下所示: 
![[attachments/Pasted image 20240727122410.png]]
封装为 QFN28, 其中29脚EP 一般接地,  <mark style="background: transparent; color: red">通过I2C接口或者 SPI接口进行命令传输, 配置其全双工 SPI 模式, 其中 IIC 接口需要CE = 0/1,  SPI需要 CE 产生下降沿部分。</mark> 
![[attachments/Pasted image 20240727122444.png]]
对于 PB8,  PB9 在原理图中作为音频的 I2C 接口, 同时支持 I2S 标准(MSB传输), MSB 标准, LSB 标准, DSP/PCM 标准。
**ADSOUT 即 ADC数据输出(SPIx-extSD)**, 第二, ES8388 要求, MCLK 时钟频率必须为256fs, 其中 fs = 音频采样率。

具体参考 Chip Control and Power Management 
R0 寄存器: 包含SCP_Reset(1将其软复位),  VMIDSEL\[1:0\] 用于控制 VMID, 用于校正噪声, <mark style="background: transparent; color: red">而 R1 寄存器(控制寄存器2)控制模拟部分的复位。 当设置PdnAna 为 0 时, 模拟部分才会工作, 即才能听到声音</mark>。

对于 Register2: 
![[attachments/Pasted image 20240727160633.png]]
其中 滤波器重置部分用于重置 ADC DEM等, dac_PDN重置 DACDEM 等等(均需要设置为0), 包括 adcVref_PDN 和 dacVref_PDN 均需要设置为0进行控制。

R4 是电源管理的寄存器, <mark style="background: transparent; color: red">R8 用于配置主从模式的控制寄存器</mark>， 同时BLCK_INV用于控制左右声道反相, BLCKDIV 用于控制主时钟分频, 一般选用不分频。
R9 寄存器控制 MIC 的左右通道增益大小, 具体如下:
![[attachments/Pasted image 20240727161717.png]]
R9, R10 为控制寄存器1, 2; 其中 R10 控制输入通道以及R11的DS差分输入选择。
R12: DATSEL 控制是否换用ADC通道, 
R13为ADC控制寄存器5，<mark style="background: transparent; color: red">其中ADCFsRatio控制主时钟相对于采样率的倍率</mark>, 一般设置为 00010 (256), 默认为 768;
R16， R17分别控制左右声道 ADC 输入(采集外部声音)的衰减。
R18 控制 ALC(Automatic Level Control, 自动电平控制) <mark style="background: transparent; color: red">ALCSEL = 11 为立体声控制, 音效更好</mark>, 
从 R23 开始是对于 DAC 的控制, <mark style="background: transparent; color: red">重要的是 DACWL, 往往设置为 100 (32位数据长度), 往往会提供更好的音质。ADCFORMAT 设置 DAC 的数据格式, 使用I2S格式(00)</mark>, 
R24中, **DACFsMode, 用于设置单速和双倍速模式, 一般设置为0**, DACFsRatio 设置应当和前面保持一致(00010为256)
R26, R27 中的 LDACVOL , RDACVOL 控制左右声道的衰减, 最高为 96db;

当配置静音时, 可以使用 R29(1Dh) 的ZeroL和ZeroR 配置位, 
R29 -> Mono 控制单声道输出, 一般默认0(Stereo), SE 设置3D音效效果, 分别体现3D 效果强弱。

另外<mark style="background: transparent; color: red">R39 设置DAC的混音器开关,</mark>
![[attachments/Pasted image 20240727170834.png]]
![[attachments/Pasted image 20240727170912.png]]
时钟控制如下: 
其中 slrck 设置ADC, DAC是否共用 LRC 
![[attachments/Pasted image 20240727170928.png]]
I2S 原理框图如下:  
![[attachments/Pasted image 20240727175042.png]]
对于 SPI 和 I2S 共用部分,  I2SMOD位部分可以, 

SD 为串行数据引脚,
WS 为字选择，用于切换左右声道, 频率 = 音频采样率, 映射到 NSS 部分 
CK 为串行时钟 (SCK/BCLK), 在I2S_CK 部分从 I2S clock Generator 中可以找到。
I2S2ext_SD  为相关的拓展引脚, 用于全双工
MCK 当 I2S 配置为主模式切 SPI_I2SPR 的 MCKOE 为1时, 被使能。  
对于 I2S_ext , 只能用于全双工且始终工作在从模式下, 此时两线均可以用于发送和接收。

I2S 支持以下四种数据和帧格式组合:
![[attachments/Pasted image 20240727180620.png]]

> [!caution] 注意
> The 24-bit and 32-bit data frames need two CPU read or write operations to/from the SPI_DR or two DMA operations if the DMA is preferred for the application. For 24-bit data frame specifically, the 8 nonsignificant bits are extended to 32 bits with 0-bits (by hardware).
> 即在24或者32位下, 需要两次DMA操作

支持的 Philips 标准传输的 I2S 时序图如下:
![[attachments/Pasted image 20240727180930.png]]
注意: SPI_DR 是16位 的寄存器, 在24位模式下的数据传输, 必须对SPI_DR执行两次读取或者写入操作。

> [!caution] 注意
> 从SD卡中得到的 wav 数据流是**低字节在前高字节在后**的,  因此16位存储时需要使用 `buff_i2s[i+1] <<8 +  buff_i2s[i]`, `SPI_DR = (uint16_t) buff_i2s[i-1]` 类似的操作，写入时会自动补齐 0 

### (4) 原理图部分说明
对于 LIN1 和 RIN 1, 接入的是 MIC_P 和 MIC_N, 即传入 DAC数据, 通道输入为 LINE_IN  部分, 而输出通道为 LOUT1, LOUT2 部分, 连接 PHONE 用于耳机输出(常见型号有 PJ-313, PJ-313B 和 PJ-320B， PJ326 等)
![[attachments/Pasted image 20240727220452.png]]
对于喇叭部分, 其输出仅来源于输出入通道2 (SPK_IN)

其二, <mark style="background: transparent; color: red">对于 DMA 数据的设置需要设为双缓冲循环模式</mark> , 以方便填充数据部分。

- 音频连接器接口设计参考 https://www.youtube.com/watch?v=PO96PH5BNr4 , 隐僻连接器 (TRS)-> Tip, Ring, Sleeve)  具体如下:
![[attachments/9169 1.png|550]]
参考下图, 实际上**含有的带弯折图部分是一个动触点**, 一般对于音频连接器,另外也有耳机兼容麦克风的接头(如PJ327系列), 

实际上, 一般下面的2和10是闭合的, 插入时, 下面的动开关2和10断开; 
参考[waht is audio jack switch](https://www.cuidevices.com/blog/understanding-audio-jack-switches-and-schematics)
![[attachments/Pasted image 20240727223903.png|750]]

<mark style="background: transparent; color: red">一般1脚即最靠近外部的引脚是接地的。</mark> 2 为 left 左声道, 一般连接音频信号的正极(LOUT1), 3 为 Right 右声道(ROUT1), 一般连接音频信号的负极。 
![[attachments/Pasted image 20240727225225.png|300]]
可以设计电路如图:
![[attachments/Pasted image 20240727225846.png]]
对于插入检测的机制, 可以将 
![[attachments/Pasted image 20240811161208.png|400]]

## 三、双缓冲I2S原理与DMA机制讲解
### (1) 双缓冲区初始化:
首先必须申请两片内存 M0AR，M1AR 部分, 程序填充好 M0AR （过程中 CPU 填充另外的内存M1AR）之后, 自动切换到 M1AR, 此时CPU填充 M0AR 部分, 
> [!caution] 注意
> 必须保证在发送过程中将另一个寄存器填满, 因此需要开启传输完成中断函数, 保证即时填满数据

双缓冲 DMA 是调用 `HAL_DMAEx_MultiBufferStart()` 函数进行设置的, 而<mark style="background: transparent; color: red">其中每个数据发送完毕之后, 硬件自动切换为下一个缓冲同时进入中断服务函数</mark>, **中断服务函数中, 执行切换缓冲区操作, 而主函数中执行填充数据到刚发送完的缓冲区操作。**

对于双缓冲区的 DMA 传输中断的编写: 仍然采用两个标志位的方式:
```c
volatile uint8_t wav_dma_ht_flag = 0;	 // half transfer 
volatile uint8_t wav_dma_tc_flag = 0;    // complete transfer 
```

如果是单缓冲区, 分成两个部分, 可以这样写:
```c
/// @brief get the flag of the DMA2_Channel3 and set the reading flag. 
void DMA2_Channel3_IRQHandler(void){
    if (DMA_GetITStatus(DMA2_IT_HT3) == SET){  // Half Transfer
        wav_dma_ht_flag = 1;
        wav_dma_tc_flag = 1;
        DMA_ClearITPendingBit(DMA2_IT_HT3);
    }else if (DMA_GetITStatus(DMA2_IT_TC3) == SET){  // Transfer Complete
        wav_dma_ht_flag = 0;
        wav_dma_tc_flag = 1;
        DMA_ClearITPendingBit(DMA2_IT_TC3);
    }
}
```

而对于双缓冲区的情况下, 往往需要判断上一个传输完成的是哪个缓冲区: 此时可以判断 DMA stream x 的 CT 位 (bit19), 表示current target;  其中:
0 表示 the currrent target memory is mem0;
1 表示 the currrent target memory is mem1;

另外需要注意的是, 发送的顺序其实和读取的顺序是不同的, 如下图所示:
![[attachments/Pasted image 20240730105149.png]]
对于<mark style="background: transparent; color: red"> 16 bit 的音频, 是可以直接读取数据直接填充到原始的 buff 中进行发送的</mark>, 但是对于24位的音频, 则需要按照其他方法进行发送。第一次发送高8位, 然后发送低8位
```c
if (bits == 24)                 /* 24bit音频,需要处理一下 */
{
	readlen = (size / 4) * 3;   /* 此次要读取的字节数 */
	f_read(g_audiodev.file, g_audiodev.tbuf, readlen, (UINT*)&bread);   /* 读取数据 */
	p = g_audiodev.tbuf;
	for (i = 0; i < size;)
	{
		buf[i++] = p[1];
		buf[i] = p[2];
		i += 2;
		buf[i++] = p[0];
		p += 3;
	}
	bread = (bread * 4) / 3;    /* 填充后的大小. */
}
```
对于发送过程中, I2S 的 DR 是 16 位位宽的寄存器, 上述的操作实际上是: `buf[0] = p[1], buf[1] = p[2], buf[4] = p[0]`; 
![[Excalidraw/2. ES8388 芯片 mp3 和 wav 的解码和播放 2024-07-31 14.53.13]]

一般可以采用分别两个 BUF 的方法解决, 另外也可以通过**从后向前进行计算和交换填充解决**。

### (2) DMA 位宽配置注意事项
<mark style="background: transparent; color: red"><b>最后必须注意的是, 初始化DMA时, 双缓冲区模式下的 DMAEx_MultiBufferStart 中, 转运的大小是 size/2</b></mark>， 即使用DMA初始化的空间实际上<mark style="background: transparent; color: red">是Buffer_Size的一半</mark>, 也对应于原始代码中的**i2s_init(....../WAV_I2S_TX_DMA_BUFSIZE/2)** 
```c
HAL_DMAEx_MultiBufferStart(&es8388_dma_handler,(uint32_t)buff1, (uint32_t)&ES8388_I2S_SPI_PORT->DR, (uint32_t)buff2, size/2);
```
这是因为: **后面的size是指的 我们的缓冲区设置是 8192 bytes, 而 I2S 传输的DR寄存器位宽是 16 位,** 而**两个 buffer 均为 uint8_t 的部分, 因此需要进行除2处理, 同样地, DMA 的位宽也是设置为 16bit 传输(半字)部分的**, 这个在整个部分是统一的, 而 size 需要符合这个大小。

### (3) I2S DMA 使能位设置
其二, 对于 I2S 的初始化, 参考[[💻softwares/⚡Circuit/🤖 STM32F4和HAL库/基本外设部分/2. DMA 外设的使用及DMA加速W25Q128|2. DMA 外设的使用及DMA加速W25Q128]], 中间不得缺少这两句:
```c
    /*##-5- Configure the NVIC for SPI #########################################*/
    HAL_NVIC_SetPriority(W25Qxx_SPI_IRQn, 0, 2);
    HAL_NVIC_EnableIRQ(W25Qxx_SPI_IRQn);
```
在SPI_CR2中即必须使能 TXDMAEN 位, 才能保证
![[attachments/Pasted image 20240730113816.png]]
实际上是调用了 `__HAL_I2S_ENABLE_IT` 来设置其中的CR2 寄存器, 应当使能这个中断, 才能让:
```c
__HAL_I2S_ENABLE_IT(&es8388_i2s_handler, I2S_IT_TXE);
__HAL_I2S_ENABLE(&es8388_i2s_handler);  /* start I2S enable bit -> must be added */  
// 这一句必须在初始化之后加上, 否则无法进入中断
```

> [!caution] 中断请求使能和处理使能函数的理解
> 对于 I2S 等等的TX标志位, 是没有相应的清除函数的(这是因为满后如果没有发送的仍然会置一), <b><mark style="background: transparent; color: red">我们需要使能 IRQ  但是不使能 IT </mark></b>, <b><mark style="background: transparent; color: blue">其中 IRQ(Interrupt Request) 表示特定的中断线请求,  即启用这个来保证请求可以发送到 DMA 部分, 而 __HAL_ENABLE_IT 是用于满足中断条件时, 触发中断处理程序</mark></b>，因此我们在使用DMA时一般不会调用 `__HAL_ENABLE_IT`, 但是需要使能 IRQn 请求。

上面部分即 SPI2 TX DMA请求使能, 但是这样**实际上没有使能 I2S 的TX中断**, **目前只能考虑使用直接操作 CR2 寄存器使能中断**, 使用如下函数: (这是因为HAL库本身I2S循环模式下, `__HAL_LINKDMA` 函数会失效造成的)
```c
void i2s_dma_enable(void)
{
    uint32_t tempreg = 0;
    I2S_SPI->CR2  |= 1 << 1;          /* 使能DMA */
}
```

### (4) PLLI2S 锁相环时钟和中断配置 
1. <b><mark style="background: transparent; color: red">在 HAL 库中, 还有一个重要的时钟，即 PLLI2S 在调用前必须进行使能, 这个控制的是 RCC-> CR 的PLLI2SON位</mark> </b>, 调用的方法是: 
```c
__HAL_RCC_PLLI2S_ENABLE();
```
这个也是**极其重要的一个时钟初始化**, 并且是可以放在前面的时钟初始化中。

另外需要注意: `HAL_DMAEx_MultiBufferStart_IT` 是不能使用的, 应当使用 `HAL_DMAEx_MultiBufferStart`，由于 使用_IT 会使得在 DMA 传输完成时, 同时触发中断(会使能所有的中断)， 其内部逻辑如下:
```c title:带有__IT的内部逻辑
/* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
    hdma->Instance->FCR |= DMA_IT_FE;
```

其二, **注意 DMA 请求的 TCIFx 部分, 对应TCIF0是针对Stream的部分, 因此对应的中断应当设置为 DMA_TCIF0_4**表示Stream4的中断, 

之后, 需要将 OUT 部分的定义进行更改: 
```c
GPIO_InitStruct.Alternate = ES8388_I2SEx_AF;  // 这个会导致初始化错误, 

/* 在使用 SDOUT 初始化, 仍然采用 SPI 默认的 AF,  不用 ext */
GPIO_InitStruct.Pin = ES8388_SDOUT_PIN;
HAL_GPIO_Init(ES8388_SDOUT_GPIO, &GPIO_InitStruct);
```

因此我们可以通过如下的函数自动重置采样率:
```
uint8_t set_samplerate(uint32_t samplerate)
{
	__HAL_I2S_DISABLE(&g_i2s_handler);
    switch (samplerate){
        case 8000:  g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_8K; break;
        case 11025: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_11K; break;
        case 16000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_16K; break;
        case 22050: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_22K; break;
        case 32000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_32K; break;
        case 44100: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_44K; break;
        case 48000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_48K; break;
        case 96000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_96K; break;
        default: return 1;  /* unsupported sample rate */
    }
    if (HAL_I2S_Init(&g_i2s_handler) != HAL_OK){  /* I2S init fail */
        printf("Init failed!!!!\r\n");
        return 1;
    }
    __HAL_I2S_ENABLE(&g_i2s_handler);  /** keep the  i2s enable --> not disable it */
}
```

此外, 需要注意 ES8388 必须设置音量和 DAC 输出之后才能正常运行, 这是由于设置音量部分DAC默认是00000000, 没有音量输出。
```c
es8388_hpvol_set(25);       /* 设置耳机音量 */
es8388_spkvol_set(20);      /* 设置喇叭音量 */
es8388_adda_cfg(1, 0);      /* 开启DAC关闭ADC */
es8388_output_cfg(1, 1);    /* DAC选择通道1输出 */
```
**由于当DAC没有开启时, 转运不会成功, 此时 I2S 不会触发中断。**
```c
ES8388_PwrCtrl(1, 0);    /** Power down ADC and up DAC */
ES8388_OutputCtrl(1,1);    /** Enable DAC output */
ES8388_SetVolume_ch1(20);    /** Set volume of DAC output */
ES8388_SetVolume_ch2(20);    /** Set volume of DAC output */
```

## 四、HAL 库的硬件 I2C 使用 
### (1) 初始化示例代码
在 I2C 中， 起始信号是 0(Start) + 001000 + AD0 + RW 部分, 此处将 AD0 设置为0) 
可以通过 Es8388_write (0x2e或者 0x2f), 即寄存器 R46, R47

> [!caution] ES8388 I2C 初始化注意事项
> 对于ES8388而言, 时钟线必须采用推挽输出, 不能采用开漏输出模式, 否则无法读写寄存器。

示例初始化代码如下: 
```c title:ES8388_I2C总线初始化代码
GPIO_InitStruct.Pin = ES8388_I2C_SCL_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
GPIO_InitStruct.Alternate = ES8388_I2C_AF;
HAL_GPIO_Init(ES8388_I2C_SCL_GPIO, &GPIO_InitStruct);

GPIO_InitStruct.Pin = ES8388_I2C_SDA_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
HAL_GPIO_Init(ES8388_I2C_SDA_GPIO, &GPIO_InitStruct);
```

### (2) 硬件 I2C 死锁解决方案
对于 I2C，一般首先都需要使用软件初始化并产生停止信号来停止总线的所有设备, 以避免总线死锁。
```c
/**
 * @brief       产生IIC停止信号
 * @param       无
 * @retval      无
 */
void iic_stop(void)
{
    IIC_SDA(0);     /* STOP信号: 当SCL为高时, SDA从低变成高, 表示停止信号 */
    iic_delay();
    IIC_SCL(1);
    iic_delay();
    IIC_SDA(1);     /* 发送I2C总线结束信号 */
    iic_delay();
}
```
在 硬件 I2C 的初始化中, 可以加入如下的中断函数, 用于将 HAL 库中的 I2C 事件中断继承初始的事件中断:
```c title:硬件I2C中断使用
/**
  * @brief  This function handles I2C event interrupt request.
  * @param  None
  * @retval None
  * @Note   This function is redefined in "main.h" and related to I2C data transmission
  */
void I2Cx_EV_IRQHandler(void)
{
  HAL_I2C_EV_IRQHandler(& I2CxHandle);
}

/**
  * @brief  This function handles I2C error interrupt request.
  * @param  None
  * @retval None
  * @Note   This function is redefined in "main.h" and related to I2C error
  */
void I2Cx_ER_IRQHandler(void)
{
  HAL_I2C_ER_IRQHandler(& I2CxHandle);
}
```

参考文章 [HAL库STM32常用外设教程（九）—— I2C通信（读写EEPROM](https://blog.csdn.net/That_Assassin/article/details/135981146) ,  可知:
首先 HAL 库提供了一个方便的函数用于检查是否存在: 
```c
if (HAL_I2C_IsDeviceReady(&es8388_i2c_handler, addr,10, 1000)== HAL_OK)
```

需要注意的是, 其中retry 一般不能设的太小, 可以设为10左右的值就可以基本上保证每次都初始化成功。
```c
HAL_I2C_IsDeviceReady(&es8388_i2c_handler,ES8388_ADDR, 10, 200); 
```

第二, **使用软件方法解除I2C 总线的死锁问题**:
```c
void ES8388_Unlock(void){
    /** Use GPIO for Init */
    ES8388_GPIO_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    GPIO_InitStruct.Pin = ES8388_I2C_SCL_PIN;
    HAL_GPIO_Init(ES8388_I2C_SCL_GPIO, &GPIO_InitStruct);
    GPIO_InitStruct.Pin = ES8388_I2C_SDA_PIN;
    HAL_GPIO_Init(ES8388_I2C_SDA_GPIO, &GPIO_InitStruct);
    
    /** Generate Stop Signal In GPIO Mode */ 
    HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    /* write 16 clock pulse */
    for (int i = 0; i < 16; i++) {
        HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_RESET);
        HAL_Delay(2);
        HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
        HAL_Delay(2);
    }
    /* Stop Singal  */
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_RESET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_SET);
    HAL_Delay(300);
}
```
其中, **如果需要初始化 EEPROM，只需给出其地址 0xA0 即可，而板载的地址也包括ES8388,其地址为0x20**; IIC 总线实际上如下所示:
![[attachments/Pasted image 20240728171409.png]]
对于硬件 I2C 的发送和接收函数, 重要的是如下几个函数:

| 函数 (Function)             | 功能描述 (Function Description) |
|---------------------------|-----------------------------|
| HAL_I2C_IsDeviceReady()   | 检查目标设备就绪状态                  |
| HAL_I2C_Master_Transmit() | 以主机发送数据到指定的从机设备             |
| HAL_I2C_Master_Receive()  | 以主机接收指定的从机设备发送来的数据          |
| HAL_I2C_Slave_Transmit()  | 以从机发送数据给主机，仅当主机请求时          |
| HAL_I2C_Mem_Write()       | 以主机模式向指定的从机设备内部地址写入数据       |
| HAL_I2C_Mem_Read()        | 以主机模式读取指定的从机设备内部地址的数据       |

注意使用使用 IT 是带中断式的读取和写入, 其中专门用于存储器读写的，具体如下: 

| 函数名                        | 函数功能描述                   | 关联的回调函数                      |
|----------------------------|--------------------------|------------------------------|
| HAL_I2C_Master_Transmit_IT | 主设备向某个地址的从设备发送一定长度的数据    | HAL_I2C_MasterTxCpltCallback |
| HAL_I2C_Master_Receive_IT  | 主设备从某个地址的从设备接收一定长度的数据    | HAL_I2C_MasterRxCpltCallback |
| HAL_I2C_Master_Abort_IT    | 主设备主动中止中断传输过程            | HAL_I2C_AbortCpltCallback    |
| HAL_I2C_Slave_Receive_IT   | 作为从设备接收一定长度的数据           | HAL_I2C_SlaveRxCpltCallback  |
| HAL_I2C_Slave_Transmit_IT  | 作为从设备发送一定长度的数据           | HAL_I2C_SlaveTxCpltCallback  |
| HAL_I2C_Mem_Write_IT       | 向某个从设备的指定存储地址开始写入一定长度的数据 | HAL_I2C_MemTxCpltCallback    |
| HAL_I2C_Mem_Read_IT        | 从某个从设备的指定存储地址开始读取一定长度的数据 | HAL_I2C_MemRxCpltCallback    |
| HAL_I2C_ErrorCallback      | 所有中断方式传输函数中出现错误时调用       | 无                            |

General Call address detection，广播呼叫检测。设置为Disable表示禁止广播呼叫，不对地址0x00应答；否则，就是允许广播呼叫，对地址0x00应答。

### (3) 读写函数的编写
实际写入函数和读取函数只要使用下面就行了: (对于24C02, 延时设置为2ms即可)

```c
/**
 * @brief Write the register of ES8388
 * @note  The register address is 8-bit, and the data is 8-bit 
 * 
 */
uint8_t ES8388_write_reg(uint16_t reg_addr, uint8_t data){
    uint8_t res = 0;
    res = HAL_I2C_Mem_Write(&es8388_i2c_handler,ES8388_ADDR ,reg_addr,I2C_MEMADD_SIZE_8BIT, &data, 1, ES8388_TIMEOUT);
    HAL_Delay(2);  // This Delay must be add during the write and next operation */
    return res;
}

/**
 * @brief Read the register of ES8388
 * @param reg_addr 
 * @param data 
 * @return  
 */
uint8_t ES8388_read_reg(uint16_t reg_addr, uint8_t *data){
    uint8_t res = 0;
    res = HAL_I2C_Mem_Read(&es8388_i2c_handler, ES8388_ADDR, reg_addr, I2C_MEMADD_SIZE_8BIT, data, 1, ES8388_TIMEOUT);
    HAL_Delay(2); // This Delay must be add during the write and next operation */
    return res;
}
```
其中大小采用 I2C_MEMADD_SIZE_8BIT  8位地址部分
说明: **在硬件I2C传输中只需要定义一个固定的 I2C 地址(按8位算, 或者7位左移1位)**, **HAL 库会自动加上 R/W其中写为0,读为1, 进行发送, 需要注意，在读写过程中, 一定要加上等待函数**;
```c title:测试I2C通信代码
void EEPROM_test(){
	EEPROM_i2cInit();
	/** Use EEPROM as test */
	if (HAL_I2C_IsDeviceReady(&es8388_i2c_handler, 0xA0, 5, 1000)== HAL_OK){
		printf("EEPROM is ready\r\n");
	}
	uint8_t data = 0x55, res = 0;
	if (HAL_I2C_Mem_Write(&es8388_i2c_handler, 0xA0, 0, I2C_MEMADD_SIZE_8BIT, &data, 1, 0xffff)){
		printf("Write failed\r\n");
		return 1;
	}
	HAL_Delay(10);    /* This Delay must be add during the write and read */
	if (HAL_I2C_Mem_Read(&es8388_i2c_handler, 0xA0, 0, I2C_MEMADD_SIZE_8BIT, &res, 1, 0xffff)){
		printf("Read failed\r\n");
		return 1;
	};
	printf("res: %x\r\n", res);
}
```
参考 原理图
![[attachments/Pasted image 20240728202441.png]]
以及程序框图, ADC是接入 LIN 和 RIN 部分的, 因此不使用 MIC 可以考虑不开启 ADC, 
![[attachments/Pasted image 20240728202456.png|800]]
同时, LIN 和 RIN 对于 DACR, DACL 中也有选择通道, 可以选用是否进行获取。

R4 寄存器用于配置 LOUT1, LOUT2, ROUT1, ROUT2 的音频, <mark style="background: transparent; color: red">在板载的部分, ROUT2 和 LOUT2 是用电容混音后, 接入 SPK_IN 喇叭部分的, 而 LOUT1, ROUT1 接入 PHONE  耳机输出接口</mark>。
对于 DMA 初始化，采用 I2S 作为触发源, 参考[[💻softwares/⚡Circuit/🤖 STM32F4和HAL库/基本外设部分/2. DMA 外设的使用及DMA加速W25Q128|DMA 外设的使用及DMA加速W25Q128]] 部分, 类似SPI地, **使用 SPI2_TX 作为触发源**, 即使用 DMA1 Stream4, Channel0 部分;

## 五、I2S 时钟预分频配置
寄存器方法精确配置采样率时钟配置需要用到如下的两个重要函数: 
其中 PeriphCLKConfig 用于配置  PLLI2SN, PLLI2SR 部分, 
```c
HAL_RCCEx_PeriphCLKConfig(&ES8388_I2S_PeriphCLKInit);
HAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit);
#define __HAL_RCC_I2S_CONFIG(__SOURCE__) (MODIFY_REG(RCC->CFGR, RCC_CFGR_I2SSRC, (__SOURCE__))) 
```

其中第三个是设置时钟源, 有如下两个参数:
- `RCC_I2SCLKSOURCE_PLLI2S`：使用 PLLI2S 作为 I2S 时钟源。
- `RCC_I2SCLKSOURCE_EXT`：使用外部时钟作为 I2S 时钟源。

在 HAL_SPI_I2S_Init 函数中就有了相关的波特率设置, 但是需要注意:
```c
   -@- Make sure that either:
        (+@) I2S PLL clock is configured or
        (+@) External clock source is configured after setting correctly
             the define constant EXTERNAL_CLOCK_VALUE in the stm32f4xx_hal_conf.h file.
```
其中 EXTERNAL_CLOCK_VALUE = 12288000U (即12.288MHz)

其中 Init 函数调用了这个函数: 
```c
HAL_RCCEx_GetPeriphCLKFreq
```

实际上是这样写的 : 
```c
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
  uint32_t srcclk = 0U;
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
  switch (PeriphClk)
  {
  case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
      switch (srcclk)
      {
      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
      case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
          break;
        }
      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */
      case RCC_I2SCLKSOURCE_PLLI2S:
        {
#if defined(STM32F411xE)
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
#else
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
          break;
        }
        /* Clock not enabled for I2S*/
      default:
        {
          frequency = 0U;
          break;
        }
      }
      break;
    }
  default:
    {
       break;
    }
  }
  return frequency;
}
``` 
根据: 
$$ I2S \space Clocks  =  8MHz * PLL2SN / 8(M)  / PLL2SR   $$
我们只需要设置PLL2SN = 86,   PLL2SR = 7, 则对应的频率为  12.28571MHz, 与12.288MHz误差为 0.018%, 符合预期。

因此实际上只要这样写即可: 
```c
uint8_t musicplayer_setSampleRate(uint32_t audio_freq){
    __HAL_RCC_I2S_CONFIG(RCC_I2SCLKSOURCE_PLLI2S);    /* use PLLI2S as I2S clock source */
    
    RCC_PLLI2SInitTypeDef i2s_clk = {0};
    i2s_clk.PLLI2SN = 86;
    i2s_clk.PLLI2SR = 7;
    HAL_RCCEx_EnablePLLI2S(&i2s_clk);
    
    __HAL_I2S_DISABLE(&es8388_i2s_handler);
    es8388_i2s_handler.Init.AudioFreq = audio_freq;
    ES8388_Init(audio_freq);
    __HAL_I2S_ENABLE(&es8388_i2s_handler);
    return 0;
}
```

![[attachments/Pasted image 20240729152302.png]]
需要注意的是, 在**初始化中断完成之后, 一定要清除对应中断的标志位**, 这样才能够进行:
```c
__HAL_DMA_CLEAR_FLAG(&es8388_dma_handler, ESP8388_I2S_DMA_TC_FLAG);   /** Clear DMA transfer complete flag */
```

## 六、STM32 解码 MP3 部分
此处移植主要参考野火例程; 以及 [[💻softwares/⚡Circuit/🎮STM32教程/五、扩展模块/stm32读取和播放SD卡中的音乐mp3和wav文件|stm32读取和播放SD卡中的音乐mp3和wav文件]] 以及 [[💻softwares/⚡Circuit/🎮STM32教程/🎶 Helix MP3软件解码库/2.Helix 库移植 stm32 进行软解码音乐播放|2.Helix 库移植 stm32 进行软解码音乐播放]]   
对于定义helix内存分配的部分, 使用 buffers.c 进行相应的定义;
```c
// #define static_buffers
#ifdef static_buffers
MP3DecInfo  mp3DecInfo;     //  0x7f0 =  2032 
SubbandInfo sbi;            // 0x2204 =  8708
IMDCTInfo mi;               // 0x1b20 =  6944
HuffmanInfo hi;             // 0x1210 =  4624
DequantInfo di;             //  0x348 =   840
ScaleFactorInfo sfi;        //  0x124 =   292
SideInfo si;                //  0x148 =   328
FrameHeader fh;             //   0x38 =    56
#else
#include "mymalloc.h"
#define malloc(x) mymalloc(SRAMIN, x);
#define free(x)   myfree(SRAMIN, x);
#endif
``` 
一般而言,参考[[💻softwares/⚡Circuit/🎮STM32教程/🎶 Helix MP3软件解码库/2.Helix 库移植 stm32 进行软解码音乐播放#(4) 缓冲区内存控制|缓冲区内存控制]] 处理立体声数据时, 一帧输出缓冲区为 2304 * 16 字节; 此时, 需要一个 2304 * 16bit 的缓冲区接收 Decoder 的数据; 同时需要两个 2304 * 8 bit 的缓冲区作为DMA发送和接收;

最终需要 4 个数组, 两个 tx buffer 数组, 大小为 2 *  2304 字节;  一个 16 bit 解码帧缓存数组: 2304 * 2 bytes; 一个文件读数组 (5 * 1024 bytes); 因此在 MP3 解码器进行运行时, 需要的总 RAM 约为 18.5 kb (20kb左右)

需要注意的是, 在 mp3dec.h 中有定义 MAINBUF_SIZE = 1940; 这个是在MP3decode 中记录剩余字节数的, 例程逻辑是当 bytesleft < 2 * MAINBUF_SIZE 时, 再读取 5kb 文件并填充; 

主要的解码部分包括如下几个(按顺序): 
1. MP3FindSyncWord 
2. MP3Decode 
3. MP3GetLastFrameInfo 

需要说明的是, 对于 uint16_t* 转为 uint8_t* 的过程, 实际上是**按照地址转的**, 而不是将 uint16_t* 取低 8位 , 即  uint16_t* (a,b) (c,d) ->  uint8_t* (a) (b) (c) (d) , 这样也保留了 16 位的高位数据;

对于使用 DAC 情况下, 需要将PCM 数据从 32767 投影到 65536 范围, 但是 ES8388 只需直接写入对应的PCM数据即可, 不需进行偏移。 

下面是一个完整的代码示例, 但是这个解码过快; 
```c
/** transfer the decode data to es8388 for output */
while (mp3_dma_tc_flag == 0);                 // wait for  the last DMA transfer complete
mp3_dma_tc_flag = 0;                          // clear the DMA transfer complete flag 

// note : the 16-bit data is signed integar, so we cast it into 8 bit as follows:  
if (mp3_dma_tar_mem == 0){
	for (int i = 0; i < MP3_AUDIO_TX_BUFF_SZ/2; i++){
		uint16_t temp = music_player_buff_rx16[i];
		music_player_buff1[2 * i] = (temp & 0xFF);
		music_player_buff1[2 * i + 1] = (temp >> 8);
	}
}else{ // mp3_dma_tar_mem == 1 
	for (int i = 0; i < MP3_AUDIO_TX_BUFF_SZ/2; i++){
		uint16_t temp = music_player_buff_rx16[i];
		music_player_buff0[2 * i] = (temp & 0xFF);
		music_player_buff0[2 * i + 1] = (temp >> 8);
}
```

虽然歌曲是双声道的, 但是有时会读出单声道的情况, 此时, 再次按照单声道进行填充即会出现错误。
![[attachments/Pasted image 20240804182758.png]]
因此之后必须采用先解码一帧然后锁存的格式;

其二, 播放的速度远大于正常速度, 实际上是实际播放速度的好多倍; 但是 WAV 的播放速率大小和 wav_audio_buffer_size 实际上没有关系。

而且, mp3 播放速度实际上和 mp3 的 i2s 频率设置也没有很大关系;
首先, mp3 的 I2S 设置是 16 位数据长度, 也可以设置为 16 位扩展帧长度; 同时 WM8978 部分设置为 16 位数据长度;


> [!caution] DMA 缓冲区大小的设置部分
> 在标准库中, 通过  DMA_BufferSize 确定 DMA 每次传输数据大小; 对于 WAV 传输的数据, 每一次传输的大小是 WAV_AUDIO_BUFFER_SIZE;
> 即初始化是 `ES8388_OutPut_Init((uint8_t*)music_player_buff0,(uint8_t*)music_player_buff1, WAV_AUDIO_BUFFER_SIZE)`

最终修复问题方法是将厂家更改 wav 采样频率的 SetSampleRate_Precise 更改为 SetSampleRate_Auto, 获得了很稳定的效果; 
```c title:mp3_player_play函数编写示例
// start playing the current mp3 file 
/// @note : in play function, storge must be freed after calling it (use stop function)
uint8_t mp3_player_play(void){
    MP3FrameInfo mp3frameinfo;
    uint8_t res;
    unsigned char* readptr;	// MP3 decodes the read pointer
    int err = 0;            // error for mp3 decode  
    int offset=0;	        // Offset
    int bytesleft=0;        // buffer also has valid data remaining
    UINT br = 0;
    
    /**  Init hardware layer output controller */
    ES8388_i2s_tc_callback = mp3player_i2s_callback;   /* set up callback function */
    
    
    if (ES8388_OutPut_Init((uint8_t*)music_player_buff0, (uint8_t*)music_player_buff1, MP3_AUDIO_TX_BUFF_SZ) ||
        decoder == NULL || ES8388_SetSampleRate_Auto(mp3ctrl.samplerate))   // note : if use accurate -> can't set sample rate correctly;
    {
        return 1;   /** es8388 error */
    }
    ES8388_I2SModeSet(I2S_STANDARD_PHILIPS, I2S_DATAFORMAT_16B, 1, DMA_CIRCULAR, 1);
    musicplayer_setoutput(playerctrl.OutputDevice);
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_HEADPHONE, playerctrl.ch1Volume);   /** Initialize  */
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_SPEAKER, playerctrl.ch2Volume);
    
    decoder = MP3InitDecoder();     /* Init mp3 decoder */
    if (f_open(&mp3_file, (char*) music_name_playing, FA_READ)!=FR_OK) return 1;
    f_lseek(&mp3_file, mp3ctrl.datastart);	   //Skip the tag in the file header
    
    /** before start playing, try read the buffer and decode the 1st frame */
    // res = f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);
    // readptr = music_player_buff_rx8;
    // if (res != FR_OK) {
    //     f_close(&mp3_file); return -1;
    // }else{
    //     offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
        
    // }

    ES8388_DMAStart();
    while(!f_eof(&mp3_file)){
        offset = 0;
        bytesleft = 0;
        f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);
        if (res!= FR_OK)  break;   /** considering plug out the card during playing */
        bytesleft += br;           /**  bytes left in the buffer  */ 
        readptr = (uint8_t*)music_player_buff_rx8;
        
        while (!f_eof(&mp3_file))
        {
            mp3_get_curtime(&mp3_file, &mp3ctrl);
            err = 0;
            /* find the sync word from buff each time */ 
            offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
            if (offset < 0) break;  /* can't find the sync word -> read again for next frame */ 
            /* fix the reading pointer and bytes left */
            readptr   += offset;
            bytesleft -= offset;
            err=MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0); /* may be fast forward and backward  */ 
            if (err!=ERR_MP3_NONE) break;   /** read again and try decode the next frame */
            
            MP3GetLastFrameInfo(decoder, &mp3frameinfo);        /** get the last frame from decoder */
            mp3ctrl.bitrate = mp3frameinfo.bitrate;
            
            mp3_fill_buffer(mp3ctrl.outsamples, 2);
            if (bytesleft < MAINBUF_SIZE){  /* read  new data in the buffer */
                uint8_t byte_align = 4 - bytesleft&3;  // make sure the bytesleft is 4 bytes alignment 
                bytesleft += byte_align;
                memcpy((void*)music_player_buff_rx8, (void*)(readptr - byte_align), bytesleft);   /** copy the bytesleft length data to tx buffer  */
                res = f_read(&mp3_file,  (void*)(music_player_buff_rx8 + bytesleft), MP3_FILE_READ_BUFF_SZ - bytesleft, &br);
                if (res != FR_OK) break;
                if (br <  MP3_FILE_READ_BUFF_SZ - bytesleft){
                    memset((void*)(music_player_buff_rx8 + bytesleft + br), 0,  MP3_FILE_READ_BUFF_SZ - br);
                }
                readptr = (unsigned char*)music_player_buff_rx8;
                bytesleft += br;
            }
        }
    }
    ES8388_DMAStop();
    MP3FreeDecoder(decoder);
    return res;
}
```

为了优化上述 mp3 播放函数, 首先需要先解码一帧和填充 buffer, 代码部分如下:
```c
/** before start playing, try read the buffer and decode the 1st frame */
res = f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);    

/* try decode the first frame */
if (res == FR_OK) {
	readptr = (uint8_t*) music_player_buff_rx8;
	bytesleft = br;
	offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
	readptr += offset;
	bytesleft -= offset;
	err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
	if (offset < 0 || err!=ERR_MP3_NONE) 
	{
		f_close(&mp3_file); return 1;
	}
	MP3GetLastFrameInfo(decoder, &mp3frameinfo);
	mp3ctrl.nChannels = mp3frameinfo.nChans;
	/* set buffer to mute first */
	__Mem_Set___((void*)music_player_buff0, 0, MP3_AUDIO_TX_BUFF_SZ);
	__Mem_Set___((void*)music_player_buff1, 0, MP3_AUDIO_TX_BUFF_SZ); 
}
else
{
	f_close(&mp3_file); return 1;
}
```

同时, 有的帧存在解码不出的情况, 此时就需要跳过对应的帧, 而跳过帧的方法是通过将读指针偏移一位, 此时就可以直接通过下一次 MP3FindSyncWord 找到下一帧对应的位置了; 即只需要两行代码:
```c
readptr  ++;
bytesleft --;
```

最终通过重试4次, 可以保证 mp3 播放整体的连续性, 因此整体的播放代码如下:

```c
// start playing the current mp3 file 
/// @note : in play function, storge must be freed after calling it (use stop function)
uint8_t mp3_player_play(void){
    MP3FrameInfo mp3frameinfo;
    uint8_t res;
    unsigned char* readptr;	// MP3 decodes the read pointer
    int err = 0;            // error for mp3 decode  
    int offset=0;	        // Offset
    int bytesleft=0;        // buffer also has valid data remaining
    UINT br = 0;
    
    /**  Init hardware layer output controller */
    ES8388_i2s_tc_callback = mp3player_i2s_callback;   /* set up callback function */
    
    
    if (ES8388_OutPut_Init((uint8_t*)music_player_buff0, (uint8_t*)music_player_buff1, MP3_AUDIO_TX_BUFF_SZ) ||
        decoder == NULL || ES8388_SetSampleRate_Auto(mp3ctrl.samplerate))   // note : if use accurate -> can't set sample rate correctly;
    {
        return 1;   /** es8388 error */
    }
    ES8388_I2SModeSet(I2S_STANDARD_PHILIPS, I2S_DATAFORMAT_16B, 1, DMA_CIRCULAR, 1);
    musicplayer_setoutput(playerctrl.OutputDevice);
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_HEADPHONE, playerctrl.ch1Volume);   /** Initialize  */
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_SPEAKER, playerctrl.ch2Volume);
    
    decoder = MP3InitDecoder();     /* Init mp3 decoder */
    if (f_open(&mp3_file, (char*) music_name_playing, FA_READ)!=FR_OK) return 1;
    f_lseek(&mp3_file, mp3ctrl.datastart);	   //Skip the tag in the file header
    
    /** before start playing, try read the buffer and decode the 1st frame */
    res = f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);    
    
    /* try decode the first frame */
    if (res == FR_OK) {
        readptr = (uint8_t*) music_player_buff_rx8;
        bytesleft = br;
        offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
        readptr += offset;
        bytesleft -= offset;
        err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
        if (offset < 0 || err!=ERR_MP3_NONE) 
        {
            f_close(&mp3_file); return 1;
        }
        MP3GetLastFrameInfo(decoder, &mp3frameinfo);
        mp3ctrl.nChannels = mp3frameinfo.nChans;
        /* set buffer to mute first */
        __Mem_Set___((void*)music_player_buff0, 0, MP3_AUDIO_TX_BUFF_SZ);
        __Mem_Set___((void*)music_player_buff1, 0, MP3_AUDIO_TX_BUFF_SZ); 
    }
    else
    {
        f_close(&mp3_file); return 1;
    }


    /** start the music player and decode all the frames */
    ES8388_DMAStart();
    while(!f_eof(&mp3_file)){
        offset = 0;
        err = 0;
        
        /** fill the last frame */
        mp3_get_curtime(&mp3_file, &mp3ctrl);
        mp3_fill_buffer(mp3ctrl.outsamples, mp3ctrl.nChannels);
        
        /** begin decode this frame */
        offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
        /* find the sync word from buff each time */
        if (offset < 0)
        {   /* if sync word can't be found, jump this frame */
            if (f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br)!= FR_OK) break;
            /** reset read pointer and bytes left */
            readptr   = (unsigned char*)music_player_buff_rx8;
            bytesleft = br;
            continue;
        }
        /* fix the reading pointer and bytes left */
        else
        {
            /** decode from offset */
            readptr   += offset;
            bytesleft -= offset;
            
            for (int i = 0; i < 4; i ++){
                err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
                if (err == ERR_MP3_NONE) break;
                readptr++;
                bytesleft--;
                offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
                readptr += offset;
                bytesleft -= offset;
                if (bytesleft < 0|| offset < 0) break;
            }

            if (err != ERR_MP3_NONE){
                /** if still decode failed, fill with mute to avoid  */
                // printf("frame decode failed, replaced with mute\r\n");
                __Mem_Set___((void*)music_player_buff_rx16, 0, MP3_AUDIO_TX_BUFF_SZ);
            }
            
            // MP3GetLastFrameInfo(decoder, &mp3frameinfo);        /** get the last frame from decoder */
            if (bytesleft < MAINBUF_SIZE){  /* read  new data in the buffer */
                uint8_t byte_align = 4 - bytesleft&3;  // make sure the bytesleft is 4 bytes alignment 
                bytesleft += byte_align;
                memcpy((void*)music_player_buff_rx8, (void*)(readptr - byte_align), bytesleft);   /** copy the bytesleft length data to tx buffer  */
                res = f_read(&mp3_file,  (void*)(music_player_buff_rx8 + bytesleft), MP3_FILE_READ_BUFF_SZ - bytesleft, &br);
                if (res != FR_OK) break;
                if (br <  MP3_FILE_READ_BUFF_SZ - bytesleft){
                    memset((void*)(music_player_buff_rx8 + bytesleft + br), 0,  MP3_FILE_READ_BUFF_SZ - br);
                }
                readptr = (unsigned char*)music_player_buff_rx8;
                bytesleft += br;
            }
        }
    }
    ES8388_DMAStop();
    MP3FreeDecoder(decoder);
    return res;
}
```

附注: 有时可能出现播放音乐大量杂音问题， 可以尝试扩大栈空间解决;

## 七、WAV 解码部分的完善
由于实际上 ES8388 支持 24 位和 32 位整形解码, 我们也需要对其添加 16 位单双声道, 

测试文件:
ARM.wav : 16 位单声道测试
Knock Me Out.wav: 16 位双声道测试
From_Dust_to_Dawn.wav : 24位单声道
Free_Loop.wav : 24 位双声道 
Silence.wav  : 32 位单声道
Edge Of My Life.wav : 32位双声道


> [!caution] 为何使用  I2S_Mode_Set 前必须使用的是 ES8388_SetSampleRate_Auto 
> 重复调用 I2SModeSet 之后, 会重置预分频值, 这会使得预先设置的和表内的不符合, 一种解决方法是先设置 I2SMode, 再调用精确设置(Set Accurate)函数;
> 因此, 实际上SetAuto 函数更加灵活, 而 SetAccurate 必须在 I2S 被正确配置之后, 才能进行设置.

对于 16 位单声道, 错误代码如下: 
```c
for (int i = WAV_AUDIO_BUFFER_SIZE/2; i > 0; i--){
	p[i*2-1] = p[i-1];
	p[i*2-2] = p[i-1];
}
```
上面这个只是简单将数据复制为两个;

查找 WAV 文件格式, 由于高低字节是交错的, 因此填充方式实际上是错误的;
![[attachments/Screenshot_20240805_184043_com.microsoft.skydrive.png|800]]
写出一种代码如下, 但是这个代码运算量较大, 考虑如何优化:
```c
for (int i = size/4 -1; i >= 0; i--){
	uint8_t tmp1 = p[2 * i], tmp2 = p[2 * i + 1];
	p[4 * i] = tmp1;
	p[4 * i + 1] = tmp2;
	p[4 * i + 2] = tmp1;
	p[4 * i + 3] = tmp2;
}
```


下面的是 FreeLoop 的块分布
![[attachments/Pasted image 20240805205512.png]]
这个是标准可解码的对比:
![[attachments/Pasted image 20240805205554.png]]
第一个正确读出对应的偏移Chunk Size = 40, 即偏移 12 + 8 + 40， 实际上是 60 的位置: 即从 60 开始读取; 应该是正确的, 但是**读取时分配RAM太小了; 导致没有找到**;

删除原先使用的 buff_temp 部分，改用 music_player_buff 进行获取, 解决问题;
![[attachments/Screenshot_20240805_214652_com.microsoft.skydrive.png|900]]

根据 16 帧或者 32 帧数据格式图, 基本时序如下:
![[attachments/Screenshot_20240805_215104_com.microsoft.skydrive.png|900]]
对于 16-bit frame length 和 24 bit frame length, 实际上也是根据

实际上我们需要按照 MSB 进行填充, 即采用如下代码填充:
```c
if (f_read(&FileRead, p, (WAV_AUDIO_BUFFER_SIZE/4) * 3, &br)) return 1;
	for (int i = WAV_AUDIO_BUFFER_SIZE/4 -1; i >= 0; i--){
		uint16_t idx = 4 * i, idx2 = 3 * i;
		p[idx] = p[idx2 + 2];
		p[idx + 1] = p[idx2 + 1];
		p[idx + 2] = p[idx2];
		p[idx + 3] = 0;
	}
```
后面查出是由于两个缓冲区颠倒问题， 导致巨大的杂音, 即下面两个buff1 和 buff0写反, 但是没有反过来写;
```c
if (wav_dma_tar_mem ==0) {
	p = (uint8_t*)music_player_buff1;
}else{
	p = (uint8_t*)music_player_buff0;
}
```

另外, 对于24 位单声道的数据, <mark style="background: transparent; color: red">只需与 24 位双声道处理完全相同即可, 不需要像16位一样复制数据;</mark>


对于mp3 单声道的支持, 使用如下代码(由于读取到mp3单声道文件的outputsamples仍然是2304,但是实际上仅前1152个用于解码, 因此需要采用 < outsamples/2 标志, 用以支持单声道mp3):
```c
if (nchans == 1){ // chans == 1 -> copy mono to stereo 
	for (int i = 0; i < outsamples/2; i++){    // this is applied to mono mp3 
		uint16_t temp = music_player_buff_rx16[i];
		uint16_t idx  = 4 * i;
		p[idx]      = (temp & 0xFF);
		p[idx + 1]  = (temp >> 8);
		p[idx + 2]  = p[idx];
		p[idx + 3]  = p[idx + 1];
	}
}else{ //  (nchans == 2) 
	for (int i = 0; i < outsamples; i++){
		uint16_t temp = music_player_buff_rx16[i];
		p[2 * i] = (temp & 0xFF);
		p[2 * i + 1] = (temp >> 8);
	}
}
```


## 七、解码错误处理和音质提升
对于野火的解决方案, 如下:
```c
switch (err)
{
	case ERR_MP3_INDATA_UNDERFLOW:
					printf("ERR_MP3_INDATA_UNDERFLOW\r\n");
					result = f_read(&file, inputbuf, INPUTBUF_SIZE, &bw);
					*read_ptr = inputbuf;
					*bytes_left = bw;
		break;		
	case ERR_MP3_MAINDATA_UNDERFLOW:
					/* do nothing - next call to decode will provide more mainData */
					printf("ERR_MP3_MAINDATA_UNDERFLOW\r\n");
		break;		
	default:
					printf("UNKNOWN ERROR:%d\r\n", err);		
					// 跳过此帧
					if (*bytes_left > 0)
					{
						(*bytes_left) --;
						read_ptr ++;
					}
		break;
}
return 0;
```
最常见且频发的错误是 ERR_MP3_INVALID_FRAMEHEADER, 且仅需要跳过即可;
因此我们可以使用 continue 来忽略错误统计中的该错误;

最终的错误处理函数如下:
```c
for (int i = 0; i < 10; i ++){
	err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
	if (err == ERR_MP3_NONE) break;
	switch (err){
		case ERR_MP3_INVALID_FRAMEHEADER:
			readptr++;
			bytesleft--;
			offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
			if (offset < 0) break;
			readptr += offset;
			bytesleft -= offset;
			continue;
		case ERR_MP3_INDATA_UNDERFLOW:   /** not enough message for this frame */
		case ERR_MP3_MAINDATA_UNDERFLOW:
			memcpy((void*)music_player_buff_rx8, (void*)readptr, bytesleft);   /** copy the bytesleft length data to tx buffer  */
			f_read(&mp3_file,  (void*)(music_player_buff_rx8 + bytesleft), MP3_FILE_READ_BUFF_SZ - bytesleft, &br);
			readptr = (unsigned char*)music_player_buff_rx8;
			bytesleft += br;
			break;
		default:
			readptr++;
			bytesleft--;
			break;
	}
	offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
	readptr += offset;
	bytesleft -= offset;
	/* in this case, no frame in the buffer, read whole buffer, not consider  */
	if (bytesleft <= 0|| offset < 0){
		if (f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br)!=FR_OK) {
			res = 1;
			break;
		}
		readptr   = (unsigned char*)music_player_buff_rx8;
		bytesleft = br;
	}
}
```

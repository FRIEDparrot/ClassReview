## ä¸€ã€ES8388 èŠ¯ç‰‡ç®€ä»‹
å¯¹äº ES8388 èŠ¯ç‰‡æ”¯æŒ I2S å’Œ SAI æ¥å£é€šä¿¡, å…¶ä¸­WM8978ä¹Ÿæ”¯æŒI2Sé€šä¿¡æ¥å£,  è€ŒVS1053 ä½¿ç”¨ SPI è¿›è¡Œé€šä¿¡ã€‚
å¯¹äº VS1053, æ”¯æŒç¡¬ä»¶ SPI ç›´æ¥å‘é€ wav å’Œ mp3æ•°æ®è§£ç , è€Œes8388 æœ‰æ›´å¥½çš„éŸ³è´¨, ä½†æ˜¯éœ€è¦è¿›è¡Œè½¯ä»¶è§£ç ã€‚

RIFF (Resource Interchange File Format), æ”¯æŒMS ADPCM, CCITT , ALAW ç­‰ç­‰å¤šç§å‹ç¼©ç®—æ³•, ä¸€èˆ¬çš„é‡‡æ ·ç‡éƒ½æ˜¯ 44100 Hz, èƒ½å¤Ÿå­˜æ”¾é«˜è´¨é‡éŸ³é¢‘ã€‚
WAV æ˜¯ç»è¿‡å‹ç¼©ç®—æ³•çš„ PCM(æœªå‹ç¼©) æ ¼å¼ã€‚

å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/äº”ã€æ‰©å±•æ¨¡å—/stm32è¯»å–å’Œæ’­æ”¾SDå¡ä¸­çš„éŸ³ä¹mp3å’Œwavæ–‡ä»¶|stm32è¯»å–å’Œæ’­æ”¾SDå¡ä¸­çš„éŸ³ä¹mp3å’Œwavæ–‡ä»¶]] ä»¥åŠ [[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/å…­ã€è¯­éŸ³è¯†åˆ«æ¨¡å—æ•™ç¨‹è®²è§£/STM32F103RET6çš„DACæ¨¡å—å’ŒéŸ³é¢‘è¾“å‡º|DACæ¨¡å—å’ŒéŸ³é¢‘è¾“å‡º]] éƒ¨åˆ†, 
é‡è¦çš„æ˜¯é‡‡æ ·ç‡ sample rate å’Œé‡‡æ ·ä½æ•° (16, 32)

æˆ‘ä»¬å®é™…ä¸Šéœ€è¦å°† SPI3 å¤ç”¨ä¸º I2S è¾“å‡ºç»™

ç¬¬ä¸€, RIFF Chunk 
```c
typedef __PACKED_STRUCT
Â {
Â  uint32_t ChunkID; Â  /* chunk id;è¿™é‡Œå›ºå®šä¸º"RIFF",å³ 0X46464952 */
Â  uint32_t ChunkSize ; Â  /* é›†åˆå¤§å°;æ–‡ä»¶æ€»å¤§å°-8 */
Â  uint32_t Format; Â  /* æ ¼å¼;WAVE,å³ 0X45564157 */
} ChunkRIFF ;
```

å…¶äºŒ, FMT Chunk 
```c
typedef struct
{
  uint32_t   ChunkID;       /* 0 */ /* chunk id;è¿™é‡Œå›ºå®šä¸º"fmt ",å³ 0X20746D66 */ 
  uint32_t   FileSize;      /* 4 */   /* å­é›†åˆå¤§å°(ä¸åŒ…æ‹¬ ID å’Œ Size) */  -> ä¸€èˆ¬ä¸º 8 
  uint32_t   FileFormat;    /* 8 */  /* éŸ³é¢‘æ ¼å¼;0X01,è¡¨ç¤ºçº¿æ€§ PCM;0X11 è¡¨ç¤º IMA ADPCM */
  uint32_t   SubChunk1ID;   /* 12 */   /* é€šé“æ•°é‡;1,è¡¨ç¤ºå•å£°é“;2,è¡¨ç¤ºåŒå£°é“; */ 
  uint32_t   SubChunk1Size; /* 16*/  /* é‡‡æ ·ç‡;0X1F40,è¡¨ç¤º 8Khz */ 
  uint16_t   AudioFormat;   /* 20 */   /* å­—èŠ‚é€Ÿç‡=é‡‡æ ·ç‡*é€šé“æ•°*(ADCä½æ•°/8) */  -> è®¡ç®— bitrate 
  uint16_t   NbrChannels;   /* 22 */   /* å—å¯¹é½(å­—èŠ‚)=é€šé“æ•°*(ADCä½æ•°/8) */ 
  uint32_t   SampleRate;    /* 24 */   /* å•ä¸ªé‡‡æ ·çš„ä½æ•°;16ä½PCM,è®¾ç½®ä¸º16 */  
  
  uint32_t   ByteRate;      /* 28 */
  uint16_t   BlockAlign;    /* 32 */  
  uint16_t   BitPerSample;  /* 34 */  
  uint32_t   SubChunk2ID;   /* 36 */   
  uint32_t   SubChunk2Size; /* 40 */   
}WAVE_FormatTypeDef;
```

å…¶ä¸‰, æœ‰ä¸€ä¸ªå¯é€‰çš„ FACT Chunk, 
```c
typedef __PACKED_STRUCT 
{ 
	uint32_t ChunkID; 			/* chunk id;è¿™é‡Œå›ºå®šä¸º"fact",å³ 0X74636166; */ 
	uint32_t ChunkSize; 		/* å­é›†åˆå¤§å°(ä¸åŒ…æ‹¬ ID å’Œ Size);è¿™é‡Œä¸º:4 */ 
	uint32_t DataFactSize; 		/* æ•°æ®è½¬æ¢ä¸ºPCMæ ¼å¼åçš„å¤§å° */ 
}ChunkFACT; 					/* fact å— */
```

æœ€åæ˜¯ DATA Chunk, å…¶ bit ä½çš„å½¢å¼æ˜¯ : 
![[attachments/Pasted image 20240727104433.png]]
å¯¹äº 24ä½é‡åŒ–, æ˜¯  ä½> ä¸­> é«˜ è¿›è¡Œæ’­æ”¾çš„;
ä¸€èˆ¬åªéœ€è¦è·å–åˆ° wav æ•°æ®å¹¶**é€šè¿‡I2Sé€ç»™ wm8978 å³å¯**ã€‚

## äºŒã€STM32F4 çš„ I2S å¤–è®¾ç®€ä»‹
### (1) STM32 I2S å¤–è®¾ç®€ä»‹
I2S (Inter IC Sound) æ˜¯ä¸€ç§éŸ³é¢‘æ•°æ®ä¼ è¾“æŒ‡å®šçš„æ€»çº¿æ ‡å‡†ã€‚æ˜¯ä¸€ç§ä¼ è¾“ PCM ç¼–ç éŸ³é¢‘æ•°æ®æµçš„å¤–è®¾, æ”¯æŒ<mark style="background: transparent; color: red">å…¨åŒå·¥, åŠåŒå·¥å’Œä¸»ä»æ¨¡å¼</mark>, è€Œä¸»æ¨¡å¼æ˜¯ STM32F4, WM8978 æ˜¯ä»æ¨¡å¼ã€‚
å¯¹äºSPI1æ²¡æœ‰ç›¸å…³çš„I2Så¤–è®¾, ä»…æœ‰ SPI2, SPI3 æ”¯æŒã€‚
I2Sæœ€å°‘æœ‰3æ ¹ä¿¡å·çº¿: 
1. SCK/SCLK/BCLK(ä¸€ä¸ªæ—¶é’Ÿä¼ è¾“1bitæ•°æ®), é¢‘ç‡ = å£°é“æ•° * é‡‡æ ·é¢‘ç‡ * é‡‡æ ·ä½æ•°;  
2. LRCK (å·¦å³æ—¶é’Ÿ, å¸§æ—¶é’Ÿ/WS), ç”¨äºå£°é“é€‰æ‹©; **å…¶ä¸­ "1" è¡¨ç¤ºä¼ è¾“å³å£°é“çš„æ•°æ®, "0" è¡¨ç¤ºä¼ è¾“å·¦å£°é“çš„æ•°æ®**, å…¶æœ‰**é¢‘ç‡ = é‡‡æ ·ç‡**(ä¸€ä¸ªå‘¨æœŸä¸­, åŒæ—¶é‡‡æ ·å³å£°é“å’Œå·¦å£°é“çš„æ•°æ®)
3. SDATA(1-2æ ¹ä¸²è¡Œæ•°æ®çº¿):  å½“ä¸€æ ¹æ—¶, ä¸ºåŠåŒå·¥; åŒçº¿æ—¶ä¸ºå…¨åŒå·¥; 
4. (optional) MCLK (ç³»ç»Ÿæ—¶é’Ÿ, ç”¨äºå°†ç³»ç»Ÿæ—¶é’Ÿæ›´å¥½çš„åŒæ­¥, é¢‘ç‡ = 128æˆ– 256* samplerate), <mark style="background: transparent; color: red">æœ¬æ¿ä½¿ç”¨ PC6(I2S2-MCK) ä½œä¸º I2S_MCLK éƒ¨åˆ†</mark>;
I2S å…·æœ‰ Philips(I2S)æ ‡å‡†, å·¦å¯¹é½ MSB æ ‡å‡† å’Œå³å¯¹é½(LSB) æ ‡å‡†ã€‚
æ•°æ®åœ¨è·Ÿéš LRCLK ä¼ è¾“, <mark style="background: transparent; color: red">åœ¨ BCLK çš„ç¬¬äºŒä¸ªä¸Šå‡æ²¿æ—¶ï¼Œ ä¼ è¾“ MSB éƒ¨åˆ†</mark>(é¦–å…ˆéœ€è¦ç­‰å¾…ä¸€ä¸ªå‘¨æœŸ)ï¼Œ ä¸€èˆ¬å…è®¸32 ä½æ•°æ®ä¼ è¾“, å¦‚æœæ•°æ®ä¸è¶³, åˆ™åé¢è¡¥ 0; 

å¯¹äº ES8388 æ˜¯ä¸€ç§åŒ ADC/DAC é€šé“, æ”¾å¤§å™¨ä»¥åŠæ•°ç»„éŸ³æ•ˆ, æ¨¡æ‹Ÿæ··åˆå¢ç›ŠåŠŸèƒ½çš„éŸ³é¢‘è§£ç å™¨ã€‚åŒæ—¶æœ‰æ•°å­—éŸ³æ•ˆ,æ¨¡æ‹Ÿæ··åˆç­‰åŠŸèƒ½ã€‚
<mark style="background: transparent; color: red">DAC ä¿¡å™ªæ¯”ä¸º 96db, ADC ä¿¡å™ªæ¯” 95db, æ”¯æŒå·¦å³å£°é“éŸ³é‡ç‹¬ç«‹è°ƒèŠ‚, æ”¯æŒä¸»æœºå’Œä»æœºæ¨¡å¼</mark>ã€‚

å¯¹äº STM32F4 çš„ I2S éƒ¨åˆ†, æ”¯æŒå…¨åŒå·¥å’ŒåŠåŒå·¥é€šä¿¡, æ”¯æŒä¸»ä», å¯ç¼–ç¨‹8ä½çº¿æ€§é¢„åˆ†é¢‘å™¨ï¼Œ å®ç° 8-192kHzçš„ç²¾ç¡®é‡‡æ ·ã€‚æ”¯æŒ 16, 24, 32 ä½çš„æ•°æ®æ ¼å¼ã€‚æ”¯æŒ<b><mark style="background: transparent; color: blue">MSBå¯¹é½, LSBå¯¹é½, é£åˆ©æµ¦æ ‡å‡†</mark></b>, åŒæ—¶æ”¯æŒDMAä¼ è¾“ï¼Œæ•°æ®æ–¹å‘å›ºå®š MSB åœ¨å‰,å¹¶ä¸”æ”¯æŒä¸»æ—¶é’Ÿè¾“å‡ºã€‚
â€¢ Master clock may be output to drive an external audio component. Ratio is fixed at 256 Ã— FS (where FS is the audio sampling frequency) -> å¿…é¡»è®¾ç½®ä¸º 256 å€ Master Clock æ—¶é’ŸåŒæ­¥é¢‘ç‡ã€‚

### (2) STM32 I2S å‘ç”Ÿå™¨æ—¶é’Ÿ
å¯¹äº I2S å¤–è®¾, å…¶æ—¶é’Ÿæ¥è‡ª I2S_CLK éƒ¨åˆ†, ä¸€èˆ¬é‡‡ç”¨ I2S CKIN éƒ¨åˆ†, åœ¨æ—¶é’Ÿæ ‘ä¸­, I2S æ—¶é’Ÿæ˜¯æ¥è‡ªäº /R éƒ¨åˆ†çš„ PLL2SCK, ä¹Ÿå¯ä»¥æ¥è‡ªäº I2S_CKIN(å¤–éƒ¨æä¾›);
![[attachments/Pasted image 20240727211914.png]]
è€Œé”ç›¸ç¯ PLL2CLK éƒ¨åˆ†æ˜¯é€šè¿‡HSE (8MHz)å…¶ä¸­ PLLCLK æ˜¯ 168MHz, å³ 8Mhz * 336 / M / P  ; (M = 8, P = 2)å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ¤– STM32F4å’ŒHALåº“/åŸºæœ¬å†…å®¹/3. HALåº“æ—¶é’Ÿåˆå§‹åŒ–|3. HALåº“æ—¶é’Ÿåˆå§‹åŒ–]], è€Œ Q ä¸€èˆ¬è®¾ç½®ä¸º 7, å³ 48 MHz çš„é¢‘ç‡ï¼Œ <mark style="background: transparent; color: red">å…¶ä¸­æœ‰ä¸¤ä¸ªé”ç›¸ç¯, å…¶ä¸­ä¸€èˆ¬ PLL1SN å›ºå®šä¸º336éƒ¨åˆ†</mark> 

I2S çš„æ—¶é’Ÿé¢‘ç‡æ˜¯: 
$$ I2S \space Clocks  =  8MHz * PLL2SN / 8(M)  / PLL2SR   $$
è€Œå‚è€ƒp908 I2S å¤–è®¾æ—¶é’Ÿç”Ÿæˆç»“æ„æ¡†å›¾å¾—åˆ°:
![[attachments/Pasted image 20240727213224.png]]
I2SxCLK éœ€è¦æ ¹æ® fs é…ç½®åˆ†é¢‘ç³»æ•°ã€‚è€Œè®¾ç½®é‡‡æ ·ç‡çš„æ–¹æ¡ˆå¦‚ä¸‹: 
![[attachments/Pasted image 20240727213414.png]]
ä¸€èˆ¬ä¸»æ¨¡å¼ä¸‹çš„æ—¶é’Ÿé¢‘ç‡è®¡ç®—å¦‚ä¸Š: å…¶ä¸­ fs ä¸ºé¢‘ç‡;
å¯¹äºå·¦å³å£°é“, æ¯æ¬¡ä¼ è¾“2ä¸ªæ•°æ®, åˆ™:
$$ Fs = \frac{I2SCLK}{32 * 2 * (2 * I2SDIV + ODD) * 4 } $$
å…¶ä¸­ I2SDIV å’Œ ODD å‡ä¸ºåˆ†é¢‘ç³»æ•°, ODD = 0-1, I2SDIV = 2~255 , è€Œ R å–å€¼èŒƒå›´2-7
å› æ­¤
1. I2S Clk =  1MHz * PLL2SN/PLL2SR (t = 2-7), èŒƒå›´48 Mhz- 168Mhz, 
2. Fs = I2SClk / (256 * (2 * I2SDIV +  ODD))
éœ€è¦è¯´æ˜çš„æ˜¯, ä¸Šè¿°æ–¹æ³•ä¸€èˆ¬ä»…èƒ½å¾—åˆ°å…·æœ‰è¯¯å·®çš„é‡‡æ ·ç‡,<mark style="background: transparent; color: red"> è€Œéœ€è¦é›¶è¯¯å·®çš„æƒ…å†µä¸‹, ä¼šé‡‡ç”¨ I2S_CKIN å¤–éƒ¨æ—¶é’Ÿ</mark>, èƒ½å¤Ÿå¾—åˆ°æœ€ä¸ºç²¾ç¡®çš„ç»“æœã€‚ 

ä¸€èˆ¬è€Œè¨€, æŒ‰ç…§ä¸åŒçš„é‡‡æ ·ç‡, å…¶å¯¹åº”çš„æœ€ä½³ PLLI2SN, PLLI2SR, I2SDIV, ODD ç­‰ç»„åˆå¦‚ä¸‹æ‰€ç¤º:
![[attachments/Pasted image 20240727214618.png]]
æ³¨æ„: ä»…æœ‰I2Såœæ­¢æ—¶, æ‰èƒ½è¿›è¡Œ SPI, I2S çš„åˆ‡æ¢ï¼Œ å¹¶è®¾ç½® SPI_I2SCFGä¸­çš„ I2SMOD =1
I2SE ä½, è®¾ç½®1æ—¶, ä½¿èƒ½ I2S å¤–è®¾, å¿…é¡»è®¾ç½®å®Œ I2SMOD ä¹‹åæ‰èƒ½è¿›è¡Œç»§ç»­è®¾ç½®ã€‚

I2SSTD è®¾ç½® I2S æ ‡å‡†, CKPOL è®¾ç½®ç©ºé—²æ—¶çš„ CLK ç”µå¹³ä¸ºä½ç”µå¹³ã€‚è€Œé¢„åˆ†é¢‘å™¨å¯„å­˜å™¨è®¾ç½®8ä½çš„é¢„åˆ†é¢‘ã€‚å¦å¤–, SPI_CR2 ç”¨äºä½¿èƒ½ SPI æˆ–è€… I2Sçš„ DMA è¯·æ±‚, ç”¨äºä½¿èƒ½å‘é€ç¼“å†²åŒºçš„ DMA è¯·æ±‚ã€‚

### (3) ES8388 è¯´æ˜
æ ¹æ® ES8388 ç”µè·¯è¿çº¿å›¾, æ¡†å›¾å’Œå¼•è„šå›¾å¦‚ä¸‹æ‰€ç¤º: 
![[attachments/Pasted image 20240727122410.png]]
å°è£…ä¸º QFN28, å…¶ä¸­29è„šEP ä¸€èˆ¬æ¥åœ°,  <mark style="background: transparent; color: red">é€šè¿‡I2Cæ¥å£æˆ–è€… SPIæ¥å£è¿›è¡Œå‘½ä»¤ä¼ è¾“, é…ç½®å…¶å…¨åŒå·¥ SPI æ¨¡å¼, å…¶ä¸­ IIC æ¥å£éœ€è¦CE = 0/1,  SPIéœ€è¦ CE äº§ç”Ÿä¸‹é™æ²¿éƒ¨åˆ†ã€‚</mark> 
![[attachments/Pasted image 20240727122444.png]]
å¯¹äº PB8,  PB9 åœ¨åŸç†å›¾ä¸­ä½œä¸ºéŸ³é¢‘çš„ I2C æ¥å£, åŒæ—¶æ”¯æŒ I2S æ ‡å‡†(MSBä¼ è¾“), MSB æ ‡å‡†, LSB æ ‡å‡†, DSP/PCM æ ‡å‡†ã€‚
**ADSOUT å³ ADCæ•°æ®è¾“å‡º(SPIx-extSD)**, ç¬¬äºŒ, ES8388 è¦æ±‚, MCLK æ—¶é’Ÿé¢‘ç‡å¿…é¡»ä¸º256fs, å…¶ä¸­ fs = éŸ³é¢‘é‡‡æ ·ç‡ã€‚

å…·ä½“å‚è€ƒ Chip Control and Power Management 
R0 å¯„å­˜å™¨: åŒ…å«SCP_Reset(1å°†å…¶è½¯å¤ä½),  VMIDSEL\[1:0\] ç”¨äºæ§åˆ¶ VMID, ç”¨äºæ ¡æ­£å™ªå£°, <mark style="background: transparent; color: red">è€Œ R1 å¯„å­˜å™¨(æ§åˆ¶å¯„å­˜å™¨2)æ§åˆ¶æ¨¡æ‹Ÿéƒ¨åˆ†çš„å¤ä½ã€‚ å½“è®¾ç½®PdnAna ä¸º 0 æ—¶, æ¨¡æ‹Ÿéƒ¨åˆ†æ‰ä¼šå·¥ä½œ, å³æ‰èƒ½å¬åˆ°å£°éŸ³</mark>ã€‚

å¯¹äº Register2: 
![[attachments/Pasted image 20240727160633.png]]
å…¶ä¸­ æ»¤æ³¢å™¨é‡ç½®éƒ¨åˆ†ç”¨äºé‡ç½® ADC DEMç­‰, dac_PDNé‡ç½® DACDEM ç­‰ç­‰(å‡éœ€è¦è®¾ç½®ä¸º0), åŒ…æ‹¬ adcVref_PDN å’Œ dacVref_PDN å‡éœ€è¦è®¾ç½®ä¸º0è¿›è¡Œæ§åˆ¶ã€‚

R4 æ˜¯ç”µæºç®¡ç†çš„å¯„å­˜å™¨, <mark style="background: transparent; color: red">R8 ç”¨äºé…ç½®ä¸»ä»æ¨¡å¼çš„æ§åˆ¶å¯„å­˜å™¨</mark>ï¼Œ åŒæ—¶BLCK_INVç”¨äºæ§åˆ¶å·¦å³å£°é“åç›¸, BLCKDIV ç”¨äºæ§åˆ¶ä¸»æ—¶é’Ÿåˆ†é¢‘, ä¸€èˆ¬é€‰ç”¨ä¸åˆ†é¢‘ã€‚
R9 å¯„å­˜å™¨æ§åˆ¶ MIC çš„å·¦å³é€šé“å¢ç›Šå¤§å°, å…·ä½“å¦‚ä¸‹:
![[attachments/Pasted image 20240727161717.png]]
R9, R10 ä¸ºæ§åˆ¶å¯„å­˜å™¨1, 2; å…¶ä¸­ R10 æ§åˆ¶è¾“å…¥é€šé“ä»¥åŠR11çš„DSå·®åˆ†è¾“å…¥é€‰æ‹©ã€‚
R12: DATSEL æ§åˆ¶æ˜¯å¦æ¢ç”¨ADCé€šé“, 
R13ä¸ºADCæ§åˆ¶å¯„å­˜å™¨5ï¼Œ<mark style="background: transparent; color: red">å…¶ä¸­ADCFsRatioæ§åˆ¶ä¸»æ—¶é’Ÿç›¸å¯¹äºé‡‡æ ·ç‡çš„å€ç‡</mark>, ä¸€èˆ¬è®¾ç½®ä¸º 00010 (256), é»˜è®¤ä¸º 768;
R16ï¼Œ R17åˆ†åˆ«æ§åˆ¶å·¦å³å£°é“ ADC è¾“å…¥(é‡‡é›†å¤–éƒ¨å£°éŸ³)çš„è¡°å‡ã€‚
R18 æ§åˆ¶ ALC(Automatic Level Control, è‡ªåŠ¨ç”µå¹³æ§åˆ¶) <mark style="background: transparent; color: red">ALCSEL = 11 ä¸ºç«‹ä½“å£°æ§åˆ¶, éŸ³æ•ˆæ›´å¥½</mark>, 
ä» R23 å¼€å§‹æ˜¯å¯¹äº DAC çš„æ§åˆ¶, <mark style="background: transparent; color: red">é‡è¦çš„æ˜¯ DACWL, å¾€å¾€è®¾ç½®ä¸º 100 (32ä½æ•°æ®é•¿åº¦), å¾€å¾€ä¼šæä¾›æ›´å¥½çš„éŸ³è´¨ã€‚ADCFORMAT è®¾ç½® DAC çš„æ•°æ®æ ¼å¼, ä½¿ç”¨I2Sæ ¼å¼(00)</mark>, 
R24ä¸­, **DACFsMode, ç”¨äºè®¾ç½®å•é€Ÿå’ŒåŒå€é€Ÿæ¨¡å¼, ä¸€èˆ¬è®¾ç½®ä¸º0**, DACFsRatio è®¾ç½®åº”å½“å’Œå‰é¢ä¿æŒä¸€è‡´(00010ä¸º256)
R26, R27 ä¸­çš„ LDACVOL , RDACVOL æ§åˆ¶å·¦å³å£°é“çš„è¡°å‡, æœ€é«˜ä¸º 96db;

å½“é…ç½®é™éŸ³æ—¶, å¯ä»¥ä½¿ç”¨ R29(1Dh) çš„ZeroLå’ŒZeroR é…ç½®ä½, 
R29 -> Mono æ§åˆ¶å•å£°é“è¾“å‡º, ä¸€èˆ¬é»˜è®¤0(Stereo), SE è®¾ç½®3DéŸ³æ•ˆæ•ˆæœ, åˆ†åˆ«ä½“ç°3D æ•ˆæœå¼ºå¼±ã€‚

å¦å¤–<mark style="background: transparent; color: red">R39 è®¾ç½®DACçš„æ··éŸ³å™¨å¼€å…³,</mark>
![[attachments/Pasted image 20240727170834.png]]
![[attachments/Pasted image 20240727170912.png]]
æ—¶é’Ÿæ§åˆ¶å¦‚ä¸‹: 
å…¶ä¸­ slrck è®¾ç½®ADC, DACæ˜¯å¦å…±ç”¨ LRC 
![[attachments/Pasted image 20240727170928.png]]
I2S åŸç†æ¡†å›¾å¦‚ä¸‹:  
![[attachments/Pasted image 20240727175042.png]]
å¯¹äº SPI å’Œ I2S å…±ç”¨éƒ¨åˆ†,  I2SMODä½éƒ¨åˆ†å¯ä»¥, 

SD ä¸ºä¸²è¡Œæ•°æ®å¼•è„š,
WS ä¸ºå­—é€‰æ‹©ï¼Œç”¨äºåˆ‡æ¢å·¦å³å£°é“, é¢‘ç‡ = éŸ³é¢‘é‡‡æ ·ç‡, æ˜ å°„åˆ° NSS éƒ¨åˆ† 
CK ä¸ºä¸²è¡Œæ—¶é’Ÿ (SCK/BCLK), åœ¨I2S_CK éƒ¨åˆ†ä» I2S clock Generator ä¸­å¯ä»¥æ‰¾åˆ°ã€‚
I2S2ext_SD  ä¸ºç›¸å…³çš„æ‹“å±•å¼•è„š, ç”¨äºå…¨åŒå·¥
MCK å½“ I2S é…ç½®ä¸ºä¸»æ¨¡å¼åˆ‡ SPI_I2SPR çš„ MCKOE ä¸º1æ—¶, è¢«ä½¿èƒ½ã€‚  
å¯¹äº I2S_ext , åªèƒ½ç”¨äºå…¨åŒå·¥ä¸”å§‹ç»ˆå·¥ä½œåœ¨ä»æ¨¡å¼ä¸‹, æ­¤æ—¶ä¸¤çº¿å‡å¯ä»¥ç”¨äºå‘é€å’Œæ¥æ”¶ã€‚

I2S æ”¯æŒä»¥ä¸‹å››ç§æ•°æ®å’Œå¸§æ ¼å¼ç»„åˆ:
![[attachments/Pasted image 20240727180620.png]]

> [!caution] æ³¨æ„
> The 24-bit and 32-bit data frames need two CPU read or write operations to/from the SPI_DR or two DMA operations if the DMA is preferred for the application. For 24-bit data frame specifically, the 8 nonsignificant bits are extended to 32 bits with 0-bits (by hardware).
> å³åœ¨24æˆ–è€…32ä½ä¸‹, éœ€è¦ä¸¤æ¬¡DMAæ“ä½œ

æ”¯æŒçš„ Philips æ ‡å‡†ä¼ è¾“çš„ I2S æ—¶åºå›¾å¦‚ä¸‹:
![[attachments/Pasted image 20240727180930.png]]
æ³¨æ„: SPI_DR æ˜¯16ä½ çš„å¯„å­˜å™¨, åœ¨24ä½æ¨¡å¼ä¸‹çš„æ•°æ®ä¼ è¾“, å¿…é¡»å¯¹SPI_DRæ‰§è¡Œä¸¤æ¬¡è¯»å–æˆ–è€…å†™å…¥æ“ä½œã€‚

> [!caution] æ³¨æ„
> ä»SDå¡ä¸­å¾—åˆ°çš„ wav æ•°æ®æµæ˜¯**ä½å­—èŠ‚åœ¨å‰é«˜å­—èŠ‚åœ¨å**çš„,  å› æ­¤16ä½å­˜å‚¨æ—¶éœ€è¦ä½¿ç”¨ `buff_i2s[i+1] <<8 +  buff_i2s[i]`, `SPI_DR = (uint16_t) buff_i2s[i-1]` ç±»ä¼¼çš„æ“ä½œï¼Œå†™å…¥æ—¶ä¼šè‡ªåŠ¨è¡¥é½ 0 

### (4) åŸç†å›¾éƒ¨åˆ†è¯´æ˜
å¯¹äº LIN1 å’Œ RIN 1, æ¥å…¥çš„æ˜¯ MIC_P å’Œ MIC_N, å³ä¼ å…¥ DACæ•°æ®, é€šé“è¾“å…¥ä¸º LINE_IN  éƒ¨åˆ†, è€Œè¾“å‡ºé€šé“ä¸º LOUT1, LOUT2 éƒ¨åˆ†, è¿æ¥ PHONE ç”¨äºè€³æœºè¾“å‡º(å¸¸è§å‹å·æœ‰ PJ-313, PJ-313B å’Œ PJ-320Bï¼Œ PJ326 ç­‰)
![[attachments/Pasted image 20240727220452.png]]
å¯¹äºå–‡å­éƒ¨åˆ†, å…¶è¾“å‡ºä»…æ¥æºäºè¾“å‡ºå…¥é€šé“2 (SPK_IN)

å…¶äºŒ, <mark style="background: transparent; color: red">å¯¹äº DMA æ•°æ®çš„è®¾ç½®éœ€è¦è®¾ä¸ºåŒç¼“å†²å¾ªç¯æ¨¡å¼</mark> , ä»¥æ–¹ä¾¿å¡«å……æ•°æ®éƒ¨åˆ†ã€‚

- éŸ³é¢‘è¿æ¥å™¨æ¥å£è®¾è®¡å‚è€ƒ https://www.youtube.com/watch?v=PO96PH5BNr4 , éšåƒ»è¿æ¥å™¨ (TRS)-> Tip, Ring, Sleeve)  å…·ä½“å¦‚ä¸‹:
![[attachments/9169 1.png|550]]
å‚è€ƒä¸‹å›¾, å®é™…ä¸Š**å«æœ‰çš„å¸¦å¼¯æŠ˜å›¾éƒ¨åˆ†æ˜¯ä¸€ä¸ªåŠ¨è§¦ç‚¹**, ä¸€èˆ¬å¯¹äºéŸ³é¢‘è¿æ¥å™¨,å¦å¤–ä¹Ÿæœ‰è€³æœºå…¼å®¹éº¦å…‹é£çš„æ¥å¤´(å¦‚PJ327ç³»åˆ—), 

å®é™…ä¸Š, ä¸€èˆ¬ä¸‹é¢çš„2å’Œ10æ˜¯é—­åˆçš„, æ’å…¥æ—¶, ä¸‹é¢çš„åŠ¨å¼€å…³2å’Œ10æ–­å¼€; 
å‚è€ƒ[waht is audio jack switch](https://www.cuidevices.com/blog/understanding-audio-jack-switches-and-schematics)
![[attachments/Pasted image 20240727223903.png|750]]

<mark style="background: transparent; color: red">ä¸€èˆ¬1è„šå³æœ€é è¿‘å¤–éƒ¨çš„å¼•è„šæ˜¯æ¥åœ°çš„ã€‚</mark> 2 ä¸º left å·¦å£°é“, ä¸€èˆ¬è¿æ¥éŸ³é¢‘ä¿¡å·çš„æ­£æ(LOUT1), 3 ä¸º Right å³å£°é“(ROUT1), ä¸€èˆ¬è¿æ¥éŸ³é¢‘ä¿¡å·çš„è´Ÿæã€‚ 
![[attachments/Pasted image 20240727225225.png|300]]
å¯ä»¥è®¾è®¡ç”µè·¯å¦‚å›¾:
![[attachments/Pasted image 20240727225846.png]]
å¯¹äºæ’å…¥æ£€æµ‹çš„æœºåˆ¶, å¯ä»¥å°† 
![[attachments/Pasted image 20240811161208.png|400]]

## ä¸‰ã€åŒç¼“å†²I2SåŸç†ä¸DMAæœºåˆ¶è®²è§£
### (1) åŒç¼“å†²åŒºåˆå§‹åŒ–:
é¦–å…ˆå¿…é¡»ç”³è¯·ä¸¤ç‰‡å†…å­˜ M0ARï¼ŒM1AR éƒ¨åˆ†, ç¨‹åºå¡«å……å¥½ M0AR ï¼ˆè¿‡ç¨‹ä¸­ CPU å¡«å……å¦å¤–çš„å†…å­˜M1ARï¼‰ä¹‹å, è‡ªåŠ¨åˆ‡æ¢åˆ° M1AR, æ­¤æ—¶CPUå¡«å…… M0AR éƒ¨åˆ†, 
> [!caution] æ³¨æ„
> å¿…é¡»ä¿è¯åœ¨å‘é€è¿‡ç¨‹ä¸­å°†å¦ä¸€ä¸ªå¯„å­˜å™¨å¡«æ»¡, å› æ­¤éœ€è¦å¼€å¯ä¼ è¾“å®Œæˆä¸­æ–­å‡½æ•°, ä¿è¯å³æ—¶å¡«æ»¡æ•°æ®

åŒç¼“å†² DMA æ˜¯è°ƒç”¨ `HAL_DMAEx_MultiBufferStart()` å‡½æ•°è¿›è¡Œè®¾ç½®çš„, è€Œ<mark style="background: transparent; color: red">å…¶ä¸­æ¯ä¸ªæ•°æ®å‘é€å®Œæ¯•ä¹‹å, ç¡¬ä»¶è‡ªåŠ¨åˆ‡æ¢ä¸ºä¸‹ä¸€ä¸ªç¼“å†²åŒæ—¶è¿›å…¥ä¸­æ–­æœåŠ¡å‡½æ•°</mark>, **ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­, æ‰§è¡Œåˆ‡æ¢ç¼“å†²åŒºæ“ä½œ, è€Œä¸»å‡½æ•°ä¸­æ‰§è¡Œå¡«å……æ•°æ®åˆ°åˆšå‘é€å®Œçš„ç¼“å†²åŒºæ“ä½œã€‚**

å¯¹äºåŒç¼“å†²åŒºçš„ DMA ä¼ è¾“ä¸­æ–­çš„ç¼–å†™: ä»ç„¶é‡‡ç”¨ä¸¤ä¸ªæ ‡å¿—ä½çš„æ–¹å¼:
```c
volatile uint8_t wav_dma_ht_flag = 0;	 // half transfer 
volatile uint8_t wav_dma_tc_flag = 0;    // complete transfer 
```

å¦‚æœæ˜¯å•ç¼“å†²åŒº, åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†, å¯ä»¥è¿™æ ·å†™:
```c
/// @brief get the flag of the DMA2_Channel3 and set the reading flag. 
void DMA2_Channel3_IRQHandler(void){
    if (DMA_GetITStatus(DMA2_IT_HT3) == SET){  // Half Transfer
        wav_dma_ht_flag = 1;
        wav_dma_tc_flag = 1;
        DMA_ClearITPendingBit(DMA2_IT_HT3);
    }else if (DMA_GetITStatus(DMA2_IT_TC3) == SET){  // Transfer Complete
        wav_dma_ht_flag = 0;
        wav_dma_tc_flag = 1;
        DMA_ClearITPendingBit(DMA2_IT_TC3);
    }
}
```

è€Œå¯¹äºåŒç¼“å†²åŒºçš„æƒ…å†µä¸‹, å¾€å¾€éœ€è¦åˆ¤æ–­ä¸Šä¸€ä¸ªä¼ è¾“å®Œæˆçš„æ˜¯å“ªä¸ªç¼“å†²åŒº: æ­¤æ—¶å¯ä»¥åˆ¤æ–­ DMA stream x çš„ CT ä½ (bit19), è¡¨ç¤ºcurrent target;  å…¶ä¸­:
0 è¡¨ç¤º the currrent target memory is mem0;
1 è¡¨ç¤º the currrent target memory is mem1;

å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯, å‘é€çš„é¡ºåºå…¶å®å’Œè¯»å–çš„é¡ºåºæ˜¯ä¸åŒçš„, å¦‚ä¸‹å›¾æ‰€ç¤º:
![[attachments/Pasted image 20240730105149.png]]
å¯¹äº<mark style="background: transparent; color: red"> 16 bit çš„éŸ³é¢‘, æ˜¯å¯ä»¥ç›´æ¥è¯»å–æ•°æ®ç›´æ¥å¡«å……åˆ°åŸå§‹çš„ buff ä¸­è¿›è¡Œå‘é€çš„</mark>, ä½†æ˜¯å¯¹äº24ä½çš„éŸ³é¢‘, åˆ™éœ€è¦æŒ‰ç…§å…¶ä»–æ–¹æ³•è¿›è¡Œå‘é€ã€‚ç¬¬ä¸€æ¬¡å‘é€é«˜8ä½, ç„¶åå‘é€ä½8ä½
```c
if (bits == 24)                 /* 24bitéŸ³é¢‘,éœ€è¦å¤„ç†ä¸€ä¸‹ */
{
	readlen = (size / 4) * 3;   /* æ­¤æ¬¡è¦è¯»å–çš„å­—èŠ‚æ•° */
	f_read(g_audiodev.file, g_audiodev.tbuf, readlen, (UINT*)&bread);   /* è¯»å–æ•°æ® */
	p = g_audiodev.tbuf;
	for (i = 0; i < size;)
	{
		buf[i++] = p[1];
		buf[i] = p[2];
		i += 2;
		buf[i++] = p[0];
		p += 3;
	}
	bread = (bread * 4) / 3;    /* å¡«å……åçš„å¤§å°. */
}
```
å¯¹äºå‘é€è¿‡ç¨‹ä¸­, I2S çš„ DR æ˜¯ 16 ä½ä½å®½çš„å¯„å­˜å™¨, ä¸Šè¿°çš„æ“ä½œå®é™…ä¸Šæ˜¯: `buf[0] = p[1], buf[1] = p[2], buf[4] = p[0]`; 
![[Excalidraw/2. ES8388 èŠ¯ç‰‡ mp3 å’Œ wav çš„è§£ç å’Œæ’­æ”¾ 2024-07-31 14.53.13]]

ä¸€èˆ¬å¯ä»¥é‡‡ç”¨åˆ†åˆ«ä¸¤ä¸ª BUF çš„æ–¹æ³•è§£å†³, å¦å¤–ä¹Ÿå¯ä»¥é€šè¿‡**ä»åå‘å‰è¿›è¡Œè®¡ç®—å’Œäº¤æ¢å¡«å……è§£å†³**ã€‚

### (2) DMA ä½å®½é…ç½®æ³¨æ„äº‹é¡¹
<mark style="background: transparent; color: red"><b>æœ€åå¿…é¡»æ³¨æ„çš„æ˜¯, åˆå§‹åŒ–DMAæ—¶, åŒç¼“å†²åŒºæ¨¡å¼ä¸‹çš„ DMAEx_MultiBufferStart ä¸­, è½¬è¿çš„å¤§å°æ˜¯ size/2</b></mark>ï¼Œ å³ä½¿ç”¨DMAåˆå§‹åŒ–çš„ç©ºé—´å®é™…ä¸Š<mark style="background: transparent; color: red">æ˜¯Buffer_Sizeçš„ä¸€åŠ</mark>, ä¹Ÿå¯¹åº”äºåŸå§‹ä»£ç ä¸­çš„**i2s_init(....../WAV_I2S_TX_DMA_BUFSIZE/2)** 
```c
HAL_DMAEx_MultiBufferStart(&es8388_dma_handler,(uint32_t)buff1, (uint32_t)&ES8388_I2S_SPI_PORT->DR, (uint32_t)buff2, size/2);
```
è¿™æ˜¯å› ä¸º: **åé¢çš„sizeæ˜¯æŒ‡çš„ æˆ‘ä»¬çš„ç¼“å†²åŒºè®¾ç½®æ˜¯ 8192 bytes, è€Œ I2S ä¼ è¾“çš„DRå¯„å­˜å™¨ä½å®½æ˜¯ 16 ä½,** è€Œ**ä¸¤ä¸ª buffer å‡ä¸º uint8_t çš„éƒ¨åˆ†, å› æ­¤éœ€è¦è¿›è¡Œé™¤2å¤„ç†, åŒæ ·åœ°, DMA çš„ä½å®½ä¹Ÿæ˜¯è®¾ç½®ä¸º 16bit ä¼ è¾“(åŠå­—)éƒ¨åˆ†çš„**, è¿™ä¸ªåœ¨æ•´ä¸ªéƒ¨åˆ†æ˜¯ç»Ÿä¸€çš„, è€Œ size éœ€è¦ç¬¦åˆè¿™ä¸ªå¤§å°ã€‚

### (3) I2S DMA ä½¿èƒ½ä½è®¾ç½®
å…¶äºŒ, å¯¹äº I2S çš„åˆå§‹åŒ–, å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ¤– STM32F4å’ŒHALåº“/åŸºæœ¬å¤–è®¾éƒ¨åˆ†/2. DMA å¤–è®¾çš„ä½¿ç”¨åŠDMAåŠ é€ŸW25Q128|2. DMA å¤–è®¾çš„ä½¿ç”¨åŠDMAåŠ é€ŸW25Q128]], ä¸­é—´ä¸å¾—ç¼ºå°‘è¿™ä¸¤å¥:
```c
    /*##-5- Configure the NVIC for SPI #########################################*/
    HAL_NVIC_SetPriority(W25Qxx_SPI_IRQn, 0, 2);
    HAL_NVIC_EnableIRQ(W25Qxx_SPI_IRQn);
```
åœ¨SPI_CR2ä¸­å³å¿…é¡»ä½¿èƒ½ TXDMAEN ä½, æ‰èƒ½ä¿è¯
![[attachments/Pasted image 20240730113816.png]]
å®é™…ä¸Šæ˜¯è°ƒç”¨äº† `__HAL_I2S_ENABLE_IT` æ¥è®¾ç½®å…¶ä¸­çš„CR2 å¯„å­˜å™¨, åº”å½“ä½¿èƒ½è¿™ä¸ªä¸­æ–­, æ‰èƒ½è®©:
```c
__HAL_I2S_ENABLE_IT(&es8388_i2s_handler, I2S_IT_TXE);
__HAL_I2S_ENABLE(&es8388_i2s_handler); Â /* start I2S enable bit -> must be added */  
// è¿™ä¸€å¥å¿…é¡»åœ¨åˆå§‹åŒ–ä¹‹ååŠ ä¸Š, å¦åˆ™æ— æ³•è¿›å…¥ä¸­æ–­
```

> [!caution] ä¸­æ–­è¯·æ±‚ä½¿èƒ½å’Œå¤„ç†ä½¿èƒ½å‡½æ•°çš„ç†è§£
> å¯¹äº I2S ç­‰ç­‰çš„TXæ ‡å¿—ä½, æ˜¯æ²¡æœ‰ç›¸åº”çš„æ¸…é™¤å‡½æ•°çš„(è¿™æ˜¯å› ä¸ºæ»¡åå¦‚æœæ²¡æœ‰å‘é€çš„ä»ç„¶ä¼šç½®ä¸€), <b><mark style="background: transparent; color: red">æˆ‘ä»¬éœ€è¦ä½¿èƒ½ IRQ  ä½†æ˜¯ä¸ä½¿èƒ½ IT </mark></b>, <b><mark style="background: transparent; color: blue">å…¶ä¸­ IRQ(Interrupt Request) è¡¨ç¤ºç‰¹å®šçš„ä¸­æ–­çº¿è¯·æ±‚,  å³å¯ç”¨è¿™ä¸ªæ¥ä¿è¯è¯·æ±‚å¯ä»¥å‘é€åˆ° DMA éƒ¨åˆ†, è€Œ __HAL_ENABLE_IT æ˜¯ç”¨äºæ»¡è¶³ä¸­æ–­æ¡ä»¶æ—¶, è§¦å‘ä¸­æ–­å¤„ç†ç¨‹åº</mark></b>ï¼Œå› æ­¤æˆ‘ä»¬åœ¨ä½¿ç”¨DMAæ—¶ä¸€èˆ¬ä¸ä¼šè°ƒç”¨ `__HAL_ENABLE_IT`, ä½†æ˜¯éœ€è¦ä½¿èƒ½ IRQn è¯·æ±‚ã€‚

ä¸Šé¢éƒ¨åˆ†å³ SPI2 TX DMAè¯·æ±‚ä½¿èƒ½, ä½†æ˜¯è¿™æ ·**å®é™…ä¸Šæ²¡æœ‰ä½¿èƒ½ I2S çš„TXä¸­æ–­**, **ç›®å‰åªèƒ½è€ƒè™‘ä½¿ç”¨ç›´æ¥æ“ä½œ CR2 å¯„å­˜å™¨ä½¿èƒ½ä¸­æ–­**, ä½¿ç”¨å¦‚ä¸‹å‡½æ•°: (è¿™æ˜¯å› ä¸ºHALåº“æœ¬èº«I2Så¾ªç¯æ¨¡å¼ä¸‹, `__HAL_LINKDMA` å‡½æ•°ä¼šå¤±æ•ˆé€ æˆçš„)
```c
void i2s_dma_enable(void)
{
    uint32_t tempreg = 0;
    I2S_SPI->CR2  |= 1 << 1;          /* ä½¿èƒ½DMA */
}
```

### (4) PLLI2S é”ç›¸ç¯æ—¶é’Ÿå’Œä¸­æ–­é…ç½® 
1. <b><mark style="background: transparent; color: red">åœ¨ HAL åº“ä¸­, è¿˜æœ‰ä¸€ä¸ªé‡è¦çš„æ—¶é’Ÿï¼Œå³ PLLI2S åœ¨è°ƒç”¨å‰å¿…é¡»è¿›è¡Œä½¿èƒ½, è¿™ä¸ªæ§åˆ¶çš„æ˜¯ RCC-> CR çš„PLLI2SONä½</mark> </b>, è°ƒç”¨çš„æ–¹æ³•æ˜¯: 
```c
__HAL_RCC_PLLI2S_ENABLE();
```
è¿™ä¸ªä¹Ÿæ˜¯**æå…¶é‡è¦çš„ä¸€ä¸ªæ—¶é’Ÿåˆå§‹åŒ–**, å¹¶ä¸”æ˜¯å¯ä»¥æ”¾åœ¨å‰é¢çš„æ—¶é’Ÿåˆå§‹åŒ–ä¸­ã€‚

å¦å¤–éœ€è¦æ³¨æ„: `HAL_DMAEx_MultiBufferStart_IT` æ˜¯ä¸èƒ½ä½¿ç”¨çš„, åº”å½“ä½¿ç”¨ `HAL_DMAEx_MultiBufferStart`ï¼Œç”±äº ä½¿ç”¨_IT ä¼šä½¿å¾—åœ¨ DMA ä¼ è¾“å®Œæˆæ—¶, åŒæ—¶è§¦å‘ä¸­æ–­(ä¼šä½¿èƒ½æ‰€æœ‰çš„ä¸­æ–­)ï¼Œ å…¶å†…éƒ¨é€»è¾‘å¦‚ä¸‹:
```c title:å¸¦æœ‰__ITçš„å†…éƒ¨é€»è¾‘
/* Enable Common interrupts*/
Â  Â  hdma->Instance->CR Â |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
Â  Â  hdma->Instance->FCR |= DMA_IT_FE;
```

å…¶äºŒ, **æ³¨æ„ DMA è¯·æ±‚çš„ TCIFx éƒ¨åˆ†, å¯¹åº”TCIF0æ˜¯é’ˆå¯¹Streamçš„éƒ¨åˆ†, å› æ­¤å¯¹åº”çš„ä¸­æ–­åº”å½“è®¾ç½®ä¸º DMA_TCIF0_4**è¡¨ç¤ºStream4çš„ä¸­æ–­, 

ä¹‹å, éœ€è¦å°† OUT éƒ¨åˆ†çš„å®šä¹‰è¿›è¡Œæ›´æ”¹: 
```c
GPIO_InitStruct.Alternate = ES8388_I2SEx_AF;  // è¿™ä¸ªä¼šå¯¼è‡´åˆå§‹åŒ–é”™è¯¯, 

/* åœ¨ä½¿ç”¨ SDOUT åˆå§‹åŒ–, ä»ç„¶é‡‡ç”¨ SPI é»˜è®¤çš„ AF,  ä¸ç”¨ ext */
GPIO_InitStruct.Pin = ES8388_SDOUT_PIN;
HAL_GPIO_Init(ES8388_SDOUT_GPIO, &GPIO_InitStruct);
```

å› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡å¦‚ä¸‹çš„å‡½æ•°è‡ªåŠ¨é‡ç½®é‡‡æ ·ç‡:
```
uint8_t set_samplerate(uint32_t samplerate)
{
	__HAL_I2S_DISABLE(&g_i2s_handler);
    switch (samplerate){
        case 8000:  g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_8K; break;
        case 11025: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_11K; break;
        case 16000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_16K; break;
        case 22050: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_22K; break;
        case 32000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_32K; break;
        case 44100: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_44K; break;
        case 48000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_48K; break;
        case 96000: g_i2s_handler.Init.AudioFreq = I2S_AUDIOFREQ_96K; break;
        default: return 1;  /* unsupported sample rate */
    }
    if (HAL_I2S_Init(&g_i2s_handler) != HAL_OK){  /* I2S init fail */
        printf("Init failed!!!!\r\n");
        return 1;
    }
    __HAL_I2S_ENABLE(&g_i2s_handler);  /** keep the  i2s enable --> not disable it */
}
```

æ­¤å¤–, éœ€è¦æ³¨æ„ ES8388 å¿…é¡»è®¾ç½®éŸ³é‡å’Œ DAC è¾“å‡ºä¹‹åæ‰èƒ½æ­£å¸¸è¿è¡Œ, è¿™æ˜¯ç”±äºè®¾ç½®éŸ³é‡éƒ¨åˆ†DACé»˜è®¤æ˜¯00000000, æ²¡æœ‰éŸ³é‡è¾“å‡ºã€‚
```c
es8388_hpvol_set(25); Â  Â  Â  /* è®¾ç½®è€³æœºéŸ³é‡ */
es8388_spkvol_set(20); Â  Â  Â /* è®¾ç½®å–‡å­éŸ³é‡ */
es8388_adda_cfg(1, 0); Â  Â  Â /* å¼€å¯DACå…³é—­ADC */
es8388_output_cfg(1, 1); Â  Â /* DACé€‰æ‹©é€šé“1è¾“å‡º */
```
**ç”±äºå½“DACæ²¡æœ‰å¼€å¯æ—¶, è½¬è¿ä¸ä¼šæˆåŠŸ, æ­¤æ—¶ I2S ä¸ä¼šè§¦å‘ä¸­æ–­ã€‚**
```c
ES8388_PwrCtrl(1, 0); Â  Â /** Power down ADC and up DAC */
ES8388_OutputCtrl(1,1); Â  Â /** Enable DAC output */
ES8388_SetVolume_ch1(20); Â  Â /** Set volume of DAC output */
ES8388_SetVolume_ch2(20); Â  Â /** Set volume of DAC output */
```

## å››ã€HAL åº“çš„ç¡¬ä»¶ I2C ä½¿ç”¨ 
### (1) åˆå§‹åŒ–ç¤ºä¾‹ä»£ç 
åœ¨ I2C ä¸­ï¼Œ èµ·å§‹ä¿¡å·æ˜¯ 0(Start) + 001000 + AD0 + RW éƒ¨åˆ†, æ­¤å¤„å°† AD0 è®¾ç½®ä¸º0) 
å¯ä»¥é€šè¿‡ Es8388_write (0x2eæˆ–è€… 0x2f), å³å¯„å­˜å™¨ R46, R47

> [!caution] ES8388 I2C åˆå§‹åŒ–æ³¨æ„äº‹é¡¹
> å¯¹äºES8388è€Œè¨€, æ—¶é’Ÿçº¿å¿…é¡»é‡‡ç”¨æ¨æŒ½è¾“å‡º, ä¸èƒ½é‡‡ç”¨å¼€æ¼è¾“å‡ºæ¨¡å¼, å¦åˆ™æ— æ³•è¯»å†™å¯„å­˜å™¨ã€‚

ç¤ºä¾‹åˆå§‹åŒ–ä»£ç å¦‚ä¸‹: 
```c title:ES8388_I2Cæ€»çº¿åˆå§‹åŒ–ä»£ç 
GPIO_InitStruct.Pin = ES8388_I2C_SCL_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
GPIO_InitStruct.Alternate = ES8388_I2C_AF;
HAL_GPIO_Init(ES8388_I2C_SCL_GPIO, &GPIO_InitStruct);

GPIO_InitStruct.Pin = ES8388_I2C_SDA_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
HAL_GPIO_Init(ES8388_I2C_SDA_GPIO, &GPIO_InitStruct);
```

### (2) ç¡¬ä»¶ I2C æ­»é”è§£å†³æ–¹æ¡ˆ
å¯¹äº I2Cï¼Œä¸€èˆ¬é¦–å…ˆéƒ½éœ€è¦ä½¿ç”¨è½¯ä»¶åˆå§‹åŒ–å¹¶äº§ç”Ÿåœæ­¢ä¿¡å·æ¥åœæ­¢æ€»çº¿çš„æ‰€æœ‰è®¾å¤‡, ä»¥é¿å…æ€»çº¿æ­»é”ã€‚
```c
/**
 * @brief       äº§ç”ŸIICåœæ­¢ä¿¡å·
 * @param       æ— 
 * @retval      æ— 
 */
void iic_stop(void)
{
    IIC_SDA(0);     /* STOPä¿¡å·: å½“SCLä¸ºé«˜æ—¶, SDAä»ä½å˜æˆé«˜, è¡¨ç¤ºåœæ­¢ä¿¡å· */
    iic_delay();
    IIC_SCL(1);
    iic_delay();
    IIC_SDA(1);     /* å‘é€I2Cæ€»çº¿ç»“æŸä¿¡å· */
    iic_delay();
}
```
åœ¨ ç¡¬ä»¶ I2C çš„åˆå§‹åŒ–ä¸­, å¯ä»¥åŠ å…¥å¦‚ä¸‹çš„ä¸­æ–­å‡½æ•°, ç”¨äºå°† HAL åº“ä¸­çš„ I2C äº‹ä»¶ä¸­æ–­ç»§æ‰¿åˆå§‹çš„äº‹ä»¶ä¸­æ–­:
```c title:ç¡¬ä»¶I2Cä¸­æ–­ä½¿ç”¨
/**
  * @brief  This function handles I2C event interrupt request.
  * @param  None
  * @retval None
  * @Note   This function is redefined in "main.h" and related to I2C data transmission
  */
void I2Cx_EV_IRQHandler(void)
{
  HAL_I2C_EV_IRQHandler(& I2CxHandle);
}

/**
  * @brief  This function handles I2C error interrupt request.
  * @param  None
  * @retval None
  * @Note   This function is redefined in "main.h" and related to I2C error
  */
void I2Cx_ER_IRQHandler(void)
{
  HAL_I2C_ER_IRQHandler(& I2CxHandle);
}
```

å‚è€ƒæ–‡ç«  [HALåº“STM32å¸¸ç”¨å¤–è®¾æ•™ç¨‹ï¼ˆä¹ï¼‰â€”â€” I2Cé€šä¿¡ï¼ˆè¯»å†™EEPROM](https://blog.csdn.net/That_Assassin/article/details/135981146) ,  å¯çŸ¥:
é¦–å…ˆ HAL åº“æä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„å‡½æ•°ç”¨äºæ£€æŸ¥æ˜¯å¦å­˜åœ¨: 
```c
if (HAL_I2C_IsDeviceReady(&es8388_i2c_handler, addr,10, 1000)== HAL_OK)
```

éœ€è¦æ³¨æ„çš„æ˜¯, å…¶ä¸­retry ä¸€èˆ¬ä¸èƒ½è®¾çš„å¤ªå°, å¯ä»¥è®¾ä¸º10å·¦å³çš„å€¼å°±å¯ä»¥åŸºæœ¬ä¸Šä¿è¯æ¯æ¬¡éƒ½åˆå§‹åŒ–æˆåŠŸã€‚
```c
HAL_I2C_IsDeviceReady(&es8388_i2c_handler,ES8388_ADDR, 10, 200); 
```

ç¬¬äºŒ, **ä½¿ç”¨è½¯ä»¶æ–¹æ³•è§£é™¤I2C æ€»çº¿çš„æ­»é”é—®é¢˜**:
```c
void ES8388_Unlock(void){
    /** Use GPIO for Init */
    ES8388_GPIO_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    GPIO_InitStruct.Pin = ES8388_I2C_SCL_PIN;
    HAL_GPIO_Init(ES8388_I2C_SCL_GPIO, &GPIO_InitStruct);
    GPIO_InitStruct.Pin = ES8388_I2C_SDA_PIN;
    HAL_GPIO_Init(ES8388_I2C_SDA_GPIO, &GPIO_InitStruct);
    
    /** Generate Stop Signal In GPIO Mode */ 
    HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    /* write 16 clock pulse */
    for (int i = 0; i < 16; i++) {
        HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_RESET);
        HAL_Delay(2);
        HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
        HAL_Delay(2);
    }
    /* Stop Singal  */
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_RESET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_SET);
    HAL_Delay(300);
}
```
å…¶ä¸­, **å¦‚æœéœ€è¦åˆå§‹åŒ– EEPROMï¼Œåªéœ€ç»™å‡ºå…¶åœ°å€ 0xA0 å³å¯ï¼Œè€Œæ¿è½½çš„åœ°å€ä¹ŸåŒ…æ‹¬ES8388,å…¶åœ°å€ä¸º0x20**; IIC æ€»çº¿å®é™…ä¸Šå¦‚ä¸‹æ‰€ç¤º:
![[attachments/Pasted image 20240728171409.png]]
å¯¹äºç¡¬ä»¶ I2C çš„å‘é€å’Œæ¥æ”¶å‡½æ•°, é‡è¦çš„æ˜¯å¦‚ä¸‹å‡ ä¸ªå‡½æ•°:

| å‡½æ•° (Function)             | åŠŸèƒ½æè¿° (Function Description) |
|---------------------------|-----------------------------|
| HAL_I2C_IsDeviceReady()   | æ£€æŸ¥ç›®æ ‡è®¾å¤‡å°±ç»ªçŠ¶æ€                  |
| HAL_I2C_Master_Transmit() | ä»¥ä¸»æœºå‘é€æ•°æ®åˆ°æŒ‡å®šçš„ä»æœºè®¾å¤‡             |
| HAL_I2C_Master_Receive()  | ä»¥ä¸»æœºæ¥æ”¶æŒ‡å®šçš„ä»æœºè®¾å¤‡å‘é€æ¥çš„æ•°æ®          |
| HAL_I2C_Slave_Transmit()  | ä»¥ä»æœºå‘é€æ•°æ®ç»™ä¸»æœºï¼Œä»…å½“ä¸»æœºè¯·æ±‚æ—¶          |
| HAL_I2C_Mem_Write()       | ä»¥ä¸»æœºæ¨¡å¼å‘æŒ‡å®šçš„ä»æœºè®¾å¤‡å†…éƒ¨åœ°å€å†™å…¥æ•°æ®       |
| HAL_I2C_Mem_Read()        | ä»¥ä¸»æœºæ¨¡å¼è¯»å–æŒ‡å®šçš„ä»æœºè®¾å¤‡å†…éƒ¨åœ°å€çš„æ•°æ®       |

æ³¨æ„ä½¿ç”¨ä½¿ç”¨ IT æ˜¯å¸¦ä¸­æ–­å¼çš„è¯»å–å’Œå†™å…¥, å…¶ä¸­ä¸“é—¨ç”¨äºå­˜å‚¨å™¨è¯»å†™çš„ï¼Œå…·ä½“å¦‚ä¸‹: 

| å‡½æ•°å                        | å‡½æ•°åŠŸèƒ½æè¿°                   | å…³è”çš„å›è°ƒå‡½æ•°                      |
|----------------------------|--------------------------|------------------------------|
| HAL_I2C_Master_Transmit_IT | ä¸»è®¾å¤‡å‘æŸä¸ªåœ°å€çš„ä»è®¾å¤‡å‘é€ä¸€å®šé•¿åº¦çš„æ•°æ®    | HAL_I2C_MasterTxCpltCallback |
| HAL_I2C_Master_Receive_IT  | ä¸»è®¾å¤‡ä»æŸä¸ªåœ°å€çš„ä»è®¾å¤‡æ¥æ”¶ä¸€å®šé•¿åº¦çš„æ•°æ®    | HAL_I2C_MasterRxCpltCallback |
| HAL_I2C_Master_Abort_IT    | ä¸»è®¾å¤‡ä¸»åŠ¨ä¸­æ­¢ä¸­æ–­ä¼ è¾“è¿‡ç¨‹            | HAL_I2C_AbortCpltCallback    |
| HAL_I2C_Slave_Receive_IT   | ä½œä¸ºä»è®¾å¤‡æ¥æ”¶ä¸€å®šé•¿åº¦çš„æ•°æ®           | HAL_I2C_SlaveRxCpltCallback  |
| HAL_I2C_Slave_Transmit_IT  | ä½œä¸ºä»è®¾å¤‡å‘é€ä¸€å®šé•¿åº¦çš„æ•°æ®           | HAL_I2C_SlaveTxCpltCallback  |
| HAL_I2C_Mem_Write_IT       | å‘æŸä¸ªä»è®¾å¤‡çš„æŒ‡å®šå­˜å‚¨åœ°å€å¼€å§‹å†™å…¥ä¸€å®šé•¿åº¦çš„æ•°æ® | HAL_I2C_MemTxCpltCallback    |
| HAL_I2C_Mem_Read_IT        | ä»æŸä¸ªä»è®¾å¤‡çš„æŒ‡å®šå­˜å‚¨åœ°å€å¼€å§‹è¯»å–ä¸€å®šé•¿åº¦çš„æ•°æ® | HAL_I2C_MemRxCpltCallback    |
| HAL_I2C_ErrorCallback      | æ‰€æœ‰ä¸­æ–­æ–¹å¼ä¼ è¾“å‡½æ•°ä¸­å‡ºç°é”™è¯¯æ—¶è°ƒç”¨       | æ—                             |

General Call address detectionï¼Œå¹¿æ’­å‘¼å«æ£€æµ‹ã€‚è®¾ç½®ä¸ºDisableè¡¨ç¤ºç¦æ­¢å¹¿æ’­å‘¼å«ï¼Œä¸å¯¹åœ°å€0x00åº”ç­”ï¼›å¦åˆ™ï¼Œå°±æ˜¯å…è®¸å¹¿æ’­å‘¼å«ï¼Œå¯¹åœ°å€0x00åº”ç­”ã€‚

### (3) è¯»å†™å‡½æ•°çš„ç¼–å†™
å®é™…å†™å…¥å‡½æ•°å’Œè¯»å–å‡½æ•°åªè¦ä½¿ç”¨ä¸‹é¢å°±è¡Œäº†: (å¯¹äº24C02, å»¶æ—¶è®¾ç½®ä¸º2mså³å¯)

```c
/**
 * @brief Write the register of ES8388
 * @note  The register address is 8-bit, and the data is 8-bit 
 * 
 */
uint8_t ES8388_write_reg(uint16_t reg_addr, uint8_t data){
    uint8_t res = 0;
    res = HAL_I2C_Mem_Write(&es8388_i2c_handler,ES8388_ADDR ,reg_addr,I2C_MEMADD_SIZE_8BIT, &data, 1, ES8388_TIMEOUT);
    HAL_Delay(2);  // This Delay must be add during the write and next operation */
    return res;
}

/**
 * @brief Read the register of ES8388
 * @param reg_addr 
 * @param data 
 * @return  
 */
uint8_t ES8388_read_reg(uint16_t reg_addr, uint8_t *data){
    uint8_t res = 0;
    res = HAL_I2C_Mem_Read(&es8388_i2c_handler, ES8388_ADDR, reg_addr, I2C_MEMADD_SIZE_8BIT, data, 1, ES8388_TIMEOUT);
    HAL_Delay(2); // This Delay must be add during the write and next operation */
    return res;
}
```
å…¶ä¸­å¤§å°é‡‡ç”¨ I2C_MEMADD_SIZE_8BIT  8ä½åœ°å€éƒ¨åˆ†
è¯´æ˜: **åœ¨ç¡¬ä»¶I2Cä¼ è¾“ä¸­åªéœ€è¦å®šä¹‰ä¸€ä¸ªå›ºå®šçš„ I2C åœ°å€(æŒ‰8ä½ç®—, æˆ–è€…7ä½å·¦ç§»1ä½)**, **HAL åº“ä¼šè‡ªåŠ¨åŠ ä¸Š R/Wå…¶ä¸­å†™ä¸º0,è¯»ä¸º1, è¿›è¡Œå‘é€, éœ€è¦æ³¨æ„ï¼Œåœ¨è¯»å†™è¿‡ç¨‹ä¸­, ä¸€å®šè¦åŠ ä¸Šç­‰å¾…å‡½æ•°**;
```c title:æµ‹è¯•I2Cé€šä¿¡ä»£ç 
void EEPROM_test(){
	EEPROM_i2cInit();
	/** Use EEPROM as test */
	if (HAL_I2C_IsDeviceReady(&es8388_i2c_handler, 0xA0, 5, 1000)== HAL_OK){
		printf("EEPROM is ready\r\n");
	}
	uint8_t data = 0x55, res = 0;
	if (HAL_I2C_Mem_Write(&es8388_i2c_handler, 0xA0, 0, I2C_MEMADD_SIZE_8BIT, &data, 1, 0xffff)){
		printf("Write failed\r\n");
		return 1;
	}
	HAL_Delay(10);    /* This Delay must be add during the write and read */
	if (HAL_I2C_Mem_Read(&es8388_i2c_handler, 0xA0, 0, I2C_MEMADD_SIZE_8BIT, &res, 1, 0xffff)){
		printf("Read failed\r\n");
		return 1;
	};
	printf("res: %x\r\n", res);
}
```
å‚è€ƒ åŸç†å›¾
![[attachments/Pasted image 20240728202441.png]]
ä»¥åŠç¨‹åºæ¡†å›¾, ADCæ˜¯æ¥å…¥ LIN å’Œ RIN éƒ¨åˆ†çš„, å› æ­¤ä¸ä½¿ç”¨ MIC å¯ä»¥è€ƒè™‘ä¸å¼€å¯ ADC, 
![[attachments/Pasted image 20240728202456.png|800]]
åŒæ—¶, LIN å’Œ RIN å¯¹äº DACR, DACL ä¸­ä¹Ÿæœ‰é€‰æ‹©é€šé“, å¯ä»¥é€‰ç”¨æ˜¯å¦è¿›è¡Œè·å–ã€‚

R4 å¯„å­˜å™¨ç”¨äºé…ç½® LOUT1, LOUT2, ROUT1, ROUT2 çš„éŸ³é¢‘, <mark style="background: transparent; color: red">åœ¨æ¿è½½çš„éƒ¨åˆ†, ROUT2 å’Œ LOUT2 æ˜¯ç”¨ç”µå®¹æ··éŸ³å, æ¥å…¥ SPK_IN å–‡å­éƒ¨åˆ†çš„, è€Œ LOUT1, ROUT1 æ¥å…¥ PHONE  è€³æœºè¾“å‡ºæ¥å£</mark>ã€‚
å¯¹äº DMA åˆå§‹åŒ–ï¼Œé‡‡ç”¨ I2S ä½œä¸ºè§¦å‘æº, å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ¤– STM32F4å’ŒHALåº“/åŸºæœ¬å¤–è®¾éƒ¨åˆ†/2. DMA å¤–è®¾çš„ä½¿ç”¨åŠDMAåŠ é€ŸW25Q128|DMA å¤–è®¾çš„ä½¿ç”¨åŠDMAåŠ é€ŸW25Q128]] éƒ¨åˆ†, ç±»ä¼¼SPIåœ°, **ä½¿ç”¨ SPI2_TX ä½œä¸ºè§¦å‘æº**, å³ä½¿ç”¨ DMA1 Stream4, Channel0 éƒ¨åˆ†;

## äº”ã€I2S æ—¶é’Ÿé¢„åˆ†é¢‘é…ç½®
å¯„å­˜å™¨æ–¹æ³•ç²¾ç¡®é…ç½®é‡‡æ ·ç‡æ—¶é’Ÿé…ç½®éœ€è¦ç”¨åˆ°å¦‚ä¸‹çš„ä¸¤ä¸ªé‡è¦å‡½æ•°: 
å…¶ä¸­ PeriphCLKConfig ç”¨äºé…ç½®  PLLI2SN, PLLI2SR éƒ¨åˆ†, 
```c
HAL_RCCEx_PeriphCLKConfig(&ES8388_I2S_PeriphCLKInit);
HAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef Â *PLLI2SInit);
#define __HAL_RCC_I2S_CONFIG(__SOURCE__) (MODIFY_REG(RCC->CFGR, RCC_CFGR_I2SSRC, (__SOURCE__))) 
```

å…¶ä¸­ç¬¬ä¸‰ä¸ªæ˜¯è®¾ç½®æ—¶é’Ÿæº, æœ‰å¦‚ä¸‹ä¸¤ä¸ªå‚æ•°:
- `RCC_I2SCLKSOURCE_PLLI2S`ï¼šä½¿ç”¨ PLLI2S ä½œä¸º I2S æ—¶é’Ÿæºã€‚
- `RCC_I2SCLKSOURCE_EXT`ï¼šä½¿ç”¨å¤–éƒ¨æ—¶é’Ÿä½œä¸º I2S æ—¶é’Ÿæºã€‚

åœ¨ HAL_SPI_I2S_Init å‡½æ•°ä¸­å°±æœ‰äº†ç›¸å…³çš„æ³¢ç‰¹ç‡è®¾ç½®, ä½†æ˜¯éœ€è¦æ³¨æ„:
```c
Â  Â -@- Make sure that either:
Â  Â  Â  Â  (+@) I2S PLL clock is configured or
Â  Â  Â  Â  (+@) External clock source is configured after setting correctly
Â  Â  Â  Â  Â  Â  Â the define constant EXTERNAL_CLOCK_VALUE in the stm32f4xx_hal_conf.h file.
```
å…¶ä¸­ EXTERNAL_CLOCK_VALUE = 12288000U (å³12.288MHz)

å…¶ä¸­ Init å‡½æ•°è°ƒç”¨äº†è¿™ä¸ªå‡½æ•°: 
```c
HAL_RCCEx_GetPeriphCLKFreq
```

å®é™…ä¸Šæ˜¯è¿™æ ·å†™çš„ : 
```c
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
  uint32_t srcclk = 0U;
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
  switch (PeriphClk)
  {
  case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
      switch (srcclk)
      {
      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
      case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
          break;
        }
      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */
      case RCC_I2SCLKSOURCE_PLLI2S:
        {
#if defined(STM32F411xE)
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
#else
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
          break;
        }
        /* Clock not enabled for I2S*/
      default:
        {
          frequency = 0U;
          break;
        }
      }
      break;
    }
  default:
    {
       break;
    }
  }
  return frequency;
}
``` 
æ ¹æ®: 
$$ I2S \space Clocks  =  8MHz * PLL2SN / 8(M)  / PLL2SR   $$
æˆ‘ä»¬åªéœ€è¦è®¾ç½®PLL2SN = 86,   PLL2SR = 7, åˆ™å¯¹åº”çš„é¢‘ç‡ä¸º  12.28571MHz, ä¸12.288MHzè¯¯å·®ä¸º 0.018%, ç¬¦åˆé¢„æœŸã€‚

å› æ­¤å®é™…ä¸Šåªè¦è¿™æ ·å†™å³å¯: 
```c
uint8_t musicplayer_setSampleRate(uint32_t audio_freq){
    __HAL_RCC_I2S_CONFIG(RCC_I2SCLKSOURCE_PLLI2S);    /* use PLLI2S as I2S clock source */
    
    RCC_PLLI2SInitTypeDef i2s_clk = {0};
    i2s_clk.PLLI2SN = 86;
    i2s_clk.PLLI2SR = 7;
    HAL_RCCEx_EnablePLLI2S(&i2s_clk);
    
    __HAL_I2S_DISABLE(&es8388_i2s_handler);
    es8388_i2s_handler.Init.AudioFreq = audio_freq;
    ES8388_Init(audio_freq);
    __HAL_I2S_ENABLE(&es8388_i2s_handler);
    return 0;
}
```

![[attachments/Pasted image 20240729152302.png]]
éœ€è¦æ³¨æ„çš„æ˜¯, åœ¨**åˆå§‹åŒ–ä¸­æ–­å®Œæˆä¹‹å, ä¸€å®šè¦æ¸…é™¤å¯¹åº”ä¸­æ–­çš„æ ‡å¿—ä½**, è¿™æ ·æ‰èƒ½å¤Ÿè¿›è¡Œ:
```c
__HAL_DMA_CLEAR_FLAG(&es8388_dma_handler, ESP8388_I2S_DMA_TC_FLAG); Â  /** Clear DMA transfer complete flag */
```

## å…­ã€STM32 è§£ç  MP3 éƒ¨åˆ†
æ­¤å¤„ç§»æ¤ä¸»è¦å‚è€ƒé‡ç«ä¾‹ç¨‹; ä»¥åŠ [[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/äº”ã€æ‰©å±•æ¨¡å—/stm32è¯»å–å’Œæ’­æ”¾SDå¡ä¸­çš„éŸ³ä¹mp3å’Œwavæ–‡ä»¶|stm32è¯»å–å’Œæ’­æ”¾SDå¡ä¸­çš„éŸ³ä¹mp3å’Œwavæ–‡ä»¶]] ä»¥åŠ [[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/ğŸ¶ Helix MP3è½¯ä»¶è§£ç åº“/2.Helix åº“ç§»æ¤ stm32 è¿›è¡Œè½¯è§£ç éŸ³ä¹æ’­æ”¾|2.Helix åº“ç§»æ¤ stm32 è¿›è¡Œè½¯è§£ç éŸ³ä¹æ’­æ”¾]]   
å¯¹äºå®šä¹‰helixå†…å­˜åˆ†é…çš„éƒ¨åˆ†, ä½¿ç”¨ buffers.c è¿›è¡Œç›¸åº”çš„å®šä¹‰;
```c
// #define static_buffers
#ifdef static_buffers
MP3DecInfo  mp3DecInfo;     //  0x7f0 =  2032 
SubbandInfo sbi;            // 0x2204 =  8708
IMDCTInfo mi;               // 0x1b20 =  6944
HuffmanInfo hi;             // 0x1210 =  4624
DequantInfo di;             //  0x348 =   840
ScaleFactorInfo sfi;        //  0x124 =   292
SideInfo si;                //  0x148 =   328
FrameHeader fh;             //   0x38 =    56
#else
#include "mymalloc.h"
#define malloc(x) mymalloc(SRAMIN, x);
#define free(x)   myfree(SRAMIN, x);
#endif
``` 
ä¸€èˆ¬è€Œè¨€,å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/ğŸ¶ Helix MP3è½¯ä»¶è§£ç åº“/2.Helix åº“ç§»æ¤ stm32 è¿›è¡Œè½¯è§£ç éŸ³ä¹æ’­æ”¾#(4) ç¼“å†²åŒºå†…å­˜æ§åˆ¶|ç¼“å†²åŒºå†…å­˜æ§åˆ¶]] å¤„ç†ç«‹ä½“å£°æ•°æ®æ—¶, ä¸€å¸§è¾“å‡ºç¼“å†²åŒºä¸º 2304 * 16 å­—èŠ‚; æ­¤æ—¶, éœ€è¦ä¸€ä¸ª 2304 * 16bit çš„ç¼“å†²åŒºæ¥æ”¶ Decoder çš„æ•°æ®; åŒæ—¶éœ€è¦ä¸¤ä¸ª 2304 * 8 bit çš„ç¼“å†²åŒºä½œä¸ºDMAå‘é€å’Œæ¥æ”¶;

æœ€ç»ˆéœ€è¦ 4 ä¸ªæ•°ç»„, ä¸¤ä¸ª tx buffer æ•°ç»„, å¤§å°ä¸º 2 *  2304 å­—èŠ‚;  ä¸€ä¸ª 16 bit è§£ç å¸§ç¼“å­˜æ•°ç»„: 2304 * 2 bytes; ä¸€ä¸ªæ–‡ä»¶è¯»æ•°ç»„ (5 * 1024 bytes); å› æ­¤åœ¨ MP3 è§£ç å™¨è¿›è¡Œè¿è¡Œæ—¶, éœ€è¦çš„æ€» RAM çº¦ä¸º 18.5 kb (20kbå·¦å³)

éœ€è¦æ³¨æ„çš„æ˜¯, åœ¨ mp3dec.h ä¸­æœ‰å®šä¹‰ MAINBUF_SIZE = 1940; è¿™ä¸ªæ˜¯åœ¨MP3decode ä¸­è®°å½•å‰©ä½™å­—èŠ‚æ•°çš„, ä¾‹ç¨‹é€»è¾‘æ˜¯å½“ bytesleft < 2 * MAINBUF_SIZE æ—¶, å†è¯»å– 5kb æ–‡ä»¶å¹¶å¡«å……; 

ä¸»è¦çš„è§£ç éƒ¨åˆ†åŒ…æ‹¬å¦‚ä¸‹å‡ ä¸ª(æŒ‰é¡ºåº): 
1. MP3FindSyncWord 
2. MP3Decode 
3. MP3GetLastFrameInfo 

éœ€è¦è¯´æ˜çš„æ˜¯, å¯¹äº uint16_t* è½¬ä¸º uint8_t* çš„è¿‡ç¨‹, å®é™…ä¸Šæ˜¯**æŒ‰ç…§åœ°å€è½¬çš„**, è€Œä¸æ˜¯å°† uint16_t* å–ä½ 8ä½ , å³  uint16_t* (a,b) (c,d) ->  uint8_t* (a) (b) (c) (d) , è¿™æ ·ä¹Ÿä¿ç•™äº† 16 ä½çš„é«˜ä½æ•°æ®;

å¯¹äºä½¿ç”¨ DAC æƒ…å†µä¸‹, éœ€è¦å°†PCM æ•°æ®ä» 32767 æŠ•å½±åˆ° 65536 èŒƒå›´, ä½†æ˜¯ ES8388 åªéœ€ç›´æ¥å†™å…¥å¯¹åº”çš„PCMæ•°æ®å³å¯, ä¸éœ€è¿›è¡Œåç§»ã€‚ 

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä»£ç ç¤ºä¾‹, ä½†æ˜¯è¿™ä¸ªè§£ç è¿‡å¿«; 
```c
/** transfer the decode data to es8388 for output */
while (mp3_dma_tc_flag == 0);                 // wait for  the last DMA transfer complete
mp3_dma_tc_flag = 0;                          // clear the DMA transfer complete flag 

// note : the 16-bit data is signed integar, so we cast it into 8 bit as follows:  
if (mp3_dma_tar_mem == 0){
	for (int i = 0; i < MP3_AUDIO_TX_BUFF_SZ/2; i++){
		uint16_t temp = music_player_buff_rx16[i];
		music_player_buff1[2 * i] = (temp & 0xFF);
		music_player_buff1[2 * i + 1] = (temp >> 8);
	}
}else{ // mp3_dma_tar_mem == 1 
	for (int i = 0; i < MP3_AUDIO_TX_BUFF_SZ/2; i++){
		uint16_t temp = music_player_buff_rx16[i];
		music_player_buff0[2 * i] = (temp & 0xFF);
		music_player_buff0[2 * i + 1] = (temp >> 8);
}
```

è™½ç„¶æ­Œæ›²æ˜¯åŒå£°é“çš„, ä½†æ˜¯æœ‰æ—¶ä¼šè¯»å‡ºå•å£°é“çš„æƒ…å†µ, æ­¤æ—¶, å†æ¬¡æŒ‰ç…§å•å£°é“è¿›è¡Œå¡«å……å³ä¼šå‡ºç°é”™è¯¯ã€‚
![[attachments/Pasted image 20240804182758.png]]
å› æ­¤ä¹‹åå¿…é¡»é‡‡ç”¨å…ˆè§£ç ä¸€å¸§ç„¶åé”å­˜çš„æ ¼å¼;

å…¶äºŒ, æ’­æ”¾çš„é€Ÿåº¦è¿œå¤§äºæ­£å¸¸é€Ÿåº¦, å®é™…ä¸Šæ˜¯å®é™…æ’­æ”¾é€Ÿåº¦çš„å¥½å¤šå€; ä½†æ˜¯ WAV çš„æ’­æ”¾é€Ÿç‡å¤§å°å’Œ wav_audio_buffer_size å®é™…ä¸Šæ²¡æœ‰å…³ç³»ã€‚

è€Œä¸”, mp3 æ’­æ”¾é€Ÿåº¦å®é™…ä¸Šå’Œ mp3 çš„ i2s é¢‘ç‡è®¾ç½®ä¹Ÿæ²¡æœ‰å¾ˆå¤§å…³ç³»;
é¦–å…ˆ, mp3 çš„ I2S è®¾ç½®æ˜¯ 16 ä½æ•°æ®é•¿åº¦, ä¹Ÿå¯ä»¥è®¾ç½®ä¸º 16 ä½æ‰©å±•å¸§é•¿åº¦; åŒæ—¶ WM8978 éƒ¨åˆ†è®¾ç½®ä¸º 16 ä½æ•°æ®é•¿åº¦;


> [!caution] DMA ç¼“å†²åŒºå¤§å°çš„è®¾ç½®éƒ¨åˆ†
> åœ¨æ ‡å‡†åº“ä¸­, é€šè¿‡  DMA_BufferSize ç¡®å®š DMA æ¯æ¬¡ä¼ è¾“æ•°æ®å¤§å°; å¯¹äº WAV ä¼ è¾“çš„æ•°æ®, æ¯ä¸€æ¬¡ä¼ è¾“çš„å¤§å°æ˜¯ WAV_AUDIO_BUFFER_SIZE;
> å³åˆå§‹åŒ–æ˜¯ `ES8388_OutPut_Init((uint8_t*)music_player_buff0,(uint8_t*)music_player_buff1, WAV_AUDIO_BUFFER_SIZE)`

æœ€ç»ˆä¿®å¤é—®é¢˜æ–¹æ³•æ˜¯å°†å‚å®¶æ›´æ”¹ wav é‡‡æ ·é¢‘ç‡çš„ SetSampleRate_Precise æ›´æ”¹ä¸º SetSampleRate_Auto, è·å¾—äº†å¾ˆç¨³å®šçš„æ•ˆæœ; 
```c title:mp3_player_playå‡½æ•°ç¼–å†™ç¤ºä¾‹
// start playing the current mp3 file 
/// @note : in play function, storge must be freed after calling it (use stop function)
uint8_t mp3_player_play(void){
    MP3FrameInfo mp3frameinfo;
    uint8_t res;
    unsigned char* readptr;	// MP3 decodes the read pointer
    int err = 0;            // error for mp3 decode  
    int offset=0;	        // Offset
    int bytesleft=0;        // buffer also has valid data remaining
    UINT br = 0;
    
    /**  Init hardware layer output controller */
    ES8388_i2s_tc_callback = mp3player_i2s_callback;   /* set up callback function */
    
    
    if (ES8388_OutPut_Init((uint8_t*)music_player_buff0, (uint8_t*)music_player_buff1, MP3_AUDIO_TX_BUFF_SZ) ||
        decoder == NULL || ES8388_SetSampleRate_Auto(mp3ctrl.samplerate))   // note : if use accurate -> can't set sample rate correctly;
    {
        return 1;   /** es8388 error */
    }
    ES8388_I2SModeSet(I2S_STANDARD_PHILIPS, I2S_DATAFORMAT_16B, 1, DMA_CIRCULAR, 1);
    musicplayer_setoutput(playerctrl.OutputDevice);
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_HEADPHONE, playerctrl.ch1Volume);   /** Initialize  */
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_SPEAKER, playerctrl.ch2Volume);
    
    decoder = MP3InitDecoder();     /* Init mp3 decoder */
    if (f_open(&mp3_file, (char*) music_name_playing, FA_READ)!=FR_OK) return 1;
    f_lseek(&mp3_file, mp3ctrl.datastart);	   //Skip the tag in the file header
    
    /** before start playing, try read the buffer and decode the 1st frame */
    // res = f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);
    // readptr = music_player_buff_rx8;
    // if (res != FR_OK) {
    //     f_close(&mp3_file); return -1;
    // }else{
    //     offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
        
    // }

    ES8388_DMAStart();
    while(!f_eof(&mp3_file)){
        offset = 0;
        bytesleft = 0;
        f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);
        if (res!= FR_OK)  break;   /** considering plug out the card during playing */
        bytesleft += br;           /**  bytes left in the buffer  */ 
        readptr = (uint8_t*)music_player_buff_rx8;
        
        while (!f_eof(&mp3_file))
        {
            mp3_get_curtime(&mp3_file, &mp3ctrl);
            err = 0;
            /* find the sync word from buff each time */ 
            offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
            if (offset < 0) break;  /* can't find the sync word -> read again for next frame */ 
            /* fix the reading pointer and bytes left */
            readptr   += offset;
            bytesleft -= offset;
            err=MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0); /* may be fast forward and backward  */ 
            if (err!=ERR_MP3_NONE) break;   /** read again and try decode the next frame */
            
            MP3GetLastFrameInfo(decoder, &mp3frameinfo);        /** get the last frame from decoder */
            mp3ctrl.bitrate = mp3frameinfo.bitrate;
            
            mp3_fill_buffer(mp3ctrl.outsamples, 2);
            if (bytesleft < MAINBUF_SIZE){  /* read  new data in the buffer */
                uint8_t byte_align = 4 - bytesleft&3;  // make sure the bytesleft is 4 bytes alignment 
                bytesleft += byte_align;
                memcpy((void*)music_player_buff_rx8, (void*)(readptr - byte_align), bytesleft);   /** copy the bytesleft length data to tx buffer  */
                res = f_read(&mp3_file,  (void*)(music_player_buff_rx8 + bytesleft), MP3_FILE_READ_BUFF_SZ - bytesleft, &br);
                if (res != FR_OK) break;
                if (br <  MP3_FILE_READ_BUFF_SZ - bytesleft){
                    memset((void*)(music_player_buff_rx8 + bytesleft + br), 0,  MP3_FILE_READ_BUFF_SZ - br);
                }
                readptr = (unsigned char*)music_player_buff_rx8;
                bytesleft += br;
            }
        }
    }
    ES8388_DMAStop();
    MP3FreeDecoder(decoder);
    return res;
}
```

ä¸ºäº†ä¼˜åŒ–ä¸Šè¿° mp3 æ’­æ”¾å‡½æ•°, é¦–å…ˆéœ€è¦å…ˆè§£ç ä¸€å¸§å’Œå¡«å…… buffer, ä»£ç éƒ¨åˆ†å¦‚ä¸‹:
```c
/** before start playing, try read the buffer and decode the 1st frame */
res = f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);    

/* try decode the first frame */
if (res == FR_OK) {
	readptr = (uint8_t*) music_player_buff_rx8;
	bytesleft = br;
	offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
	readptr += offset;
	bytesleft -= offset;
	err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
	if (offset < 0 || err!=ERR_MP3_NONE) 
	{
		f_close(&mp3_file); return 1;
	}
	MP3GetLastFrameInfo(decoder, &mp3frameinfo);
	mp3ctrl.nChannels = mp3frameinfo.nChans;
	/* set buffer to mute first */
	__Mem_Set___((void*)music_player_buff0, 0, MP3_AUDIO_TX_BUFF_SZ);
	__Mem_Set___((void*)music_player_buff1, 0, MP3_AUDIO_TX_BUFF_SZ); 
}
else
{
	f_close(&mp3_file); return 1;
}
```

åŒæ—¶, æœ‰çš„å¸§å­˜åœ¨è§£ç ä¸å‡ºçš„æƒ…å†µ, æ­¤æ—¶å°±éœ€è¦è·³è¿‡å¯¹åº”çš„å¸§, è€Œè·³è¿‡å¸§çš„æ–¹æ³•æ˜¯é€šè¿‡å°†è¯»æŒ‡é’ˆåç§»ä¸€ä½, æ­¤æ—¶å°±å¯ä»¥ç›´æ¥é€šè¿‡ä¸‹ä¸€æ¬¡ MP3FindSyncWord æ‰¾åˆ°ä¸‹ä¸€å¸§å¯¹åº”çš„ä½ç½®äº†; å³åªéœ€è¦ä¸¤è¡Œä»£ç :
```c
readptr Â ++;
bytesleft --;
```

æœ€ç»ˆé€šè¿‡é‡è¯•4æ¬¡, å¯ä»¥ä¿è¯ mp3 æ’­æ”¾æ•´ä½“çš„è¿ç»­æ€§, å› æ­¤æ•´ä½“çš„æ’­æ”¾ä»£ç å¦‚ä¸‹:

```c
// start playing the current mp3 file 
/// @note : in play function, storge must be freed after calling it (use stop function)
uint8_t mp3_player_play(void){
    MP3FrameInfo mp3frameinfo;
    uint8_t res;
    unsigned char* readptr;	// MP3 decodes the read pointer
    int err = 0;            // error for mp3 decode  
    int offset=0;	        // Offset
    int bytesleft=0;        // buffer also has valid data remaining
    UINT br = 0;
    
    /**  Init hardware layer output controller */
    ES8388_i2s_tc_callback = mp3player_i2s_callback;   /* set up callback function */
    
    
    if (ES8388_OutPut_Init((uint8_t*)music_player_buff0, (uint8_t*)music_player_buff1, MP3_AUDIO_TX_BUFF_SZ) ||
        decoder == NULL || ES8388_SetSampleRate_Auto(mp3ctrl.samplerate))   // note : if use accurate -> can't set sample rate correctly;
    {
        return 1;   /** es8388 error */
    }
    ES8388_I2SModeSet(I2S_STANDARD_PHILIPS, I2S_DATAFORMAT_16B, 1, DMA_CIRCULAR, 1);
    musicplayer_setoutput(playerctrl.OutputDevice);
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_HEADPHONE, playerctrl.ch1Volume);   /** Initialize  */
    musicplayer_setvolume( PLAYER_OUTPUT_DEVICE_SPEAKER, playerctrl.ch2Volume);
    
    decoder = MP3InitDecoder();     /* Init mp3 decoder */
    if (f_open(&mp3_file, (char*) music_name_playing, FA_READ)!=FR_OK) return 1;
    f_lseek(&mp3_file, mp3ctrl.datastart);	   //Skip the tag in the file header
    
    /** before start playing, try read the buffer and decode the 1st frame */
    res = f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br);    
    
    /* try decode the first frame */
    if (res == FR_OK) {
        readptr = (uint8_t*) music_player_buff_rx8;
        bytesleft = br;
        offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
        readptr += offset;
        bytesleft -= offset;
        err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
        if (offset < 0 || err!=ERR_MP3_NONE) 
        {
            f_close(&mp3_file); return 1;
        }
        MP3GetLastFrameInfo(decoder, &mp3frameinfo);
        mp3ctrl.nChannels = mp3frameinfo.nChans;
        /* set buffer to mute first */
        __Mem_Set___((void*)music_player_buff0, 0, MP3_AUDIO_TX_BUFF_SZ);
        __Mem_Set___((void*)music_player_buff1, 0, MP3_AUDIO_TX_BUFF_SZ); 
    }
    else
    {
        f_close(&mp3_file); return 1;
    }


    /** start the music player and decode all the frames */
    ES8388_DMAStart();
    while(!f_eof(&mp3_file)){
        offset = 0;
        err = 0;
        
        /** fill the last frame */
        mp3_get_curtime(&mp3_file, &mp3ctrl);
        mp3_fill_buffer(mp3ctrl.outsamples, mp3ctrl.nChannels);
        
        /** begin decode this frame */
        offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
        /* find the sync word from buff each time */
        if (offset < 0)
        {   /* if sync word can't be found, jump this frame */
            if (f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br)!= FR_OK) break;
            /** reset read pointer and bytes left */
            readptr   = (unsigned char*)music_player_buff_rx8;
            bytesleft = br;
            continue;
        }
        /* fix the reading pointer and bytes left */
        else
        {
            /** decode from offset */
            readptr   += offset;
            bytesleft -= offset;
            
            for (int i = 0; i < 4; i ++){
                err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
                if (err == ERR_MP3_NONE) break;
                readptr++;
                bytesleft--;
                offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
                readptr += offset;
                bytesleft -= offset;
                if (bytesleft < 0|| offset < 0) break;
            }

            if (err != ERR_MP3_NONE){
                /** if still decode failed, fill with mute to avoid  */
                // printf("frame decode failed, replaced with mute\r\n");
                __Mem_Set___((void*)music_player_buff_rx16, 0, MP3_AUDIO_TX_BUFF_SZ);
            }
            
            // MP3GetLastFrameInfo(decoder, &mp3frameinfo);        /** get the last frame from decoder */
            if (bytesleft < MAINBUF_SIZE){  /* read  new data in the buffer */
                uint8_t byte_align = 4 - bytesleft&3;  // make sure the bytesleft is 4 bytes alignment 
                bytesleft += byte_align;
                memcpy((void*)music_player_buff_rx8, (void*)(readptr - byte_align), bytesleft);   /** copy the bytesleft length data to tx buffer  */
                res = f_read(&mp3_file,  (void*)(music_player_buff_rx8 + bytesleft), MP3_FILE_READ_BUFF_SZ - bytesleft, &br);
                if (res != FR_OK) break;
                if (br <  MP3_FILE_READ_BUFF_SZ - bytesleft){
                    memset((void*)(music_player_buff_rx8 + bytesleft + br), 0,  MP3_FILE_READ_BUFF_SZ - br);
                }
                readptr = (unsigned char*)music_player_buff_rx8;
                bytesleft += br;
            }
        }
    }
    ES8388_DMAStop();
    MP3FreeDecoder(decoder);
    return res;
}
```

é™„æ³¨: æœ‰æ—¶å¯èƒ½å‡ºç°æ’­æ”¾éŸ³ä¹å¤§é‡æ‚éŸ³é—®é¢˜ï¼Œ å¯ä»¥å°è¯•æ‰©å¤§æ ˆç©ºé—´è§£å†³;

## ä¸ƒã€WAV è§£ç éƒ¨åˆ†çš„å®Œå–„
ç”±äºå®é™…ä¸Š ES8388 æ”¯æŒ 24 ä½å’Œ 32 ä½æ•´å½¢è§£ç , æˆ‘ä»¬ä¹Ÿéœ€è¦å¯¹å…¶æ·»åŠ  16 ä½å•åŒå£°é“, 

æµ‹è¯•æ–‡ä»¶:
ARM.wav : 16 ä½å•å£°é“æµ‹è¯•
Knock Me Out.wav: 16 ä½åŒå£°é“æµ‹è¯•
From_Dust_to_Dawn.wav : 24ä½å•å£°é“
Free_Loop.wav : 24 ä½åŒå£°é“ 
Silence.wav  : 32 ä½å•å£°é“
Edge Of My Life.wav : 32ä½åŒå£°é“


> [!caution] ä¸ºä½•ä½¿ç”¨  I2S_Mode_Set å‰å¿…é¡»ä½¿ç”¨çš„æ˜¯ ES8388_SetSampleRate_Auto 
> é‡å¤è°ƒç”¨ I2SModeSet ä¹‹å, ä¼šé‡ç½®é¢„åˆ†é¢‘å€¼, è¿™ä¼šä½¿å¾—é¢„å…ˆè®¾ç½®çš„å’Œè¡¨å†…çš„ä¸ç¬¦åˆ, ä¸€ç§è§£å†³æ–¹æ³•æ˜¯å…ˆè®¾ç½® I2SMode, å†è°ƒç”¨ç²¾ç¡®è®¾ç½®(Set Accurate)å‡½æ•°;
> å› æ­¤, å®é™…ä¸ŠSetAuto å‡½æ•°æ›´åŠ çµæ´», è€Œ SetAccurate å¿…é¡»åœ¨ I2S è¢«æ­£ç¡®é…ç½®ä¹‹å, æ‰èƒ½è¿›è¡Œè®¾ç½®.

å¯¹äº 16 ä½å•å£°é“, é”™è¯¯ä»£ç å¦‚ä¸‹: 
```c
for (int i = WAV_AUDIO_BUFFER_SIZE/2; i > 0; i--){
	p[i*2-1] = p[i-1];
	p[i*2-2] = p[i-1];
}
```
ä¸Šé¢è¿™ä¸ªåªæ˜¯ç®€å•å°†æ•°æ®å¤åˆ¶ä¸ºä¸¤ä¸ª;

æŸ¥æ‰¾ WAV æ–‡ä»¶æ ¼å¼, ç”±äºé«˜ä½å­—èŠ‚æ˜¯äº¤é”™çš„, å› æ­¤å¡«å……æ–¹å¼å®é™…ä¸Šæ˜¯é”™è¯¯çš„;
![[attachments/Screenshot_20240805_184043_com.microsoft.skydrive.png|800]]
å†™å‡ºä¸€ç§ä»£ç å¦‚ä¸‹, ä½†æ˜¯è¿™ä¸ªä»£ç è¿ç®—é‡è¾ƒå¤§, è€ƒè™‘å¦‚ä½•ä¼˜åŒ–:
```c
for (int i = size/4 -1; i >= 0; i--){
	uint8_t tmp1 = p[2 * i], tmp2 = p[2 * i + 1];
	p[4 * i] = tmp1;
	p[4 * i + 1] = tmp2;
	p[4 * i + 2] = tmp1;
	p[4 * i + 3] = tmp2;
}
```


ä¸‹é¢çš„æ˜¯ FreeLoop çš„å—åˆ†å¸ƒ
![[attachments/Pasted image 20240805205512.png]]
è¿™ä¸ªæ˜¯æ ‡å‡†å¯è§£ç çš„å¯¹æ¯”:
![[attachments/Pasted image 20240805205554.png]]
ç¬¬ä¸€ä¸ªæ­£ç¡®è¯»å‡ºå¯¹åº”çš„åç§»Chunk Size = 40, å³åç§» 12 + 8 + 40ï¼Œ å®é™…ä¸Šæ˜¯ 60 çš„ä½ç½®: å³ä» 60 å¼€å§‹è¯»å–; åº”è¯¥æ˜¯æ­£ç¡®çš„, ä½†æ˜¯**è¯»å–æ—¶åˆ†é…RAMå¤ªå°äº†; å¯¼è‡´æ²¡æœ‰æ‰¾åˆ°**;

åˆ é™¤åŸå…ˆä½¿ç”¨çš„ buff_temp éƒ¨åˆ†ï¼Œæ”¹ç”¨ music_player_buff è¿›è¡Œè·å–, è§£å†³é—®é¢˜;
![[attachments/Screenshot_20240805_214652_com.microsoft.skydrive.png|900]]

æ ¹æ® 16 å¸§æˆ–è€… 32 å¸§æ•°æ®æ ¼å¼å›¾, åŸºæœ¬æ—¶åºå¦‚ä¸‹:
![[attachments/Screenshot_20240805_215104_com.microsoft.skydrive.png|900]]
å¯¹äº 16-bit frame length å’Œ 24 bit frame length, å®é™…ä¸Šä¹Ÿæ˜¯æ ¹æ®

å®é™…ä¸Šæˆ‘ä»¬éœ€è¦æŒ‰ç…§ MSB è¿›è¡Œå¡«å……, å³é‡‡ç”¨å¦‚ä¸‹ä»£ç å¡«å……:
```c
if (f_read(&FileRead, p, (WAV_AUDIO_BUFFER_SIZE/4) * 3, &br)) return 1;
	for (int i = WAV_AUDIO_BUFFER_SIZE/4 -1; i >= 0; i--){
		uint16_t idx = 4 * i, idx2 = 3 * i;
		p[idx] = p[idx2 + 2];
		p[idx + 1] = p[idx2 + 1];
		p[idx + 2] = p[idx2];
		p[idx + 3] = 0;
	}
```
åé¢æŸ¥å‡ºæ˜¯ç”±äºä¸¤ä¸ªç¼“å†²åŒºé¢ å€’é—®é¢˜ï¼Œ å¯¼è‡´å·¨å¤§çš„æ‚éŸ³, å³ä¸‹é¢ä¸¤ä¸ªbuff1 å’Œ buff0å†™å, ä½†æ˜¯æ²¡æœ‰åè¿‡æ¥å†™;
```c
if (wav_dma_tar_mem ==0) {
	p = (uint8_t*)music_player_buff1;
}else{
	p = (uint8_t*)music_player_buff0;
}
```

å¦å¤–, å¯¹äº24 ä½å•å£°é“çš„æ•°æ®, <mark style="background: transparent; color: red">åªéœ€ä¸ 24 ä½åŒå£°é“å¤„ç†å®Œå…¨ç›¸åŒå³å¯, ä¸éœ€è¦åƒ16ä½ä¸€æ ·å¤åˆ¶æ•°æ®;</mark>


å¯¹äºmp3 å•å£°é“çš„æ”¯æŒ, ä½¿ç”¨å¦‚ä¸‹ä»£ç (ç”±äºè¯»å–åˆ°mp3å•å£°é“æ–‡ä»¶çš„outputsamplesä»ç„¶æ˜¯2304,ä½†æ˜¯å®é™…ä¸Šä»…å‰1152ä¸ªç”¨äºè§£ç , å› æ­¤éœ€è¦é‡‡ç”¨ < outsamples/2 æ ‡å¿—, ç”¨ä»¥æ”¯æŒå•å£°é“mp3):
```c
if (nchans == 1){ // chans == 1 -> copy mono to stereo 
	for (int i = 0; i < outsamples/2; i++){    // this is applied to mono mp3 
		uint16_t temp = music_player_buff_rx16[i];
		uint16_t idx  = 4 * i;
		p[idx]      = (temp & 0xFF);
		p[idx + 1]  = (temp >> 8);
		p[idx + 2]  = p[idx];
		p[idx + 3]  = p[idx + 1];
	}
}else{ //  (nchans == 2) 
	for (int i = 0; i < outsamples; i++){
		uint16_t temp = music_player_buff_rx16[i];
		p[2 * i] = (temp & 0xFF);
		p[2 * i + 1] = (temp >> 8);
	}
}
```


## ä¸ƒã€è§£ç é”™è¯¯å¤„ç†å’ŒéŸ³è´¨æå‡
å¯¹äºé‡ç«çš„è§£å†³æ–¹æ¡ˆ, å¦‚ä¸‹:
```c
switch (err)
{
	case ERR_MP3_INDATA_UNDERFLOW:
					printf("ERR_MP3_INDATA_UNDERFLOW\r\n");
					result = f_read(&file, inputbuf, INPUTBUF_SIZE, &bw);
					*read_ptr = inputbuf;
					*bytes_left = bw;
		break;		
	case ERR_MP3_MAINDATA_UNDERFLOW:
					/* do nothing - next call to decode will provide more mainData */
					printf("ERR_MP3_MAINDATA_UNDERFLOW\r\n");
		break;		
	default:
					printf("UNKNOWN ERROR:%d\r\n", err);		
					// è·³è¿‡æ­¤å¸§
					if (*bytes_left > 0)
					{
						(*bytes_left) --;
						read_ptr ++;
					}
		break;
}
return 0;
```
æœ€å¸¸è§ä¸”é¢‘å‘çš„é”™è¯¯æ˜¯ ERR_MP3_INVALID_FRAMEHEADER, ä¸”ä»…éœ€è¦è·³è¿‡å³å¯;
å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ continue æ¥å¿½ç•¥é”™è¯¯ç»Ÿè®¡ä¸­çš„è¯¥é”™è¯¯;

æœ€ç»ˆçš„é”™è¯¯å¤„ç†å‡½æ•°å¦‚ä¸‹:
```c
for (int i = 0; i < 10; i ++){
	err = MP3Decode(decoder, &readptr, &bytesleft, (short*)music_player_buff_rx16, 0);
	if (err == ERR_MP3_NONE) break;
	switch (err){
		case ERR_MP3_INVALID_FRAMEHEADER:
			readptr++;
			bytesleft--;
			offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
			if (offset < 0) break;
			readptr += offset;
			bytesleft -= offset;
			continue;
		case ERR_MP3_INDATA_UNDERFLOW:   /** not enough message for this frame */
		case ERR_MP3_MAINDATA_UNDERFLOW:
			memcpy((void*)music_player_buff_rx8, (void*)readptr, bytesleft);   /** copy the bytesleft length data to tx buffer  */
			f_read(&mp3_file,  (void*)(music_player_buff_rx8 + bytesleft), MP3_FILE_READ_BUFF_SZ - bytesleft, &br);
			readptr = (unsigned char*)music_player_buff_rx8;
			bytesleft += br;
			break;
		default:
			readptr++;
			bytesleft--;
			break;
	}
	offset = MP3FindSyncWord((unsigned char*)readptr, bytesleft);
	readptr += offset;
	bytesleft -= offset;
	/* in this case, no frame in the buffer, read whole buffer, not consider  */
	if (bytesleft <= 0|| offset < 0){
		if (f_read(&mp3_file, (void*)music_player_buff_rx8, MP3_FILE_READ_BUFF_SZ, &br)!=FR_OK) {
			res = 1;
			break;
		}
		readptr   = (unsigned char*)music_player_buff_rx8;
		bytesleft = br;
	}
}
```

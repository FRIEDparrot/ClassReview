## 一、LVGL 移植基本内容
使用硬件SPI + DMA + LVGL 双缓冲区方案实现尽可能的高效显示。 

需要说明的是, 在过程中可以先不使用  helium . helium 是可以通过高效的引擎和硬件加速技术, 实现 stm32 中的高效绘图特性。
![[attachments/Pasted image 20240813132746.png]]
另外, 对于 lv_port_disp.c 中, 官方在 lv_port_disp_init 中提供了几个不同的缓冲区示例, 其中3需要两个巨大的 buffer, 注释掉。
```c
// /* Example 1
    //* One buffer for partial rendering*/
    // static uint8_t buf_1_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];            /*A buffer for 10 rows*/
    // lv_display_set_buffers(disp, buf_1_1, NULL, sizeof(buf_1_1), LV_DISPLAY_RENDER_MODE_PARTIAL);

// /* Example 3 
    //* Two buffers screen sized buffer for double buffering.
    //* Both LV_DISPLAY_RENDER_MODE_DIRECT and LV_DISPLAY_RENDER_MODE_FULL works, see their comments*/
    // static uint8_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES * BYTE_PER_PIXEL];
    // static uint8_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES * BYTE_PER_PIXEL];
    // lv_display_set_buffers(disp, buf_3_1, buf_3_2, sizeof(buf_3_1), LV_DISPLAY_RENDER_MODE_DIRECT);
```

CJK 写系统支持中文输入; 
需要说明的是, 单个 buffer 情况下, LVGL 需要等待 lv_display_flush_ready 信号才进行下一次写入, 而两个情况下, 往往使用 DMA 进行; 

对于相应的调试, 可以在 文件中重定义 LOG 标志:
```c
/*1: Print the log with 'printf';
*0: User need to register a callback with `lv_log_register_print_cb()`*/
#define LV_LOG_PRINTF 0

/*Set callback to print the logs.
 *E.g `my_print`. The prototype should be `void my_print(lv_log_level_t level, const char * buf)`
 *Can be overwritten by `lv_log_register_print_cb`*/
#define LV_LOG_PRINT_CB    my_print

// 在lv_log.c 中添加: 
void my_print(lv_log_level_t level, const char * buf){
    printf(buf);
    printf("\r\n");
}
```

> [!caution] 主循环中的回调函数标志位
> 主循环中一定不要忘了加入时间刷新, 否则 call_flush_cb 无法运行

```c
while (1){
	lv_timer_handler();  // must be called during while loop
}
```

其二, 不要将 lcd.c 中私有的 lcd_handler 通过 extern 进行共用，否则可能导致一些问题。
第三, 使用DMA 的情况下, 如果一次传输太多数据, 则 TFT 屏不会显示, 因此必须进行分次传输; 因此需要定义一个 MAX_DMA_TRANSFER_NUM, 一般设置为 200 左右。
另外, 必须在传输DMA调用之后, 等待 SPI 传输忙状态, 否则导致直接无法写入;
```c
void ILI9341_Fill_buff(uint16_t x1, uint16_t y1 ,uint16_t x2, uint16_t y2, uint8_t *buff){
    uint16_t w = (x2 - x1 + 1);
    uint16_t h = (y2 - y1 + 1);
    uint32_t amount = w * h * 2;  // 2 bytes per pixel
    
    ILI9341_SetWindows(x1, y1, x2, y2); // set the window
    ILI9341_CS_CLR();
    ILI9341_DC_SET();             // DATA MODE

    while (amount > MAX_DMA_TRANSFER_NUM){
        HAL_SPI_Transmit_DMA(&lcd_spi_handler,  buff, MAX_DMA_TRANSFER_NUM);
        amount -= MAX_DMA_TRANSFER_NUM;
        buff   += MAX_DMA_TRANSFER_NUM;
        while (HAL_SPI_GetState(&lcd_spi_handler) == HAL_SPI_STATE_BUSY_TX);
    }
    if (amount > 0){
        HAL_SPI_Transmit_DMA(&lcd_spi_handler, buff, amount);
        while (HAL_SPI_GetState(&lcd_spi_handler) == HAL_SPI_STATE_BUSY_TX);
    }
    ILI9341_CS_SET();
    ILI9341_SetWindows(0,0,lcddev.width-1,lcddev.height-1); // restore setting to the whole screen
}
```

最后是数据发送的格式, 应该是低字节在前, 高字节在后, 实际的 disp_flush 代码如下所示: 
```c
static void disp_flush(lv_display_t * disp_drv, const lv_area_t * area, uint8_t * px_map)
{
    if(disp_flush_enabled) {
        // ILI9341_Fill_buff(area->x1, area->y1, area->x2, area->y2, (uint8_t*)px_map);
        int x, y;
        for(y = area->y1; y <= area->y2; y++) {
            for(x = area->x1; x <= area->x2; x++) {
                /* Combine two 8-bit values into one 16-bit color value */
                uint16_t color = (px_map[0] & 0xff) | (px_map[1] << 8);
                ILI9341_Fill(x, y, x,y, color);
                px_map += 2; // Move to the next pixel
            }
        }
    }
    /*IMPORTANT!!!  Inform the graphics library that you are ready with the flushing */
    lv_display_flush_ready(disp_drv);
}
```

根据lvgl 文档， 有描述(但是LV_COLOR_16_SWAP在9.1中弃用): 
> You may set `LV_COLOR_16_SWAP` in `lv_conf.h` to swap bytes of _RGB565_ colors. You may need this when sending 16-bit colors via a byte-oriented interface like SPI. As 16-bit numbers are stored in little-endian format (lower byte at the lower address), the interface will send the lower byte first. However, displays usually need the higher byte first. A mismatch in the byte order will result in highly distorted colors.

## 二、mipi 优化接口和helium驱动移植方案 
为了移植官方的驱动过来, 首先应当将 ILI9341 的部分定义为1, 然后将定义的 ILI9341 使用设为 1
```c
#define LV_USE_ILI9341		1
```

然后将其中的初始化函数移植过来: 
```c
extern void lv_port_disp_init(void);  
```

在官方的驱动中, 通过如下方法, 将传输完成的 Flag 注册到 spi 中, 以判断实际DMA是否传输完成:
```c
HAL_SPI_RegisterCallback(&lcd_spi_handler, HAL_SPI_TX_COMPLETE_CB_ID, lcd_color_transfer_ready_cb);
```

实际上我们只需要修改 ILI9341 本身的驱动就行了, 不需要移植  portstm32 文件部分; 因此, 直接添加上述代码到 ILI9341_spi_init 中即可;

官方代码的机制是, 通过 `lcd_bus_busy = 1;` 判断每次传输是否完成, 然后在每次传输之前进行等待;
最后直接调用 `lv_ili9341_create` 即可创建同时, 注册命令函数和传输 DMA 函数。即在初始化中仅有这两行: 
```c
disp_init();
lcd_disp = lv_ili9341_create(MY_DISP_HOR_RES, MY_DISP_VER_RES, LV_LCD_FLAG_NONE, ILI9341_send_cmd, ILI9341_send_color);
lv_display_set_buffers(disp, buf1, buf2, sizeof(buf1), LV_DISPLAY_RENDER_MODE_PARTIAL);
```

需要说明的是, 在init 函数中只需要初始化 gpio 和reset 就可以了, 而初始化序列已经 lvgl 写好了。

在官方驱动中, 使用 16bit 进行 SPI 传输, 但是仅将 spi 部分设置为了 16 bit, 而 DMA 没有设置为 16 bit 对齐; 因此, 相应的 DMA 必须也配置为 16bit 对齐。修改DMA初始化函数如下。
```
lcd_dma_handler.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
lcd_dma_handler.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
```


> [!NOTE] 颜色高低字节问题
> 参考 [Where is LV_COLOR_16_SWAP in 9.0.0 dev version ? · Issue #3935 · lvgl/lvgl · GitHub](https://github.com/lvgl/lvgl/issues/3935) , 提供了  lv_draw_sw_rgb565_swap() 函数, 

> [!bug] 不能正确填充结果的现象

另外, 使用 DMA 在从 8bit -mode 切换到 16-bit mode 时, 会产生一个特殊现象:  
```c title:这个代码可以正确将SPI重置为16-bit mode 
ILI9341_DC_SET();
lcd_spi_handler.Init.DataSize = SPI_DATASIZE_16BIT;   /* Set the SPI in 16-bit mode to match endianness */
HAL_SPI_Init(&lcd_spi_handler);
```

但是, 如果将上述两句放在 DC_Set 之前, 则得不到正确填充结果, 这和使用 DMA 的情况相同。
```c
lcd_spi_handler.Init.DataSize = SPI_DATASIZE_16BIT;   /* Set the SPI in 16-bit mode to match endianness */
HAL_SPI_Init(&lcd_spi_handler);
ILI9341_DC_SET();
```

这个是由于 DMA 总是以 8bit 进行传输导致的, <mark style="background: transparent; color: red">这个是由于之后在其他函数中乱设置和初始化DMA8bit模式, 因此实际上 DMA 没有传输完成就被设置为8-bit 模式, 最终导致dma无法使用</mark>。对于这个问题, 我们只需要统一使用8位DMA就可以了;

最终使用 DMA 运行的代码如下: 
```c
#include "ILI9341_lcd.h"
#include "stdlib.h"

#define MAX_DMA_TRANSFER_NUM  (256)    // 1kb

_lcd_dev lcddev;

uint16_t POINT_COLOR = 0x0000,BACK_COLOR = 0xFFFF;  
uint16_t DeviceCode;

// !! NOTE: DONT USE EXTERN ON LCD_SPI_HANDLER
static SPI_HandleTypeDef lcd_spi_handler;
static DMA_HandleTypeDef lcd_dma_handler;

volatile uint8_t lcd_bus_busy = 0;


/******************* private function declaration ****************************/
static void __ILI9341_LCD_GPIO_Init(void);
static void __ILI9341_LCD_SPI_Init(void);
static void __ILI9341_LCD_SPI_DMA_Init(void);
static void __ILI9341_LCD_SPI_SetSpeed(SPI_TypeDef* SPIx,uint8_t baud_psc);


void ILI9341_LCD_SPI_IRQHandler(void){
    HAL_SPI_IRQHandler(&lcd_spi_handler);
}

void ILI9341_LCD_SPI_DMA_STREAM_TX_IRQHandler(void){
    HAL_DMA_IRQHandler(&lcd_dma_handler);
}

static void __ILI9341_LCD_GPIO_Init(void)
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    
    ILI9341_LCD_GPIO_CLK_ENABLE();
      /**  Init SCK, MISO and MOSI GPIO */
    GPIO_InitStructure.Pin		= ILI9341_GPIO_PIN_SCL|ILI9341_GPIO_PIN_MISO|ILI9341_GPIO_PIN_MOSI;
    GPIO_InitStructure.Mode 	= GPIO_MODE_AF_PP;
    GPIO_InitStructure.Pull  	= GPIO_PULLUP;
    GPIO_InitStructure.Speed 	= GPIO_SPEED_FAST;
    GPIO_InitStructure.Alternate= ILI9341_LCD_SPI_AF;
    HAL_GPIO_Init(ILI9341_LCD_GPIO_PORT, &GPIO_InitStructure);
    
    /** Init General GPIO (DC, CS, LED, RST) */
    GPIO_InitStructure.Pin 		=  ILI9341_GPIO_PIN_DC| ILI9341_GPIO_PIN_CS | ILI9341_GPIO_PIN_LED| ILI9341_GPIO_PIN_RST;
    GPIO_InitStructure.Mode 	= GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Speed 	= GPIO_SPEED_FAST;
    GPIO_InitStructure.Pull 	= GPIO_PULLUP;
    GPIO_InitStructure.Alternate= 0;

    HAL_GPIO_Init(ILI9341_LCD_GPIO_PORT, &GPIO_InitStructure);
}

/*****************************************************************************
 * @name       :void __ILI9341_LCD_SPI_Init(void)	
 * @date       :2018-08-09 
 * @function   :Initialize the STM32 hardware SPI 
 * @parameters :None
 * @retvalue   :None
******************************************************************************/
static void __ILI9341_LCD_SPI_Init(void)
{	
    ILI9341_LCD_SPI_CLK_ENABLE();
    lcd_spi_handler.Instance 			= ILI9341_LCD_SPI;
    lcd_spi_handler.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
    lcd_spi_handler.Init.CLKPhase 		= SPI_PHASE_1EDGE;
    lcd_spi_handler.Init.CLKPolarity 	= SPI_POLARITY_LOW;
    lcd_spi_handler.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    lcd_spi_handler.Init.CRCPolynomial  = 7;
    lcd_spi_handler.Init.DataSize 		= SPI_DATASIZE_8BIT;
    lcd_spi_handler.Init.Direction		= SPI_DIRECTION_2LINES;
    lcd_spi_handler.Init.FirstBit		= SPI_FIRSTBIT_MSB;
    lcd_spi_handler.Init.Mode			= SPI_MODE_MASTER;
    lcd_spi_handler.Init.NSS 			= SPI_NSS_SOFT;
    lcd_spi_handler.Init.TIMode			= SPI_TIMODE_DISABLE;
    HAL_SPI_DeInit(&lcd_spi_handler);
    HAL_SPI_Init(&lcd_spi_handler);

    // HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3); /** set priority group */
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    HAL_NVIC_SetPriority(ILI9341_LCD_SPI_IRQn, 0, 2);
    HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_IRQn);
    
    /* Register SPI Tx Complete Callback -> defined in lv_port_disp.c */
    HAL_SPI_RegisterCallback(&lcd_spi_handler, HAL_SPI_TX_COMPLETE_CB_ID, lcd_color_transfer_ready_cb);
    
    __HAL_SPI_ENABLE(&lcd_spi_handler);  /** enabel the spi handler */
}

static void __ILI9341_LCD_SPI_DMA_Init(void)
{
    /* DMA controller clock enable */
    ILI9341_LCD_DMA_CLK_ENABLE();
    __HAL_LINKDMA(&lcd_spi_handler, hdmatx, lcd_dma_handler);   /** !! link TX part to DMA request at 16 bit transfer mode */
    /* DMA interrupt init */
    lcd_dma_handler.Instance = ILI9341_LCD_SPI_DMA_STREAM_TX;
    lcd_dma_handler.Init.Channel = ILI9341_LCD_SPI_DMA_CHANNEL_TX;
    lcd_dma_handler.Init.Direction = DMA_MEMORY_TO_PERIPH;
    lcd_dma_handler.Init.PeriphInc = DMA_PINC_DISABLE;
    lcd_dma_handler.Init.MemInc    = DMA_MINC_ENABLE;
    lcd_dma_handler.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    lcd_dma_handler.Init.MemDataAlignment    = DMA_MDATAALIGN_HALFWORD;
    lcd_dma_handler.Init.Mode = DMA_NORMAL;
    lcd_dma_handler.Init.Priority = DMA_PRIORITY_LOW;
    lcd_dma_handler.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    lcd_dma_handler.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    lcd_dma_handler.Init.MemBurst = DMA_MBURST_INC16;
    lcd_dma_handler.Init.PeriphBurst = DMA_PBURST_SINGLE;
    HAL_DMA_DeInit(&lcd_dma_handler);
    HAL_DMA_Init(&lcd_dma_handler);
    
    /* DMA2_Stream0_IRQn interrupt configuration */
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    HAL_NVIC_SetPriority(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn, 0, 1);
    HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn); /** enable DMA TX part */
}

/*****************************************************************************
 * @name       :void SPI_SetSpeed(SPI_TypeDef* SPIx,uint8_t SpeedSet)
 * @date       :2018-08-09 
 * @function   :Set hardware SPI Speed
 * @parameters :SPIx: SPI type,x for 1,2,3
                SpeedSet:0-high speed
                                                 1-low speed
 * @retvalue   :None
******************************************************************************/
static void __ILI9341_LCD_SPI_SetSpeed(SPI_TypeDef* SPIx,uint8_t baud_psc)
{   
    assert_param(IS_SPI_BAUDRATE_PRESCALER(baud_psc));
    __HAL_SPI_DISABLE(&lcd_spi_handler);
    lcd_spi_handler.Instance->CR1 &= 0XFFC7;         /* clear bit 3-5 for set baudrate */ 
    lcd_spi_handler.Instance->CR1 |= baud_psc << 3;  /* set SPI speed */
    __HAL_SPI_ENABLE(&lcd_spi_handler);
}

/*****************************************************************************
 * @name       :void ILI9341_RESET(void)
 * @date       :2018-08-09 
 * @function   :Reset LCD screen
 * @parameters :None
 * @retvalue   :None
******************************************************************************/	
static void ILI9341_RESET(void)
{
    ILI9341_RST_CLR();
    HAL_Delay(100);
    ILI9341_RST_SET();
    HAL_Delay(100);
}

/*****************************************************************************
 * @name       :void ILI9341_LCD_Init (void)
 * @date       :2018-08-09 
 * @function   :Initialization LCD screen
 * @parameters :None
 * @retvalue   :None
******************************************************************************/	 	 
void ILI9341_LCD_Init(void)
{
    __ILI9341_LCD_GPIO_Init();
    __ILI9341_LCD_SPI_Init();
    __ILI9341_LCD_SPI_DMA_Init();

    ILI9341_RESET();
    ILI9341_LED_SET();
    ILI9341_CS_SET();
    ILI9341_DC_SET();
}


/* Platform-specific implementation of the LCD send command function. In general this should use polling transfer. */
void ILI9341_send_cmd(lv_display_t * disp, const uint8_t * cmd, size_t cmd_size, uint8_t * param, size_t param_size)
{
    LV_UNUSED(disp);
    while(lcd_bus_busy);    /* wait until previous transfer is finished */
    /* DCX low (command) */
    ILI9341_DC_CLR();
    /* CS low */
    ILI9341_CS_CLR();

    /* send command */
    if(HAL_SPI_Transmit(&lcd_spi_handler,(uint8_t*)cmd, cmd_size, ILI9341_TIMEOUT) == HAL_OK) {
        /* DCX high (data) */
        ILI9341_DC_SET();
        /* for short data blocks we use polling transfer */
        HAL_SPI_Transmit(&lcd_spi_handler, (uint8_t*)param, (uint16_t)param_size, ILI9341_TIMEOUT);
        /* CS high */
        ILI9341_CS_SET();
    }
}

/* Platform-specific implementation of the LCD send color function. For better performance this should use DMA transfer.
 * In case of a DMA transfer a callback must be installed to notify LVGL about the end of the transfer.
 */
void ILI9341_send_color(lv_display_t * disp, const uint8_t * cmd, size_t cmd_size, uint8_t * param, size_t param_size)
{
    LV_UNUSED(disp);
    while(lcd_bus_busy);    /* wait until previous transfer is finished */
    /* CS low */
    ILI9341_CS_CLR();
    /* DCX low (command) */
    ILI9341_DC_CLR();
    /* send command */
    if(HAL_SPI_Transmit(&lcd_spi_handler, (uint8_t*)cmd, cmd_size, ILI9341_TIMEOUT) != HAL_OK) return;
    /* DCX high (data) */
    ILI9341_DC_SET();
    lcd_bus_busy = 1;
    
    lv_draw_sw_rgb565_swap(param, param_size/2);
    HAL_SPI_Transmit_DMA(&lcd_spi_handler,(uint8_t*)param, param_size);   // due to 8bit is dma align
}

```

其中在 port_disp 中, 两个重要的函数如下(主要是lcd_color_transfer_ready_cb回调函数): 
```c
void lv_port_disp_init(void)
{
    /*-------------------------
     * Initialize your display
     * -----------------------*/
    disp_init();
    /*------------------------------------
     * Create a display and set a flush_cb
     * -----------------------------------*/
    lcd_disp = lv_ili9341_create(MY_DISP_HOR_RES, MY_DISP_VER_RES, LV_LCD_FLAG_NONE, ILI9341_send_cmd, ILI9341_send_color);
    lv_display_set_rotation(lcd_disp, LV_DISPLAY_ROTATION_0);
    /* Example 1 * One buffer for partial rendering*/
    lv_display_set_buffers(lcd_disp, buf1, buf2, sizeof(buf1), LV_DISPLAY_RENDER_MODE_PARTIAL);
}

/* Callback is called when background transfer finished */
void lcd_color_transfer_ready_cb()
{
    /* CS high */
    ILI9341_CS_SET();
    lcd_bus_busy = 0;    // bus busy flag (defined in ILI9341_lcd.c)
    lv_display_flush_ready(lcd_disp);
}
```
也可以在 HAL_TIM_PeriodElapsedCallback 函数部分,添加 lv_tick_inc(1)
helium 驱动移植比较简单, 直接使用宏定义就可以了:
```c
#define  LV_USE_DRAW_SW_ASM     LV_DRAW_SW_ASM_HELIUM
```

如果希望更快, 在初始化完成之后, 使用SetSpeed函数将 SPI 设置为二分频即可;
## 三、触摸屏 LVGL 移植
> [!warning] 警告
> 第一, <mark style="background: transparent; color: red">不能使用 PA1 作为 CS 进行测试</mark>, 否则会导致显示屏无法正常显示工作;
> 第二, 在LVGL移植过程中, 其运行可能和SD卡挂载文件系统有一定的关系, 建议不挂载先测试。之后修复SD卡挂载影响 LVGL 的问题;

在调试好 ili9341_touch.c 之后, 即可移植 LVGL 了, **LVGL 支持触摸屏, 键盘, 鼠标, 编码器和按键输入等等**。对应使用

另外LVGL提供了多种输入设备, 可以按照需求进行裁剪。 在有驱动情况下, 即可**移植触摸检测和坐标获取函数**(两个基本的移植接口函数)。

在 lv_port_indev.h 中, 提供了如下的函数部分, 我们在测试中, **采用一个触摸屏部分, 并采用自带的 KEY0-KAY2, KEY_UP 共4个按键来进行初始化，并可接入一个旋转编码器接口, 用于阅读滚轮和调节音量**。
```c
static void touchpad_init(void);
static void touchpad_read(lv_indev_t * indev, lv_indev_data_t * data);
static bool touchpad_is_pressed(void);
static void touchpad_get_xy(int32_t * x, int32_t * y);

static void mouse_init(void);
static void mouse_read(lv_indev_t * indev, lv_indev_data_t * data);
static bool mouse_is_pressed(void);
static void mouse_get_xy(int32_t * x, int32_t * y);

static void keypad_init(void);
static void keypad_read(lv_indev_t * indev, lv_indev_data_t * data);
static uint32_t keypad_get_key(void);

static void encoder_init(void);
static void encoder_read(lv_indev_t * indev, lv_indev_data_t * data);
static void encoder_handler(void);

static void button_init(void);
static void button_read(lv_indev_t * indev, lv_indev_data_t * data);
static int8_t button_get_pressed_id(void);
static bool button_is_pressed(uint8_t id);
```

对于 LVGL 中, 有如下的标志位, 使用touchpad_read函数进行切换:
```c
LV_INDEV_STATE_PRESSED
LV_INDEV_STATE_RELEASED
```

对于触摸函数, 最简单的方法是直接判断, 最终获取状态值。
```c
/*Return true is the touchpad is pressed*/
static bool touchpad_is_pressed(void)
{
    /*Your code comes here*/
    tp_dev.scan(0);   // read screen coordinate 
    if (tp_dev.sta & TP_PRES_DOWN) return true;
    return false;
}
``` 
需要说明的是, 其中在tp_dev.scan 中获取了按键坐标值, 因此只需要在获取x,y函数中使用如下:
```c
static void touchpad_get_xy(int32_t * x, int32_t * y)
{
    /*Your code comes here*/
    (*x) = tp_dev.x;
    (*y) = tp_dev.y;
}
```

需要说明的是, 电阻屏必须进行校准, 参考 TP_Get_Adjdata 函数, 得到的阐述应该是 xfac, yfac, xoff, yoff 参数;
```c
u8 TP_Get_Adjdata(void)
{					  
	s32 tempfac;
	tempfac=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+13);//读取标记字,看是否校准过！ 		 
	if(tempfac==0X0A)//触摸屏已经校准过了			   
	{    												 
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE,4);		   
		tp_dev.xfac=(float)tempfac/100000000;//得到x校准参数
		
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+4,4);			          
		tp_dev.yfac=(float)tempfac/100000000;//得到y校准参数
	    //得到x偏移量
		tp_dev.xoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+8,2);			   	  
 	    //得到y偏移量
		tp_dev.yoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+10,2);				 	  
 		tp_dev.touchtype=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+12);//读取触屏类型标记
		if(tp_dev.touchtype)//X,Y方向与屏幕相反
		{
			CMD_RDX=0X90;
			CMD_RDY=0XD0;	 
		}else				   //X,Y方向与屏幕相同
		{
			CMD_RDX=0XD0;
			CMD_RDY=0X90;	 
		}		 
		return 1;	 
	}
	return 0;
}
```

为了方便直接采用已经校准过的数据即可。
```c
u8 TP_Get_Adjdata(void)
{	
	s32 tempfac;
	
	LCD_Clear(WHITE);
	tempfac=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+13);//读取标记字,看是否校准过！ 		 
	if(tempfac==0X0A)//触摸屏已经校准过了			   
	{    												 
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE,4);		   
		tp_dev.xfac=(float)tempfac/100000000;//得到x校准参数
		
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+4,4);			          
		tp_dev.yfac=(float)tempfac/100000000;//得到y校准参数
	    //得到x偏移量
		tp_dev.xoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+8,2);			   	  
 	    //得到y偏移量
		tp_dev.yoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+10,2);				 	  
 		tp_dev.touchtype=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+12);//读取触屏类型标记
		if(tp_dev.touchtype)//X,Y方向与屏幕相反
		{
			CMD_RDX=0X90;
			CMD_RDY=0XD0;	 
		}else				   //X,Y方向与屏幕相同
		{
			CMD_RDX=0XD0;
			CMD_RDY=0X90;	 
		}
		
		LCD_ShowString(10,10, 16, "xfac:",0); LCD_ShowNum(100,10,tp_dev.xfac * 100000000,15,16);
		LCD_ShowString(10,30, 16, "yfac:",0); LCD_ShowNum(100,30,tp_dev.yfac * 100000000,15,16);
		LCD_ShowString(10,50, 16, "xoff:",0); LCD_ShowNum(100,50,tp_dev.xoff,15,16);
		LCD_ShowString(10,70, 16, "yoff:",0); LCD_ShowNum(100,70,tp_dev.yoff,15,16);
		delay_ms(5000);
		// printf("xfac:%f, yfac:%f, xoff:%d, yoff:%d\r\n",tp_dev.xfac, tp_dev.yfac, tp_dev.xoff,tp_dev.yoff);
		return 1;
	}
	return 0;
}
```

典型值: 
```c
xoff:-13 yoff:349 xfac:0.066007 yfac:-0.089686
```

只需要通过如下代码读取即可: 
```c
uint8_t TP_Get_Adjdata(void)
{	
    uint8_t tmp1;
	int32_t tempfac;
    uint8_t tempbuf[4];
    uint8_t tempbuf2[2];

    at24cxx_init();
	tmp1 = at24cxx_read_one_byte(SAVE_ADDR_BASE + 13); // Read the marker to check if it has been calibrated
	if (tmp1 == 0X0A) // The touch screen has been calibrated
	{   
		at24cxx_read(SAVE_ADDR_BASE, tempbuf,4);
		tempfac = ((uint32_t)(tempbuf[3] << 24) | (tempbuf[2] << 16) | (tempbuf[1] << 8) | tempbuf[0]);
		tp_dev.xfac = (float)tempfac / 100000000; // Get x calibration parameter
		at24cxx_read(SAVE_ADDR_BASE + 4,tempbuf, 4);
		tempfac = ((uint32_t)(tempbuf[3] << 24) | (tempbuf[2] << 16) | (tempbuf[1] << 8) | tempbuf[0]); 
		tp_dev.yfac = (float)tempfac / 100000000; // Get y calibration parameter
		at24cxx_read(SAVE_ADDR_BASE + 8, tempbuf2,2);
		tp_dev.xoff = ((tempbuf2[1] << 8) | tempbuf2[0]); // Get x offset
 	    at24cxx_read(SAVE_ADDR_BASE + 10, tempbuf2, 2);
		tp_dev.yoff = ((tempbuf2[1] << 8) | tempbuf2[0]); // Get y offset
        tp_dev.touchtype = at24cxx_read_one_byte(SAVE_ADDR_BASE+12);
        if(tp_dev.touchtype)  // 0X0,normal touch;0X01,inverse touch  
        {
            CMD_RDX=0X90;
            CMD_RDY=0XD0;	 
        }
        else				 
        {
            CMD_RDX=0XD0;
            CMD_RDY=0X90;
        }
		return 1;
	}
	return 0;
}
```

需要说明的是, 一般在 lv_conf.h 中有LV_INDEV_DEF_READ_PERIOD 的宏定义, 定义了扫描输入设备的时间(默认定义30)。这个在 8.9 中有相关的定义

注意移植官方例程时, 必须将两个W,H互相统一, 这样才能够保证实际显示的一致性:
```c
#define LCD_W 240
#define LCD_H 320
```
注意这个是不应当改动的;

## 四、带有 FreeRTOS 系统和的 LVGL 移植
### (1) 移植准备 
参考 [[💻softwares/⚡Circuit/🤖 STM32F4和HAL库/基本外设部分/5. STM32F4 的 FREERTOS 操作系统移植|STM32F4 的 FREERTOS 操作系统移植]]。
```c
#define configTOTAL_HEAP_SIZE			( ( size_t ) ( 50 * 1024 ) )
```

更改内存分配函数:
```c
#if (SYS_USER_MALLOC == 1) &&  (SYS_SUPPORT_FREERTOS == 0)
    #include "../MALLOC/mymalloc.h"
    #define __Malloc_Buff__(x)  mymalloc(SRAMIN, x)
    #define __Free_Buff__(x)    myfree(SRAMIN, x)
    #define __Mem_Set___(a,b,c) my_mem_set(a,b,c)
#elif (SYS_USER_MALLOC == 1) &&  (SYS_SUPPORT_FREERTOS == 1)
    #include "FreeRTOS.h"
    #include "string.h"
    #define __Malloc_Buff__(x)         pvPortMalloc(x)   * Use the heap-4 algorithm for malloc */ 
    #define __Free_Buff__(x)           vPortFree(x) 
    #define __Mem_Set__(a,b,c)         memset(a,b,c)
    // pvPortMalloc()
#else
    #include "stdlib.h"
    #define __Malloc_Buff__(x) malloc(x)
    #define __Free_Buff__(x)   free(x)
    #define __Mem_Set___(a,b,c) memset(a,b,c)
#endif
```

新的 Systick_Handler 在 delay.c 中定义(已经放在it.c中): 
```c
void SysTick_Handler(void)
{    
    uint32_t ulPreviousMask;
    /* HAL lib operation and lvgl */
    HAL_IncTick();
    lv_tick_inc(1);
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
    {
        ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
	     
        /* Increase the  RTOS clock */
        if (xTaskIncrementTick() != pdFALSE){
            /* Pend a context switch  */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
}
```

对于 FreeRTOS，其获取时间的函数是xTaskGetTickCount(); 这个也可以作为 lvgl 时钟来源(具体参考文档)

### (2) FreeRTOS 移植程序
首先需要更改定义 `#define LV_USE_OS   LV_OS_FREERTOS` , 则自动启用 lv_freertos.h 中的部分。 
一般在 lvgl 和 FreeRTOS 同时使用时, 可以在 SysTick 中断函数中不加入 `lv_tick_inc(1)` 部分; 

需要说明的是, LVGL 不是线程安全的, 可能会出现资源冲突, 因此必须采用互斥锁(Mutexes)保证资源访问的一致性。

`````ad-note
title:线程安全的概念
collapse: open
**线程安全**是指在多线程环境下，多个线程同时访问共享资源时，能够保证数据的一致性和正确性，不会出现数据竞争或不确定的结果。
##### 线程安全的三个核心概念
1. **原子性**：
    - 操作要么全部执行，要么全部不执行，没有中间状态。例如，银行转账操作必须确保金额从一个账户扣除并同时添加到另一个账户。
2. **可见性**：
    
    - 一个线程对共享变量的修改，其他线程能够立即看到。由于CPU缓存机制，线程对变量的修改可能不会立即反映到主内存中，导致其他线程读取到旧值。
3. **有序性**：
    - 程序执行的顺序按照代码的先后顺序执行。编译器和处理器可能会对指令进行重排序，但最终结果必须与代码顺序执行的结果一致。

##### 如何实现线程安全
1. **互斥同步**：
    - 使用锁（如互斥锁、synchronized关键字）确保同一时刻只有一个线程访问共享资源。例如:  

```c
// 使用互斥锁保护共享资源
pthread_mutex_t lock;
pthread_mutex_lock(&lock);
// 访问共享资源
pthread_mutex_unlock(&lock);
``` 
1. **非阻塞同步**: 
    - 使用原子操作（如CAS操作）来确保操作的原子性和可见性，而不需要锁。例如: 
```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();
```
1. **使用线程安全的数据结构**:
    - 例如Java中的ConcurrentHashMap，Python中的Queue等，这些数据结构内部已经实现了线程安全机制。 
通过这些方法，可以确保在多线程环境下，程序能够正确地访问和修改共享资源，避免数据不一致和竞争问题。
`````

在 lv_freertos.h 中说明了构建 freeRTOS 线程安全的方法, 一种是使用二值信号量标志使 freeRTOS 解除阻塞, 另一种方法是**使用直接通知 FreeRTOS 解除阻塞**, 通知往往有更好的性能。 

```c
/*
 * Unblocking an RTOS task with a direct notification is 45% faster and uses less RAM
 * than unblocking a task using an intermediary object such as a binary semaphore.
 *
 * RTOS task notifications can only be used when there is only one task that can be the recipient of the event.
 */
```

freeRTOS 主要提供了如下的三个定义部分, 用于线程安全的任务创建:
```c
typedef struct {
    void (*pvStartRoutine)(void *);       /**< Application thread function. */
    void * xTaskArg;                      /**< Arguments for application thread function. */
    TaskHandle_t xTaskHandle;             /**< FreeRTOS task handle. */
} lv_thread_t;

typedef struct {
    BaseType_t xIsInitialized;            /**< Set to pdTRUE if this mutex is initialized, pdFALSE otherwise. */
    SemaphoreHandle_t xMutex;             /**< FreeRTOS mutex. */
} lv_mutex_t;

typedef struct {
	TaskHandle_t xTaskToNotify;
} lv_thread_sync_t;

```

而 lvgl 部分实际上是自动算在 freeRTOS 任务里面的, 因此 lv_tick_inc 中断可以删除。 实际上会利用如下两个函数:  
```c
#define _enter_critical()   taskENTER_CRITICAL();
#define _exit_critical()    taskEXIT_CRITICAL();
```

公用函数接口均放在了 lv_os.h 中, 具体如下(没有os则都是空函数)
```c
lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size, void * user_data);
lv_result_t lv_thread_delete(lv_thread_t * thread);
lv_result_t lv_mutex_init(lv_mutex_t * mutex);
lv_result_t lv_mutex_lock(lv_mutex_t * mutex);
lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex);
lv_result_t lv_mutex_unlock(lv_mutex_t * mutex);
lv_result_t lv_mutex_delete(lv_mutex_t * mutex);
lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync);
lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync);
lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync);
lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync);
```

具体操作系统移植需要参考 https://docs.lvgl.io/master/porting/os.html, 对于 lvgl 和 FreeRTOS 结合的情况下, 需要
```c
/* LVGL timer for tasks. */
void LVGLTimer(void const * argument)
{
  for(;;)
  {
    lv_timer_handler();
    osDelay(20);
  }
}
/* LVGL tick source */
void LVGLTick(void const * argument)
{
  for(;;)
  {
    lv_tick_inc(10);
    osDelay(10);
  }
}
```

线程安全和互斥使用:  LVGL has a built-in mutex which can be used with: - [`lv_lock()`](https://docs.lvgl.io/master/API/osal/lv_os.html#_CPPv47lv_lockv "lv_lock") and [`lv_lock_isr()`](https://docs.lvgl.io/master/API/osal/lv_os.html#_CPPv411lv_lock_isrv "lv_lock_isr") - [`lv_unlock()`](https://docs.lvgl.io/master/API/osal/lv_os.html#_CPPv49lv_unlockv "lv_unlock") 

```c
void lvgl_thread(void)
{
    while(1) {
        uint32_t time_till_next;
        time_till_next = lv_timer_handler(); /*lv_lock/lv_unlock is called internally*/
        thread_sleep(time_till_next); /* sleep for a while */
    }
}

void other_thread(void)
{
    /* You must always hold the mutex while using LVGL APIs */
    lv_lock();
    lv_obj_t *img = lv_image_create(lv_screen_active());
    lv_unlock();

    while(1) {
        lv_lock();
        /* change to the next image */
        lv_image_set_src(img, next_image);
        lv_unlock();
        thread_sleep(2000);
    }
}
```

对于主程序, 我们需要单独创建一个 lvgl 刷新屏幕进程, 在 while 中调用 vTaskDelay 函数和 lv_timer_handler() 部分。

其二是需要解决 LVGL 和显示屏显示不兼容的问题。在启用 FreeRTOS 之后, 显示屏显示失效。**解决方案是将 usart_init 放在显示屏初始化的后面, 才能进行正常初始化**, 

重定义获取时间函数: https://docs.lvgl.io/master/porting/tick.html#tick-interface 

### (3) HAL_Delay 死循环问题解决方案
需要说明的是, 首先对于usart, 不能正常初始化的原因是<mark style="background: transparent; color: red">没有正确配置串口的接收中断</mark>, 我们修改代码, 并将其中串口接收部分进行去除, 即可得到正确的初始化函数;

另外, 在使用 FreeRTOS 情况下, <mark style="background: transparent; color: red">必须修改串口打印的 printf 函数即 fputc, 保证其在打印过程中不收到线程干扰, 具体修改办法如下:</mark> 
```c
int fputc(int ch, FILE *f)
{
    #if SYS_SUPPORT_FREERTOS
        vPortEnterCritical();
    #endif 

    while ((USART1->SR & 0X40) == 0);               /*Wait for the previous character to be sent*/
    USART1->DR = (uint8_t)ch;                       /*Write the character ch to be sent to the DR register*/

    #if SYS_SUPPORT_FREERTOS
        vPortExitCritical();
    #endif
    return ch;
}
```


在移植FreeRTOS过程中, 如果没有重定义的 HAL_Delay 函数, 则HAL_Delay 在 ILI9341_LED.c 中的 HAL_Delay 全部失效, 一旦调用, 则会陷入死循环。这是由于中断函数不正常工作导致的, 同时 `lv_delay_ms` 也会直接陷入死循环, 无法正常工作。

1. **正点原子的解决方法是重定义HAL_delay**，需要说明的是, HAL_Delay 应当尽可能小, 因为实际上delay_ms 实际上是调用delay_us进行死循环占用时间的, 在多线程进行调度的情况下, 重定义会使得 在一块程序内 HAL_Delay过程中切换到别的程序, 导致实际延时增加, 同时没有从根本上解决中断产生的问题。
```c
void HAL_Delay(uint32_t Delay)
{
     delay_ms(Delay);
}
```

>  可以在 SystickConfig 函数中后面加上这两句(其实没啥用, 实际上是HAL_Conf.h就已经配置好了)

```c
NVIC_SetPriority(SysTick_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
NVIC_EnableIRQ(SysTick_IRQn);
```

去掉重定义的HAL_delay之后, 在systick中断中调试当前的 HAL_GetTick 参数, 发现仅在程序开始后调用了一次,  systick中断仅进入了一次就没有再进入Systick 中断了。 即 HAL_Tick 参数仅从0变成了1, 之后就再也没有进入中断了。 调试使用类似如下的代码:

```c
/**
 * @brief     systick中断服务函数,使用OS时用到
 * @param     ticks : 延时的节拍数  
 * @retval    无
 */  
void xPortSysTickHandler(void)
{
    uint32_t ulPreviousMask;
    printf("inc tick: %d", HAL_GetTick());
    HAL_IncTick();
    printf(" tick: %d\r\n", HAL_GetTick());
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
    {
        ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
        
        /* Increase the  RTOS clock */
        if (xTaskIncrementTick() != pdFALSE){
            /* Pend a context switch  */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
    HAL_SYSTICK_IRQHandler();
}
#endif
```

> [!CAUTION] 最终解决方案
> 参考:  https://forums.freertos.org/t/problem-with-hal-delay-function-in-freertos/12288 ， 
>  The issue is that FreeRTOS INTENTIONALLY disables interrupts before the scheduler is started in many of its functions
> 在任务调度器开始之前, FREERTOS 会自动禁用 SysTick 中断

<b><mark style="background: transparent; color: blue">我们不应当在开始任务调度之前调用 delay 函数, 而是必须在开始任务之后调用 delay,  因此建议的做法是将带有Delay 函数的初始化函数放到任务调度器中当成任务进行执行</mark></b>; 在初始化完成之后, <mark style="background: transparent; color: red">可以使用一个二值信号量进行等待初始化完毕, 最终才能初始化成功</mark> 

正确的代码示例如下(将初始化函数创建为task1, 等待执行完毕然后运行freertos_task函数), 同时设置一个等待函数, 用于等待二值信号量并接管控制权;
```c
static TaskHandle_t task1_handler;
SemaphoreHandle_t xSemaphore1 = NULL;

void init_function(void *pvParameters){
    if (xSemaphoreTake(xSemaphore1, portMAX_DELAY) == pdPASS){
        printf("Semaphore1 Taken\r\n");
    }
    else{
        printf("Semaphore1 Not Taken\r\n");
    };
    printf("Hello World!\r\n");
    ILI9341_Init();
    HAL_Delay(1000);
    ILI9341_Fill(0,0, 239, 319,RED);
    printf("Hello World2!\r\n");
    LED_Init();
    Timer_Init();
    xSemaphoreGive(xSemaphore1);
    vTaskDelete(NULL);   // delete self after  execution;
}

// wait task function 
void wait_task(void *pvParameters) {
    xSemaphoreTake(xSemaphore1, portMAX_DELAY);
    printf("init task complete\r\n");
    freertostask();
    vTaskDelete(NULL);   // delete self after execution
}

/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
    HAL_Init();
    /* Configure the system clock to 168 MHz */
    SystemClock_Config(); 
    usart_init(115200);
    delay_init(168);
    printf("test1\r\n");
    xSemaphore1 = xSemaphoreCreateBinary();
    xSemaphoreGive(xSemaphore1);

    taskENTER_CRITICAL();
    xTaskCreate(init_function, "init", 1024, NULL, 1, &task1_handler);
    xTaskCreate(wait_task, "wait", 1024, NULL, 1, NULL);
    taskEXIT_CRITICAL();

    vTaskStartScheduler();
    printf("init task complete\r\n");

    freertostask();
}
```

### (4) FreeRTOS 软件定时器和显示屏刷新函数
对于lv_tick_inc 函数，仍然放在中断中即可, 也可以不加，然后使用 `lv_tick_set_cb(xTaskGetTickCount);  //  Set lvgl tick source as FreeRTOS tick` 进行代替即可。 
实际上我们需要单独创建一个线程, 优先级较高且每隔一段时间调用, 在其中调用 lv_timer_handler() 函数;

为了保证任务按照顺序执行, 参考[[💻softwares/⚡Circuit/🤖 STM32F4和HAL库/基本外设部分/5. STM32F4 的 FREERTOS 操作系统移植|FREERTOS 操作系统移植]], 可以<mark style="background: transparent; color: red">使用队列集(先进先出)</mark>或者使用进入 CRITICAL 区域按任务序列创建任务并执行的办法。

另外, lvgl 也单独提供了线程的创建函数: lv_thread_init 可以创建较为安全的线程运行。增加分配给两个任务的堆栈大小为 1024 字节, 则后面两个线程正常运行。<mark style="background: transparent; color: red">但是, 在含有lv_timer_handler()的函数部分, 由于采用的 RAM 比较大, 其所在线程仍然不能正常工作, 如果去掉该句, 则线程能够工作</mark>。

因此考虑使用软件中断刷新屏幕, STM32F4 的 16 个 EXTI 中断均可以通过软件进行触发, 具体参考 NVIC 部分。可以产生多达 23  个 software event/interrupt requests.

需要说明的是, 不是所有的中断线都对其他中断没有干扰(参考p383):
![[attachments/Pasted image 20240819093137.png]]

根据官方文档, lv_timer_handler 可以在下面的任一进行调用: 
To handle the tasks of LVGL you need to call lv_timer_handler() periodically in one of the following:

while(1) of main() function  
timer interrupt periodically (lower priority than lv_tick_inc())  
an OS task periodically

由于我们采用 Systick 进行计数和时间处理, 本身就是最低优先级的, 因此需要采用相同优先级的外部中断， 在中断中调用 lv_timer_handler(), 相同优先级情况下, 实际上抢占优先级相同, 即响应顺序由向量表决定。

因此<mark style="background: transparent; color: red">考虑使用一个单独定时器设置 lv_tick_inc 函数, 并使用较低优先级的软件中断调用其中的lv_timer_handler()函数</mark>, 这样就可以保证在刷屏过程中, 不产生过大的额外 RAM 消耗。

触发软件中断方法如下: 
```c
__HAL_GPIO_EXTI_GENERATE_SWIT(GPIO_PIN_1);
```

具体方法是:
```c
EXTI->IMR |= EXTI_IMR_IM1;  //  Enable the external interrupt
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
HAL_NVIC_SetPriority(EXTI1_IRQn, 15, 0);
HAL_NVIC_EnableIRQ(EXTI1_IRQn);
```

其中上面第一句也可以用这个代替, 但比较麻烦:
```c
EXTI_HandleTypeDef EXTI_Handler;
EXTI_Handler.Line = EXTI_LINE_1;
EXTI_Handler.PendingCallback = NULL;

EXTI_ConfigTypeDef EXTI_Config;
EXTI_Config.Line = EXTI_LINE_1;
EXTI_Config.Mode = EXTI_MODE_INTERRUPT;
EXTI_Config.Trigger = EXTI_TRIGGER_NONE;
EXTI_Config.GPIOSel = EXTI_GPIOA;
HAL_EXTI_SetConfigLine(&EXTI_Handler, &EXTI_Config);
```


但是放到 EXTI1 中没有解决问题; 虽然允许软件产生中断, 但还是导致出错 `Error: .\FreeRTOS\portable\port.c, 441` 

```c
void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
    uxCriticalNesting++;
    
    /* This is not the interrupt safe version of the enter critical function so
     * assert() if it is being called from an interrupt context.  Only API
     * functions that end in "FromISR" can be used in an interrupt.  Only assert if
     * the critical nesting count is 1 to protect against recursive calls if the
     * assert function also uses a critical section. */
    if( uxCriticalNesting == 1)
    {
        configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 ); // 441 
    }
}
```

441 问题的解决参考 https://blog.csdn.net/weixin_38975819/article/details/123633554, 这个一般是由于其中的中断优先级超过了FreeRTOS 能够管理的最高中断优先级，因此实际上可能是 SPI 中断引起的，<mark style="background: transparent; color: red">因此去显示屏的 SPI 函数中修改触发DMA 的中断优先级</mark>， 包括 SPI 和 DMA : 

```c
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
HAL_NVIC_SetPriority(ILI9341_LCD_SPI_IRQn, 8, 0);
HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_IRQn);

HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
HAL_NVIC_SetPriority(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn, 9, 0);
HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn); /** enable DMA TX part */
```

**原因**：在中断中调用了任务级的freertos函数，应调用中断级（即以ISR结尾的）

使用硬件方法
```c
TIM_HandleTypeDef TIM2_Handler;

/* USE TIMER2 for 5ms interruption */
void TIM2_IRQHandler(void){
    taskENTER_CRITICAL_FROM_ISR();
    HAL_TIM_IRQHandler(&TIM2_Handler);
    // lv_timer_handler();
    taskEXIT_CRITICAL_FROM_ISR(pdPASS);
}
void TIM2_InitFunc(void){
    __HAL_RCC_TIM2_CLK_ENABLE();
    /* USE TIM2 for refresh function */
    TIM2_Handler.Instance = TIM2;    /* 84MHz */
    TIM2_Handler.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
    TIM2_Handler.Init.CounterMode = TIM_COUNTERMODE_UP;
    TIM2_Handler.Init.Period = 500 - 1;        /** 5ms timer */
    TIM2_Handler.Init.Prescaler = 8400 - 1;    
    TIM2_Handler.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    TIM2_Handler.Init.RepetitionCounter = 0;
    HAL_TIM_Base_Init(&TIM2_Handler); 
    HAL_TIM_Base_Start_IT(&TIM2_Handler);  /* Start the TIM2 interrupt */
    
    NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    HAL_NVIC_SetPriority(TIM2_IRQn, 7, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);  /* Enable the TIM2 interrupt */
}
```

实际上是卡在了 spi 的函数中, 而不是内存不够的问题, 因此针对卡死的部分进行修改:
逐步查找卡死位置: lv_timer_exec 中的 timer-> timer_cb 部分; 即在回调部分卡死。
```c
printf("begin timer cb\r\n");
if(timer->timer_cb && original_repeat_count != 0) timer->timer_cb(timer);
printf("end timer cb\r\n");
```

这个实际上使用的是默认回调函数: lv_timer_handler, 可以在其中找到定义, 
导向  lv_refr.c 中的 `_lv_display_refr_timer` 

最终找到 lv_refr.c 中的 `refr_invalid_areas();` 部分, 实际上是卡死在这个部分的;
定位到 574 行的 `refr_area(&disp_refr->inv_areas[i]);`  

定位到 744 行 `draw_buf_flush(disp_refr);` 部分, 调用了 `lv_draw_dispatch_wait_for_request();`, 而在其中包含了 lv_draw.c 中的 `lv_thread_sync_wait(&_draw_info.sync);`, 而这个就是 FreeRTOS 的信号量等待操作。实际上也是卡死在这个里面的。

我们在 lv_thread_sync_wait 中加入如下代码进行测试:
```c
printf("waiting sync thread\r\n");
ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
printf("sync thread notified\r\n");
```

显然是由于信号量没有成功获取到而造成的。

我们参考 `lvgl-master\env_support\rt-thread` 中的 port.c 进行移植:
修改程序结构重新创建任务, <mark style="background: transparent; color: red">并将初始化函数和 while 循环整个放在一起作为一个线程整体执行</mark>, 则解决了不能成功获取信号量的问题;

但是显示仍然是异常的, 发现在 waiting for flushing 中重新卡死; 具体在 lv_refr.c 的 `while(disp->flushing) {};` 部分; 由于没有中断将显示部分打断(lv_display_flush_ready(lcd_disp);即设置flushing=0的), 所以没有进行。

实际上通过添加传输可知, 程序已经调用了 color transfer 函数, 但是没有等到回调函数。
即没有调用 lcd_color_transfer_ready_cb 回调函数;

如果设置为: 
```c
HAL_SPI_Transmit(&lcd_spi_handler, (uint8_t*)param, param_size, ILI9341_TIMEOUT);
// HAL_SPI_Transmit_DMA(&lcd_spi_handler,(uint8_t*)param, param_size);   // due to 8bit is dma align
lcd_color_transfer_ready_cb();
```
则能够正常工作, 换用 `HAL_SPI_Transmit_IT`, 所获得结果也一切均正常。但是如果使用 DMA, 则中断函数得不到触发, 仍然困在原先的回调位置等待flush.

调整中断优先级, 将 DMA 的中断优先级设置为比 SPI 更高的优先级, 无济于事。
需要说明的是, 不要把 printf 之类加在传输中断回调函数里面, 否则会导致无法传输。
目前，仅以 Transmit_IT 为传输函数实现移植, 之后详细学习中断内容。

## 五、LVGL 的文件系统的移植
### (1) 常见的配置笔记
主题过渡时间:
```c
#define LV_THEME_DEFAULT_TRANSITION_TIME 80
```

如果需要开辟 48 kb 内存, 可以采用 LV_MEM_ADR 指定开辟内存地址的偏移位置:例如:
```c
#define LV_MEM_ADR 0x20014000
```
这个是在 SRAM1 的 80 kb 附近开辟一个 48 kb 大小的内存;

以下两个可以重定义内存分配函数:
```c
#undef LV_MEM_POOL_INCLUDE
#undef LV_MEM_POOL_ALLOC
```

对于默认的情况下, LVGL有一个宏定义来配置刷新频率的大小（同时适用于9.0):
```c
#define LV_DEF_REFR_PERIOD  33      /*[ms]*/
```
<mark style="background: transparent; color: red">即默认为 30 帧刷新速率, 一般设置5-30可以保证刷新流畅</mark>。

对于 LVGL8, 也有定义读取速率的 LV_INDEV_DEF_READ_PERIOD 函数, 一般设置为 5-30 都可以;
对于 F429 等等具有 DMA2D 外设的部分, 可以开启 DMA2D 来加速渲染。另外 LVGL 也支持其他 GPU 渲染的部分;
```c
/* Use Arm-2D to accelerate the sw render */
#define LV_USE_DRAW_ARM2D_SYNC      0
```
此外有错误和断言相关配置:
```c 
/*Enable asserts if an operation is failed or an invalid data is found.
 *If LV_USE_LOG is enabled an error message will be printed on failure*/
#define LV_USE_ASSERT_NULL          1   /*Check if the parameter is NULL. (Very fast, recommended)*/
#define LV_USE_ASSERT_MALLOC        1   /*Checks is the memory is successfully allocated or no. (Very fast, recommended)*/
#define LV_USE_ASSERT_STYLE         0   /*Check if the styles are properly initialized. (Very fast, recommended)*/
#define LV_USE_ASSERT_MEM_INTEGRITY 0   /*Check the integrity of `lv_mem` after critical operations. (Slow)*/
#define LV_USE_ASSERT_OBJ           0   /*Check the object's type and existence (e.g. not deleted). (Slow)*/

```

对于帧率显示的配置, 需要开启系统监视器:
```c
#define LV_USE_SYSMON   1
```

此时, 可以通过下面的宏定义显示帧率以及 CPU 使用情况:
```txt
/*1: Show CPU usage and FPS count
 * Requires `LV_USE_SYSMON = 1`*/
#define LV_USE_PERF_MONITOR 1
```

大端序列系统使能: 
```c
#define LV_BIG_ENDIAN_SYSTEM 0
```

lvgl 库的常见的第三方库接口配置部分: 
```bash
/*====================
 * 3RD PARTS LIBRARIES
 *====================*/

/*File system interfaces for common APIs */

/*API for fopen, fread, etc*/
#define LV_USE_FS_STDIO 0
#if LV_USE_FS_STDIO
    #define LV_FS_STDIO_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_STDIO_PATH ""         /*Set the working directory. File/directory paths will be appended to it.*/
    #define LV_FS_STDIO_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif

/*API for open, read, etc*/
#define LV_USE_FS_POSIX 0
#if LV_USE_FS_POSIX
    #define LV_FS_POSIX_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_POSIX_PATH ""         /*Set the working directory. File/directory paths will be appended to it.*/
    #define LV_FS_POSIX_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif

/*API for CreateFile, ReadFile, etc*/
#define LV_USE_FS_WIN32 0
#if LV_USE_FS_WIN32
    #define LV_FS_WIN32_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_WIN32_PATH ""         /*Set the working directory. File/directory paths will be appended to it.*/
    #define LV_FS_WIN32_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif

/*API for FATFS (needs to be added separately). Uses f_open, f_read, etc*/
#define LV_USE_FS_FATFS 0
#if LV_USE_FS_FATFS
    #define LV_FS_FATFS_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_FATFS_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif
```
还可以配置 PNG, BMP, JPEG, GIF 等等的第三方库，以支持更多接口

### (2) LVGL 的文件系统移植
首先, 在 `lvgl\src\libs` 中, 有大量封装的第三方库文件。
主要部分包含如下的文件(核心是 lv_fs_fatfs.c 文件):
![[attachments/Pasted image 20240819222518.png]]
将 LV_USE_FS_FATFS 置一, 主要的两个定义有:
```c
#define LV_FS_FATFS_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
#define LV_FS_FATFS_CACHE_SIZE 2    /*>0 to cache this number of bytes in lv_fs_read()
```

一般在仅需要挂载一个盘符的情况下, 采用 `#define LV_FS_FATFS_LETTER '0'` 即可, 一般 LV_FS_FATFS_LETTER 部分

在 fs_init 中仅需要初始化和挂载即可。

> [!caution] 注意
> 为了能够正常打开文件, 实际上 fs_open 等等中, path 实际上不是完整的路径, 而是去掉盘符之后的缺损路径
> fs_open: /font/SimHei16.bin lv_fs_fatfs.c:129
> 因此, 为了实现正常移植, 还需要加上如下的函数:

```c
char* abs_path[MAX_ABSOLUTE_PATH_LENGTH];
memset(abs_path, 0, strlen(abs_path));
if (strlen(path) + 4 > MAX_ABSOLUTE_PATH_LENGTH) return NULL; /* failed to open file */
sprintf(abs_path, "%c:/%s\0", drv->letter, path);
```

上面部分已经集成为两句:
```c
char* abs_path[MAX_ABSOLUTE_PATH_LENGTH];
if (str_make_abs_dir(drv->letter, path, abs_path)) return NULL;
```

直接放到主循环中, 则可以读取bin文件同时创建成功, 但是, 仍然会占据很大的内存空间; 会产生 hard_fault 导致文件无法正常读取;

但是, 将 `#define LV_FONT_SIMSUN_16_CJK            1` 设置好后, 会消耗 162kb 的存储空间, 而且不能很好地对中文进行支持, 方法如下:
```c
lv_obj_set_style_text_font(panel1, &lv_font_simsun_16_cjk, LV_PART_MAIN);
```

首先, 为了减小内存占用, 应当尽可能减少内存使用:
```c
#define LV_USE_FONT_COMPRESSED 1
```


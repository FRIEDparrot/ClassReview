## ä¸€ã€LVGL ç§»æ¤åŸºæœ¬å†…å®¹
ä½¿ç”¨ç¡¬ä»¶SPI + DMA + LVGL åŒç¼“å†²åŒºæ–¹æ¡ˆå®ç°å°½å¯èƒ½çš„é«˜æ•ˆæ˜¾ç¤ºã€‚ 

éœ€è¦è¯´æ˜çš„æ˜¯, åœ¨è¿‡ç¨‹ä¸­å¯ä»¥å…ˆä¸ä½¿ç”¨  helium . helium æ˜¯å¯ä»¥é€šè¿‡é«˜æ•ˆçš„å¼•æ“å’Œç¡¬ä»¶åŠ é€ŸæŠ€æœ¯, å®ç° stm32 ä¸­çš„é«˜æ•ˆç»˜å›¾ç‰¹æ€§ã€‚
![[attachments/Pasted image 20240813132746.png]]
å¦å¤–, å¯¹äº lv_port_disp.c ä¸­, å®˜æ–¹åœ¨ lv_port_disp_init ä¸­æä¾›äº†å‡ ä¸ªä¸åŒçš„ç¼“å†²åŒºç¤ºä¾‹, å…¶ä¸­3éœ€è¦ä¸¤ä¸ªå·¨å¤§çš„ buffer, æ³¨é‡Šæ‰ã€‚
```c
// /* Example 1
Â  Â  //* One buffer for partial rendering*/
Â  Â  // static uint8_t buf_1_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL]; Â  Â  Â  Â  Â  Â /*A buffer for 10 rows*/
Â  Â  // lv_display_set_buffers(disp, buf_1_1, NULL, sizeof(buf_1_1), LV_DISPLAY_RENDER_MODE_PARTIAL);

// /* Example 3 
    //* Two buffers screen sized buffer for double buffering.
    //* Both LV_DISPLAY_RENDER_MODE_DIRECT and LV_DISPLAY_RENDER_MODE_FULL works, see their comments*/
    // static uint8_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES * BYTE_PER_PIXEL];
    // static uint8_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES * BYTE_PER_PIXEL];
    // lv_display_set_buffers(disp, buf_3_1, buf_3_2, sizeof(buf_3_1), LV_DISPLAY_RENDER_MODE_DIRECT);
```

CJK å†™ç³»ç»Ÿæ”¯æŒä¸­æ–‡è¾“å…¥; 
éœ€è¦è¯´æ˜çš„æ˜¯, å•ä¸ª buffer æƒ…å†µä¸‹, LVGL éœ€è¦ç­‰å¾… lv_display_flush_ready ä¿¡å·æ‰è¿›è¡Œä¸‹ä¸€æ¬¡å†™å…¥, è€Œä¸¤ä¸ªæƒ…å†µä¸‹, å¾€å¾€ä½¿ç”¨ DMA è¿›è¡Œ; 

å¯¹äºç›¸åº”çš„è°ƒè¯•, å¯ä»¥åœ¨ æ–‡ä»¶ä¸­é‡å®šä¹‰ LOG æ ‡å¿—:
```c
/*1: Print the log with 'printf';
*0: User need to register a callback with `lv_log_register_print_cb()`*/
#define LV_LOG_PRINTF 0

/*Set callback to print the logs.
 *E.g `my_print`. The prototype should be `void my_print(lv_log_level_t level, const char * buf)`
 *Can be overwritten by `lv_log_register_print_cb`*/
#define LV_LOG_PRINT_CB    my_print

// åœ¨lv_log.c ä¸­æ·»åŠ : 
void my_print(lv_log_level_t level, const char * buf){
Â  Â  printf(buf);
Â  Â  printf("\r\n");
}
```

> [!caution] ä¸»å¾ªç¯ä¸­çš„å›è°ƒå‡½æ•°æ ‡å¿—ä½
> ä¸»å¾ªç¯ä¸­ä¸€å®šä¸è¦å¿˜äº†åŠ å…¥æ—¶é—´åˆ·æ–°, å¦åˆ™ call_flush_cb æ— æ³•è¿è¡Œ

```c
while (1){
	lv_timer_handler(); Â // must be called during while loop
}
```

å…¶äºŒ, ä¸è¦å°† lcd.c ä¸­ç§æœ‰çš„ lcd_handler é€šè¿‡ extern è¿›è¡Œå…±ç”¨ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´ä¸€äº›é—®é¢˜ã€‚
ç¬¬ä¸‰, ä½¿ç”¨DMA çš„æƒ…å†µä¸‹, å¦‚æœä¸€æ¬¡ä¼ è¾“å¤ªå¤šæ•°æ®, åˆ™ TFT å±ä¸ä¼šæ˜¾ç¤º, å› æ­¤å¿…é¡»è¿›è¡Œåˆ†æ¬¡ä¼ è¾“; å› æ­¤éœ€è¦å®šä¹‰ä¸€ä¸ª MAX_DMA_TRANSFER_NUM, ä¸€èˆ¬è®¾ç½®ä¸º 200 å·¦å³ã€‚
å¦å¤–, å¿…é¡»åœ¨ä¼ è¾“DMAè°ƒç”¨ä¹‹å, ç­‰å¾… SPI ä¼ è¾“å¿™çŠ¶æ€, å¦åˆ™å¯¼è‡´ç›´æ¥æ— æ³•å†™å…¥;
```c
void ILI9341_Fill_buff(uint16_t x1, uint16_t y1 ,uint16_t x2, uint16_t y2, uint8_t *buff){
    uint16_t w = (x2 - x1 + 1);
    uint16_t h = (y2 - y1 + 1);
    uint32_t amount = w * h * 2;  // 2 bytes per pixel
    
    ILI9341_SetWindows(x1, y1, x2, y2); // set the window
    ILI9341_CS_CLR();
    ILI9341_DC_SET();             // DATA MODE

    while (amount > MAX_DMA_TRANSFER_NUM){
        HAL_SPI_Transmit_DMA(&lcd_spi_handler,  buff, MAX_DMA_TRANSFER_NUM);
        amount -= MAX_DMA_TRANSFER_NUM;
        buff   += MAX_DMA_TRANSFER_NUM;
        while (HAL_SPI_GetState(&lcd_spi_handler) == HAL_SPI_STATE_BUSY_TX);
    }
    if (amount > 0){
        HAL_SPI_Transmit_DMA(&lcd_spi_handler, buff, amount);
        while (HAL_SPI_GetState(&lcd_spi_handler) == HAL_SPI_STATE_BUSY_TX);
    }
    ILI9341_CS_SET();
    ILI9341_SetWindows(0,0,lcddev.width-1,lcddev.height-1); // restore setting to the whole screen
}
```

æœ€åæ˜¯æ•°æ®å‘é€çš„æ ¼å¼, åº”è¯¥æ˜¯ä½å­—èŠ‚åœ¨å‰, é«˜å­—èŠ‚åœ¨å, å®é™…çš„ disp_flush ä»£ç å¦‚ä¸‹æ‰€ç¤º: 
```c
static void disp_flush(lv_display_t * disp_drv, const lv_area_t * area, uint8_t * px_map)
{
    if(disp_flush_enabled) {
        // ILI9341_Fill_buff(area->x1, area->y1, area->x2, area->y2, (uint8_t*)px_map);
        int x, y;
        for(y = area->y1; y <= area->y2; y++) {
            for(x = area->x1; x <= area->x2; x++) {
                /* Combine two 8-bit values into one 16-bit color value */
                uint16_t color = (px_map[0] & 0xff) | (px_map[1] << 8);
                ILI9341_Fill(x, y, x,y, color);
                px_map += 2; // Move to the next pixel
            }
        }
    }
    /*IMPORTANT!!!  Inform the graphics library that you are ready with the flushing */
    lv_display_flush_ready(disp_drv);
}
```

æ ¹æ®lvgl æ–‡æ¡£ï¼Œ æœ‰æè¿°(ä½†æ˜¯LV_COLOR_16_SWAPåœ¨9.1ä¸­å¼ƒç”¨): 
> You may setÂ `LV_COLOR_16_SWAP`Â inÂ `lv_conf.h`Â to swap bytes ofÂ _RGB565_Â colors. You may need this when sending 16-bit colors via a byte-oriented interface like SPI. As 16-bit numbers are stored in little-endian format (lower byte at the lower address), the interface will send the lower byte first. However, displays usually need the higher byte first. A mismatch in the byte order will result in highly distorted colors.

## äºŒã€mipi ä¼˜åŒ–æ¥å£å’Œheliumé©±åŠ¨ç§»æ¤æ–¹æ¡ˆ 
ä¸ºäº†ç§»æ¤å®˜æ–¹çš„é©±åŠ¨è¿‡æ¥, é¦–å…ˆåº”å½“å°† ILI9341 çš„éƒ¨åˆ†å®šä¹‰ä¸º1, ç„¶åå°†å®šä¹‰çš„ ILI9341 ä½¿ç”¨è®¾ä¸º 1
```c
#define LV_USE_ILI9341		1
```

ç„¶åå°†å…¶ä¸­çš„åˆå§‹åŒ–å‡½æ•°ç§»æ¤è¿‡æ¥: 
```c
extern void lv_port_disp_init(void);  
```

åœ¨å®˜æ–¹çš„é©±åŠ¨ä¸­, é€šè¿‡å¦‚ä¸‹æ–¹æ³•, å°†ä¼ è¾“å®Œæˆçš„ Flag æ³¨å†Œåˆ° spi ä¸­, ä»¥åˆ¤æ–­å®é™…DMAæ˜¯å¦ä¼ è¾“å®Œæˆ:
```c
HAL_SPI_RegisterCallback(&lcd_spi_handler, HAL_SPI_TX_COMPLETE_CB_ID, lcd_color_transfer_ready_cb);
```

å®é™…ä¸Šæˆ‘ä»¬åªéœ€è¦ä¿®æ”¹ ILI9341 æœ¬èº«çš„é©±åŠ¨å°±è¡Œäº†, ä¸éœ€è¦ç§»æ¤  portstm32 æ–‡ä»¶éƒ¨åˆ†; å› æ­¤, ç›´æ¥æ·»åŠ ä¸Šè¿°ä»£ç åˆ° ILI9341_spi_init ä¸­å³å¯;

å®˜æ–¹ä»£ç çš„æœºåˆ¶æ˜¯, é€šè¿‡ `lcd_bus_busy = 1;` åˆ¤æ–­æ¯æ¬¡ä¼ è¾“æ˜¯å¦å®Œæˆ, ç„¶ååœ¨æ¯æ¬¡ä¼ è¾“ä¹‹å‰è¿›è¡Œç­‰å¾…;
æœ€åç›´æ¥è°ƒç”¨ `lv_ili9341_create` å³å¯åˆ›å»ºåŒæ—¶, æ³¨å†Œå‘½ä»¤å‡½æ•°å’Œä¼ è¾“ DMA å‡½æ•°ã€‚å³åœ¨åˆå§‹åŒ–ä¸­ä»…æœ‰è¿™ä¸¤è¡Œ: 
```c
disp_init();
lcd_disp = lv_ili9341_create(MY_DISP_HOR_RES, MY_DISP_VER_RES, LV_LCD_FLAG_NONE, ILI9341_send_cmd, ILI9341_send_color);
lv_display_set_buffers(disp, buf1, buf2, sizeof(buf1), LV_DISPLAY_RENDER_MODE_PARTIAL);
```

éœ€è¦è¯´æ˜çš„æ˜¯, åœ¨init å‡½æ•°ä¸­åªéœ€è¦åˆå§‹åŒ– gpio å’Œreset å°±å¯ä»¥äº†, è€Œåˆå§‹åŒ–åºåˆ—å·²ç» lvgl å†™å¥½äº†ã€‚

åœ¨å®˜æ–¹é©±åŠ¨ä¸­, ä½¿ç”¨ 16bit è¿›è¡Œ SPI ä¼ è¾“, ä½†æ˜¯ä»…å°† spi éƒ¨åˆ†è®¾ç½®ä¸ºäº† 16 bit, è€Œ DMA æ²¡æœ‰è®¾ç½®ä¸º 16 bit å¯¹é½; å› æ­¤, ç›¸åº”çš„ DMA å¿…é¡»ä¹Ÿé…ç½®ä¸º 16bit å¯¹é½ã€‚ä¿®æ”¹DMAåˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹ã€‚
```
lcd_dma_handler.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
lcd_dma_handler.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
```


> [!NOTE] é¢œè‰²é«˜ä½å­—èŠ‚é—®é¢˜
> å‚è€ƒ [Where is LV_COLOR_16_SWAP in 9.0.0 dev version ? Â· Issue #3935 Â· lvgl/lvgl Â· GitHub](https://github.com/lvgl/lvgl/issues/3935) , æä¾›äº†  lv_draw_sw_rgb565_swap() å‡½æ•°, 

> [!bug] ä¸èƒ½æ­£ç¡®å¡«å……ç»“æœçš„ç°è±¡

å¦å¤–, ä½¿ç”¨ DMA åœ¨ä» 8bit -mode åˆ‡æ¢åˆ° 16-bit mode æ—¶, ä¼šäº§ç”Ÿä¸€ä¸ªç‰¹æ®Šç°è±¡:  
```c title:è¿™ä¸ªä»£ç å¯ä»¥æ­£ç¡®å°†SPIé‡ç½®ä¸º16-bit mode 
ILI9341_DC_SET();
lcd_spi_handler.Init.DataSize = SPI_DATASIZE_16BIT; Â  /* Set the SPI in 16-bit mode to match endianness */
HAL_SPI_Init(&lcd_spi_handler);
```

ä½†æ˜¯, å¦‚æœå°†ä¸Šè¿°ä¸¤å¥æ”¾åœ¨ DC_Set ä¹‹å‰, åˆ™å¾—ä¸åˆ°æ­£ç¡®å¡«å……ç»“æœ, è¿™å’Œä½¿ç”¨ DMA çš„æƒ…å†µç›¸åŒã€‚
```c
lcd_spi_handler.Init.DataSize = SPI_DATASIZE_16BIT; Â  /* Set the SPI in 16-bit mode to match endianness */
HAL_SPI_Init(&lcd_spi_handler);
ILI9341_DC_SET();
```

è¿™ä¸ªæ˜¯ç”±äº DMA æ€»æ˜¯ä»¥ 8bit è¿›è¡Œä¼ è¾“å¯¼è‡´çš„, <mark style="background: transparent; color: red">è¿™ä¸ªæ˜¯ç”±äºä¹‹ååœ¨å…¶ä»–å‡½æ•°ä¸­ä¹±è®¾ç½®å’Œåˆå§‹åŒ–DMA8bitæ¨¡å¼, å› æ­¤å®é™…ä¸Š DMA æ²¡æœ‰ä¼ è¾“å®Œæˆå°±è¢«è®¾ç½®ä¸º8-bit æ¨¡å¼, æœ€ç»ˆå¯¼è‡´dmaæ— æ³•ä½¿ç”¨</mark>ã€‚å¯¹äºè¿™ä¸ªé—®é¢˜, æˆ‘ä»¬åªéœ€è¦ç»Ÿä¸€ä½¿ç”¨8ä½DMAå°±å¯ä»¥äº†;

æœ€ç»ˆä½¿ç”¨ DMA è¿è¡Œçš„ä»£ç å¦‚ä¸‹: 
```c
#include "ILI9341_lcd.h"
#include "stdlib.h"

#define MAX_DMA_TRANSFER_NUM  (256)    // 1kb

_lcd_dev lcddev;

uint16_t POINT_COLOR = 0x0000,BACK_COLOR = 0xFFFF;  
uint16_t DeviceCode;

// !! NOTE: DONT USE EXTERN ON LCD_SPI_HANDLER
static SPI_HandleTypeDef lcd_spi_handler;
static DMA_HandleTypeDef lcd_dma_handler;

volatile uint8_t lcd_bus_busy = 0;


/******************* private function declaration ****************************/
static void __ILI9341_LCD_GPIO_Init(void);
static void __ILI9341_LCD_SPI_Init(void);
static void __ILI9341_LCD_SPI_DMA_Init(void);
static void __ILI9341_LCD_SPI_SetSpeed(SPI_TypeDef* SPIx,uint8_t baud_psc);


void ILI9341_LCD_SPI_IRQHandler(void){
    HAL_SPI_IRQHandler(&lcd_spi_handler);
}

void ILI9341_LCD_SPI_DMA_STREAM_TX_IRQHandler(void){
    HAL_DMA_IRQHandler(&lcd_dma_handler);
}

static void __ILI9341_LCD_GPIO_Init(void)
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    
    ILI9341_LCD_GPIO_CLK_ENABLE();
      /**  Init SCK, MISO and MOSI GPIO */
    GPIO_InitStructure.Pin		= ILI9341_GPIO_PIN_SCL|ILI9341_GPIO_PIN_MISO|ILI9341_GPIO_PIN_MOSI;
    GPIO_InitStructure.Mode 	= GPIO_MODE_AF_PP;
    GPIO_InitStructure.Pull  	= GPIO_PULLUP;
    GPIO_InitStructure.Speed 	= GPIO_SPEED_FAST;
    GPIO_InitStructure.Alternate= ILI9341_LCD_SPI_AF;
    HAL_GPIO_Init(ILI9341_LCD_GPIO_PORT, &GPIO_InitStructure);
    
    /** Init General GPIO (DC, CS, LED, RST) */
    GPIO_InitStructure.Pin 		=  ILI9341_GPIO_PIN_DC| ILI9341_GPIO_PIN_CS | ILI9341_GPIO_PIN_LED| ILI9341_GPIO_PIN_RST;
    GPIO_InitStructure.Mode 	= GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Speed 	= GPIO_SPEED_FAST;
    GPIO_InitStructure.Pull 	= GPIO_PULLUP;
    GPIO_InitStructure.Alternate= 0;

    HAL_GPIO_Init(ILI9341_LCD_GPIO_PORT, &GPIO_InitStructure);
}

/*****************************************************************************
 * @name       :void __ILI9341_LCD_SPI_Init(void)	
 * @date       :2018-08-09 
 * @function   :Initialize the STM32 hardware SPI 
 * @parameters :None
 * @retvalue   :None
******************************************************************************/
static void __ILI9341_LCD_SPI_Init(void)
{	
    ILI9341_LCD_SPI_CLK_ENABLE();
    lcd_spi_handler.Instance 			= ILI9341_LCD_SPI;
    lcd_spi_handler.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
    lcd_spi_handler.Init.CLKPhase 		= SPI_PHASE_1EDGE;
    lcd_spi_handler.Init.CLKPolarity 	= SPI_POLARITY_LOW;
    lcd_spi_handler.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    lcd_spi_handler.Init.CRCPolynomial  = 7;
    lcd_spi_handler.Init.DataSize 		= SPI_DATASIZE_8BIT;
    lcd_spi_handler.Init.Direction		= SPI_DIRECTION_2LINES;
    lcd_spi_handler.Init.FirstBit		= SPI_FIRSTBIT_MSB;
    lcd_spi_handler.Init.Mode			= SPI_MODE_MASTER;
    lcd_spi_handler.Init.NSS 			= SPI_NSS_SOFT;
    lcd_spi_handler.Init.TIMode			= SPI_TIMODE_DISABLE;
    HAL_SPI_DeInit(&lcd_spi_handler);
    HAL_SPI_Init(&lcd_spi_handler);

    // HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3); /** set priority group */
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    HAL_NVIC_SetPriority(ILI9341_LCD_SPI_IRQn, 0, 2);
    HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_IRQn);
    
    /* Register SPI Tx Complete Callback -> defined in lv_port_disp.c */
    HAL_SPI_RegisterCallback(&lcd_spi_handler, HAL_SPI_TX_COMPLETE_CB_ID, lcd_color_transfer_ready_cb);
    
    __HAL_SPI_ENABLE(&lcd_spi_handler);  /** enabel the spi handler */
}

static void __ILI9341_LCD_SPI_DMA_Init(void)
{
    /* DMA controller clock enable */
    ILI9341_LCD_DMA_CLK_ENABLE();
    __HAL_LINKDMA(&lcd_spi_handler, hdmatx, lcd_dma_handler);   /** !! link TX part to DMA request at 16 bit transfer mode */
    /* DMA interrupt init */
    lcd_dma_handler.Instance = ILI9341_LCD_SPI_DMA_STREAM_TX;
    lcd_dma_handler.Init.Channel = ILI9341_LCD_SPI_DMA_CHANNEL_TX;
    lcd_dma_handler.Init.Direction = DMA_MEMORY_TO_PERIPH;
    lcd_dma_handler.Init.PeriphInc = DMA_PINC_DISABLE;
    lcd_dma_handler.Init.MemInc    = DMA_MINC_ENABLE;
    lcd_dma_handler.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    lcd_dma_handler.Init.MemDataAlignment    = DMA_MDATAALIGN_HALFWORD;
    lcd_dma_handler.Init.Mode = DMA_NORMAL;
    lcd_dma_handler.Init.Priority = DMA_PRIORITY_LOW;
    lcd_dma_handler.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    lcd_dma_handler.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    lcd_dma_handler.Init.MemBurst = DMA_MBURST_INC16;
    lcd_dma_handler.Init.PeriphBurst = DMA_PBURST_SINGLE;
    HAL_DMA_DeInit(&lcd_dma_handler);
    HAL_DMA_Init(&lcd_dma_handler);
    
    /* DMA2_Stream0_IRQn interrupt configuration */
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    HAL_NVIC_SetPriority(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn, 0, 1);
    HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn); /** enable DMA TX part */
}

/*****************************************************************************
 * @name       :void SPI_SetSpeed(SPI_TypeDef* SPIx,uint8_t SpeedSet)
 * @date       :2018-08-09 
 * @function   :Set hardware SPI Speed
 * @parameters :SPIx: SPI type,x for 1,2,3
                SpeedSet:0-high speed
                                                 1-low speed
 * @retvalue   :None
******************************************************************************/
static void __ILI9341_LCD_SPI_SetSpeed(SPI_TypeDef* SPIx,uint8_t baud_psc)
{   
    assert_param(IS_SPI_BAUDRATE_PRESCALER(baud_psc));
    __HAL_SPI_DISABLE(&lcd_spi_handler);
    lcd_spi_handler.Instance->CR1 &= 0XFFC7;         /* clear bit 3-5 for set baudrate */ 
    lcd_spi_handler.Instance->CR1 |= baud_psc << 3;  /* set SPI speed */
    __HAL_SPI_ENABLE(&lcd_spi_handler);
}

/*****************************************************************************
 * @name       :void ILI9341_RESET(void)
 * @date       :2018-08-09 
 * @function   :Reset LCD screen
 * @parameters :None
 * @retvalue   :None
******************************************************************************/	
static void ILI9341_RESET(void)
{
    ILI9341_RST_CLR();
    HAL_Delay(100);
    ILI9341_RST_SET();
    HAL_Delay(100);
}

/*****************************************************************************
 * @name       :void ILI9341_LCD_Init (void)
 * @date       :2018-08-09 
 * @function   :Initialization LCD screen
 * @parameters :None
 * @retvalue   :None
******************************************************************************/	 	 
void ILI9341_LCD_Init(void)
{
    __ILI9341_LCD_GPIO_Init();
    __ILI9341_LCD_SPI_Init();
    __ILI9341_LCD_SPI_DMA_Init();

    ILI9341_RESET();
    ILI9341_LED_SET();
    ILI9341_CS_SET();
    ILI9341_DC_SET();
}


/* Platform-specific implementation of the LCD send command function. In general this should use polling transfer. */
void ILI9341_send_cmd(lv_display_t * disp, const uint8_t * cmd, size_t cmd_size, uint8_t * param, size_t param_size)
{
    LV_UNUSED(disp);
    while(lcd_bus_busy);    /* wait until previous transfer is finished */
    /* DCX low (command) */
    ILI9341_DC_CLR();
    /* CS low */
    ILI9341_CS_CLR();

    /* send command */
    if(HAL_SPI_Transmit(&lcd_spi_handler,(uint8_t*)cmd, cmd_size, ILI9341_TIMEOUT) == HAL_OK) {
        /* DCX high (data) */
        ILI9341_DC_SET();
        /* for short data blocks we use polling transfer */
        HAL_SPI_Transmit(&lcd_spi_handler, (uint8_t*)param, (uint16_t)param_size, ILI9341_TIMEOUT);
        /* CS high */
        ILI9341_CS_SET();
    }
}

/* Platform-specific implementation of the LCD send color function. For better performance this should use DMA transfer.
 * In case of a DMA transfer a callback must be installed to notify LVGL about the end of the transfer.
 */
void ILI9341_send_color(lv_display_t * disp, const uint8_t * cmd, size_t cmd_size, uint8_t * param, size_t param_size)
{
    LV_UNUSED(disp);
    while(lcd_bus_busy);    /* wait until previous transfer is finished */
    /* CS low */
    ILI9341_CS_CLR();
    /* DCX low (command) */
    ILI9341_DC_CLR();
    /* send command */
    if(HAL_SPI_Transmit(&lcd_spi_handler, (uint8_t*)cmd, cmd_size, ILI9341_TIMEOUT) != HAL_OK) return;
    /* DCX high (data) */
    ILI9341_DC_SET();
    lcd_bus_busy = 1;
    
    lv_draw_sw_rgb565_swap(param, param_size/2);
    HAL_SPI_Transmit_DMA(&lcd_spi_handler,(uint8_t*)param, param_size);   // due to 8bit is dma align
}

```

å…¶ä¸­åœ¨ port_disp ä¸­, ä¸¤ä¸ªé‡è¦çš„å‡½æ•°å¦‚ä¸‹(ä¸»è¦æ˜¯lcd_color_transfer_ready_cbå›è°ƒå‡½æ•°): 
```c
void lv_port_disp_init(void)
{
    /*-------------------------
     * Initialize your display
     * -----------------------*/
    disp_init();
    /*------------------------------------
     * Create a display and set a flush_cb
     * -----------------------------------*/
    lcd_disp = lv_ili9341_create(MY_DISP_HOR_RES, MY_DISP_VER_RES, LV_LCD_FLAG_NONE, ILI9341_send_cmd, ILI9341_send_color);
    lv_display_set_rotation(lcd_disp, LV_DISPLAY_ROTATION_0);
    /* Example 1 * One buffer for partial rendering*/
    lv_display_set_buffers(lcd_disp, buf1, buf2, sizeof(buf1), LV_DISPLAY_RENDER_MODE_PARTIAL);
}

/* Callback is called when background transfer finished */
void lcd_color_transfer_ready_cb()
{
    /* CS high */
    ILI9341_CS_SET();
    lcd_bus_busy = 0;    // bus busy flag (defined in ILI9341_lcd.c)
    lv_display_flush_ready(lcd_disp);
}
```
ä¹Ÿå¯ä»¥åœ¨ HAL_TIM_PeriodElapsedCallback å‡½æ•°éƒ¨åˆ†,æ·»åŠ  lv_tick_inc(1)
helium é©±åŠ¨ç§»æ¤æ¯”è¾ƒç®€å•, ç›´æ¥ä½¿ç”¨å®å®šä¹‰å°±å¯ä»¥äº†:
```c
#define Â LV_USE_DRAW_SW_ASM Â  Â  LV_DRAW_SW_ASM_HELIUM
```

å¦‚æœå¸Œæœ›æ›´å¿«, åœ¨åˆå§‹åŒ–å®Œæˆä¹‹å, ä½¿ç”¨SetSpeedå‡½æ•°å°† SPI è®¾ç½®ä¸ºäºŒåˆ†é¢‘å³å¯;
## ä¸‰ã€è§¦æ‘¸å± LVGL ç§»æ¤
> [!warning] è­¦å‘Š
> ç¬¬ä¸€, <mark style="background: transparent; color: red">ä¸èƒ½ä½¿ç”¨ PA1 ä½œä¸º CS è¿›è¡Œæµ‹è¯•</mark>, å¦åˆ™ä¼šå¯¼è‡´æ˜¾ç¤ºå±æ— æ³•æ­£å¸¸æ˜¾ç¤ºå·¥ä½œ;
> ç¬¬äºŒ, åœ¨LVGLç§»æ¤è¿‡ç¨‹ä¸­, å…¶è¿è¡Œå¯èƒ½å’ŒSDå¡æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿæœ‰ä¸€å®šçš„å…³ç³», å»ºè®®ä¸æŒ‚è½½å…ˆæµ‹è¯•ã€‚ä¹‹åä¿®å¤SDå¡æŒ‚è½½å½±å“ LVGL çš„é—®é¢˜;

åœ¨è°ƒè¯•å¥½ ili9341_touch.c ä¹‹å, å³å¯ç§»æ¤ LVGL äº†, **LVGL æ”¯æŒè§¦æ‘¸å±, é”®ç›˜, é¼ æ ‡, ç¼–ç å™¨å’ŒæŒ‰é”®è¾“å…¥ç­‰ç­‰**ã€‚å¯¹åº”ä½¿ç”¨

å¦å¤–LVGLæä¾›äº†å¤šç§è¾“å…¥è®¾å¤‡, å¯ä»¥æŒ‰ç…§éœ€æ±‚è¿›è¡Œè£å‰ªã€‚ åœ¨æœ‰é©±åŠ¨æƒ…å†µä¸‹, å³å¯**ç§»æ¤è§¦æ‘¸æ£€æµ‹å’Œåæ ‡è·å–å‡½æ•°**(ä¸¤ä¸ªåŸºæœ¬çš„ç§»æ¤æ¥å£å‡½æ•°)ã€‚

åœ¨ lv_port_indev.h ä¸­, æä¾›äº†å¦‚ä¸‹çš„å‡½æ•°éƒ¨åˆ†, æˆ‘ä»¬åœ¨æµ‹è¯•ä¸­, **é‡‡ç”¨ä¸€ä¸ªè§¦æ‘¸å±éƒ¨åˆ†, å¹¶é‡‡ç”¨è‡ªå¸¦çš„ KEY0-KAY2, KEY_UP å…±4ä¸ªæŒ‰é”®æ¥è¿›è¡Œåˆå§‹åŒ–ï¼Œå¹¶å¯æ¥å…¥ä¸€ä¸ªæ—‹è½¬ç¼–ç å™¨æ¥å£, ç”¨äºé˜…è¯»æ»šè½®å’Œè°ƒèŠ‚éŸ³é‡**ã€‚
```c
static void touchpad_init(void);
static void touchpad_read(lv_indev_t * indev, lv_indev_data_t * data);
static bool touchpad_is_pressed(void);
static void touchpad_get_xy(int32_t * x, int32_t * y);

static void mouse_init(void);
static void mouse_read(lv_indev_t * indev, lv_indev_data_t * data);
static bool mouse_is_pressed(void);
static void mouse_get_xy(int32_t * x, int32_t * y);

static void keypad_init(void);
static void keypad_read(lv_indev_t * indev, lv_indev_data_t * data);
static uint32_t keypad_get_key(void);

static void encoder_init(void);
static void encoder_read(lv_indev_t * indev, lv_indev_data_t * data);
static void encoder_handler(void);

static void button_init(void);
static void button_read(lv_indev_t * indev, lv_indev_data_t * data);
static int8_t button_get_pressed_id(void);
static bool button_is_pressed(uint8_t id);
```

å¯¹äº LVGL ä¸­, æœ‰å¦‚ä¸‹çš„æ ‡å¿—ä½, ä½¿ç”¨touchpad_readå‡½æ•°è¿›è¡Œåˆ‡æ¢:
```c
LV_INDEV_STATE_PRESSED
LV_INDEV_STATE_RELEASED
```

å¯¹äºè§¦æ‘¸å‡½æ•°, æœ€ç®€å•çš„æ–¹æ³•æ˜¯ç›´æ¥åˆ¤æ–­, æœ€ç»ˆè·å–çŠ¶æ€å€¼ã€‚
```c
/*Return true is the touchpad is pressed*/
static bool touchpad_is_pressed(void)
{
    /*Your code comes here*/
    tp_dev.scan(0);   // read screen coordinate 
    if (tp_dev.sta & TP_PRES_DOWN) return true;
    return false;
}
``` 
éœ€è¦è¯´æ˜çš„æ˜¯, å…¶ä¸­åœ¨tp_dev.scan ä¸­è·å–äº†æŒ‰é”®åæ ‡å€¼, å› æ­¤åªéœ€è¦åœ¨è·å–x,yå‡½æ•°ä¸­ä½¿ç”¨å¦‚ä¸‹:
```c
static void touchpad_get_xy(int32_t * x, int32_t * y)
{
    /*Your code comes here*/
    (*x) = tp_dev.x;
    (*y) = tp_dev.y;
}
```

éœ€è¦è¯´æ˜çš„æ˜¯, ç”µé˜»å±å¿…é¡»è¿›è¡Œæ ¡å‡†, å‚è€ƒ TP_Get_Adjdata å‡½æ•°, å¾—åˆ°çš„é˜è¿°åº”è¯¥æ˜¯ xfac, yfac, xoff, yoff å‚æ•°;
```c
u8 TP_Get_Adjdata(void)
{					  
	s32 tempfac;
	tempfac=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+13);//è¯»å–æ ‡è®°å­—,çœ‹æ˜¯å¦æ ¡å‡†è¿‡ï¼ 		 
	if(tempfac==0X0A)//è§¦æ‘¸å±å·²ç»æ ¡å‡†è¿‡äº†			   
	{    												 
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE,4);		   
		tp_dev.xfac=(float)tempfac/100000000;//å¾—åˆ°xæ ¡å‡†å‚æ•°
		
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+4,4);			          
		tp_dev.yfac=(float)tempfac/100000000;//å¾—åˆ°yæ ¡å‡†å‚æ•°
	    //å¾—åˆ°xåç§»é‡
		tp_dev.xoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+8,2);			   	  
 	    //å¾—åˆ°yåç§»é‡
		tp_dev.yoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+10,2);				 	  
 		tp_dev.touchtype=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+12);//è¯»å–è§¦å±ç±»å‹æ ‡è®°
		if(tp_dev.touchtype)//X,Yæ–¹å‘ä¸å±å¹•ç›¸å
		{
			CMD_RDX=0X90;
			CMD_RDY=0XD0;	 
		}else				   //X,Yæ–¹å‘ä¸å±å¹•ç›¸åŒ
		{
			CMD_RDX=0XD0;
			CMD_RDY=0X90;	 
		}		 
		return 1;	 
	}
	return 0;
}
```

ä¸ºäº†æ–¹ä¾¿ç›´æ¥é‡‡ç”¨å·²ç»æ ¡å‡†è¿‡çš„æ•°æ®å³å¯ã€‚
```c
u8 TP_Get_Adjdata(void)
{	
	s32 tempfac;
	
	LCD_Clear(WHITE);
	tempfac=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+13);//è¯»å–æ ‡è®°å­—,çœ‹æ˜¯å¦æ ¡å‡†è¿‡ï¼ 		 
	if(tempfac==0X0A)//è§¦æ‘¸å±å·²ç»æ ¡å‡†è¿‡äº†			   
	{    												 
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE,4);		   
		tp_dev.xfac=(float)tempfac/100000000;//å¾—åˆ°xæ ¡å‡†å‚æ•°
		
		tempfac=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+4,4);			          
		tp_dev.yfac=(float)tempfac/100000000;//å¾—åˆ°yæ ¡å‡†å‚æ•°
	    //å¾—åˆ°xåç§»é‡
		tp_dev.xoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+8,2);			   	  
 	    //å¾—åˆ°yåç§»é‡
		tp_dev.yoff=AT24CXX_ReadLenByte(SAVE_ADDR_BASE+10,2);				 	  
 		tp_dev.touchtype=AT24CXX_ReadOneByte(SAVE_ADDR_BASE+12);//è¯»å–è§¦å±ç±»å‹æ ‡è®°
		if(tp_dev.touchtype)//X,Yæ–¹å‘ä¸å±å¹•ç›¸å
		{
			CMD_RDX=0X90;
			CMD_RDY=0XD0;	 
		}else				   //X,Yæ–¹å‘ä¸å±å¹•ç›¸åŒ
		{
			CMD_RDX=0XD0;
			CMD_RDY=0X90;	 
		}
		
		LCD_ShowString(10,10, 16, "xfac:",0); LCD_ShowNum(100,10,tp_dev.xfac * 100000000,15,16);
		LCD_ShowString(10,30, 16, "yfac:",0); LCD_ShowNum(100,30,tp_dev.yfac * 100000000,15,16);
		LCD_ShowString(10,50, 16, "xoff:",0); LCD_ShowNum(100,50,tp_dev.xoff,15,16);
		LCD_ShowString(10,70, 16, "yoff:",0); LCD_ShowNum(100,70,tp_dev.yoff,15,16);
		delay_ms(5000);
		// printf("xfac:%f, yfac:%f, xoff:%d, yoff:%d\r\n",tp_dev.xfac, tp_dev.yfac, tp_dev.xoff,tp_dev.yoff);
		return 1;
	}
	return 0;
}
```

å…¸å‹å€¼: 
```c
xoff:-13 yoff:349 xfac:0.066007 yfac:-0.089686
```

åªéœ€è¦é€šè¿‡å¦‚ä¸‹ä»£ç è¯»å–å³å¯: 
```c
uint8_t TP_Get_Adjdata(void)
{	
    uint8_t tmp1;
	int32_t tempfac;
    uint8_t tempbuf[4];
    uint8_t tempbuf2[2];

    at24cxx_init();
	tmp1 = at24cxx_read_one_byte(SAVE_ADDR_BASE + 13); // Read the marker to check if it has been calibrated
	if (tmp1 == 0X0A) // The touch screen has been calibrated
	{   
		at24cxx_read(SAVE_ADDR_BASE, tempbuf,4);
		tempfac = ((uint32_t)(tempbuf[3] << 24) | (tempbuf[2] << 16) | (tempbuf[1] << 8) | tempbuf[0]);
		tp_dev.xfac = (float)tempfac / 100000000; // Get x calibration parameter
		at24cxx_read(SAVE_ADDR_BASE + 4,tempbuf, 4);
		tempfac = ((uint32_t)(tempbuf[3] << 24) | (tempbuf[2] << 16) | (tempbuf[1] << 8) | tempbuf[0]); 
		tp_dev.yfac = (float)tempfac / 100000000; // Get y calibration parameter
		at24cxx_read(SAVE_ADDR_BASE + 8, tempbuf2,2);
		tp_dev.xoff = ((tempbuf2[1] << 8) | tempbuf2[0]); // Get x offset
 	    at24cxx_read(SAVE_ADDR_BASE + 10, tempbuf2, 2);
		tp_dev.yoff = ((tempbuf2[1] << 8) | tempbuf2[0]); // Get y offset
        tp_dev.touchtype = at24cxx_read_one_byte(SAVE_ADDR_BASE+12);
        if(tp_dev.touchtype)  // 0X0,normal touch;0X01,inverse touch  
        {
            CMD_RDX=0X90;
            CMD_RDY=0XD0;	 
        }
        else				 
        {
            CMD_RDX=0XD0;
            CMD_RDY=0X90;
        }
		return 1;
	}
	return 0;
}
```

éœ€è¦è¯´æ˜çš„æ˜¯, ä¸€èˆ¬åœ¨ lv_conf.h ä¸­æœ‰LV_INDEV_DEF_READ_PERIOD çš„å®å®šä¹‰, å®šä¹‰äº†æ‰«æè¾“å…¥è®¾å¤‡çš„æ—¶é—´(é»˜è®¤å®šä¹‰30)ã€‚è¿™ä¸ªåœ¨ 8.9 ä¸­æœ‰ç›¸å…³çš„å®šä¹‰

æ³¨æ„ç§»æ¤å®˜æ–¹ä¾‹ç¨‹æ—¶, å¿…é¡»å°†ä¸¤ä¸ªW,Häº’ç›¸ç»Ÿä¸€, è¿™æ ·æ‰èƒ½å¤Ÿä¿è¯å®é™…æ˜¾ç¤ºçš„ä¸€è‡´æ€§:
```c
#define LCD_W 240
#define LCD_H 320
```
æ³¨æ„è¿™ä¸ªæ˜¯ä¸åº”å½“æ”¹åŠ¨çš„;

## å››ã€å¸¦æœ‰ FreeRTOS ç³»ç»Ÿå’Œçš„ LVGL ç§»æ¤
### (1) ç§»æ¤å‡†å¤‡ 
å‚è€ƒ [[ğŸ’»softwares/âš¡Circuit/ğŸ¤– STM32F4å’ŒHALåº“/åŸºæœ¬å¤–è®¾éƒ¨åˆ†/5. STM32F4 çš„ FREERTOS æ“ä½œç³»ç»Ÿç§»æ¤|STM32F4 çš„ FREERTOS æ“ä½œç³»ç»Ÿç§»æ¤]]ã€‚
```c
#define configTOTAL_HEAP_SIZE			( ( size_t ) ( 50 * 1024 ) )
```

æ›´æ”¹å†…å­˜åˆ†é…å‡½æ•°:
```c
#if (SYS_USER_MALLOC == 1) &&  (SYS_SUPPORT_FREERTOS == 0)
    #include "../MALLOC/mymalloc.h"
    #define __Malloc_Buff__(x)  mymalloc(SRAMIN, x)
    #define __Free_Buff__(x)    myfree(SRAMIN, x)
    #define __Mem_Set___(a,b,c) my_mem_set(a,b,c)
#elif (SYS_USER_MALLOC == 1) &&  (SYS_SUPPORT_FREERTOS == 1)
    #include "FreeRTOS.h"
    #include "string.h"
    #define __Malloc_Buff__(x)         pvPortMalloc(x)   * Use the heap-4 algorithm for malloc */ 
    #define __Free_Buff__(x)           vPortFree(x) 
    #define __Mem_Set__(a,b,c)         memset(a,b,c)
    // pvPortMalloc()
#else
    #include "stdlib.h"
    #define __Malloc_Buff__(x) malloc(x)
    #define __Free_Buff__(x)   free(x)
    #define __Mem_Set___(a,b,c) memset(a,b,c)
#endif
```

æ–°çš„ Systick_Handler åœ¨ delay.c ä¸­å®šä¹‰(å·²ç»æ”¾åœ¨it.cä¸­): 
```c
void SysTick_Handler(void)
{    
    uint32_t ulPreviousMask;
    /* HAL lib operation and lvgl */
    HAL_IncTick();
    lv_tick_inc(1);
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
    {
        ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
	     
        /* Increase the  RTOS clock */
        if (xTaskIncrementTick() != pdFALSE){
            /* Pend a context switch  */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
}
```

å¯¹äº FreeRTOSï¼Œå…¶è·å–æ—¶é—´çš„å‡½æ•°æ˜¯xTaskGetTickCount(); è¿™ä¸ªä¹Ÿå¯ä»¥ä½œä¸º lvgl æ—¶é’Ÿæ¥æº(å…·ä½“å‚è€ƒæ–‡æ¡£)

### (2) FreeRTOS ç§»æ¤ç¨‹åº
é¦–å…ˆéœ€è¦æ›´æ”¹å®šä¹‰ `#define LV_USE_OS Â  LV_OS_FREERTOS` , åˆ™è‡ªåŠ¨å¯ç”¨ lv_freertos.h ä¸­çš„éƒ¨åˆ†ã€‚ 
ä¸€èˆ¬åœ¨ lvgl å’Œ FreeRTOS åŒæ—¶ä½¿ç”¨æ—¶, å¯ä»¥åœ¨ SysTick ä¸­æ–­å‡½æ•°ä¸­ä¸åŠ å…¥ `lv_tick_inc(1)` éƒ¨åˆ†; 

éœ€è¦è¯´æ˜çš„æ˜¯, LVGL ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„, å¯èƒ½ä¼šå‡ºç°èµ„æºå†²çª, å› æ­¤å¿…é¡»é‡‡ç”¨äº’æ–¥é”(Mutexes)ä¿è¯èµ„æºè®¿é—®çš„ä¸€è‡´æ€§ã€‚

`````ad-note
title:çº¿ç¨‹å®‰å…¨çš„æ¦‚å¿µ
collapse: open
**çº¿ç¨‹å®‰å…¨**æ˜¯æŒ‡åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œèƒ½å¤Ÿä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œæ­£ç¡®æ€§ï¼Œä¸ä¼šå‡ºç°æ•°æ®ç«äº‰æˆ–ä¸ç¡®å®šçš„ç»“æœã€‚
##### çº¿ç¨‹å®‰å…¨çš„ä¸‰ä¸ªæ ¸å¿ƒæ¦‚å¿µ
1. **åŸå­æ€§**ï¼š
    - æ“ä½œè¦ä¹ˆå…¨éƒ¨æ‰§è¡Œï¼Œè¦ä¹ˆå…¨éƒ¨ä¸æ‰§è¡Œï¼Œæ²¡æœ‰ä¸­é—´çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œé“¶è¡Œè½¬è´¦æ“ä½œå¿…é¡»ç¡®ä¿é‡‘é¢ä»ä¸€ä¸ªè´¦æˆ·æ‰£é™¤å¹¶åŒæ—¶æ·»åŠ åˆ°å¦ä¸€ä¸ªè´¦æˆ·ã€‚
2. **å¯è§æ€§**ï¼š
    
    - ä¸€ä¸ªçº¿ç¨‹å¯¹å…±äº«å˜é‡çš„ä¿®æ”¹ï¼Œå…¶ä»–çº¿ç¨‹èƒ½å¤Ÿç«‹å³çœ‹åˆ°ã€‚ç”±äºCPUç¼“å­˜æœºåˆ¶ï¼Œçº¿ç¨‹å¯¹å˜é‡çš„ä¿®æ”¹å¯èƒ½ä¸ä¼šç«‹å³åæ˜ åˆ°ä¸»å†…å­˜ä¸­ï¼Œå¯¼è‡´å…¶ä»–çº¿ç¨‹è¯»å–åˆ°æ—§å€¼ã€‚
3. **æœ‰åºæ€§**ï¼š
    - ç¨‹åºæ‰§è¡Œçš„é¡ºåºæŒ‰ç…§ä»£ç çš„å…ˆåé¡ºåºæ‰§è¡Œã€‚ç¼–è¯‘å™¨å’Œå¤„ç†å™¨å¯èƒ½ä¼šå¯¹æŒ‡ä»¤è¿›è¡Œé‡æ’åºï¼Œä½†æœ€ç»ˆç»“æœå¿…é¡»ä¸ä»£ç é¡ºåºæ‰§è¡Œçš„ç»“æœä¸€è‡´ã€‚

##### å¦‚ä½•å®ç°çº¿ç¨‹å®‰å…¨
1. **äº’æ–¥åŒæ­¥**ï¼š
    - ä½¿ç”¨é”ï¼ˆå¦‚äº’æ–¥é”ã€synchronizedå…³é”®å­—ï¼‰ç¡®ä¿åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºã€‚ä¾‹å¦‚:  

```c
// ä½¿ç”¨äº’æ–¥é”ä¿æŠ¤å…±äº«èµ„æº
pthread_mutex_t lock;
pthread_mutex_lock(&lock);
// è®¿é—®å…±äº«èµ„æº
pthread_mutex_unlock(&lock);
``` 
1. **éé˜»å¡åŒæ­¥**: 
    - ä½¿ç”¨åŸå­æ“ä½œï¼ˆå¦‚CASæ“ä½œï¼‰æ¥ç¡®ä¿æ“ä½œçš„åŸå­æ€§å’Œå¯è§æ€§ï¼Œè€Œä¸éœ€è¦é”ã€‚ä¾‹å¦‚: 
```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();
```
1. **ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„**:
    - ä¾‹å¦‚Javaä¸­çš„ConcurrentHashMapï¼ŒPythonä¸­çš„Queueç­‰ï¼Œè¿™äº›æ•°æ®ç»“æ„å†…éƒ¨å·²ç»å®ç°äº†çº¿ç¨‹å®‰å…¨æœºåˆ¶ã€‚ 
é€šè¿‡è¿™äº›æ–¹æ³•ï¼Œå¯ä»¥ç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œç¨‹åºèƒ½å¤Ÿæ­£ç¡®åœ°è®¿é—®å’Œä¿®æ”¹å…±äº«èµ„æºï¼Œé¿å…æ•°æ®ä¸ä¸€è‡´å’Œç«äº‰é—®é¢˜ã€‚
`````

åœ¨ lv_freertos.h ä¸­è¯´æ˜äº†æ„å»º freeRTOS çº¿ç¨‹å®‰å…¨çš„æ–¹æ³•, ä¸€ç§æ˜¯ä½¿ç”¨äºŒå€¼ä¿¡å·é‡æ ‡å¿—ä½¿ freeRTOS è§£é™¤é˜»å¡, å¦ä¸€ç§æ–¹æ³•æ˜¯**ä½¿ç”¨ç›´æ¥é€šçŸ¥ FreeRTOS è§£é™¤é˜»å¡**, é€šçŸ¥å¾€å¾€æœ‰æ›´å¥½çš„æ€§èƒ½ã€‚ 

```c
/*
 * Unblocking an RTOS task with a direct notification is 45% faster and uses less RAM
 * than unblocking a task using an intermediary object such as a binary semaphore.
 *
 * RTOS task notifications can only be used when there is only one task that can be the recipient of the event.
 */
```

freeRTOS ä¸»è¦æä¾›äº†å¦‚ä¸‹çš„ä¸‰ä¸ªå®šä¹‰éƒ¨åˆ†, ç”¨äºçº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡åˆ›å»º:
```c
typedef struct {
    void (*pvStartRoutine)(void *);       /**< Application thread function. */
    void * xTaskArg;                      /**< Arguments for application thread function. */
    TaskHandle_t xTaskHandle;             /**< FreeRTOS task handle. */
} lv_thread_t;

typedef struct {
    BaseType_t xIsInitialized;            /**< Set to pdTRUE if this mutex is initialized, pdFALSE otherwise. */
    SemaphoreHandle_t xMutex;             /**< FreeRTOS mutex. */
} lv_mutex_t;

typedef struct {
	TaskHandle_t xTaskToNotify;
} lv_thread_sync_t;

```

è€Œ lvgl éƒ¨åˆ†å®é™…ä¸Šæ˜¯è‡ªåŠ¨ç®—åœ¨ freeRTOS ä»»åŠ¡é‡Œé¢çš„, å› æ­¤ lv_tick_inc ä¸­æ–­å¯ä»¥åˆ é™¤ã€‚ å®é™…ä¸Šä¼šåˆ©ç”¨å¦‚ä¸‹ä¸¤ä¸ªå‡½æ•°:  
```c
#define _enter_critical() Â  taskENTER_CRITICAL();
#define _exit_critical() Â  Â taskEXIT_CRITICAL();
```

å…¬ç”¨å‡½æ•°æ¥å£å‡æ”¾åœ¨äº† lv_os.h ä¸­, å…·ä½“å¦‚ä¸‹(æ²¡æœ‰osåˆ™éƒ½æ˜¯ç©ºå‡½æ•°)
```c
lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size, void * user_data);
lv_result_t lv_thread_delete(lv_thread_t * thread);
lv_result_t lv_mutex_init(lv_mutex_t * mutex);
lv_result_t lv_mutex_lock(lv_mutex_t * mutex);
lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex);
lv_result_t lv_mutex_unlock(lv_mutex_t * mutex);
lv_result_t lv_mutex_delete(lv_mutex_t * mutex);
lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync);
lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync);
lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync);
lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync);
```

å…·ä½“æ“ä½œç³»ç»Ÿç§»æ¤éœ€è¦å‚è€ƒ https://docs.lvgl.io/master/porting/os.html, å¯¹äº lvgl å’Œ FreeRTOS ç»“åˆçš„æƒ…å†µä¸‹, éœ€è¦
```c
/* LVGL timer for tasks. */
void LVGLTimer(void const * argument)
{
  for(;;)
  {
    lv_timer_handler();
    osDelay(20);
  }
}
/* LVGL tick source */
void LVGLTick(void const * argument)
{
  for(;;)
  {
    lv_tick_inc(10);
    osDelay(10);
  }
}
```

çº¿ç¨‹å®‰å…¨å’Œäº’æ–¥ä½¿ç”¨:  LVGL has a built-in mutex which can be used with: -Â [`lv_lock()`](https://docs.lvgl.io/master/API/osal/lv_os.html#_CPPv47lv_lockv "lv_lock")Â andÂ [`lv_lock_isr()`](https://docs.lvgl.io/master/API/osal/lv_os.html#_CPPv411lv_lock_isrv "lv_lock_isr")Â -Â [`lv_unlock()`](https://docs.lvgl.io/master/API/osal/lv_os.html#_CPPv49lv_unlockv "lv_unlock") 

```c
void lvgl_thread(void)
{
    while(1) {
        uint32_t time_till_next;
        time_till_next = lv_timer_handler(); /*lv_lock/lv_unlock is called internally*/
        thread_sleep(time_till_next); /* sleep for a while */
    }
}

void other_thread(void)
{
    /* You must always hold the mutex while using LVGL APIs */
    lv_lock();
    lv_obj_t *img = lv_image_create(lv_screen_active());
    lv_unlock();

    while(1) {
        lv_lock();
        /* change to the next image */
        lv_image_set_src(img, next_image);
        lv_unlock();
        thread_sleep(2000);
    }
}
```

å¯¹äºä¸»ç¨‹åº, æˆ‘ä»¬éœ€è¦å•ç‹¬åˆ›å»ºä¸€ä¸ª lvgl åˆ·æ–°å±å¹•è¿›ç¨‹, åœ¨ while ä¸­è°ƒç”¨ vTaskDelay å‡½æ•°å’Œ lv_timer_handler() éƒ¨åˆ†ã€‚

å…¶äºŒæ˜¯éœ€è¦è§£å†³ LVGL å’Œæ˜¾ç¤ºå±æ˜¾ç¤ºä¸å…¼å®¹çš„é—®é¢˜ã€‚åœ¨å¯ç”¨ FreeRTOS ä¹‹å, æ˜¾ç¤ºå±æ˜¾ç¤ºå¤±æ•ˆã€‚**è§£å†³æ–¹æ¡ˆæ˜¯å°† usart_init æ”¾åœ¨æ˜¾ç¤ºå±åˆå§‹åŒ–çš„åé¢, æ‰èƒ½è¿›è¡Œæ­£å¸¸åˆå§‹åŒ–**, 

é‡å®šä¹‰è·å–æ—¶é—´å‡½æ•°: https://docs.lvgl.io/master/porting/tick.html#tick-interface 

### (3) HAL_Delay æ­»å¾ªç¯é—®é¢˜è§£å†³æ–¹æ¡ˆ
éœ€è¦è¯´æ˜çš„æ˜¯, é¦–å…ˆå¯¹äºusart, ä¸èƒ½æ­£å¸¸åˆå§‹åŒ–çš„åŸå› æ˜¯<mark style="background: transparent; color: red">æ²¡æœ‰æ­£ç¡®é…ç½®ä¸²å£çš„æ¥æ”¶ä¸­æ–­</mark>, æˆ‘ä»¬ä¿®æ”¹ä»£ç , å¹¶å°†å…¶ä¸­ä¸²å£æ¥æ”¶éƒ¨åˆ†è¿›è¡Œå»é™¤, å³å¯å¾—åˆ°æ­£ç¡®çš„åˆå§‹åŒ–å‡½æ•°;

å¦å¤–, åœ¨ä½¿ç”¨ FreeRTOS æƒ…å†µä¸‹, <mark style="background: transparent; color: red">å¿…é¡»ä¿®æ”¹ä¸²å£æ‰“å°çš„ printf å‡½æ•°å³ fputc, ä¿è¯å…¶åœ¨æ‰“å°è¿‡ç¨‹ä¸­ä¸æ”¶åˆ°çº¿ç¨‹å¹²æ‰°, å…·ä½“ä¿®æ”¹åŠæ³•å¦‚ä¸‹:</mark> 
```c
int fputc(int ch, FILE *f)
{
    #if SYS_SUPPORT_FREERTOS
        vPortEnterCritical();
    #endif 

    while ((USART1->SR & 0X40) == 0);               /*Wait for the previous character to be sent*/
    USART1->DR = (uint8_t)ch;                       /*Write the character ch to be sent to the DR register*/

    #if SYS_SUPPORT_FREERTOS
        vPortExitCritical();
    #endif
    return ch;
}
```


åœ¨ç§»æ¤FreeRTOSè¿‡ç¨‹ä¸­, å¦‚æœæ²¡æœ‰é‡å®šä¹‰çš„ HAL_Delay å‡½æ•°, åˆ™HAL_Delay åœ¨ ILI9341_LED.c ä¸­çš„ HAL_Delay å…¨éƒ¨å¤±æ•ˆ, ä¸€æ—¦è°ƒç”¨, åˆ™ä¼šé™·å…¥æ­»å¾ªç¯ã€‚è¿™æ˜¯ç”±äºä¸­æ–­å‡½æ•°ä¸æ­£å¸¸å·¥ä½œå¯¼è‡´çš„, åŒæ—¶ `lv_delay_ms` ä¹Ÿä¼šç›´æ¥é™·å…¥æ­»å¾ªç¯, æ— æ³•æ­£å¸¸å·¥ä½œã€‚

1. **æ­£ç‚¹åŸå­çš„è§£å†³æ–¹æ³•æ˜¯é‡å®šä¹‰HAL_delay**ï¼Œéœ€è¦è¯´æ˜çš„æ˜¯, HAL_Delay åº”å½“å°½å¯èƒ½å°, å› ä¸ºå®é™…ä¸Šdelay_ms å®é™…ä¸Šæ˜¯è°ƒç”¨delay_usè¿›è¡Œæ­»å¾ªç¯å ç”¨æ—¶é—´çš„, åœ¨å¤šçº¿ç¨‹è¿›è¡Œè°ƒåº¦çš„æƒ…å†µä¸‹, é‡å®šä¹‰ä¼šä½¿å¾— åœ¨ä¸€å—ç¨‹åºå†… HAL_Delayè¿‡ç¨‹ä¸­åˆ‡æ¢åˆ°åˆ«çš„ç¨‹åº, å¯¼è‡´å®é™…å»¶æ—¶å¢åŠ , åŒæ—¶æ²¡æœ‰ä»æ ¹æœ¬ä¸Šè§£å†³ä¸­æ–­äº§ç”Ÿçš„é—®é¢˜ã€‚
```c
void HAL_Delay(uint32_t Delay)
{
Â  Â  Â delay_ms(Delay);
}
```

>  å¯ä»¥åœ¨ SystickConfig å‡½æ•°ä¸­åé¢åŠ ä¸Šè¿™ä¸¤å¥(å…¶å®æ²¡å•¥ç”¨, å®é™…ä¸Šæ˜¯HAL_Conf.hå°±å·²ç»é…ç½®å¥½äº†)

```c
NVIC_SetPriority(SysTick_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
NVIC_EnableIRQ(SysTick_IRQn);
```

å»æ‰é‡å®šä¹‰çš„HAL_delayä¹‹å, åœ¨systickä¸­æ–­ä¸­è°ƒè¯•å½“å‰çš„ HAL_GetTick å‚æ•°, å‘ç°ä»…åœ¨ç¨‹åºå¼€å§‹åè°ƒç”¨äº†ä¸€æ¬¡,  systickä¸­æ–­ä»…è¿›å…¥äº†ä¸€æ¬¡å°±æ²¡æœ‰å†è¿›å…¥Systick ä¸­æ–­äº†ã€‚ å³ HAL_Tick å‚æ•°ä»…ä»0å˜æˆäº†1, ä¹‹åå°±å†ä¹Ÿæ²¡æœ‰è¿›å…¥ä¸­æ–­äº†ã€‚ è°ƒè¯•ä½¿ç”¨ç±»ä¼¼å¦‚ä¸‹çš„ä»£ç :

```c
/**
 * @brief     systickä¸­æ–­æœåŠ¡å‡½æ•°,ä½¿ç”¨OSæ—¶ç”¨åˆ°
 * @param     ticks : å»¶æ—¶çš„èŠ‚æ‹æ•°  
 * @retval    æ— 
 */  
void xPortSysTickHandler(void)
{
    uint32_t ulPreviousMask;
    printf("inc tick: %d", HAL_GetTick());
    HAL_IncTick();
    printf(" tick: %d\r\n", HAL_GetTick());
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
    {
        ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
        
        /* Increase the  RTOS clock */
        if (xTaskIncrementTick() != pdFALSE){
            /* Pend a context switch  */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
    HAL_SYSTICK_IRQHandler();
}
#endif
```

> [!CAUTION] æœ€ç»ˆè§£å†³æ–¹æ¡ˆ
> å‚è€ƒ:  https://forums.freertos.org/t/problem-with-hal-delay-function-in-freertos/12288 ï¼Œ 
>  The issue is that FreeRTOS INTENTIONALLY disables interrupts before the scheduler is started in many of its functions
> åœ¨ä»»åŠ¡è°ƒåº¦å™¨å¼€å§‹ä¹‹å‰, FREERTOS ä¼šè‡ªåŠ¨ç¦ç”¨ SysTick ä¸­æ–­

<b><mark style="background: transparent; color: blue">æˆ‘ä»¬ä¸åº”å½“åœ¨å¼€å§‹ä»»åŠ¡è°ƒåº¦ä¹‹å‰è°ƒç”¨ delay å‡½æ•°, è€Œæ˜¯å¿…é¡»åœ¨å¼€å§‹ä»»åŠ¡ä¹‹åè°ƒç”¨ delay,  å› æ­¤å»ºè®®çš„åšæ³•æ˜¯å°†å¸¦æœ‰Delay å‡½æ•°çš„åˆå§‹åŒ–å‡½æ•°æ”¾åˆ°ä»»åŠ¡è°ƒåº¦å™¨ä¸­å½“æˆä»»åŠ¡è¿›è¡Œæ‰§è¡Œ</mark></b>; åœ¨åˆå§‹åŒ–å®Œæˆä¹‹å, <mark style="background: transparent; color: red">å¯ä»¥ä½¿ç”¨ä¸€ä¸ªäºŒå€¼ä¿¡å·é‡è¿›è¡Œç­‰å¾…åˆå§‹åŒ–å®Œæ¯•, æœ€ç»ˆæ‰èƒ½åˆå§‹åŒ–æˆåŠŸ</mark> 

æ­£ç¡®çš„ä»£ç ç¤ºä¾‹å¦‚ä¸‹(å°†åˆå§‹åŒ–å‡½æ•°åˆ›å»ºä¸ºtask1, ç­‰å¾…æ‰§è¡Œå®Œæ¯•ç„¶åè¿è¡Œfreertos_taskå‡½æ•°), åŒæ—¶è®¾ç½®ä¸€ä¸ªç­‰å¾…å‡½æ•°, ç”¨äºç­‰å¾…äºŒå€¼ä¿¡å·é‡å¹¶æ¥ç®¡æ§åˆ¶æƒ;
```c
static TaskHandle_t task1_handler;
SemaphoreHandle_t xSemaphore1 = NULL;

void init_function(void *pvParameters){
    if (xSemaphoreTake(xSemaphore1, portMAX_DELAY) == pdPASS){
        printf("Semaphore1 Taken\r\n");
    }
    else{
        printf("Semaphore1 Not Taken\r\n");
    };
    printf("Hello World!\r\n");
    ILI9341_Init();
    HAL_Delay(1000);
    ILI9341_Fill(0,0, 239, 319,RED);
    printf("Hello World2!\r\n");
    LED_Init();
    Timer_Init();
    xSemaphoreGive(xSemaphore1);
    vTaskDelete(NULL);   // delete self after  execution;
}

// wait task function 
void wait_task(void *pvParameters) {
    xSemaphoreTake(xSemaphore1, portMAX_DELAY);
    printf("init task complete\r\n");
    freertostask();
    vTaskDelete(NULL);   // delete self after execution
}

/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
    HAL_Init();
    /* Configure the system clock to 168 MHz */
    SystemClock_Config(); 
    usart_init(115200);
    delay_init(168);
    printf("test1\r\n");
    xSemaphore1 = xSemaphoreCreateBinary();
    xSemaphoreGive(xSemaphore1);

    taskENTER_CRITICAL();
    xTaskCreate(init_function, "init", 1024, NULL, 1, &task1_handler);
    xTaskCreate(wait_task, "wait", 1024, NULL, 1, NULL);
    taskEXIT_CRITICAL();

    vTaskStartScheduler();
    printf("init task complete\r\n");

    freertostask();
}
```

### (4) FreeRTOS è½¯ä»¶å®šæ—¶å™¨å’Œæ˜¾ç¤ºå±åˆ·æ–°å‡½æ•°
å¯¹äºlv_tick_inc å‡½æ•°ï¼Œä»ç„¶æ”¾åœ¨ä¸­æ–­ä¸­å³å¯, ä¹Ÿå¯ä»¥ä¸åŠ ï¼Œç„¶åä½¿ç”¨ `lv_tick_set_cb(xTaskGetTickCount); Â // Â Set lvgl tick source as FreeRTOS tick` è¿›è¡Œä»£æ›¿å³å¯ã€‚ 
å®é™…ä¸Šæˆ‘ä»¬éœ€è¦å•ç‹¬åˆ›å»ºä¸€ä¸ªçº¿ç¨‹, ä¼˜å…ˆçº§è¾ƒé«˜ä¸”æ¯éš”ä¸€æ®µæ—¶é—´è°ƒç”¨, åœ¨å…¶ä¸­è°ƒç”¨ lv_timer_handler() å‡½æ•°;

ä¸ºäº†ä¿è¯ä»»åŠ¡æŒ‰ç…§é¡ºåºæ‰§è¡Œ, å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ¤– STM32F4å’ŒHALåº“/åŸºæœ¬å¤–è®¾éƒ¨åˆ†/5. STM32F4 çš„ FREERTOS æ“ä½œç³»ç»Ÿç§»æ¤|FREERTOS æ“ä½œç³»ç»Ÿç§»æ¤]], å¯ä»¥<mark style="background: transparent; color: red">ä½¿ç”¨é˜Ÿåˆ—é›†(å…ˆè¿›å…ˆå‡º)</mark>æˆ–è€…ä½¿ç”¨è¿›å…¥ CRITICAL åŒºåŸŸæŒ‰ä»»åŠ¡åºåˆ—åˆ›å»ºä»»åŠ¡å¹¶æ‰§è¡Œçš„åŠæ³•ã€‚

å¦å¤–, lvgl ä¹Ÿå•ç‹¬æä¾›äº†çº¿ç¨‹çš„åˆ›å»ºå‡½æ•°: lv_thread_init å¯ä»¥åˆ›å»ºè¾ƒä¸ºå®‰å…¨çš„çº¿ç¨‹è¿è¡Œã€‚å¢åŠ åˆ†é…ç»™ä¸¤ä¸ªä»»åŠ¡çš„å †æ ˆå¤§å°ä¸º 1024 å­—èŠ‚, åˆ™åé¢ä¸¤ä¸ªçº¿ç¨‹æ­£å¸¸è¿è¡Œã€‚<mark style="background: transparent; color: red">ä½†æ˜¯, åœ¨å«æœ‰lv_timer_handler()çš„å‡½æ•°éƒ¨åˆ†, ç”±äºé‡‡ç”¨çš„ RAM æ¯”è¾ƒå¤§, å…¶æ‰€åœ¨çº¿ç¨‹ä»ç„¶ä¸èƒ½æ­£å¸¸å·¥ä½œ, å¦‚æœå»æ‰è¯¥å¥, åˆ™çº¿ç¨‹èƒ½å¤Ÿå·¥ä½œ</mark>ã€‚

å› æ­¤è€ƒè™‘ä½¿ç”¨è½¯ä»¶ä¸­æ–­åˆ·æ–°å±å¹•, STM32F4 çš„ 16 ä¸ª EXTI ä¸­æ–­å‡å¯ä»¥é€šè¿‡è½¯ä»¶è¿›è¡Œè§¦å‘, å…·ä½“å‚è€ƒ NVIC éƒ¨åˆ†ã€‚å¯ä»¥äº§ç”Ÿå¤šè¾¾ 23  ä¸ª software event/interrupt requests.

éœ€è¦è¯´æ˜çš„æ˜¯, ä¸æ˜¯æ‰€æœ‰çš„ä¸­æ–­çº¿éƒ½å¯¹å…¶ä»–ä¸­æ–­æ²¡æœ‰å¹²æ‰°(å‚è€ƒp383):
![[attachments/Pasted image 20240819093137.png]]

æ ¹æ®å®˜æ–¹æ–‡æ¡£, lv_timer_handler å¯ä»¥åœ¨ä¸‹é¢çš„ä»»ä¸€è¿›è¡Œè°ƒç”¨: 
To handle the tasks of LVGL you need to call lv_timer_handler() periodically in one of the following:

while(1) of main() function  
timer interrupt periodically (lower priority than lv_tick_inc())  
an OS task periodically

ç”±äºæˆ‘ä»¬é‡‡ç”¨ Systick è¿›è¡Œè®¡æ•°å’Œæ—¶é—´å¤„ç†, æœ¬èº«å°±æ˜¯æœ€ä½ä¼˜å…ˆçº§çš„, å› æ­¤éœ€è¦é‡‡ç”¨ç›¸åŒä¼˜å…ˆçº§çš„å¤–éƒ¨ä¸­æ–­ï¼Œ åœ¨ä¸­æ–­ä¸­è°ƒç”¨ lv_timer_handler(), ç›¸åŒä¼˜å…ˆçº§æƒ…å†µä¸‹, å®é™…ä¸ŠæŠ¢å ä¼˜å…ˆçº§ç›¸åŒ, å³å“åº”é¡ºåºç”±å‘é‡è¡¨å†³å®šã€‚

å› æ­¤<mark style="background: transparent; color: red">è€ƒè™‘ä½¿ç”¨ä¸€ä¸ªå•ç‹¬å®šæ—¶å™¨è®¾ç½® lv_tick_inc å‡½æ•°, å¹¶ä½¿ç”¨è¾ƒä½ä¼˜å…ˆçº§çš„è½¯ä»¶ä¸­æ–­è°ƒç”¨å…¶ä¸­çš„lv_timer_handler()å‡½æ•°</mark>, è¿™æ ·å°±å¯ä»¥ä¿è¯åœ¨åˆ·å±è¿‡ç¨‹ä¸­, ä¸äº§ç”Ÿè¿‡å¤§çš„é¢å¤– RAM æ¶ˆè€—ã€‚

è§¦å‘è½¯ä»¶ä¸­æ–­æ–¹æ³•å¦‚ä¸‹: 
```c
__HAL_GPIO_EXTI_GENERATE_SWIT(GPIO_PIN_1);
```

å…·ä½“æ–¹æ³•æ˜¯:
```c
EXTI->IMR |= EXTI_IMR_IM1; Â // Â Enable the external interrupt
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
HAL_NVIC_SetPriority(EXTI1_IRQn, 15, 0);
HAL_NVIC_EnableIRQ(EXTI1_IRQn);
```

å…¶ä¸­ä¸Šé¢ç¬¬ä¸€å¥ä¹Ÿå¯ä»¥ç”¨è¿™ä¸ªä»£æ›¿, ä½†æ¯”è¾ƒéº»çƒ¦:
```c
EXTI_HandleTypeDef EXTI_Handler;
EXTI_Handler.Line = EXTI_LINE_1;
EXTI_Handler.PendingCallback = NULL;

EXTI_ConfigTypeDef EXTI_Config;
EXTI_Config.Line = EXTI_LINE_1;
EXTI_Config.Mode = EXTI_MODE_INTERRUPT;
EXTI_Config.Trigger = EXTI_TRIGGER_NONE;
EXTI_Config.GPIOSel = EXTI_GPIOA;
HAL_EXTI_SetConfigLine(&EXTI_Handler, &EXTI_Config);
```


ä½†æ˜¯æ”¾åˆ° EXTI1 ä¸­æ²¡æœ‰è§£å†³é—®é¢˜; è™½ç„¶å…è®¸è½¯ä»¶äº§ç”Ÿä¸­æ–­, ä½†è¿˜æ˜¯å¯¼è‡´å‡ºé”™ `Error: .\FreeRTOS\portable\port.c, 441` 

```c
void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
    uxCriticalNesting++;
    
    /* This is not the interrupt safe version of the enter critical function so
     * assert() if it is being called from an interrupt context.  Only API
     * functions that end in "FromISR" can be used in an interrupt.  Only assert if
     * the critical nesting count is 1 to protect against recursive calls if the
     * assert function also uses a critical section. */
    if( uxCriticalNesting == 1)
    {
        configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 ); // 441 
    }
}
```

441 é—®é¢˜çš„è§£å†³å‚è€ƒ https://blog.csdn.net/weixin_38975819/article/details/123633554, è¿™ä¸ªä¸€èˆ¬æ˜¯ç”±äºå…¶ä¸­çš„ä¸­æ–­ä¼˜å…ˆçº§è¶…è¿‡äº†FreeRTOS èƒ½å¤Ÿç®¡ç†çš„æœ€é«˜ä¸­æ–­ä¼˜å…ˆçº§ï¼Œå› æ­¤å®é™…ä¸Šå¯èƒ½æ˜¯ SPI ä¸­æ–­å¼•èµ·çš„ï¼Œ<mark style="background: transparent; color: red">å› æ­¤å»æ˜¾ç¤ºå±çš„ SPI å‡½æ•°ä¸­ä¿®æ”¹è§¦å‘DMA çš„ä¸­æ–­ä¼˜å…ˆçº§</mark>ï¼Œ åŒ…æ‹¬ SPI å’Œ DMA : 

```c
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
HAL_NVIC_SetPriority(ILI9341_LCD_SPI_IRQn, 8, 0);
HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_IRQn);

HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
HAL_NVIC_SetPriority(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn, 9, 0);
HAL_NVIC_EnableIRQ(ILI9341_LCD_SPI_DMA_STREAM_TX_IRQn); /** enable DMA TX part */
```

**åŸå› **ï¼šåœ¨ä¸­æ–­ä¸­è°ƒç”¨äº†ä»»åŠ¡çº§çš„freertoså‡½æ•°ï¼Œåº”è°ƒç”¨ä¸­æ–­çº§ï¼ˆå³ä»¥ISRç»“å°¾çš„ï¼‰

ä½¿ç”¨ç¡¬ä»¶æ–¹æ³•
```c
TIM_HandleTypeDef TIM2_Handler;

/* USE TIMER2 for 5ms interruption */
void TIM2_IRQHandler(void){
    taskENTER_CRITICAL_FROM_ISR();
    HAL_TIM_IRQHandler(&TIM2_Handler);
    // lv_timer_handler();
    taskEXIT_CRITICAL_FROM_ISR(pdPASS);
}
void TIM2_InitFunc(void){
    __HAL_RCC_TIM2_CLK_ENABLE();
    /* USE TIM2 for refresh function */
    TIM2_Handler.Instance = TIM2;    /* 84MHz */
    TIM2_Handler.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
    TIM2_Handler.Init.CounterMode = TIM_COUNTERMODE_UP;
    TIM2_Handler.Init.Period = 500 - 1;        /** 5ms timer */
    TIM2_Handler.Init.Prescaler = 8400 - 1;    
    TIM2_Handler.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    TIM2_Handler.Init.RepetitionCounter = 0;
    HAL_TIM_Base_Init(&TIM2_Handler); 
    HAL_TIM_Base_Start_IT(&TIM2_Handler);  /* Start the TIM2 interrupt */
    
    NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    HAL_NVIC_SetPriority(TIM2_IRQn, 7, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);  /* Enable the TIM2 interrupt */
}
```

å®é™…ä¸Šæ˜¯å¡åœ¨äº† spi çš„å‡½æ•°ä¸­, è€Œä¸æ˜¯å†…å­˜ä¸å¤Ÿçš„é—®é¢˜, å› æ­¤é’ˆå¯¹å¡æ­»çš„éƒ¨åˆ†è¿›è¡Œä¿®æ”¹:
é€æ­¥æŸ¥æ‰¾å¡æ­»ä½ç½®: lv_timer_exec ä¸­çš„ timer-> timer_cb éƒ¨åˆ†; å³åœ¨å›è°ƒéƒ¨åˆ†å¡æ­»ã€‚
```c
printf("begin timer cb\r\n");
if(timer->timer_cb && original_repeat_count != 0) timer->timer_cb(timer);
printf("end timer cb\r\n");
```

è¿™ä¸ªå®é™…ä¸Šä½¿ç”¨çš„æ˜¯é»˜è®¤å›è°ƒå‡½æ•°: lv_timer_handler, å¯ä»¥åœ¨å…¶ä¸­æ‰¾åˆ°å®šä¹‰, 
å¯¼å‘  lv_refr.c ä¸­çš„ `_lv_display_refr_timer` 

æœ€ç»ˆæ‰¾åˆ° lv_refr.c ä¸­çš„ `refr_invalid_areas();` éƒ¨åˆ†, å®é™…ä¸Šæ˜¯å¡æ­»åœ¨è¿™ä¸ªéƒ¨åˆ†çš„;
å®šä½åˆ° 574 è¡Œçš„ `refr_area(&disp_refr->inv_areas[i]);`  

å®šä½åˆ° 744 è¡Œ `draw_buf_flush(disp_refr);` éƒ¨åˆ†, è°ƒç”¨äº† `lv_draw_dispatch_wait_for_request();`, è€Œåœ¨å…¶ä¸­åŒ…å«äº† lv_draw.c ä¸­çš„ `lv_thread_sync_wait(&_draw_info.sync);`, è€Œè¿™ä¸ªå°±æ˜¯ FreeRTOS çš„ä¿¡å·é‡ç­‰å¾…æ“ä½œã€‚å®é™…ä¸Šä¹Ÿæ˜¯å¡æ­»åœ¨è¿™ä¸ªé‡Œé¢çš„ã€‚

æˆ‘ä»¬åœ¨ lv_thread_sync_wait ä¸­åŠ å…¥å¦‚ä¸‹ä»£ç è¿›è¡Œæµ‹è¯•:
```c
printf("waiting sync thread\r\n");
ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
printf("sync thread notified\r\n");
```

æ˜¾ç„¶æ˜¯ç”±äºä¿¡å·é‡æ²¡æœ‰æˆåŠŸè·å–åˆ°è€Œé€ æˆçš„ã€‚

æˆ‘ä»¬å‚è€ƒ `lvgl-master\env_support\rt-thread` ä¸­çš„ port.c è¿›è¡Œç§»æ¤:
ä¿®æ”¹ç¨‹åºç»“æ„é‡æ–°åˆ›å»ºä»»åŠ¡, <mark style="background: transparent; color: red">å¹¶å°†åˆå§‹åŒ–å‡½æ•°å’Œ while å¾ªç¯æ•´ä¸ªæ”¾åœ¨ä¸€èµ·ä½œä¸ºä¸€ä¸ªçº¿ç¨‹æ•´ä½“æ‰§è¡Œ</mark>, åˆ™è§£å†³äº†ä¸èƒ½æˆåŠŸè·å–ä¿¡å·é‡çš„é—®é¢˜;

ä½†æ˜¯æ˜¾ç¤ºä»ç„¶æ˜¯å¼‚å¸¸çš„, å‘ç°åœ¨ waiting for flushing ä¸­é‡æ–°å¡æ­»; å…·ä½“åœ¨ lv_refr.c çš„ `while(disp->flushing) {};` éƒ¨åˆ†; ç”±äºæ²¡æœ‰ä¸­æ–­å°†æ˜¾ç¤ºéƒ¨åˆ†æ‰“æ–­(lv_display_flush_ready(lcd_disp);å³è®¾ç½®flushing=0çš„), æ‰€ä»¥æ²¡æœ‰è¿›è¡Œã€‚

å®é™…ä¸Šé€šè¿‡æ·»åŠ ä¼ è¾“å¯çŸ¥, ç¨‹åºå·²ç»è°ƒç”¨äº† color transfer å‡½æ•°, ä½†æ˜¯æ²¡æœ‰ç­‰åˆ°å›è°ƒå‡½æ•°ã€‚
å³æ²¡æœ‰è°ƒç”¨ lcd_color_transfer_ready_cb å›è°ƒå‡½æ•°;

å¦‚æœè®¾ç½®ä¸º: 
```c
HAL_SPI_Transmit(&lcd_spi_handler, (uint8_t*)param, param_size, ILI9341_TIMEOUT);
// HAL_SPI_Transmit_DMA(&lcd_spi_handler,(uint8_t*)param, param_size); Â  // due to 8bit is dma align
lcd_color_transfer_ready_cb();
```
åˆ™èƒ½å¤Ÿæ­£å¸¸å·¥ä½œ, æ¢ç”¨ `HAL_SPI_Transmit_IT`, æ‰€è·å¾—ç»“æœä¹Ÿä¸€åˆ‡å‡æ­£å¸¸ã€‚ä½†æ˜¯å¦‚æœä½¿ç”¨ DMA, åˆ™ä¸­æ–­å‡½æ•°å¾—ä¸åˆ°è§¦å‘, ä»ç„¶å›°åœ¨åŸå…ˆçš„å›è°ƒä½ç½®ç­‰å¾…flush.

è°ƒæ•´ä¸­æ–­ä¼˜å…ˆçº§, å°† DMA çš„ä¸­æ–­ä¼˜å…ˆçº§è®¾ç½®ä¸ºæ¯” SPI æ›´é«˜çš„ä¼˜å…ˆçº§, æ— æµäºäº‹ã€‚
éœ€è¦è¯´æ˜çš„æ˜¯, ä¸è¦æŠŠ printf ä¹‹ç±»åŠ åœ¨ä¼ è¾“ä¸­æ–­å›è°ƒå‡½æ•°é‡Œé¢, å¦åˆ™ä¼šå¯¼è‡´æ— æ³•ä¼ è¾“ã€‚
ç›®å‰ï¼Œä»…ä»¥ Transmit_IT ä¸ºä¼ è¾“å‡½æ•°å®ç°ç§»æ¤, ä¹‹åè¯¦ç»†å­¦ä¹ ä¸­æ–­å†…å®¹ã€‚

## äº”ã€LVGL çš„æ–‡ä»¶ç³»ç»Ÿçš„ç§»æ¤
### (1) å¸¸è§çš„é…ç½®ç¬”è®°
ä¸»é¢˜è¿‡æ¸¡æ—¶é—´:
```c
#define LV_THEME_DEFAULT_TRANSITION_TIME 80
```

å¦‚æœéœ€è¦å¼€è¾Ÿ 48 kb å†…å­˜, å¯ä»¥é‡‡ç”¨ LV_MEM_ADR æŒ‡å®šå¼€è¾Ÿå†…å­˜åœ°å€çš„åç§»ä½ç½®:ä¾‹å¦‚:
```c
#define LV_MEM_ADR 0x20014000
```
è¿™ä¸ªæ˜¯åœ¨ SRAM1 çš„ 80 kb é™„è¿‘å¼€è¾Ÿä¸€ä¸ª 48 kb å¤§å°çš„å†…å­˜;

ä»¥ä¸‹ä¸¤ä¸ªå¯ä»¥é‡å®šä¹‰å†…å­˜åˆ†é…å‡½æ•°:
```c
#undef LV_MEM_POOL_INCLUDE
#undef LV_MEM_POOL_ALLOC
```

å¯¹äºé»˜è®¤çš„æƒ…å†µä¸‹, LVGLæœ‰ä¸€ä¸ªå®å®šä¹‰æ¥é…ç½®åˆ·æ–°é¢‘ç‡çš„å¤§å°ï¼ˆåŒæ—¶é€‚ç”¨äº9.0):
```c
#define LV_DEF_REFR_PERIOD Â 33 Â  Â  Â /*[ms]*/
```
<mark style="background: transparent; color: red">å³é»˜è®¤ä¸º 30 å¸§åˆ·æ–°é€Ÿç‡, ä¸€èˆ¬è®¾ç½®5-30å¯ä»¥ä¿è¯åˆ·æ–°æµç•…</mark>ã€‚

å¯¹äº LVGL8, ä¹Ÿæœ‰å®šä¹‰è¯»å–é€Ÿç‡çš„ LV_INDEV_DEF_READ_PERIOD å‡½æ•°, ä¸€èˆ¬è®¾ç½®ä¸º 5-30 éƒ½å¯ä»¥;
å¯¹äº F429 ç­‰ç­‰å…·æœ‰ DMA2D å¤–è®¾çš„éƒ¨åˆ†, å¯ä»¥å¼€å¯ DMA2D æ¥åŠ é€Ÿæ¸²æŸ“ã€‚å¦å¤– LVGL ä¹Ÿæ”¯æŒå…¶ä»– GPU æ¸²æŸ“çš„éƒ¨åˆ†;
```c
/* Use Arm-2D to accelerate the sw render */
#define LV_USE_DRAW_ARM2D_SYNC Â  Â  Â 0
```
æ­¤å¤–æœ‰é”™è¯¯å’Œæ–­è¨€ç›¸å…³é…ç½®:
```c 
/*Enable asserts if an operation is failed or an invalid data is found.
 *If LV_USE_LOG is enabled an error message will be printed on failure*/
#define LV_USE_ASSERT_NULL          1   /*Check if the parameter is NULL. (Very fast, recommended)*/
#define LV_USE_ASSERT_MALLOC        1   /*Checks is the memory is successfully allocated or no. (Very fast, recommended)*/
#define LV_USE_ASSERT_STYLE         0   /*Check if the styles are properly initialized. (Very fast, recommended)*/
#define LV_USE_ASSERT_MEM_INTEGRITY 0   /*Check the integrity of `lv_mem` after critical operations. (Slow)*/
#define LV_USE_ASSERT_OBJ           0   /*Check the object's type and existence (e.g. not deleted). (Slow)*/

```

å¯¹äºå¸§ç‡æ˜¾ç¤ºçš„é…ç½®, éœ€è¦å¼€å¯ç³»ç»Ÿç›‘è§†å™¨:
```c
#define LV_USE_SYSMON Â  1
```

æ­¤æ—¶, å¯ä»¥é€šè¿‡ä¸‹é¢çš„å®å®šä¹‰æ˜¾ç¤ºå¸§ç‡ä»¥åŠ CPU ä½¿ç”¨æƒ…å†µ:
```txt
/*1: Show CPU usage and FPS count
 * Requires `LV_USE_SYSMON = 1`*/
#define LV_USE_PERF_MONITOR 1
```

å¤§ç«¯åºåˆ—ç³»ç»Ÿä½¿èƒ½: 
```c
#define LV_BIG_ENDIAN_SYSTEM 0
```

lvgl åº“çš„å¸¸è§çš„ç¬¬ä¸‰æ–¹åº“æ¥å£é…ç½®éƒ¨åˆ†: 
```bash
/*====================
 * 3RD PARTS LIBRARIES
 *====================*/

/*File system interfaces for common APIs */

/*API for fopen, fread, etc*/
#define LV_USE_FS_STDIO 0
#if LV_USE_FS_STDIO
    #define LV_FS_STDIO_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_STDIO_PATH ""         /*Set the working directory. File/directory paths will be appended to it.*/
    #define LV_FS_STDIO_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif

/*API for open, read, etc*/
#define LV_USE_FS_POSIX 0
#if LV_USE_FS_POSIX
    #define LV_FS_POSIX_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_POSIX_PATH ""         /*Set the working directory. File/directory paths will be appended to it.*/
    #define LV_FS_POSIX_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif

/*API for CreateFile, ReadFile, etc*/
#define LV_USE_FS_WIN32 0
#if LV_USE_FS_WIN32
    #define LV_FS_WIN32_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_WIN32_PATH ""         /*Set the working directory. File/directory paths will be appended to it.*/
    #define LV_FS_WIN32_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif

/*API for FATFS (needs to be added separately). Uses f_open, f_read, etc*/
#define LV_USE_FS_FATFS 0
#if LV_USE_FS_FATFS
    #define LV_FS_FATFS_LETTER '\0'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
    #define LV_FS_FATFS_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
#endif
```
è¿˜å¯ä»¥é…ç½® PNG, BMP, JPEG, GIF ç­‰ç­‰çš„ç¬¬ä¸‰æ–¹åº“ï¼Œä»¥æ”¯æŒæ›´å¤šæ¥å£

### (2) LVGL çš„æ–‡ä»¶ç³»ç»Ÿç§»æ¤
é¦–å…ˆ, åœ¨ `lvgl\src\libs` ä¸­, æœ‰å¤§é‡å°è£…çš„ç¬¬ä¸‰æ–¹åº“æ–‡ä»¶ã€‚
ä¸»è¦éƒ¨åˆ†åŒ…å«å¦‚ä¸‹çš„æ–‡ä»¶(æ ¸å¿ƒæ˜¯ lv_fs_fatfs.c æ–‡ä»¶):
![[attachments/Pasted image 20240819222518.png]]
å°† LV_USE_FS_FATFS ç½®ä¸€, ä¸»è¦çš„ä¸¤ä¸ªå®šä¹‰æœ‰:
```c
#define LV_FS_FATFS_LETTER '\0' Â  Â  /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
#define LV_FS_FATFS_CACHE_SIZE 2 Â  Â /*>0 to cache this number of bytes in lv_fs_read()
```

ä¸€èˆ¬åœ¨ä»…éœ€è¦æŒ‚è½½ä¸€ä¸ªç›˜ç¬¦çš„æƒ…å†µä¸‹, é‡‡ç”¨ `#define LV_FS_FATFS_LETTER '0'` å³å¯, ä¸€èˆ¬ LV_FS_FATFS_LETTER éƒ¨åˆ†

åœ¨ fs_init ä¸­ä»…éœ€è¦åˆå§‹åŒ–å’ŒæŒ‚è½½å³å¯ã€‚

> [!caution] æ³¨æ„
> ä¸ºäº†èƒ½å¤Ÿæ­£å¸¸æ‰“å¼€æ–‡ä»¶, å®é™…ä¸Š fs_open ç­‰ç­‰ä¸­, path å®é™…ä¸Šä¸æ˜¯å®Œæ•´çš„è·¯å¾„, è€Œæ˜¯å»æ‰ç›˜ç¬¦ä¹‹åçš„ç¼ºæŸè·¯å¾„
> fs_open: /font/SimHei16.bin lv_fs_fatfs.c:129
> å› æ­¤, ä¸ºäº†å®ç°æ­£å¸¸ç§»æ¤, è¿˜éœ€è¦åŠ ä¸Šå¦‚ä¸‹çš„å‡½æ•°:

```c
char* abs_path[MAX_ABSOLUTE_PATH_LENGTH];
memset(abs_path, 0, strlen(abs_path));
if (strlen(path) + 4 > MAX_ABSOLUTE_PATH_LENGTH) return NULL; /* failed to open file */
sprintf(abs_path, "%c:/%s\0", drv->letter, path);
```

ä¸Šé¢éƒ¨åˆ†å·²ç»é›†æˆä¸ºä¸¤å¥:
```c
char* abs_path[MAX_ABSOLUTE_PATH_LENGTH];
if (str_make_abs_dir(drv->letter, path, abs_path)) return NULL;
```

ç›´æ¥æ”¾åˆ°ä¸»å¾ªç¯ä¸­, åˆ™å¯ä»¥è¯»å–binæ–‡ä»¶åŒæ—¶åˆ›å»ºæˆåŠŸ, ä½†æ˜¯, ä»ç„¶ä¼šå æ®å¾ˆå¤§çš„å†…å­˜ç©ºé—´; ä¼šäº§ç”Ÿ hard_fault å¯¼è‡´æ–‡ä»¶æ— æ³•æ­£å¸¸è¯»å–;

ä½†æ˜¯, å°† `#define LV_FONT_SIMSUN_16_CJK Â  Â  Â  Â  Â  Â 1` è®¾ç½®å¥½å, ä¼šæ¶ˆè€— 162kb çš„å­˜å‚¨ç©ºé—´, è€Œä¸”ä¸èƒ½å¾ˆå¥½åœ°å¯¹ä¸­æ–‡è¿›è¡Œæ”¯æŒ, æ–¹æ³•å¦‚ä¸‹:
```c
lv_obj_set_style_text_font(panel1, &lv_font_simsun_16_cjk, LV_PART_MAIN);
```

é¦–å…ˆ, ä¸ºäº†å‡å°å†…å­˜å ç”¨, åº”å½“å°½å¯èƒ½å‡å°‘å†…å­˜ä½¿ç”¨:
```c
#define LV_USE_FONT_COMPRESSED 1
```


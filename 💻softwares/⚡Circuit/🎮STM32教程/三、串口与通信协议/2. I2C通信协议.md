# I2C 通信协议内容
### (1) 优点与应用
参考[[💻softwares/⚡Circuit/💻51单片机教程/4. 定时器, 中断, 串口通信与温度传感器/I2C-E2PROM通信与掉电数据保存|I2C-E2PROM通信与掉电数据保存]], 我们可以使用AT24C02芯片实现I2C掉电数据存储, 也可以与MPU6050陀螺仪加速度传感器进行通信和获取加速度和

I2C是**半双工通信**, 同时可以实现**多机通信**和**应答机制**, 同时是**同步时序**的通信机制。 并支持**一主多从和多主多从模式**。 同时可以进行总线仲裁和时钟同步。 

异步通信缺点是对时间要求严格且对硬件电路依赖严重; 而同步时序对硬件依赖较小。但多一根时钟线。
常用的部分有OLED, MPU6050, AT24C02, DS3231(时钟模块)部分;

基本硬件模型如下: 
![[Excalidraw/I2C-EEPROM实验-原理与简介 2023-12-31 15.06.49|450]]
注意: 为了**避免I2C的电源短路现象**(主从同时输出高低电平); I2C通信 <b><mark style="background: transparent; color: red">要求禁止所有设备输出强上拉的高电平， 同时采用外置上拉电路和开漏输出的电路结构</mark></b>, 即必须使用MODE_AF_OD(开漏输出)模式; 其中SCL和SDA的引脚输入结构如下图所示: 
![[attachments/Pasted image 20240217112321.png|400]]
相比于推挽输出, 开漏输出**去掉了强上拉的开关管**, 输出低电平时, 下管为强下拉; 而**输出高电平时上管断开，引脚浮空**; 
因而可以实现GND不和电源相接触的办法, 同时使用电阻进行弱上拉。

避免了**引脚模式的频繁切换**， 同时兼具输入和输出的功能; 

### (2) 通信时序
具体通信时序参考[[💻softwares/⚡Circuit/💻51单片机教程/4. 定时器, 中断, 串口通信与温度传感器/I2C-E2PROM通信与掉电数据保存#1. 起始信号和终止信号|I2C-E2PROM通信与掉电数据保存]], 
起始和终止信号如下: 
![[attachments/Pasted image 20231231165013.png|500]]
主机只需要在低电平的任意时刻将数据放在SDA上, 然后给一个上升沿即可; 而从机在每个上升沿(高电平过程)读取数据;

除起始，终止信号和应答以外，SCL为高电平期间, SDA不允许数据变化。而**主机每传输完一个字节之后, 从机都会有一个应答响应**, 这个位是在SCL 为高电平期间的SDA上的应答, 如下图 
![[attachments/Pasted image 20231231165459.png|500]]
> [!CAUTION] I2C的位规定办法
> 利用I2C规定, 在I2C数据传输中， 使用高位(MSB)先行的办法。第一位是B7;

而主机读取数据时， 先释放SDA, 然后只需要在SCL稳定为高电平期间进行读取即可。 
同样地， **从机每传输完一个字节数据, 主机会给一个应答**, 主机在应答时, 将SDA下拉一次, 表示应答成功。 

I2C 的从机地址分为7位地址和10位地址; 10位也可以使用7位方法寻址， 而MPU6050的7位地址是 1101 000 (AT24C02为最后三位)
一般相同芯片的地址是相同的， 不同芯片地址不同; 而可以通过==地址后面的可变部分==实现挂载多个相同芯片。
在本芯片中，<mark style="background: transparent; color: red">仅AD0可以操作地址的可变的最后一位</mark>; 如果接入高电平, 则为1101 001, 如果接低电平，则为1101 000 

起始 `->` 从机地址 + 读写位(0写, 1读)

![[attachments/Pasted image 20240217115350.png]]
1. 主机释放 2: 从机拉低 SDA,  此时只需要<mark style="background: transparent; color: red">主机在高电平过程中略加等待后获取SDA状态</mark>, 即可获取到是否有应答响应。 之后在下降沿时, 从机释放SDA线, 主机即可放入数据。

停止条件时, 先拉低SDA, 再释放SCL, 再释放SDA; (即产生SCL高电平期间的SDA上升沿)

在指定地址写时序中， 有寄存器寻址; 

当前地址读时序没有寄存器寻址； 需要按照<b><mark style="background: transparent; color: blue">当前地址指针</mark></b>来读取从机数据(一般初始时指向0地址且**在写入和读出时进行自增**), 

指定地址读时序: 即**写入在寻址寄存器要读寄存器处指定地址写**但不写入, 然后直接发送一个**当前地址读时序**, 即可成为指定地址读时序。 

`指定地址写时序: 写-> 指定地址 -> 数据 -> 数据 -> .... -> 停止` 
`指定地址读时序 写 -> 指定地址->(停止-> 起始) -> 读 -> 接受数据 -> .... -> 非应答` (注意只有非应答之后, 从机才会释放总线)

也可以在指定地址写入多个字节(地址指针自增)和当前地址读出多个字节(仍然自动自增); 
软件通信使用 Out_OD模式

# STM32的I2C通信外设
### (1) I2C 外设简介
STM32F103C8T6<mark style="background: transparent; color: red">提供了I2C1和I2C2共有两个I2C接口收发电路</mark>, 可以利用硬件自动生成时钟和进行起始以及数据收发功能。 可以有效减轻CPU的负担。

•支持多主机模型(固定多主机/可变多主机) 
•支持7位/10位地址模式
•支持不同的通讯速度，<b><mark style="background: transparent; color: blue">标准速度(高达100 kHz)，快速(高达400 kHz)</mark></b>
•支持DMA (对应的引脚为Channel6, Channel 7)
•兼容SMBus协议

串口模拟非常困难, 所以往往串口仅仅使用硬件进行收发实现。而软件模拟I2C通信也是非常常见的。 

硬件模拟I2C的最大特点， 一是执行效率高, 节省软件资源,  二是功能强大， 可以实现完整的多主机通信模型， 时序波形规整和通信速率快等; 

在硬件模拟中， 软件只需要写入控制寄存器CR以及数据寄存器DR, 即可实现对应的协议。而需要说明的是, 为了监控通信的实时状态， 还要读取状态寄存器SR来获取对应状态。 

只要不在一条总线上挂载过多设备， 即可以通过后部分配置实现更多种类的设备挂载, 另外可以通过10位地址模式设置(前2个字节都作为寻址的规定模式, 而16位中<mark style="background: transparent; color: red">剩余的5位作为标志位</mark>, 即11110, 标志该寻址为10位寻址模式, 此时第一个字节剩下的两位和第二个字节8位均作为寻址)。

可以支持高达400kHz快速通信频率， 同时支持DMA辅助转运数据来大大提升效率。 

SM-Bus协议(System Manage Bus) 是系统管理总线, 而SMBus是基于I2C改进而来的, 并且应用于电源管理系统中。


### (2) I2C 外设结构图
通过SDA, SCL进行通信; 而 SMBA 是 SMBus使用的部分; 
![[Excalidraw/2. I2C通信协议 2024-02-17 20.12.51|700]]
提供的引脚为: PB5-PB7, PB10-PB12引脚; 同时I2C1可以重映射到PB8-PB9
我们此处使用PB10-PB11作为SCL和SDA, 
使用硬件进行 I2C 通信时, 发送模式下, 当数据从DR转移到数据移位寄存器中时， <b><mark style="background: transparent; color: blue">会自动置TXE = 1表示发送寄存器为空</mark></b>; 
在接收模式下, 一个字节数据收齐之后会数据整体<mark style="background: transparent; color: red">从移位寄存器转移到数据寄存器</mark>; 此时即可将数据从数据寄存器读出来。数据收发是同一组数据寄存器和移位寄存器。

移位寄存器下方是**比较器和自身地址寄存器以及双地址寄存器**。 另外一个是<mark style="background: transparent; color: red">帧错误校验计算寄存器</mark>(PEC)。 其中<mark style="background: transparent; color: red">比较器和双地址寄存器是从机模式使用的</mark> ， **通过自身地址寄存器,  可以让stm32本身作为从机进行被寻址并判断地址是否被寻找和响应**。 数据校验模块。

而PEC模块可以在发送一个多字节数据时， 硬件可以自动通过CRC算法进行自动计算, 得到一个字节的校验位来附加在数据帧后。 同时，接受到后可以自动执行校验的判定。错误后置错误标志位。 

注意GPIO口都要配置为复用开漏输出模式 AF_OD, 其中, AF_OP模式下, 复用功能输入仍然保持有效。

### (3) 发送和接受过程图
#### 1. 主机发送过程
参考数据手册p760,  主模式下的不同 EV 对应不同寄存器的设置。 
![[attachments/Pasted image 20240217212027.png|1000]]

对于I2C的控制寄存器 I2C_CR1中, 当START位= 1时, 产生起始条件(Repeated Start Generation) 起始条件发出后, 对应的START位自动清零。 而起始条件发送完成之后, SB置一; 

stm32的主从模式设置是在SR2中的MSL标志位进行决定的，当MSL = 1时， 为主模式， 否则为从模式。
当SB = 1时, 变为主模式(即上电默认是从模式， 发送起始标志位完成之后，自动变为主模式)。

SB = 1会在写完DR寄存器然后**再读取SR1之后写入寄存器时**, 自动清除。不需要手动清除。
发送地址时, 直接写入DR中即可。 然后硬件自动接收应答位并判断， 如果有应答， 则ADDR置一; 
然后我们读取SR1(TxE, 发送寄存器空, 之后发送数据), 和SR2寄存器(可以检查主模式), 将自动清除ADDR标志位; 

发送的数据写完寄存器之后, 到达移位寄存器和数据寄存器都空的情况, 此时BTF = 1, 此时直接发送停止标志位(使STOP置1使其当前字节传输)。

在Address转移到 shift register 过程中, TxE自动置1(EV8_1事件), 此时两个寄存器均空 ; 
EV8: 当转运到 shift register 后, TxE 仍然为1, 此时移位寄存器开始发送(EV8)，而数据寄存器空; 此时可以向DR寄存器写数据。 

#### 2. 主机接收流程
除此以外手册中给出了小于2个数据的特殊操作方法。
![[attachments/Pasted image 20240217215107.png|900]]
接收流程图如上: 
起始 > 从机地址 > 读时序 >  应答 > 读时序 > 主机应答 > ... 
需要说明的是, 应答需要我们配置 CR1寄存器的 ACK 位为1， 然后主机会自动在每一位接受完毕之后进行应答。而停止接受时, 需要**提前将ACK置0**,  然后发送STOP请求, 产生终止条件。 

对于10位， 必须发送重复起始条件$S_{r}$ , 

对于硬件, 在从机应答之后, 从机释放SDA和主机再次拉低SDA基本上是同步的。
![[attachments/Pasted image 20240217221207.png]]

# MPU6050寄存器简介
### (1) MPU6050工作原理
PS (Product Specification )为产品说明书
RM(Reigster Mapping )为寄存器映像(相当于寄存器描述)

MPU6050是一个6轴姿态传感器，可以测量芯片自身X、Y、Z轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角，常应用于平衡车、飞行器等需要检测自身姿态的场景

MPU6050可以分别测量XYZ三个轴的加速度和角速度(6轴传感器)。可以通过再集成3个轴磁场传感器和气压传感器(高度)最多10轴传感器。

只有将不同的数据进行融合才能获得精确的稳定的欧拉角，常见的数据融合算法有卡尔曼滤波和互补滤波等等; 
可以通过姿态传感器的解算, 可以获得对应的姿态角, 从而应用于姿态测量的情形。


对于不受重力的芯片, 则多轴的输出都是0; 而运动状态获得的倾角下会受运动加速度的影响(静态稳定， 动态不稳定)。 

而三轴陀螺仪传感器利用内部旋转轴方向不变, 可以<mark style="background: transparent; color: red">测量x,y, z轴的角速度</mark>， 分别表示绕x,y,z轴的**角速度**。 只需要通过积分的方法便可以获取不同轴的角速度。

需要说明，由于噪声作用， 会导致陀螺仪内部的角速度不为0, 可能会**由于积分作用产生角度漂移**，具有动态稳定， 静态不稳定性。 因此可以进行互补滤波，但滤波结果仍然有缺陷(<mark style="background: transparent; color: red">z轴偏航角漂移无法通过加速度计进行纠正</mark> `->` 必须通过9轴磁力计传感器的作用) 
 
而内部电路是通过电子器件(MEMS)获取对应的加速度计和陀螺仪参数的。 

内含有16位的传感器采集模拟信号，可以选择加速度计的满量程范围(加速度从$\pm 2g$到 $\pm 16g$),  而陀螺仪满量程为 $\pm 250 - \pm 2000$量程， 并可以使用数字低通滤波器和时钟源, 配置采样分频。

需要对于7位地址使用16进制进行表示, 一般有2种表示方式 `->` 方法1是转换为16进制,  (0xD0-0xD3)

MPU6050电路如图所示: (最小系统手册中会给出) 
![[Excalidraw/2. I2C通信协议 2024-02-17 15.18.08|900]]
可以看出, SCL和SDA已经接入了上拉电阻; 
而<b><mark style="background: transparent; color: blue">XCL和XDA为主机通信引脚; 可以扩展外接磁力计和气压计</mark></b>， 可以通过主机芯片

MPU6050<mark style="background: transparent; color: red">有DMP单元进行数据融合与姿态解算， 可以配合官方的DMP库进行姿态解算</mark>。   
AD0在电路 中已经弱下拉到低电平，因此也可以通过直接引到VCC方法提供上拉改变地址。 

INT可以进行相应的中断产生。MPU6050不能使用5V供电; 但可以使用左上角的5V稳压电路; 
![[attachments/Pasted image 20240217152445.png|800]]
基本框图p24 (还内置了温度传感器)
首先由于CLK是接地的, 需要事先配置转换频率, 而数据会以相应频率刷新到寄存器； 

另外芯片还给出了自测的硬件电路(先使能自测部分再失能自测求差得到自测响应, 而对应好的范围可以在手册查到); CPOUT是电荷泵(升压电路) (即电容先并后串且循环, 并加入滤波装置，则可以提供更高的电压);  

FIFO: (先入先出)缓存数据流
FYSNC: 帧同步
其中Master I2C Serial Interface 用于和MPU6050扩展设备进行通信(AUX)。 

<b><mark style="background: transparent; color: blue">芯片的I2C的SCL最大达到400kHz(最大参数), </mark></b> MPU6050没有SPI接口 
**内部时钟包括内部晶振和陀螺仪独立时钟**(一般选用内部时钟)

运动检测可以有一个高通滤波器滤除重力作用的加速度。 

### (2) 芯片相关重要寄存器参数
常用的寄存器如下: 
![[attachments/Pasted image 20240217161307.png|900]]
SMPRT_DIV: 采样频率分频器
CONFIG: 配置寄存器 
GYRO_CONFIG: 陀螺仪配置寄存器 
ACCEL_CONFIG: 加速度计配置寄存器

数据寄存器部分: 加速度计XYZ轴, 温传感器, 陀螺仪XYZ轴数据
![[attachments/Pasted image 20240217161451.png|1000]]
电源管理寄存器1,2(FIFO非重点), 器件ID号。
![[attachments/Pasted image 20240217161618.png]]
分频越小, 内部工作频率越快, 其中: 
$$sample \space rate = \frac{Gyroscope \space Output \space rate}{(1 + SMPLRT\_DIV)} $$
其中分子最高为8kHz(不使用低通滤波器(Digital Low Pass Filter(DLPF))), 其配置在Configuration Config寄存器中可以找到; (其中当DLPF_CFG不为0即使用低通滤波, 时钟频率为1kHz)

而陀螺仪的寄存器前三位用于进行自测的使能。FS_SEL选择陀螺仪的范围(量程) 
自测响应范围在电器特征表中， 可以进行检验， 

DHPF配置高通滤波器

59-64为加速度数据, 具体计算方法在

系统时钟来源可以在 PWR_MGMT_1 中进行选择(CLKSEL[0:2]部分), 一般非常建议选择陀螺仪的晶振, 由于其晶振更加精确。
另外通过电源管理寄存器2， 可以分别控制6个轴的待机模式状态, 从而使芯片省电。

ID号设置可以设置高6位, 但是时只读的。
除了107号上电默认为0x40(<b><mark style="background: transparent; color: blue">上电时，默认为睡眠模式</mark></b>), 而117号寄存器默认为0x68;

# I2C 实现与MPU6050的硬件通信编程

基本的步骤包括:
1. 初始化时钟, 包括GPIOB和I2C时钟(挂载在APB1上)
2. 配置GPIO为 AF_OD模式 
3. 使用结构体配置整个 I2C 部分 
4. 使能I2C (I2C_Cmd)

```cpp
void I2C_DeInit(I2C_TypeDef* I2Cx);
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);

void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);

void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState); // 配置ACK位 -> 这个其实在 Init 时就已经配置好, 确定接受一个字节之后是否给应答。
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);  // 发送数据 -> 直接写入 DR寄存器 
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);  // 
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction); // 写输入地址, 同时可以指定读或者写操作 

/*重要函数: 读取某个寄存器数据 -> 当读取某个寄存器时，某些位会自动清除*/
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);

void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);

// 中断函数和状态表示位部分; 
void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
```

说明: Send7bitAddress也可以使用SendData进行发送地址;  

除此之外， 还有I2C的状监控函数, 基本部分如下: 
![[attachments/Pasted image 20240218111549.png|700]]

可以通过`I2C_CheckEvent`来同时确定事件发生的标志位, 如果**反复使用GetFlagStatus进行判断, 则比较麻烦**, 因此提供了以下的**状态监控函数**:  
1. 基本状态判断监控函数: `I2C_CheckEvent();` : 同时判断一个或者多个标志位， 来确定某个Event是否发生。
2.  Advanced state monitoring: 可以返回两个状态寄存器值拼接成一个uint32_t并返回, 其处理可以获取，对应函数为 `I2C_GetLastEvent();`
3. 基于状态标志位的状态监控 `Flag-based state monitoring`: 使用`I2C_GetFlagStatus();`即可, 但是局限性是可能需要判断多次才能判断一个Event位。

```cpp
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG); 
```


I2C外设的初始化函数如下: 
```cpp
void I2C2_Port_Init(){
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, FunctionalState::ENABLE);  // start the I2C2 Clock
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, FunctionalState::ENABLE);
    
    GPIO_InitTypeDef* GPIO_InitStruct = new GPIO_InitTypeDef();
    GPIO_InitStruct->GPIO_Mode = GPIOMode_TypeDef::GPIO_Mode_AF_OD;  // use I2C port settings 
    GPIO_InitStruct->GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
    GPIO_InitStruct->GPIO_Speed = GPIOSpeed_TypeDef::GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, GPIO_InitStruct);

    I2C_InitTypeDef* I2C_InitStruct = new I2C_InitTypeDef();
    I2C_StructInit(I2C_InitStruct);
    I2C_InitStruct->I2C_Ack = I2C_Ack_Enable;
    I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_InitStruct->I2C_ClockSpeed = 100000;  // 100kHz, if use 400000 is 400kHz
    I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2; 
    I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
    I2C_InitStruct->I2C_OwnAddress1 = 0x00;

    I2C_Cmd(I2C2, FunctionalState::ENABLE);
}
```
其中: DutyCycle为设置快速模式下的时钟占空比, (在标准状态下都是1:1), 快速状态下也有16:9和2:1模式;
**快速模式下的占空比**调高是由于上升沿比较缓慢，因此需要给写入时的SDA上升沿多分配资源， 从而获取对应的占空比结果。
![[attachments/Pasted image 20240218120847.png|500]]
例如400kHz状态下, 往往需要更高的占空比(一般可以选择2:1)
![[attachments/Pasted image 20240218121029.png|500]]
而AcknowledgedAddress是配置在从机模式下可以响应多少位的地址。


在读取模式下, 每次读取完毕都要查看Event是否满足要求, 来确定响应是否发生, 我们实际上需要使用第一种
```cpp
@arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
@arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
@arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1
@arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1
@arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
@arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
@arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2
@arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
@arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
@arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3
@arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
@arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
@arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
@arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
@arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     
@arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
@arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
@arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
@arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
@arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
```

注意: 由于I2C串口通信需要加上较多的while循环作为事件等待, 一旦加入过多的while循环, 容易造成整个程序卡死。需要进行超时退出机制;

由于初始时已经进行配置， 发送地址之后， 应答位就不需要进行处理了, 只需要等待对应的事件就可以了。 
而等待完毕EV6事件之后, 会出现EV8_1事件, 而我们并不需要等待8_1事件。 
另外, EV8事件出现非常快, 基本上是不用等的; 而程序中可以例行检查EV8事件。
但是如果是发送最后一个字节需要终止， **则可以等待EV8_2事件**, 这个会在EV8之后发生(BTF=1, TxE = 1即将两级缓存清空);


对于接受数据状态过程中， 当我们<b><mark style="background: transparent; color: blue">要停止接受数据时，必须提前将ACK置零同时设置停止位为1</mark></b>;

必须在数据没有收到时，**提前将ACK置零**(数据收到之前, 应答位已经发送出); 即在EV6事件之后(开始数据接受之前)立刻将ACK置零,  STOP置一; 

```cpp
I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE);   // 在EV6事件之后, 立刻执行, 用于设置
I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
```

# I2C 总线硬件通信的调试注意事项
### (1) 卡在起始条件判断循环中无法跳出
由于在读时序过程中， MPU6050会保持拉低总线，从而导致设备一直卡在开始循环中无法切换到 Master 模式(即Generate )

产生的现象就是示例硬件程序出错且读取数据为固定负值(-11823)。

程序会卡在 GenerateStart 中死循环, 但初始化函数均正确
![[attachments/Pasted image 20240219112207.png]]

此时解决方法必须给整个设备进行重新上电(插拔STLink)(<mark style="background: transparent; color: red">也可以插拔MPU6050芯片</mark>), 然后再次烧录程序进行调试, 否则可能卡在死循环中无法检测到起始条件

这个会在一次错误的执行ReadRegister代码之后产生, 错误的ReadRegister代码如下:
```cpp
// use a vector to storge the data readed from MPU6050
uint8_t MPU6050_ReadRegister(uint8_t addr){
    uint8_t value = 0x00;
    // write register address
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    while(I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT) == ErrorStatus::ERROR);
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Transmitter);
    while(I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ErrorStatus::ERROR);
    I2C_SendData(I2C2, addr);
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ErrorStatus::ERROR);
    
    // regenerate start condition and receive data
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT) == ErrorStatus::ERROR);  // wait for event 5;
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Receiver);
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ErrorStatus::ERROR); // wait for event 6
    // regenerate
    I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE);
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
    // wait for 
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED) == ErrorStatus::ERROR);
    value = I2C_ReceiveData(I2C2);
    // dont't forget reset the acknowledge config bit
    I2C_AcknowledgeConfig(I2C2, FunctionalState::ENABLE);
    return value;
}
```

代码错误的原因是Generate Stop放在了CheckEvent前, 导致提前生成Stop代码, 由于程序调试是步进调试的, 所以STOP会提前发出。

```cpp
	I2C_GenerateSTOP(I2C2, ENABLE);  // 23
	I2C_AcknowledgeConfig(I2C2, ENABLE); // 24
```

### (2) 数据读取错误且不变， 但是读写函数均为正确

需要使用define的方式为寄存器赋对应的值，而不是为了方便在结构体中使用指针表示
```cpp title:错误原因
struct MPU60x0_REGISTER{
        uint8_t SMPLRT_DIV  = 0x19;
        uint8_t CONFIG      = 0x1A;
        uint8_t GYRO_CONFIG = 0x1B; 
        uint8_t ACCEL_CONFIG= 0x1c;
        uint8_t ACCEL_XOUT_H= 0x3B;
        uint8_t ACCEL_XOUT_L= 0x3C;
        uint8_t ACCEL_YOUT_H= 0x3D; 
        uint8_t	ACCEL_YOUT_L= 0x3E;
        uint8_t	ACCEL_ZOUT_H= 0x3F;
        uint8_t	ACCEL_ZOUT_L= 0x40;
        uint8_t	TEMP_OUT_H	= 0x41;
        uint8_t	TEMP_OUT_L	= 0x42;
        uint8_t	GYRO_XOUT_H	= 0x43;
        uint8_t	GYRO_XOUT_L	= 0x44;
        uint8_t	GYRO_YOUT_H	= 0x45;
        uint8_t	GYRO_YOUT_L	= 0x46;
        uint8_t	GYRO_ZOUT_H	= 0x47;
        uint8_t	GYRO_ZOUT_L	= 0x48;
        uint8_t PWR_MGMT_1  = 0x6B;
        uint8_t PWR_MGMT_2  = 0x6C;
        uint8_t WHO_AM_I    = 0x75;
        uint8_t	SlaveAddress= 0xD0;
}*MPU6050_Register;

然后使用如下代码: 

```

其错误原因是在创建指针时并没有创建对象, 即没有使用  new 创建一个新的指针对象， 因而成了迷途指针
```cpp title:在MPU6050_Init中加入这一句
MPU6050_Register = new MPU60x0_REGISTER(); // caution!!! -> initialize the structre object



```

代码总体整理如下:
```cpp title:I2C_func.h
#ifndef I2C_FUNC_H
#define I2C_FUNC_H
#include "stm32f10x.h"

void I2C2_INITFUNCTION(void);
uint8_t I2C2_WaitEvent(uint32_t I2C_EVENT, uint32_t timeout);


#endif // !I2C_FUNC_H

```

```cpp title:I2C_func.C
#include "I2C_func.h"

/// @brief wait for a event occured, 
/// @param I2C_EVENT 
/// @param timeout can be set about to 10000 
/// @return if event occurs, return 0, or timeout return 1;
uint8_t I2C2_WaitEvent(uint32_t I2C_EVENT, const uint32_t timeout)
{
    uint32_t temp = timeout;
	while (I2C_CheckEvent(I2C2, I2C_EVENT) != SUCCESS){
        temp--;
        if (temp <= 0){
            return 1;
        }
    }
    return 0;
}

void I2C2_INITFUNCTION(void){
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, FunctionalState::ENABLE);  // start the I2C2 Clock
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, FunctionalState::ENABLE);

    GPIO_InitTypeDef* GPIO_InitStruct = new GPIO_InitTypeDef();
    GPIO_InitStruct->GPIO_Mode = GPIOMode_TypeDef::GPIO_Mode_AF_OD;  // use I2C port settings 
    GPIO_InitStruct->GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
    GPIO_InitStruct->GPIO_Speed = GPIOSpeed_TypeDef::GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, GPIO_InitStruct);

    I2C_InitTypeDef* I2C_InitStruct = new I2C_InitTypeDef();
    I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
    I2C_InitStruct->I2C_Ack = I2C_Ack_Enable;  // Enable Automatically acknowledge
    I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_InitStruct->I2C_ClockSpeed = 100000;  // 50kHz, if use 400000 is 400kHz
    I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
    I2C_InitStruct->I2C_OwnAddress1 = 0xCF;
    I2C_Init(I2C2, I2C_InitStruct);
    I2C_Cmd(I2C2, FunctionalState::ENABLE);
}

```

```cpp title:main.cpp
#include "stm32f10x.h"
#include "OLED.h"
#include "Delay.h"
#include "I2C_func.h" 
#include <vector>
#define MPU6050_Address 0xD0

uint32_t time_out_set = 10000;

using namespace std;

struct MPU60x0_REGISTER{
    public:
        uint8_t SMPLRT_DIV  = 0x19;
        uint8_t CONFIG      = 0x1A;
        uint8_t GYRO_CONFIG = 0x1B; 
        uint8_t ACCEL_CONFIG= 0x1c;
        uint8_t ACCEL_XOUT_H= 0x3B;
        uint8_t ACCEL_XOUT_L= 0x3C;
        uint8_t ACCEL_YOUT_H= 0x3D; 
        uint8_t	ACCEL_YOUT_L= 0x3E;
        uint8_t	ACCEL_ZOUT_H= 0x3F;
        uint8_t	ACCEL_ZOUT_L= 0x40;
        uint8_t	TEMP_OUT_H	= 0x41;
        uint8_t	TEMP_OUT_L	= 0x42;
        uint8_t	GYRO_XOUT_H	= 0x43;
        uint8_t	GYRO_XOUT_L	= 0x44;
        uint8_t	GYRO_YOUT_H	= 0x45;
        uint8_t	GYRO_YOUT_L	= 0x46;
        uint8_t	GYRO_ZOUT_H	= 0x47;
        uint8_t	GYRO_ZOUT_L	= 0x48;
        uint8_t PWR_MGMT_1  = 0x6B;
        uint8_t PWR_MGMT_2  = 0x6C;
        uint8_t WHO_AM_I    = 0x75;
        uint8_t	SlaveAddress= 0xD0;
}*MPU6050_Register;  // don't forget use new to initialize

// write one byte to specific register
bool MPU6050_ErrorFlag = false;

void MPU6050_WriteRegister(uint8_t addr, uint8_t value){
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);    // Generate Start Signal
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, time_out_set)) MPU6050_ErrorFlag = true; // EV5

    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Transmitter);  // 1001000 + 0(Write Bit)
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,time_out_set)) MPU6050_ErrorFlag = true;  // EV6 
    
    I2C_SendData(I2C2, addr);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING, time_out_set)) MPU6050_ErrorFlag = true; // EV8
    
    I2C_SendData(I2C2, value);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED, time_out_set)) MPU6050_ErrorFlag = true; // EV8_1
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
}

// use a vector to storge the data readed from MPU6050
uint8_t MPU6050_ReadRegister(uint8_t addr){
    uint8_t value = 0x00;
    // write register address
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, time_out_set)) MPU6050_ErrorFlag = 1;
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Transmitter);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED, time_out_set)) MPU6050_ErrorFlag = 1;
    I2C_SendData(I2C2, addr);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED, time_out_set)) MPU6050_ErrorFlag = 1;
    
    // regenerate start condition and receive data 
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, time_out_set)) MPU6050_ErrorFlag = 1;  // wait for event 5; 
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Receiver);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED, time_out_set)) MPU6050_ErrorFlag = 1; // event 8
    
    // disable data transfer
    I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_RECEIVED, time_out_set)) MPU6050_ErrorFlag = 1;
    
    value = I2C_ReceiveData(I2C2);

    // dont't forget reset the acknowledge config bit 
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
    I2C_AcknowledgeConfig(I2C2, FunctionalState::ENABLE);
    return value;
}

void MPU6050_Init(){
    I2C2_INITFUNCTION();  // InitI2C2;
    MPU6050_Register = new MPU60x0_REGISTER();  // ****** importat ******** 

    MPU6050_WriteRegister(MPU6050_Register->PWR_MGMT_1,0x01);    // disble sleep, use X oscialltor clock for improved stability
    MPU6050_WriteRegister(MPU6050_Register->PWR_MGMT_2, 0x00);   // 
    MPU6050_WriteRegister(MPU6050_Register->SMPLRT_DIV, 0x09);   // sample rate is 1kHz==accelerometer out put rate
    MPU6050_WriteRegister(MPU6050_Register->CONFIG, 0x06);       // 8kHz Fs, FSYNC disabled 
    MPU6050_WriteRegister(MPU6050_Register->GYRO_CONFIG, 0x08);  // not use self-test, 500 degree/s range
    MPU6050_WriteRegister(MPU6050_Register->ACCEL_CONFIG, 0x08); // not use self-test, not use HPF
}

uint16_t accx = 0, accy = 0, accz = 0; // 16-bit 
uint16_t omgx = 0, omgy = 0, omgz = 0; 

uint16_t assemble_byte(uint16_t byte_H, uint16_t byte_L){
    return (byte_H<<8) | byte_L;
}

void Refresh_Display(){
    uint8_t byte_H = 0, byte_L = 0;
    byte_H = MPU6050_ReadRegister(MPU6050_Register->ACCEL_XOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->ACCEL_XOUT_L);
    accx = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->ACCEL_YOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->ACCEL_YOUT_L);
    accy = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->ACCEL_ZOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->ACCEL_ZOUT_L);
    accz = assemble_byte(byte_H, byte_L);
    // get omega;
    byte_H = MPU6050_ReadRegister(MPU6050_Register->GYRO_XOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->GYRO_XOUT_L);
    omgx = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->GYRO_YOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->GYRO_YOUT_L);
    omgy = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->GYRO_ZOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->GYRO_ZOUT_L);
    omgz = assemble_byte(byte_H, byte_L);
}

int main(){
    OLED_Init();
    OLED_ShowString(1,1, "Init...");
    
    MPU6050_Init();
    Delay_s(1);
    OLED_ShowString(1,1,"       ");
    while (1){
        Refresh_Display();
        OLED_ShowString(1,1, "Device ID:0x");
        OLED_ShowHexNum(1,13, MPU6050_ReadRegister(MPU6050_Register->WHO_AM_I), 2);
        OLED_ShowHexNum(2,1, accx, 4);
        OLED_ShowHexNum(3,1, accy, 4);
        OLED_ShowHexNum(4,1, accz, 4);
        
        OLED_ShowHexNum(2,6, omgx, 4);
        OLED_ShowHexNum(3,6, omgy, 4);
        OLED_ShowHexNum(4,6, omgz, 4);

        if (MPU6050_ErrorFlag) OLED_ShowString(4,8, "Err!");
    }
}

```

# I2C 通信协议软件编程 

> [!NOTE] 注意 
> 相对于I2C的硬件通信, **软件编程有更好的稳定性**,  同时, 在读取部分数据时,**不会出现硬件的读不出问题**, 另外硬件也不会出现卡死问题

另外注意的是, 外部必须要接上上拉电阻, 

对于I2C的初始化, 以及启动和停止, 只需要使用如下代码: 
```cpp 
#define OLED_W_SCL(x) GPIO_WriteBit(GPIOB, GPIO_Pin_12, (BitAction)(x))
#define OLED_W_SDA(x) GPIO_WriteBit(GPIOB, GPIO_Pin_13, (BitAction)(x))

void OLED_I2C_Init(void)
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;    // 开漏输出模式, 仅用于I2C通信等模式, 仅低电平有驱动
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	// ********  注意不要忘了初始化高电平 ******** 
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}

void OLED_I2C_Start(void){
    OLED_W_SDA(1);
    OLED_W_SCL(1);
    OLED_W_SDA(0);
}

void OLED_I2C_Stop(void)
{
	OLED_W_SDA(0);
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}
```

其中重定义端口除了宏定义之外, 还可以定义函数的方法进行; 同时, 定义函数可以加上对应的延时, 更好地方便了程序的移植.

> [!NOTE] Title
> 在实际应用中, Start需要兼容重复起始条件,  因此需要

睡眠模式时, 写入寄存器是无效的; 



在I2C的总线时序中, 由于是高位先行制, 所以每一次
```cpp
void OLED_I2C_SendByte(uint8_t Byte)
{
	OLED_W_SCL(0);  // 首先在传输数据过程中先要拉低总线 (别忘了这一句)
	uint8_t i;
	for (i = 0; i < 8; i++)
	{
		OLED_W_SDA(Byte & (0x80 >> i));
		OLED_W_SCL(1);
		OLED_W_SCL(0);
	}
	OLED_W_SCL(1);	//额外的一个时钟，不处理应答信号, (也可以使用一个wait Ack代替)
	OLED_W_SCL(0);
}
```

而写指令只需要
```cpp
void OLED_WriteCommand(uint8_t Command)
{
	OLED_I2C_Start();
	OLED_I2C_SendByte(0x78);		//从机地址
	OLED_I2C_SendByte(0x00);		//写命令
	OLED_I2C_SendByte(Command); 
	OLED_I2C_Stop();
}
```

卡死的重要问题解决:
在读取过程中, 往往会出现卡死的问题, 且只有整个上电复位可以解决, 此时查找出死循环在这里发生: 

```cpp 
void I2C2_WaitEvent(unsigned int I2C_EVENT, unsigned int timeout)
{
    uint16_t temp = timeout;
	if (temp == 0) return;
    while (I2C_CheckEvent(I2C2, I2C_EVENT) != SUCCESS){
        temp--;
        if (temp == 0){
            I2C2_ErrorFlag = true;
        }
    }
}
```
注意! 其原因是等待事件出现之后没有return , 导致一直死循环; 解决方法是在设置flag = true之后加上return
```cpp 
void I2C2_WaitEvent(unsigned int I2C_EVENT, unsigned int timeout)
{
    uint16_t temp = timeout;
	if (temp == 0) return;
    while (I2C_CheckEvent(I2C2, I2C_EVENT) != SUCCESS){
        temp--;
        if (temp == 0){
            I2C2_ErrorFlag = true;
            return;
        }
    }
}
```

# MPU6050通过移植DMP实现设备的欧拉角测量
使用DMP可以将原先的数据直接转换为四元数进行输出 ， 从而得到对应的欧拉角

我们在此处不使用地磁传感器和气压高度计, 而实际上可以配合HMC5883地磁传感器和BMP180高度计等等进行欧拉角测量;(也有AK8975系列三轴罗盘等等) 

DMP资料\\Embedded_MotionDriver_5.1\\core\\driver\\eMPL  中找到 inv_mpu.c, inv_mpu.h, dmpmap.h, dmpKey.h等等

DMP 即 Digital Motion Processor, 
首先, 在 MPU6050中, 需要通过对应的输出获取6轴或者9轴的旋转矩阵和四元数(quaternion)的融合演算数据, 注意的是需要DMA支持; 

参考7.9部分, DMP所产生的值是产生在寄存器中的, 可以从DMP寄存器进行获取, 也可以存储在FIFO中进行缓冲
$$a + x i + y j  + z k$$
其中, ijk均为虚数; 而单位向量绕轴(a,b,c)的旋转角度可以表示为:
$$\cos \frac{\theta}{2}  + \sin \frac{\theta}{2} \cdot (ai+ bj + ck)$$

首先找到`c_cpp _Properties.json`文件夹, 并defines中定义MPU6050
![[attachments/Pasted image 20240223113650.png]]

```cpp
"MPU6050",
STM32F10X_MD,
USE_DMP,
MPL_LOG_NDEBUG=1,
EMPL,
MPU6050,
EMPL_TARGET_STM32F1
```

首先我们编写I2C传输和读取多个字节的程序, 用于

> [!caution] 注意
> 对于读取时序, 要求先等到字节到达寄存器事件发生之后, 再读取数据, 和发送数据刚好相反. 

可移植的连续读取的I2C函数如下:
```cpp
/// @brief general I2C write function, use length to sepcify the length of data to write
/// @param slave_address slave device address 
/// @param reg_addr address of register to start to write 
/// @param legnth length of data to write 
/// @param Data   Data Array 
void I2C2_Write(uint8_t slave_address, uint8_t reg_addr, uint8_t length, uint8_t* Data){
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, I2C2_time_out); // EV5
    
    I2C_Send7bitAddress(I2C2, slave_address, I2C_Direction_Transmitter);
    I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED, I2C2_time_out);  // EV6 
    I2C_SendData(I2C2, reg_addr);
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING, I2C2_time_out); // EV8
    for (int i = 0; i< length; i++){
        I2C_SendData(I2C2,  Data[i]);
        I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING, I2C2_time_out); // EV8
    }
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED,I2C2_time_out * 2);  // EV 8_2;
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
}

/// @brief use I2C2 bus to read the data needed to Data Array;
/// @param slave_address slave device address 
/// @param reg_addr register address 
/// @param length length of data, must be >= 1
/// @param Data Data Array @attention you should have a big enough array to storge the data to read 
/// @note  this function would firstly locate the register probe to specified location and then receive data
void I2C2_Read(uint8_t slave_address, uint8_t reg_addr, uint8_t length, uint8_t *Data){
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, I2C2_time_out);              // EV5

    I2C_Send7bitAddress(I2C2, slave_address, I2C_Direction_Transmitter);
    I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED, I2C2_time_out);// EV6

    I2C_SendData(I2C2, reg_addr);
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED, I2C2_time_out);         // EV8_2

    // regenerate start condition
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, I2C2_time_out);              // EV5
    I2C_Send7bitAddress(I2C2, slave_address, I2C_Direction_Receiver);
    I2C2_WaitEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED, I2C2_time_out);   // EV6

    for (int i = 0; i < length -1; i++){
        I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_RECEIVED, I2C2_time_out);        // EV7
        Data[i] = I2C_ReceiveData(I2C2);
    }
    I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE); // disable the acknowedgement
    
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_RECEIVED, I2C2_time_out);            // EV7
    Data[length - 1] = I2C_ReceiveData(I2C2);

    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
    I2C_AcknowledgeConfig(I2C2, FunctionalState::ENABLE); // re-enable the acknowledgement
}

```

此时我们显示陀螺仪数据, 只需几行代码:
```cpp 
I2C2_Read(MPU6050_Address, MPU6050_Register->ACCEL_XOUT_H, 6, Data1);
I2C2_Read(MPU6050_Address, MPU6050_Register->GYRO_XOUT_H, 6, Data2);
for (int i = 0; i < 6; i++){
	OLED_ShowHexNum(1, 1 + 2 * i, Data1[i], 2);
	OLED_ShowHexNum(3, 1 + 2 * i, Data2[i], 2);
}
```

参考战舰STM32开发板库函数部分的代码移植, 首先 :  
对于mget_ms, 实际上是个空函数, 在我们的程序中没有用到; 

```cpp title:inv_mpu.c中get_ms的使用
// 空函数
#define get_ms      mget_ms
void mget_ms(unsigned long *time)
{
}
```

我们可以看到, 在MPU6050的部分, 寄存器已经在 reg 部分给出了全部的定义; 
![[attachments/Pasted image 20240223200632.png]]
将其修改如下: 
![[attachments/Pasted image 20240223212546.png]]

```cpp title:多重ifdef的用法
#if defined EMPL_TARGET_MSP430 || defined MOTION_DRIVER_TARGET_MSP430 || defined MOTION_DRIVER_TARGET_STM32F10X
```

对于reg_int_cb, 直接注释掉即可: 
![[attachments/Pasted image 20240223213645.png]]

另外注意: ==复数浮点转换为整形会出错,因此需要分别按照正负进行转换之后进行显示==
```cpp title:负数转换显示逻辑
if (accx > 0) OLED_ShowChar(2,1,'+'); else {OLED_ShowChar(2,1,'-'); accx = -accx;}
```

如图, dmp获取的代码实际上是在 inv_mpu.c 下的`mpu_dmp_get_data`函数, 如下图所示: 
![[attachments/Pasted image 20240224092810.png|800]]

在程序中, 芯片是以结构体的对象st命名的, 具体如下:
```cpp title:芯片对象st
static struct gyro_state_s st={
  &reg,
  &hw,
  {0},
  &test
};
```


对于MPU6050芯片, 有一个FIFO (先入先出)寄存器,可以用来进行暂存一些数据. 而FIFO寄存器用于管理哪些数据将被放到FIFO中进行寄存; 其中除了加速度和陀螺仪的数据以外, 还可以存储温度传感与其他附加的数据; 
对应的有一个FIFO counter来记录FIFO中的字节数;

对于结构体,  

```cpp title:结构体内容
/* Gyro driver state variables. */
struct gyro_state_s {
    const struct gyro_reg_s *reg;
    const struct hw_s *hw;
    struct chip_cfg_s chip_cfg;
    const struct test_s *test;
}
```

这里使用了C语言中结构体初始化对象, 按照出现的先后顺序进行初始化结构体
```cpp title:这个代码创建了结构体对象,共有三个对象reg,hw,test
// 这个实际上是一个赋值语句, 将
static struct gyro_state_s st={
  &reg,
  &hw,
  {0},
  &test
};
// 这个语句的含义相当于是将reg地址赋给上面定义中的reg, 而chip_cfg赋值为{0}
```
上述的这几个对象实际上是定义在 inv_mpu.c 文件本身中的, 通过放上鼠标可以看到:
![[attachments/Pasted image 20240224102250.png]]
定义部分如下: 
![[attachments/Pasted image 20240224103011.png]]
为了保证从机地址正确, 我们在修改后的代码中可以找到: 
```cpp title:hw的定义
const struct hw_s hw = {
    0x68,	 //addr       -> 实际上是调用I2C传入的从机地址, 0110 1000 
    1024,	 //max_fifo -> 
    118,	     //num_reg
    340,	 //temp_sens
    -521,	 //temp_offset
    256	     //bank_size
#if defined AK89xx_SECONDARY
    ,.compass_fsr    = AK89xx_FSR
#endif
};
```
而我们定义的从机地址位0xD0 `#define MPU6050_Address 0xD0` , 即 1101 0000

另外可以查看到mpu_init的格式是直接传入地址的, 因此我们应当使用0xD0作为对应的地址; 因此需要将hw部分传入的addr参数更改为0xD0
```cpp 
if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
->
I2C2_Write(MPU6050_Address, MPU6050_Register->PWR_MGMT_1, 1, data); // 实际上是类似于这个函数
```



在.h文件中, 我们可以看到其提供的大量函数:
```cpp title:mpu相关函数
/* Set up APIs */
int mpu_init(struct int_param_s *int_param);
int mpu_init_slave(void);
int mpu_set_bypass(unsigned char bypass_on);

/* Configuration APIs */
int mpu_lp_accel_mode(unsigned char rate);
int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
    unsigned char lpa_freq);
int mpu_set_int_level(unsigned char active_low);
int mpu_set_int_latched(unsigned char enable);

int mpu_set_dmp_state(unsigned char enable);
int mpu_get_dmp_state(unsigned char *enabled);

int mpu_get_lpf(unsigned short *lpf);
int mpu_set_lpf(unsigned short lpf);

int mpu_get_gyro_fsr(unsigned short *fsr);
int mpu_set_gyro_fsr(unsigned short fsr);

int mpu_get_accel_fsr(unsigned char *fsr);
int mpu_set_accel_fsr(unsigned char fsr);

int mpu_get_compass_fsr(unsigned short *fsr);

int mpu_get_gyro_sens(float *sens);
int mpu_get_accel_sens(unsigned short *sens);

int mpu_get_sample_rate(unsigned short *rate);
int mpu_set_sample_rate(unsigned short rate);
int mpu_get_compass_sample_rate(unsigned short *rate);
int mpu_set_compass_sample_rate(unsigned short rate);

int mpu_get_fifo_config(unsigned char *sensors);
int mpu_configure_fifo(unsigned char sensors);

int mpu_get_power_state(unsigned char *power_on);
int mpu_set_sensors(unsigned char sensors);

int mpu_set_accel_bias(const long *accel_bias);

/* Data getter/setter APIs */
int mpu_get_gyro_reg(short *data, unsigned long *timestamp);
int mpu_get_accel_reg(short *data, unsigned long *timestamp);
int mpu_get_compass_reg(short *data, unsigned long *timestamp);
int mpu_get_temperature(long *data, unsigned long *timestamp);

int mpu_get_int_status(short *status);
int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
    unsigned char *sensors, unsigned char *more);
int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
    unsigned char *more);
int mpu_reset_fifo(void);

int mpu_write_mem(unsigned short mem_addr, unsigned short length,
    unsigned char *data);
int mpu_read_mem(unsigned short mem_addr, unsigned short length,
    unsigned char *data);
int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
    unsigned short start_addr, unsigned short sample_rate);

int mpu_reg_dump(void);
int mpu_read_reg(unsigned char reg, unsigned char *data);
int mpu_run_self_test(long *gyro, long *accel);
int mpu_register_tap_cb(void (*func)(unsigned char, unsigned char));
```

实际上, 在inv_mpu.c中, 我们需要编写对应的初始化函数, 来保证

```cpp title:正点原子添加的代码部分
// void function 
void mget_ms(unsigned long *time){
}

#define q30  1073741824.0f   // 这个是long转换成float时的余数
static signed char gyro_orientation[9] = { 1, 0, 0, 0, 1, 0,0, 0, 1};  // 陀螺仪方向控制 

u8 run_self_test(void)
{
	int result;
	//char test_packet[4] = {0};
	long gyro[3], accel[3]; 
	result = mpu_run_self_test(gyro, accel);
	if (result == 0x3) 
	{
		/* Test passed. We can trust the gyro data here, so let's push it down to the DMP */
		float sens;
		unsigned short accel_sens;
		mpu_get_gyro_sens(&sens);
		gyro[0] = (long)(gyro[0] * sens);
		gyro[1] = (long)(gyro[1] * sens);
		gyro[2] = (long)(gyro[2] * sens);
		dmp_set_gyro_bias(gyro);
		mpu_get_accel_sens(&accel_sens);
		accel[0] *= accel_sens;
		accel[1] *= accel_sens;
		accel[2] *= accel_sens;
		dmp_set_accel_bias(accel);
		return 0;
	}else return 1;
}

unsigned short inv_orientation_matrix_to_scalar(
    const signed char *mtx)
{
    unsigned short scalar; 
    /*
       XYZ  010_001_000 Identity Matrix
       XZY  001_010_000
       YXZ  010_000_001
       YZX  000_010_001
       ZXY  001_000_010
       ZYX  000_001_010
     */
    scalar = inv_row_2_scale(mtx);
    scalar |= inv_row_2_scale(mtx + 3) << 3;
    scalar |= inv_row_2_scale(mtx + 6) << 6;

    return scalar;
}

unsigned short inv_row_2_scale(const signed char *row)
{
    unsigned short b;

    if (row[0] > 0)
        b = 0;
    else if (row[0] < 0)
        b = 4;
    else if (row[1] > 0)
        b = 1;
    else if (row[1] < 0)
        b = 5;
    else if (row[2] > 0)
        b = 2;
    else if (row[2] < 0)
        b = 6;
    else
        b = 7;      // error
    return b;
}

// mpu6050 dmp init function
u8 mpu_dmp_init(void)
{
	u8 res=0;
	MPU_IIC_Init();
	if(mpu_init()==0)  // init mpu_6050
	{
		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);
		if(res)return 1;
		res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);
		if(res)return 2;
		res=mpu_set_sample_rate(DEFAULT_MPU_HZ);
		if(res)return 3; 
		res=dmp_load_motion_driver_firmware();
		if(res)return 4; 
		res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));
		if(res)return 5; 
		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|
	DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
		    DMP_FEATURE_GYRO_CAL);
		if(res)return 6; 
		res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);	//ÉèÖÃDMPÊä³öËÙÂÊ(×î´ó²»³¬¹ý200Hz)
		if(res)return 7;   
		res=run_self_test();		//×Ô¼ì
		if(res)return 8;    
		res=mpu_set_dmp_state(1);	//Ê¹ÄÜDMP
		if(res)return 9;     
	}else return 10;
	return 0;
}

u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
{
	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
	unsigned long sensor_timestamp;
	short gyro[3], accel[3], sensors;
	unsigned char more;
	long quat[4]; 
	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))return 1;	 
	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
	**/
	/*if (sensors & INV_XYZ_GYRO )
	send_packet(PACKET_TYPE_GYRO, gyro);
	if (sensors & INV_XYZ_ACCEL)
	send_packet(PACKET_TYPE_ACCEL, accel); */
	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
	**/
	if(sensors&INV_WXYZ_QUAT) 
	{
		q0 = quat[0] / q30; 
		q1 = quat[1] / q30;
		q2 = quat[2] / q30;
		q3 = quat[3] / q30;
		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
	}else return 2;
	return 0;
}

```

重启可能是Acknowedge位的问题




修改部分如下: 
![[attachments/Pasted image 20240224193233.png]]

在原先的文件中, `gyro_reg_s` 和 `gyro_reg_s reg` 中的部分并不同, 导致寄存器读取失败; 因此我们需要增加和减少对应的寄存器, 来让最终得到正确的寄存器部分;

源文件中错误的部分如图: 
![[attachments/Pasted image 20240224194427.png|700]]
```cpp title:注释掉的三个部分如下:
struct gyro_reg_s {
    unsigned char who_am_i;
    unsigned char rate_div;
    unsigned char lpf;
    unsigned char prod_id;
    unsigned char user_ctrl;
    unsigned char fifo_en;
    unsigned char gyro_cfg;
    unsigned char accel_cfg;
    // unsigned char accel_cfg2;
    // unsigned char lp_accel_odr;
    unsigned char motion_thr;
    unsigned char motion_dur;
    unsigned char fifo_count_h;
    unsigned char fifo_r_w;
    unsigned char raw_gyro;
    unsigned char raw_accel;
    unsigned char temp;
    unsigned char int_enable;
    unsigned char dmp_int_status;
    unsigned char int_status;
    // unsigned char accel_intel;
    unsigned char pwr_mgmt_1;
    unsigned char pwr_mgmt_2;
    unsigned char int_pin_cfg;
    unsigned char mem_r_w;
    unsigned char accel_offs;
    unsigned char i2c_mst;
    unsigned char bank_sel;
    unsigned char mem_start_addr;
    unsigned char prgm_start_h;
}
```

其余基本全部照搬正点原子的代码, 就可以计算姿态角了; 
其中, 主要不精确的原因主要是 1: 本身的不精确问题 2: 没有加上磁力计, 往往会导致 Yaw 角缓慢漂移从而导致误差 ;


芯片的状态可以通过匿名四轴上位机来进行显示, 首先打开串口和基本收码 ; 
![[attachments/Pasted image 20240224214214.png|600]]


AF1CDD0288286E4DEC663140EEF6000000000000F467104E02890000000

00 88 AF 1C DD 02 88 28 6E 4D F0 A6 E6 2C ED A0 00 00 00 00 00 00 C5 C9 17 53 FD A5 00 00 00 00 6C

88 AF 1C DD 02 88 28 6E 4D F0 B6 E5 94 ED A2 00 00 00 00 00 00 C5 B6 17 45 FD A3 00 00 00 00 C2

打开高级接收即可实现操作飞控; 
需要说明的是, 如果出现程序卡死情况, 是**ULink供电不稳, 使用外加一根USB数据线进行供电即可 ,  接在串口部分.** 

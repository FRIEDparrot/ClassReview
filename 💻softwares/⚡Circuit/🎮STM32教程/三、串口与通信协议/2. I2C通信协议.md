# I2C é€šä¿¡åè®®å†…å®¹
### (1) ä¼˜ç‚¹ä¸åº”ç”¨
å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ’»51å•ç‰‡æœºæ•™ç¨‹/4. å®šæ—¶å™¨, ä¸­æ–­, ä¸²å£é€šä¿¡ä¸æ¸©åº¦ä¼ æ„Ÿå™¨/I2C-E2PROMé€šä¿¡ä¸æ‰ç”µæ•°æ®ä¿å­˜|I2C-E2PROMé€šä¿¡ä¸æ‰ç”µæ•°æ®ä¿å­˜]], æˆ‘ä»¬å¯ä»¥ä½¿ç”¨AT24C02èŠ¯ç‰‡å®ç°I2Cæ‰ç”µæ•°æ®å­˜å‚¨, ä¹Ÿå¯ä»¥ä¸MPU6050é™€èºä»ªåŠ é€Ÿåº¦ä¼ æ„Ÿå™¨è¿›è¡Œé€šä¿¡å’Œè·å–åŠ é€Ÿåº¦å’Œ

I2Cæ˜¯**åŠåŒå·¥é€šä¿¡**, åŒæ—¶å¯ä»¥å®ç°**å¤šæœºé€šä¿¡**å’Œ**åº”ç­”æœºåˆ¶**, åŒæ—¶æ˜¯**åŒæ­¥æ—¶åº**çš„é€šä¿¡æœºåˆ¶ã€‚ å¹¶æ”¯æŒ**ä¸€ä¸»å¤šä»å’Œå¤šä¸»å¤šä»æ¨¡å¼**ã€‚ åŒæ—¶å¯ä»¥è¿›è¡Œæ€»çº¿ä»²è£å’Œæ—¶é’ŸåŒæ­¥ã€‚ 

å¼‚æ­¥é€šä¿¡ç¼ºç‚¹æ˜¯å¯¹æ—¶é—´è¦æ±‚ä¸¥æ ¼ä¸”å¯¹ç¡¬ä»¶ç”µè·¯ä¾èµ–ä¸¥é‡; è€ŒåŒæ­¥æ—¶åºå¯¹ç¡¬ä»¶ä¾èµ–è¾ƒå°ã€‚ä½†å¤šä¸€æ ¹æ—¶é’Ÿçº¿ã€‚
å¸¸ç”¨çš„éƒ¨åˆ†æœ‰OLED, MPU6050, AT24C02, DS3231(æ—¶é’Ÿæ¨¡å—)éƒ¨åˆ†;

åŸºæœ¬ç¡¬ä»¶æ¨¡å‹å¦‚ä¸‹: 
![[Excalidraw/I2C-EEPROMå®éªŒ-åŸç†ä¸ç®€ä»‹ 2023-12-31 15.06.49|450]]
æ³¨æ„: ä¸ºäº†**é¿å…I2Cçš„ç”µæºçŸ­è·¯ç°è±¡**(ä¸»ä»åŒæ—¶è¾“å‡ºé«˜ä½ç”µå¹³); I2Cé€šä¿¡ <b><mark style="background: transparent; color: red">è¦æ±‚ç¦æ­¢æ‰€æœ‰è®¾å¤‡è¾“å‡ºå¼ºä¸Šæ‹‰çš„é«˜ç”µå¹³ï¼Œ åŒæ—¶é‡‡ç”¨å¤–ç½®ä¸Šæ‹‰ç”µè·¯å’Œå¼€æ¼è¾“å‡ºçš„ç”µè·¯ç»“æ„</mark></b>, å³å¿…é¡»ä½¿ç”¨MODE_AF_OD(å¼€æ¼è¾“å‡º)æ¨¡å¼; å…¶ä¸­SCLå’ŒSDAçš„å¼•è„šè¾“å…¥ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤º: 
![[attachments/Pasted image 20240217112321.png|400]]
ç›¸æ¯”äºæ¨æŒ½è¾“å‡º, å¼€æ¼è¾“å‡º**å»æ‰äº†å¼ºä¸Šæ‹‰çš„å¼€å…³ç®¡**, è¾“å‡ºä½ç”µå¹³æ—¶, ä¸‹ç®¡ä¸ºå¼ºä¸‹æ‹‰; è€Œ**è¾“å‡ºé«˜ç”µå¹³æ—¶ä¸Šç®¡æ–­å¼€ï¼Œå¼•è„šæµ®ç©º**; 
å› è€Œå¯ä»¥å®ç°GNDä¸å’Œç”µæºç›¸æ¥è§¦çš„åŠæ³•, åŒæ—¶ä½¿ç”¨ç”µé˜»è¿›è¡Œå¼±ä¸Šæ‹‰ã€‚

é¿å…äº†**å¼•è„šæ¨¡å¼çš„é¢‘ç¹åˆ‡æ¢**ï¼Œ åŒæ—¶å…¼å…·è¾“å…¥å’Œè¾“å‡ºçš„åŠŸèƒ½; 

### (2) é€šä¿¡æ—¶åº
å…·ä½“é€šä¿¡æ—¶åºå‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ’»51å•ç‰‡æœºæ•™ç¨‹/4. å®šæ—¶å™¨, ä¸­æ–­, ä¸²å£é€šä¿¡ä¸æ¸©åº¦ä¼ æ„Ÿå™¨/I2C-E2PROMé€šä¿¡ä¸æ‰ç”µæ•°æ®ä¿å­˜#1. èµ·å§‹ä¿¡å·å’Œç»ˆæ­¢ä¿¡å·|I2C-E2PROMé€šä¿¡ä¸æ‰ç”µæ•°æ®ä¿å­˜]], 
èµ·å§‹å’Œç»ˆæ­¢ä¿¡å·å¦‚ä¸‹: 
![[attachments/Pasted image 20231231165013.png|500]]
ä¸»æœºåªéœ€è¦åœ¨ä½ç”µå¹³çš„ä»»æ„æ—¶åˆ»å°†æ•°æ®æ”¾åœ¨SDAä¸Š, ç„¶åç»™ä¸€ä¸ªä¸Šå‡æ²¿å³å¯; è€Œä»æœºåœ¨æ¯ä¸ªä¸Šå‡æ²¿(é«˜ç”µå¹³è¿‡ç¨‹)è¯»å–æ•°æ®;

é™¤èµ·å§‹ï¼Œç»ˆæ­¢ä¿¡å·å’Œåº”ç­”ä»¥å¤–ï¼ŒSCLä¸ºé«˜ç”µå¹³æœŸé—´, SDAä¸å…è®¸æ•°æ®å˜åŒ–ã€‚è€Œ**ä¸»æœºæ¯ä¼ è¾“å®Œä¸€ä¸ªå­—èŠ‚ä¹‹å, ä»æœºéƒ½ä¼šæœ‰ä¸€ä¸ªåº”ç­”å“åº”**, è¿™ä¸ªä½æ˜¯åœ¨SCL ä¸ºé«˜ç”µå¹³æœŸé—´çš„SDAä¸Šçš„åº”ç­”, å¦‚ä¸‹å›¾ 
![[attachments/Pasted image 20231231165459.png|500]]
> [!CAUTION] I2Cçš„ä½è§„å®šåŠæ³•
> åˆ©ç”¨I2Cè§„å®š, åœ¨I2Cæ•°æ®ä¼ è¾“ä¸­ï¼Œ ä½¿ç”¨é«˜ä½(MSB)å…ˆè¡Œçš„åŠæ³•ã€‚ç¬¬ä¸€ä½æ˜¯B7;

è€Œä¸»æœºè¯»å–æ•°æ®æ—¶ï¼Œ å…ˆé‡Šæ”¾SDA, ç„¶ååªéœ€è¦åœ¨SCLç¨³å®šä¸ºé«˜ç”µå¹³æœŸé—´è¿›è¡Œè¯»å–å³å¯ã€‚ 
åŒæ ·åœ°ï¼Œ **ä»æœºæ¯ä¼ è¾“å®Œä¸€ä¸ªå­—èŠ‚æ•°æ®, ä¸»æœºä¼šç»™ä¸€ä¸ªåº”ç­”**, ä¸»æœºåœ¨åº”ç­”æ—¶, å°†SDAä¸‹æ‹‰ä¸€æ¬¡, è¡¨ç¤ºåº”ç­”æˆåŠŸã€‚ 

I2C çš„ä»æœºåœ°å€åˆ†ä¸º7ä½åœ°å€å’Œ10ä½åœ°å€; 10ä½ä¹Ÿå¯ä»¥ä½¿ç”¨7ä½æ–¹æ³•å¯»å€ï¼Œ è€ŒMPU6050çš„7ä½åœ°å€æ˜¯ 1101 000 (AT24C02ä¸ºæœ€åä¸‰ä½)
ä¸€èˆ¬ç›¸åŒèŠ¯ç‰‡çš„åœ°å€æ˜¯ç›¸åŒçš„ï¼Œ ä¸åŒèŠ¯ç‰‡åœ°å€ä¸åŒ; è€Œå¯ä»¥é€šè¿‡==åœ°å€åé¢çš„å¯å˜éƒ¨åˆ†==å®ç°æŒ‚è½½å¤šä¸ªç›¸åŒèŠ¯ç‰‡ã€‚
åœ¨æœ¬èŠ¯ç‰‡ä¸­ï¼Œ<mark style="background: transparent; color: red">ä»…AD0å¯ä»¥æ“ä½œåœ°å€çš„å¯å˜çš„æœ€åä¸€ä½</mark>; å¦‚æœæ¥å…¥é«˜ç”µå¹³, åˆ™ä¸º1101 001, å¦‚æœæ¥ä½ç”µå¹³ï¼Œåˆ™ä¸º1101 000 

èµ·å§‹ `->` ä»æœºåœ°å€ + è¯»å†™ä½(0å†™, 1è¯»)

![[attachments/Pasted image 20240217115350.png]]
1. ä¸»æœºé‡Šæ”¾ 2: ä»æœºæ‹‰ä½ SDA,  æ­¤æ—¶åªéœ€è¦<mark style="background: transparent; color: red">ä¸»æœºåœ¨é«˜ç”µå¹³è¿‡ç¨‹ä¸­ç•¥åŠ ç­‰å¾…åè·å–SDAçŠ¶æ€</mark>, å³å¯è·å–åˆ°æ˜¯å¦æœ‰åº”ç­”å“åº”ã€‚ ä¹‹ååœ¨ä¸‹é™æ²¿æ—¶, ä»æœºé‡Šæ”¾SDAçº¿, ä¸»æœºå³å¯æ”¾å…¥æ•°æ®ã€‚

åœæ­¢æ¡ä»¶æ—¶, å…ˆæ‹‰ä½SDA, å†é‡Šæ”¾SCL, å†é‡Šæ”¾SDA; (å³äº§ç”ŸSCLé«˜ç”µå¹³æœŸé—´çš„SDAä¸Šå‡æ²¿)

åœ¨æŒ‡å®šåœ°å€å†™æ—¶åºä¸­ï¼Œ æœ‰å¯„å­˜å™¨å¯»å€; 

å½“å‰åœ°å€è¯»æ—¶åºæ²¡æœ‰å¯„å­˜å™¨å¯»å€ï¼› éœ€è¦æŒ‰ç…§<b><mark style="background: transparent; color: blue">å½“å‰åœ°å€æŒ‡é’ˆ</mark></b>æ¥è¯»å–ä»æœºæ•°æ®(ä¸€èˆ¬åˆå§‹æ—¶æŒ‡å‘0åœ°å€ä¸”**åœ¨å†™å…¥å’Œè¯»å‡ºæ—¶è¿›è¡Œè‡ªå¢**), 

æŒ‡å®šåœ°å€è¯»æ—¶åº: å³**å†™å…¥åœ¨å¯»å€å¯„å­˜å™¨è¦è¯»å¯„å­˜å™¨å¤„æŒ‡å®šåœ°å€å†™**ä½†ä¸å†™å…¥, ç„¶åç›´æ¥å‘é€ä¸€ä¸ª**å½“å‰åœ°å€è¯»æ—¶åº**, å³å¯æˆä¸ºæŒ‡å®šåœ°å€è¯»æ—¶åºã€‚ 

`æŒ‡å®šåœ°å€å†™æ—¶åº: å†™-> æŒ‡å®šåœ°å€ -> æ•°æ® -> æ•°æ® -> .... -> åœæ­¢` 
`æŒ‡å®šåœ°å€è¯»æ—¶åº å†™ -> æŒ‡å®šåœ°å€->(åœæ­¢-> èµ·å§‹) -> è¯» -> æ¥å—æ•°æ® -> .... -> éåº”ç­”` (æ³¨æ„åªæœ‰éåº”ç­”ä¹‹å, ä»æœºæ‰ä¼šé‡Šæ”¾æ€»çº¿)

ä¹Ÿå¯ä»¥åœ¨æŒ‡å®šåœ°å€å†™å…¥å¤šä¸ªå­—èŠ‚(åœ°å€æŒ‡é’ˆè‡ªå¢)å’Œå½“å‰åœ°å€è¯»å‡ºå¤šä¸ªå­—èŠ‚(ä»ç„¶è‡ªåŠ¨è‡ªå¢); 
è½¯ä»¶é€šä¿¡ä½¿ç”¨ Out_ODæ¨¡å¼

# STM32çš„I2Cé€šä¿¡å¤–è®¾
### (1) I2C å¤–è®¾ç®€ä»‹
STM32F103C8T6<mark style="background: transparent; color: red">æä¾›äº†I2C1å’ŒI2C2å…±æœ‰ä¸¤ä¸ªI2Cæ¥å£æ”¶å‘ç”µè·¯</mark>, å¯ä»¥åˆ©ç”¨ç¡¬ä»¶è‡ªåŠ¨ç”Ÿæˆæ—¶é’Ÿå’Œè¿›è¡Œèµ·å§‹ä»¥åŠæ•°æ®æ”¶å‘åŠŸèƒ½ã€‚ å¯ä»¥æœ‰æ•ˆå‡è½»CPUçš„è´Ÿæ‹…ã€‚

â€¢æ”¯æŒå¤šä¸»æœºæ¨¡å‹(å›ºå®šå¤šä¸»æœº/å¯å˜å¤šä¸»æœº) 
â€¢æ”¯æŒ7ä½/10ä½åœ°å€æ¨¡å¼
â€¢æ”¯æŒä¸åŒçš„é€šè®¯é€Ÿåº¦ï¼Œ<b><mark style="background: transparent; color: blue">æ ‡å‡†é€Ÿåº¦(é«˜è¾¾100 kHz)ï¼Œå¿«é€Ÿ(é«˜è¾¾400 kHz)</mark></b>
â€¢æ”¯æŒDMA (å¯¹åº”çš„å¼•è„šä¸ºChannel6, Channel 7)
â€¢å…¼å®¹SMBusåè®®

ä¸²å£æ¨¡æ‹Ÿéå¸¸å›°éš¾, æ‰€ä»¥å¾€å¾€ä¸²å£ä»…ä»…ä½¿ç”¨ç¡¬ä»¶è¿›è¡Œæ”¶å‘å®ç°ã€‚è€Œè½¯ä»¶æ¨¡æ‹ŸI2Cé€šä¿¡ä¹Ÿæ˜¯éå¸¸å¸¸è§çš„ã€‚ 

ç¡¬ä»¶æ¨¡æ‹ŸI2Cçš„æœ€å¤§ç‰¹ç‚¹ï¼Œ ä¸€æ˜¯æ‰§è¡Œæ•ˆç‡é«˜, èŠ‚çœè½¯ä»¶èµ„æº,  äºŒæ˜¯åŠŸèƒ½å¼ºå¤§ï¼Œ å¯ä»¥å®ç°å®Œæ•´çš„å¤šä¸»æœºé€šä¿¡æ¨¡å‹ï¼Œ æ—¶åºæ³¢å½¢è§„æ•´å’Œé€šä¿¡é€Ÿç‡å¿«ç­‰; 

åœ¨ç¡¬ä»¶æ¨¡æ‹Ÿä¸­ï¼Œ è½¯ä»¶åªéœ€è¦å†™å…¥æ§åˆ¶å¯„å­˜å™¨CRä»¥åŠæ•°æ®å¯„å­˜å™¨DR, å³å¯å®ç°å¯¹åº”çš„åè®®ã€‚è€Œéœ€è¦è¯´æ˜çš„æ˜¯, ä¸ºäº†ç›‘æ§é€šä¿¡çš„å®æ—¶çŠ¶æ€ï¼Œ è¿˜è¦è¯»å–çŠ¶æ€å¯„å­˜å™¨SRæ¥è·å–å¯¹åº”çŠ¶æ€ã€‚ 

åªè¦ä¸åœ¨ä¸€æ¡æ€»çº¿ä¸ŠæŒ‚è½½è¿‡å¤šè®¾å¤‡ï¼Œ å³å¯ä»¥é€šè¿‡åéƒ¨åˆ†é…ç½®å®ç°æ›´å¤šç§ç±»çš„è®¾å¤‡æŒ‚è½½, å¦å¤–å¯ä»¥é€šè¿‡10ä½åœ°å€æ¨¡å¼è®¾ç½®(å‰2ä¸ªå­—èŠ‚éƒ½ä½œä¸ºå¯»å€çš„è§„å®šæ¨¡å¼, è€Œ16ä½ä¸­<mark style="background: transparent; color: red">å‰©ä½™çš„5ä½ä½œä¸ºæ ‡å¿—ä½</mark>, å³11110, æ ‡å¿—è¯¥å¯»å€ä¸º10ä½å¯»å€æ¨¡å¼, æ­¤æ—¶ç¬¬ä¸€ä¸ªå­—èŠ‚å‰©ä¸‹çš„ä¸¤ä½å’Œç¬¬äºŒä¸ªå­—èŠ‚8ä½å‡ä½œä¸ºå¯»å€)ã€‚

å¯ä»¥æ”¯æŒé«˜è¾¾400kHzå¿«é€Ÿé€šä¿¡é¢‘ç‡ï¼Œ åŒæ—¶æ”¯æŒDMAè¾…åŠ©è½¬è¿æ•°æ®æ¥å¤§å¤§æå‡æ•ˆç‡ã€‚ 

SM-Busåè®®(System Manage Bus) æ˜¯ç³»ç»Ÿç®¡ç†æ€»çº¿, è€ŒSMBusæ˜¯åŸºäºI2Cæ”¹è¿›è€Œæ¥çš„, å¹¶ä¸”åº”ç”¨äºç”µæºç®¡ç†ç³»ç»Ÿä¸­ã€‚


### (2) I2C å¤–è®¾ç»“æ„å›¾
é€šè¿‡SDA, SCLè¿›è¡Œé€šä¿¡; è€Œ SMBA æ˜¯ SMBusä½¿ç”¨çš„éƒ¨åˆ†; 
![[Excalidraw/2. I2Cé€šä¿¡åè®® 2024-02-17 20.12.51|700]]
æä¾›çš„å¼•è„šä¸º: PB5-PB7, PB10-PB12å¼•è„š; åŒæ—¶I2C1å¯ä»¥é‡æ˜ å°„åˆ°PB8-PB9
æˆ‘ä»¬æ­¤å¤„ä½¿ç”¨PB10-PB11ä½œä¸ºSCLå’ŒSDA, 
ä½¿ç”¨ç¡¬ä»¶è¿›è¡Œ I2C é€šä¿¡æ—¶, å‘é€æ¨¡å¼ä¸‹, å½“æ•°æ®ä»DRè½¬ç§»åˆ°æ•°æ®ç§»ä½å¯„å­˜å™¨ä¸­æ—¶ï¼Œ <b><mark style="background: transparent; color: blue">ä¼šè‡ªåŠ¨ç½®TXE = 1è¡¨ç¤ºå‘é€å¯„å­˜å™¨ä¸ºç©º</mark></b>; 
åœ¨æ¥æ”¶æ¨¡å¼ä¸‹, ä¸€ä¸ªå­—èŠ‚æ•°æ®æ”¶é½ä¹‹åä¼šæ•°æ®æ•´ä½“<mark style="background: transparent; color: red">ä»ç§»ä½å¯„å­˜å™¨è½¬ç§»åˆ°æ•°æ®å¯„å­˜å™¨</mark>; æ­¤æ—¶å³å¯å°†æ•°æ®ä»æ•°æ®å¯„å­˜å™¨è¯»å‡ºæ¥ã€‚æ•°æ®æ”¶å‘æ˜¯åŒä¸€ç»„æ•°æ®å¯„å­˜å™¨å’Œç§»ä½å¯„å­˜å™¨ã€‚

ç§»ä½å¯„å­˜å™¨ä¸‹æ–¹æ˜¯**æ¯”è¾ƒå™¨å’Œè‡ªèº«åœ°å€å¯„å­˜å™¨ä»¥åŠåŒåœ°å€å¯„å­˜å™¨**ã€‚ å¦å¤–ä¸€ä¸ªæ˜¯<mark style="background: transparent; color: red">å¸§é”™è¯¯æ ¡éªŒè®¡ç®—å¯„å­˜å™¨</mark>(PEC)ã€‚ å…¶ä¸­<mark style="background: transparent; color: red">æ¯”è¾ƒå™¨å’ŒåŒåœ°å€å¯„å­˜å™¨æ˜¯ä»æœºæ¨¡å¼ä½¿ç”¨çš„</mark> ï¼Œ **é€šè¿‡è‡ªèº«åœ°å€å¯„å­˜å™¨,  å¯ä»¥è®©stm32æœ¬èº«ä½œä¸ºä»æœºè¿›è¡Œè¢«å¯»å€å¹¶åˆ¤æ–­åœ°å€æ˜¯å¦è¢«å¯»æ‰¾å’Œå“åº”**ã€‚ æ•°æ®æ ¡éªŒæ¨¡å—ã€‚

è€ŒPECæ¨¡å—å¯ä»¥åœ¨å‘é€ä¸€ä¸ªå¤šå­—èŠ‚æ•°æ®æ—¶ï¼Œ ç¡¬ä»¶å¯ä»¥è‡ªåŠ¨é€šè¿‡CRCç®—æ³•è¿›è¡Œè‡ªåŠ¨è®¡ç®—, å¾—åˆ°ä¸€ä¸ªå­—èŠ‚çš„æ ¡éªŒä½æ¥é™„åŠ åœ¨æ•°æ®å¸§åã€‚ åŒæ—¶ï¼Œæ¥å—åˆ°åå¯ä»¥è‡ªåŠ¨æ‰§è¡Œæ ¡éªŒçš„åˆ¤å®šã€‚é”™è¯¯åç½®é”™è¯¯æ ‡å¿—ä½ã€‚ 

æ³¨æ„GPIOå£éƒ½è¦é…ç½®ä¸ºå¤ç”¨å¼€æ¼è¾“å‡ºæ¨¡å¼ AF_OD, å…¶ä¸­, AF_OPæ¨¡å¼ä¸‹, å¤ç”¨åŠŸèƒ½è¾“å…¥ä»ç„¶ä¿æŒæœ‰æ•ˆã€‚

### (3) å‘é€å’Œæ¥å—è¿‡ç¨‹å›¾
#### 1. ä¸»æœºå‘é€è¿‡ç¨‹
å‚è€ƒæ•°æ®æ‰‹å†Œp760,  ä¸»æ¨¡å¼ä¸‹çš„ä¸åŒ EV å¯¹åº”ä¸åŒå¯„å­˜å™¨çš„è®¾ç½®ã€‚ 
![[attachments/Pasted image 20240217212027.png|1000]]

å¯¹äºI2Cçš„æ§åˆ¶å¯„å­˜å™¨ I2C_CR1ä¸­, å½“STARTä½= 1æ—¶, äº§ç”Ÿèµ·å§‹æ¡ä»¶(Repeated Start Generation) èµ·å§‹æ¡ä»¶å‘å‡ºå, å¯¹åº”çš„STARTä½è‡ªåŠ¨æ¸…é›¶ã€‚ è€Œèµ·å§‹æ¡ä»¶å‘é€å®Œæˆä¹‹å, SBç½®ä¸€; 

stm32çš„ä¸»ä»æ¨¡å¼è®¾ç½®æ˜¯åœ¨SR2ä¸­çš„MSLæ ‡å¿—ä½è¿›è¡Œå†³å®šçš„ï¼Œå½“MSL = 1æ—¶ï¼Œ ä¸ºä¸»æ¨¡å¼ï¼Œ å¦åˆ™ä¸ºä»æ¨¡å¼ã€‚
å½“SB = 1æ—¶, å˜ä¸ºä¸»æ¨¡å¼(å³ä¸Šç”µé»˜è®¤æ˜¯ä»æ¨¡å¼ï¼Œ å‘é€èµ·å§‹æ ‡å¿—ä½å®Œæˆä¹‹åï¼Œè‡ªåŠ¨å˜ä¸ºä¸»æ¨¡å¼)ã€‚

SB = 1ä¼šåœ¨å†™å®ŒDRå¯„å­˜å™¨ç„¶å**å†è¯»å–SR1ä¹‹åå†™å…¥å¯„å­˜å™¨æ—¶**, è‡ªåŠ¨æ¸…é™¤ã€‚ä¸éœ€è¦æ‰‹åŠ¨æ¸…é™¤ã€‚
å‘é€åœ°å€æ—¶, ç›´æ¥å†™å…¥DRä¸­å³å¯ã€‚ ç„¶åç¡¬ä»¶è‡ªåŠ¨æ¥æ”¶åº”ç­”ä½å¹¶åˆ¤æ–­ï¼Œ å¦‚æœæœ‰åº”ç­”ï¼Œ åˆ™ADDRç½®ä¸€; 
ç„¶åæˆ‘ä»¬è¯»å–SR1(TxE, å‘é€å¯„å­˜å™¨ç©º, ä¹‹åå‘é€æ•°æ®), å’ŒSR2å¯„å­˜å™¨(å¯ä»¥æ£€æŸ¥ä¸»æ¨¡å¼), å°†è‡ªåŠ¨æ¸…é™¤ADDRæ ‡å¿—ä½; 

å‘é€çš„æ•°æ®å†™å®Œå¯„å­˜å™¨ä¹‹å, åˆ°è¾¾ç§»ä½å¯„å­˜å™¨å’Œæ•°æ®å¯„å­˜å™¨éƒ½ç©ºçš„æƒ…å†µ, æ­¤æ—¶BTF = 1, æ­¤æ—¶ç›´æ¥å‘é€åœæ­¢æ ‡å¿—ä½(ä½¿STOPç½®1ä½¿å…¶å½“å‰å­—èŠ‚ä¼ è¾“)ã€‚

åœ¨Addressè½¬ç§»åˆ° shift register è¿‡ç¨‹ä¸­, TxEè‡ªåŠ¨ç½®1(EV8_1äº‹ä»¶), æ­¤æ—¶ä¸¤ä¸ªå¯„å­˜å™¨å‡ç©º ; 
EV8: å½“è½¬è¿åˆ° shift register å, TxE ä»ç„¶ä¸º1, æ­¤æ—¶ç§»ä½å¯„å­˜å™¨å¼€å§‹å‘é€(EV8)ï¼Œè€Œæ•°æ®å¯„å­˜å™¨ç©º; æ­¤æ—¶å¯ä»¥å‘DRå¯„å­˜å™¨å†™æ•°æ®ã€‚ 

#### 2. ä¸»æœºæ¥æ”¶æµç¨‹
é™¤æ­¤ä»¥å¤–æ‰‹å†Œä¸­ç»™å‡ºäº†å°äº2ä¸ªæ•°æ®çš„ç‰¹æ®Šæ“ä½œæ–¹æ³•ã€‚
![[attachments/Pasted image 20240217215107.png|900]]
æ¥æ”¶æµç¨‹å›¾å¦‚ä¸Š: 
èµ·å§‹ > ä»æœºåœ°å€ > è¯»æ—¶åº >  åº”ç­” > è¯»æ—¶åº > ä¸»æœºåº”ç­” > ... 
éœ€è¦è¯´æ˜çš„æ˜¯, åº”ç­”éœ€è¦æˆ‘ä»¬é…ç½® CR1å¯„å­˜å™¨çš„ ACK ä½ä¸º1ï¼Œ ç„¶åä¸»æœºä¼šè‡ªåŠ¨åœ¨æ¯ä¸€ä½æ¥å—å®Œæ¯•ä¹‹åè¿›è¡Œåº”ç­”ã€‚è€Œåœæ­¢æ¥å—æ—¶, éœ€è¦**æå‰å°†ACKç½®0**,  ç„¶åå‘é€STOPè¯·æ±‚, äº§ç”Ÿç»ˆæ­¢æ¡ä»¶ã€‚ 

å¯¹äº10ä½ï¼Œ å¿…é¡»å‘é€é‡å¤èµ·å§‹æ¡ä»¶$S_{r}$ , 

å¯¹äºç¡¬ä»¶, åœ¨ä»æœºåº”ç­”ä¹‹å, ä»æœºé‡Šæ”¾SDAå’Œä¸»æœºå†æ¬¡æ‹‰ä½SDAåŸºæœ¬ä¸Šæ˜¯åŒæ­¥çš„ã€‚
![[attachments/Pasted image 20240217221207.png]]

# MPU6050å¯„å­˜å™¨ç®€ä»‹
### (1) MPU6050å·¥ä½œåŸç†
PS (Product Specification )ä¸ºäº§å“è¯´æ˜ä¹¦
RM(Reigster Mapping )ä¸ºå¯„å­˜å™¨æ˜ åƒ(ç›¸å½“äºå¯„å­˜å™¨æè¿°)

MPU6050æ˜¯ä¸€ä¸ª6è½´å§¿æ€ä¼ æ„Ÿå™¨ï¼Œå¯ä»¥æµ‹é‡èŠ¯ç‰‡è‡ªèº«Xã€Yã€Zè½´çš„åŠ é€Ÿåº¦ã€è§’é€Ÿåº¦å‚æ•°ï¼Œé€šè¿‡æ•°æ®èåˆï¼Œå¯è¿›ä¸€æ­¥å¾—åˆ°å§¿æ€è§’ï¼Œå¸¸åº”ç”¨äºå¹³è¡¡è½¦ã€é£è¡Œå™¨ç­‰éœ€è¦æ£€æµ‹è‡ªèº«å§¿æ€çš„åœºæ™¯

MPU6050å¯ä»¥åˆ†åˆ«æµ‹é‡XYZä¸‰ä¸ªè½´çš„åŠ é€Ÿåº¦å’Œè§’é€Ÿåº¦(6è½´ä¼ æ„Ÿå™¨)ã€‚å¯ä»¥é€šè¿‡å†é›†æˆ3ä¸ªè½´ç£åœºä¼ æ„Ÿå™¨å’Œæ°”å‹ä¼ æ„Ÿå™¨(é«˜åº¦)æœ€å¤š10è½´ä¼ æ„Ÿå™¨ã€‚

åªæœ‰å°†ä¸åŒçš„æ•°æ®è¿›è¡Œèåˆæ‰èƒ½è·å¾—ç²¾ç¡®çš„ç¨³å®šçš„æ¬§æ‹‰è§’ï¼Œå¸¸è§çš„æ•°æ®èåˆç®—æ³•æœ‰å¡å°”æ›¼æ»¤æ³¢å’Œäº’è¡¥æ»¤æ³¢ç­‰ç­‰; 
å¯ä»¥é€šè¿‡å§¿æ€ä¼ æ„Ÿå™¨çš„è§£ç®—, å¯ä»¥è·å¾—å¯¹åº”çš„å§¿æ€è§’, ä»è€Œåº”ç”¨äºå§¿æ€æµ‹é‡çš„æƒ…å½¢ã€‚


å¯¹äºä¸å—é‡åŠ›çš„èŠ¯ç‰‡, åˆ™å¤šè½´çš„è¾“å‡ºéƒ½æ˜¯0; è€Œè¿åŠ¨çŠ¶æ€è·å¾—çš„å€¾è§’ä¸‹ä¼šå—è¿åŠ¨åŠ é€Ÿåº¦çš„å½±å“(é™æ€ç¨³å®šï¼Œ åŠ¨æ€ä¸ç¨³å®š)ã€‚ 

è€Œä¸‰è½´é™€èºä»ªä¼ æ„Ÿå™¨åˆ©ç”¨å†…éƒ¨æ—‹è½¬è½´æ–¹å‘ä¸å˜, å¯ä»¥<mark style="background: transparent; color: red">æµ‹é‡x,y, zè½´çš„è§’é€Ÿåº¦</mark>ï¼Œ åˆ†åˆ«è¡¨ç¤ºç»•x,y,zè½´çš„**è§’é€Ÿåº¦**ã€‚ åªéœ€è¦é€šè¿‡ç§¯åˆ†çš„æ–¹æ³•ä¾¿å¯ä»¥è·å–ä¸åŒè½´çš„è§’é€Ÿåº¦ã€‚

éœ€è¦è¯´æ˜ï¼Œç”±äºå™ªå£°ä½œç”¨ï¼Œ ä¼šå¯¼è‡´é™€èºä»ªå†…éƒ¨çš„è§’é€Ÿåº¦ä¸ä¸º0, å¯èƒ½ä¼š**ç”±äºç§¯åˆ†ä½œç”¨äº§ç”Ÿè§’åº¦æ¼‚ç§»**ï¼Œå…·æœ‰åŠ¨æ€ç¨³å®šï¼Œ é™æ€ä¸ç¨³å®šæ€§ã€‚ å› æ­¤å¯ä»¥è¿›è¡Œäº’è¡¥æ»¤æ³¢ï¼Œä½†æ»¤æ³¢ç»“æœä»ç„¶æœ‰ç¼ºé™·(<mark style="background: transparent; color: red">zè½´åèˆªè§’æ¼‚ç§»æ— æ³•é€šè¿‡åŠ é€Ÿåº¦è®¡è¿›è¡Œçº æ­£</mark> `->` å¿…é¡»é€šè¿‡9è½´ç£åŠ›è®¡ä¼ æ„Ÿå™¨çš„ä½œç”¨) 
 
è€Œå†…éƒ¨ç”µè·¯æ˜¯é€šè¿‡ç”µå­å™¨ä»¶(MEMS)è·å–å¯¹åº”çš„åŠ é€Ÿåº¦è®¡å’Œé™€èºä»ªå‚æ•°çš„ã€‚ 

å†…å«æœ‰16ä½çš„ä¼ æ„Ÿå™¨é‡‡é›†æ¨¡æ‹Ÿä¿¡å·ï¼Œå¯ä»¥é€‰æ‹©åŠ é€Ÿåº¦è®¡çš„æ»¡é‡ç¨‹èŒƒå›´(åŠ é€Ÿåº¦ä»$\pm 2g$åˆ° $\pm 16g$),  è€Œé™€èºä»ªæ»¡é‡ç¨‹ä¸º $\pm 250 - \pm 2000$é‡ç¨‹ï¼Œ å¹¶å¯ä»¥ä½¿ç”¨æ•°å­—ä½é€šæ»¤æ³¢å™¨å’Œæ—¶é’Ÿæº, é…ç½®é‡‡æ ·åˆ†é¢‘ã€‚

éœ€è¦å¯¹äº7ä½åœ°å€ä½¿ç”¨16è¿›åˆ¶è¿›è¡Œè¡¨ç¤º, ä¸€èˆ¬æœ‰2ç§è¡¨ç¤ºæ–¹å¼ `->` æ–¹æ³•1æ˜¯è½¬æ¢ä¸º16è¿›åˆ¶,  (0xD0-0xD3)

MPU6050ç”µè·¯å¦‚å›¾æ‰€ç¤º: (æœ€å°ç³»ç»Ÿæ‰‹å†Œä¸­ä¼šç»™å‡º) 
![[Excalidraw/2. I2Cé€šä¿¡åè®® 2024-02-17 15.18.08|900]]
å¯ä»¥çœ‹å‡º, SCLå’ŒSDAå·²ç»æ¥å…¥äº†ä¸Šæ‹‰ç”µé˜»; 
è€Œ<b><mark style="background: transparent; color: blue">XCLå’ŒXDAä¸ºä¸»æœºé€šä¿¡å¼•è„š; å¯ä»¥æ‰©å±•å¤–æ¥ç£åŠ›è®¡å’Œæ°”å‹è®¡</mark></b>ï¼Œ å¯ä»¥é€šè¿‡ä¸»æœºèŠ¯ç‰‡

MPU6050<mark style="background: transparent; color: red">æœ‰DMPå•å…ƒè¿›è¡Œæ•°æ®èåˆä¸å§¿æ€è§£ç®—ï¼Œ å¯ä»¥é…åˆå®˜æ–¹çš„DMPåº“è¿›è¡Œå§¿æ€è§£ç®—</mark>ã€‚   
AD0åœ¨ç”µè·¯ ä¸­å·²ç»å¼±ä¸‹æ‹‰åˆ°ä½ç”µå¹³ï¼Œå› æ­¤ä¹Ÿå¯ä»¥é€šè¿‡ç›´æ¥å¼•åˆ°VCCæ–¹æ³•æä¾›ä¸Šæ‹‰æ”¹å˜åœ°å€ã€‚ 

INTå¯ä»¥è¿›è¡Œç›¸åº”çš„ä¸­æ–­äº§ç”Ÿã€‚MPU6050ä¸èƒ½ä½¿ç”¨5Vä¾›ç”µ; ä½†å¯ä»¥ä½¿ç”¨å·¦ä¸Šè§’çš„5Vç¨³å‹ç”µè·¯; 
![[attachments/Pasted image 20240217152445.png|800]]
åŸºæœ¬æ¡†å›¾p24 (è¿˜å†…ç½®äº†æ¸©åº¦ä¼ æ„Ÿå™¨)
é¦–å…ˆç”±äºCLKæ˜¯æ¥åœ°çš„, éœ€è¦äº‹å…ˆé…ç½®è½¬æ¢é¢‘ç‡, è€Œæ•°æ®ä¼šä»¥ç›¸åº”é¢‘ç‡åˆ·æ–°åˆ°å¯„å­˜å™¨ï¼› 

å¦å¤–èŠ¯ç‰‡è¿˜ç»™å‡ºäº†è‡ªæµ‹çš„ç¡¬ä»¶ç”µè·¯(å…ˆä½¿èƒ½è‡ªæµ‹éƒ¨åˆ†å†å¤±èƒ½è‡ªæµ‹æ±‚å·®å¾—åˆ°è‡ªæµ‹å“åº”, è€Œå¯¹åº”å¥½çš„èŒƒå›´å¯ä»¥åœ¨æ‰‹å†ŒæŸ¥åˆ°); CPOUTæ˜¯ç”µè·æ³µ(å‡å‹ç”µè·¯) (å³ç”µå®¹å…ˆå¹¶åä¸²ä¸”å¾ªç¯, å¹¶åŠ å…¥æ»¤æ³¢è£…ç½®ï¼Œåˆ™å¯ä»¥æä¾›æ›´é«˜çš„ç”µå‹);  

FIFO: (å…ˆå…¥å…ˆå‡º)ç¼“å­˜æ•°æ®æµ
FYSNC: å¸§åŒæ­¥
å…¶ä¸­Master I2C Serial Interface ç”¨äºå’ŒMPU6050æ‰©å±•è®¾å¤‡è¿›è¡Œé€šä¿¡(AUX)ã€‚ 

<b><mark style="background: transparent; color: blue">èŠ¯ç‰‡çš„I2Cçš„SCLæœ€å¤§è¾¾åˆ°400kHz(æœ€å¤§å‚æ•°), </mark></b> MPU6050æ²¡æœ‰SPIæ¥å£ 
**å†…éƒ¨æ—¶é’ŸåŒ…æ‹¬å†…éƒ¨æ™¶æŒ¯å’Œé™€èºä»ªç‹¬ç«‹æ—¶é’Ÿ**(ä¸€èˆ¬é€‰ç”¨å†…éƒ¨æ—¶é’Ÿ)

è¿åŠ¨æ£€æµ‹å¯ä»¥æœ‰ä¸€ä¸ªé«˜é€šæ»¤æ³¢å™¨æ»¤é™¤é‡åŠ›ä½œç”¨çš„åŠ é€Ÿåº¦ã€‚ 

### (2) èŠ¯ç‰‡ç›¸å…³é‡è¦å¯„å­˜å™¨å‚æ•°
å¸¸ç”¨çš„å¯„å­˜å™¨å¦‚ä¸‹: 
![[attachments/Pasted image 20240217161307.png|900]]
SMPRT_DIV: é‡‡æ ·é¢‘ç‡åˆ†é¢‘å™¨
CONFIG: é…ç½®å¯„å­˜å™¨ 
GYRO_CONFIG: é™€èºä»ªé…ç½®å¯„å­˜å™¨ 
ACCEL_CONFIG: åŠ é€Ÿåº¦è®¡é…ç½®å¯„å­˜å™¨

æ•°æ®å¯„å­˜å™¨éƒ¨åˆ†: åŠ é€Ÿåº¦è®¡XYZè½´, æ¸©ä¼ æ„Ÿå™¨, é™€èºä»ªXYZè½´æ•°æ®
![[attachments/Pasted image 20240217161451.png|1000]]
ç”µæºç®¡ç†å¯„å­˜å™¨1,2(FIFOéé‡ç‚¹), å™¨ä»¶IDå·ã€‚
![[attachments/Pasted image 20240217161618.png]]
åˆ†é¢‘è¶Šå°, å†…éƒ¨å·¥ä½œé¢‘ç‡è¶Šå¿«, å…¶ä¸­: 
$$sample \space rate = \frac{Gyroscope \space Output \space rate}{(1 + SMPLRT\_DIV)} $$
å…¶ä¸­åˆ†å­æœ€é«˜ä¸º8kHz(ä¸ä½¿ç”¨ä½é€šæ»¤æ³¢å™¨(Digital Low Pass Filter(DLPF))), å…¶é…ç½®åœ¨Configuration Configå¯„å­˜å™¨ä¸­å¯ä»¥æ‰¾åˆ°; (å…¶ä¸­å½“DLPF_CFGä¸ä¸º0å³ä½¿ç”¨ä½é€šæ»¤æ³¢, æ—¶é’Ÿé¢‘ç‡ä¸º1kHz)

è€Œé™€èºä»ªçš„å¯„å­˜å™¨å‰ä¸‰ä½ç”¨äºè¿›è¡Œè‡ªæµ‹çš„ä½¿èƒ½ã€‚FS_SELé€‰æ‹©é™€èºä»ªçš„èŒƒå›´(é‡ç¨‹) 
è‡ªæµ‹å“åº”èŒƒå›´åœ¨ç”µå™¨ç‰¹å¾è¡¨ä¸­ï¼Œ å¯ä»¥è¿›è¡Œæ£€éªŒï¼Œ 

DHPFé…ç½®é«˜é€šæ»¤æ³¢å™¨

59-64ä¸ºåŠ é€Ÿåº¦æ•°æ®, å…·ä½“è®¡ç®—æ–¹æ³•åœ¨

ç³»ç»Ÿæ—¶é’Ÿæ¥æºå¯ä»¥åœ¨ PWR_MGMT_1 ä¸­è¿›è¡Œé€‰æ‹©(CLKSEL[0:2]éƒ¨åˆ†), ä¸€èˆ¬éå¸¸å»ºè®®é€‰æ‹©é™€èºä»ªçš„æ™¶æŒ¯, ç”±äºå…¶æ™¶æŒ¯æ›´åŠ ç²¾ç¡®ã€‚
å¦å¤–é€šè¿‡ç”µæºç®¡ç†å¯„å­˜å™¨2ï¼Œ å¯ä»¥åˆ†åˆ«æ§åˆ¶6ä¸ªè½´çš„å¾…æœºæ¨¡å¼çŠ¶æ€, ä»è€Œä½¿èŠ¯ç‰‡çœç”µã€‚

IDå·è®¾ç½®å¯ä»¥è®¾ç½®é«˜6ä½, ä½†æ˜¯æ—¶åªè¯»çš„ã€‚
é™¤äº†107å·ä¸Šç”µé»˜è®¤ä¸º0x40(<b><mark style="background: transparent; color: blue">ä¸Šç”µæ—¶ï¼Œé»˜è®¤ä¸ºç¡çœ æ¨¡å¼</mark></b>), è€Œ117å·å¯„å­˜å™¨é»˜è®¤ä¸º0x68;

# I2C å®ç°ä¸MPU6050çš„ç¡¬ä»¶é€šä¿¡ç¼–ç¨‹

åŸºæœ¬çš„æ­¥éª¤åŒ…æ‹¬:
1. åˆå§‹åŒ–æ—¶é’Ÿ, åŒ…æ‹¬GPIOBå’ŒI2Cæ—¶é’Ÿ(æŒ‚è½½åœ¨APB1ä¸Š)
2. é…ç½®GPIOä¸º AF_ODæ¨¡å¼ 
3. ä½¿ç”¨ç»“æ„ä½“é…ç½®æ•´ä¸ª I2C éƒ¨åˆ† 
4. ä½¿èƒ½I2C (I2C_Cmd)

```cpp
void I2C_DeInit(I2C_TypeDef* I2Cx);
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);

void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);

void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState); // é…ç½®ACKä½ -> è¿™ä¸ªå…¶å®åœ¨ Init æ—¶å°±å·²ç»é…ç½®å¥½, ç¡®å®šæ¥å—ä¸€ä¸ªå­—èŠ‚ä¹‹åæ˜¯å¦ç»™åº”ç­”ã€‚
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);  // å‘é€æ•°æ® -> ç›´æ¥å†™å…¥ DRå¯„å­˜å™¨ 
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);  // 
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction); // å†™è¾“å…¥åœ°å€, åŒæ—¶å¯ä»¥æŒ‡å®šè¯»æˆ–è€…å†™æ“ä½œ 

/*é‡è¦å‡½æ•°: è¯»å–æŸä¸ªå¯„å­˜å™¨æ•°æ® -> å½“è¯»å–æŸä¸ªå¯„å­˜å™¨æ—¶ï¼ŒæŸäº›ä½ä¼šè‡ªåŠ¨æ¸…é™¤*/
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);

void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);

// ä¸­æ–­å‡½æ•°å’ŒçŠ¶æ€è¡¨ç¤ºä½éƒ¨åˆ†; 
void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
```

è¯´æ˜: Send7bitAddressä¹Ÿå¯ä»¥ä½¿ç”¨SendDataè¿›è¡Œå‘é€åœ°å€;  

é™¤æ­¤ä¹‹å¤–ï¼Œ è¿˜æœ‰I2Cçš„çŠ¶ç›‘æ§å‡½æ•°, åŸºæœ¬éƒ¨åˆ†å¦‚ä¸‹: 
![[attachments/Pasted image 20240218111549.png|700]]

å¯ä»¥é€šè¿‡`I2C_CheckEvent`æ¥åŒæ—¶ç¡®å®šäº‹ä»¶å‘ç”Ÿçš„æ ‡å¿—ä½, å¦‚æœ**åå¤ä½¿ç”¨GetFlagStatusè¿›è¡Œåˆ¤æ–­, åˆ™æ¯”è¾ƒéº»çƒ¦**, å› æ­¤æä¾›äº†ä»¥ä¸‹çš„**çŠ¶æ€ç›‘æ§å‡½æ•°**:  
1. åŸºæœ¬çŠ¶æ€åˆ¤æ–­ç›‘æ§å‡½æ•°: `I2C_CheckEvent();` : åŒæ—¶åˆ¤æ–­ä¸€ä¸ªæˆ–è€…å¤šä¸ªæ ‡å¿—ä½ï¼Œ æ¥ç¡®å®šæŸä¸ªEventæ˜¯å¦å‘ç”Ÿã€‚
2.  Advanced state monitoring: å¯ä»¥è¿”å›ä¸¤ä¸ªçŠ¶æ€å¯„å­˜å™¨å€¼æ‹¼æ¥æˆä¸€ä¸ªuint32_tå¹¶è¿”å›, å…¶å¤„ç†å¯ä»¥è·å–ï¼Œå¯¹åº”å‡½æ•°ä¸º `I2C_GetLastEvent();`
3. åŸºäºçŠ¶æ€æ ‡å¿—ä½çš„çŠ¶æ€ç›‘æ§ `Flag-based state monitoring`: ä½¿ç”¨`I2C_GetFlagStatus();`å³å¯, ä½†æ˜¯å±€é™æ€§æ˜¯å¯èƒ½éœ€è¦åˆ¤æ–­å¤šæ¬¡æ‰èƒ½åˆ¤æ–­ä¸€ä¸ªEventä½ã€‚

```cpp
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG); 
```


I2Cå¤–è®¾çš„åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹: 
```cpp
void I2C2_Port_Init(){
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, FunctionalState::ENABLE);  // start the I2C2 Clock
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, FunctionalState::ENABLE);
    
    GPIO_InitTypeDef* GPIO_InitStruct = new GPIO_InitTypeDef();
    GPIO_InitStruct->GPIO_Mode = GPIOMode_TypeDef::GPIO_Mode_AF_OD;  // use I2C port settings 
    GPIO_InitStruct->GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
    GPIO_InitStruct->GPIO_Speed = GPIOSpeed_TypeDef::GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, GPIO_InitStruct);

    I2C_InitTypeDef* I2C_InitStruct = new I2C_InitTypeDef();
    I2C_StructInit(I2C_InitStruct);
    I2C_InitStruct->I2C_Ack = I2C_Ack_Enable;
    I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_InitStruct->I2C_ClockSpeed = 100000;  // 100kHz, if use 400000 is 400kHz
    I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2; 
    I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
    I2C_InitStruct->I2C_OwnAddress1 = 0x00;

    I2C_Cmd(I2C2, FunctionalState::ENABLE);
}
```
å…¶ä¸­: DutyCycleä¸ºè®¾ç½®å¿«é€Ÿæ¨¡å¼ä¸‹çš„æ—¶é’Ÿå ç©ºæ¯”, (åœ¨æ ‡å‡†çŠ¶æ€ä¸‹éƒ½æ˜¯1:1), å¿«é€ŸçŠ¶æ€ä¸‹ä¹Ÿæœ‰16:9å’Œ2:1æ¨¡å¼;
**å¿«é€Ÿæ¨¡å¼ä¸‹çš„å ç©ºæ¯”**è°ƒé«˜æ˜¯ç”±äºä¸Šå‡æ²¿æ¯”è¾ƒç¼“æ…¢ï¼Œå› æ­¤éœ€è¦ç»™å†™å…¥æ—¶çš„SDAä¸Šå‡æ²¿å¤šåˆ†é…èµ„æºï¼Œ ä»è€Œè·å–å¯¹åº”çš„å ç©ºæ¯”ç»“æœã€‚
![[attachments/Pasted image 20240218120847.png|500]]
ä¾‹å¦‚400kHzçŠ¶æ€ä¸‹, å¾€å¾€éœ€è¦æ›´é«˜çš„å ç©ºæ¯”(ä¸€èˆ¬å¯ä»¥é€‰æ‹©2:1)
![[attachments/Pasted image 20240218121029.png|500]]
è€ŒAcknowledgedAddressæ˜¯é…ç½®åœ¨ä»æœºæ¨¡å¼ä¸‹å¯ä»¥å“åº”å¤šå°‘ä½çš„åœ°å€ã€‚


åœ¨è¯»å–æ¨¡å¼ä¸‹, æ¯æ¬¡è¯»å–å®Œæ¯•éƒ½è¦æŸ¥çœ‹Eventæ˜¯å¦æ»¡è¶³è¦æ±‚, æ¥ç¡®å®šå“åº”æ˜¯å¦å‘ç”Ÿ, æˆ‘ä»¬å®é™…ä¸Šéœ€è¦ä½¿ç”¨ç¬¬ä¸€ç§
```cpp
@arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
@arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
@arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1
@arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1
@arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
@arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
@arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2
@arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
@arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
@arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3
@arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
@arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
@arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
@arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
@arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     
@arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
@arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
@arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
@arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
@arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
```

æ³¨æ„: ç”±äºI2Cä¸²å£é€šä¿¡éœ€è¦åŠ ä¸Šè¾ƒå¤šçš„whileå¾ªç¯ä½œä¸ºäº‹ä»¶ç­‰å¾…, ä¸€æ—¦åŠ å…¥è¿‡å¤šçš„whileå¾ªç¯, å®¹æ˜“é€ æˆæ•´ä¸ªç¨‹åºå¡æ­»ã€‚éœ€è¦è¿›è¡Œè¶…æ—¶é€€å‡ºæœºåˆ¶;

ç”±äºåˆå§‹æ—¶å·²ç»è¿›è¡Œé…ç½®ï¼Œ å‘é€åœ°å€ä¹‹åï¼Œ åº”ç­”ä½å°±ä¸éœ€è¦è¿›è¡Œå¤„ç†äº†, åªéœ€è¦ç­‰å¾…å¯¹åº”çš„äº‹ä»¶å°±å¯ä»¥äº†ã€‚ 
è€Œç­‰å¾…å®Œæ¯•EV6äº‹ä»¶ä¹‹å, ä¼šå‡ºç°EV8_1äº‹ä»¶, è€Œæˆ‘ä»¬å¹¶ä¸éœ€è¦ç­‰å¾…8_1äº‹ä»¶ã€‚ 
å¦å¤–, EV8äº‹ä»¶å‡ºç°éå¸¸å¿«, åŸºæœ¬ä¸Šæ˜¯ä¸ç”¨ç­‰çš„; è€Œç¨‹åºä¸­å¯ä»¥ä¾‹è¡Œæ£€æŸ¥EV8äº‹ä»¶ã€‚
ä½†æ˜¯å¦‚æœæ˜¯å‘é€æœ€åä¸€ä¸ªå­—èŠ‚éœ€è¦ç»ˆæ­¢ï¼Œ **åˆ™å¯ä»¥ç­‰å¾…EV8_2äº‹ä»¶**, è¿™ä¸ªä¼šåœ¨EV8ä¹‹åå‘ç”Ÿ(BTF=1, TxE = 1å³å°†ä¸¤çº§ç¼“å­˜æ¸…ç©º);


å¯¹äºæ¥å—æ•°æ®çŠ¶æ€è¿‡ç¨‹ä¸­ï¼Œ å½“æˆ‘ä»¬<b><mark style="background: transparent; color: blue">è¦åœæ­¢æ¥å—æ•°æ®æ—¶ï¼Œå¿…é¡»æå‰å°†ACKç½®é›¶åŒæ—¶è®¾ç½®åœæ­¢ä½ä¸º1</mark></b>;

å¿…é¡»åœ¨æ•°æ®æ²¡æœ‰æ”¶åˆ°æ—¶ï¼Œ**æå‰å°†ACKç½®é›¶**(æ•°æ®æ”¶åˆ°ä¹‹å‰, åº”ç­”ä½å·²ç»å‘é€å‡º); å³åœ¨EV6äº‹ä»¶ä¹‹å(å¼€å§‹æ•°æ®æ¥å—ä¹‹å‰)ç«‹åˆ»å°†ACKç½®é›¶,  STOPç½®ä¸€; 

```cpp
I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE);   // åœ¨EV6äº‹ä»¶ä¹‹å, ç«‹åˆ»æ‰§è¡Œ, ç”¨äºè®¾ç½®
I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
```

# I2C æ€»çº¿ç¡¬ä»¶é€šä¿¡çš„è°ƒè¯•æ³¨æ„äº‹é¡¹
### (1) å¡åœ¨èµ·å§‹æ¡ä»¶åˆ¤æ–­å¾ªç¯ä¸­æ— æ³•è·³å‡º
ç”±äºåœ¨è¯»æ—¶åºè¿‡ç¨‹ä¸­ï¼Œ MPU6050ä¼šä¿æŒæ‹‰ä½æ€»çº¿ï¼Œä»è€Œå¯¼è‡´è®¾å¤‡ä¸€ç›´å¡åœ¨å¼€å§‹å¾ªç¯ä¸­æ— æ³•åˆ‡æ¢åˆ° Master æ¨¡å¼(å³Generate )

äº§ç”Ÿçš„ç°è±¡å°±æ˜¯ç¤ºä¾‹ç¡¬ä»¶ç¨‹åºå‡ºé”™ä¸”è¯»å–æ•°æ®ä¸ºå›ºå®šè´Ÿå€¼(-11823)ã€‚

ç¨‹åºä¼šå¡åœ¨ GenerateStart ä¸­æ­»å¾ªç¯, ä½†åˆå§‹åŒ–å‡½æ•°å‡æ­£ç¡®
![[attachments/Pasted image 20240219112207.png]]

æ­¤æ—¶è§£å†³æ–¹æ³•å¿…é¡»ç»™æ•´ä¸ªè®¾å¤‡è¿›è¡Œé‡æ–°ä¸Šç”µ(æ’æ‹”STLink)(<mark style="background: transparent; color: red">ä¹Ÿå¯ä»¥æ’æ‹”MPU6050èŠ¯ç‰‡</mark>), ç„¶åå†æ¬¡çƒ§å½•ç¨‹åºè¿›è¡Œè°ƒè¯•, å¦åˆ™å¯èƒ½å¡åœ¨æ­»å¾ªç¯ä¸­æ— æ³•æ£€æµ‹åˆ°èµ·å§‹æ¡ä»¶

è¿™ä¸ªä¼šåœ¨ä¸€æ¬¡é”™è¯¯çš„æ‰§è¡ŒReadRegisterä»£ç ä¹‹åäº§ç”Ÿ, é”™è¯¯çš„ReadRegisterä»£ç å¦‚ä¸‹:
```cpp
// use a vector to storge the data readed from MPU6050
uint8_t MPU6050_ReadRegister(uint8_t addr){
    uint8_t value = 0x00;
    // write register address
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    while(I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT) == ErrorStatus::ERROR);
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Transmitter);
    while(I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ErrorStatus::ERROR);
    I2C_SendData(I2C2, addr);
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ErrorStatus::ERROR);
    
    // regenerate start condition and receive data
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT) == ErrorStatus::ERROR);  // wait for event 5;
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Receiver);
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ErrorStatus::ERROR); // wait for event 6
    // regenerate
    I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE);
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
    // wait for 
    while (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED) == ErrorStatus::ERROR);
    value = I2C_ReceiveData(I2C2);
    // dont't forget reset the acknowledge config bit
    I2C_AcknowledgeConfig(I2C2, FunctionalState::ENABLE);
    return value;
}
```

ä»£ç é”™è¯¯çš„åŸå› æ˜¯Generate Stopæ”¾åœ¨äº†CheckEventå‰, å¯¼è‡´æå‰ç”ŸæˆStopä»£ç , ç”±äºç¨‹åºè°ƒè¯•æ˜¯æ­¥è¿›è°ƒè¯•çš„, æ‰€ä»¥STOPä¼šæå‰å‘å‡ºã€‚

```cpp
	I2C_GenerateSTOP(I2C2, ENABLE);  // 23
	I2C_AcknowledgeConfig(I2C2, ENABLE); // 24
```

### (2) æ•°æ®è¯»å–é”™è¯¯ä¸”ä¸å˜ï¼Œ ä½†æ˜¯è¯»å†™å‡½æ•°å‡ä¸ºæ­£ç¡®

éœ€è¦ä½¿ç”¨defineçš„æ–¹å¼ä¸ºå¯„å­˜å™¨èµ‹å¯¹åº”çš„å€¼ï¼Œè€Œä¸æ˜¯ä¸ºäº†æ–¹ä¾¿åœ¨ç»“æ„ä½“ä¸­ä½¿ç”¨æŒ‡é’ˆè¡¨ç¤º
```cpp title:é”™è¯¯åŸå› 
struct MPU60x0_REGISTER{
        uint8_t SMPLRT_DIV  = 0x19;
        uint8_t CONFIG      = 0x1A;
        uint8_t GYRO_CONFIG = 0x1B; 
        uint8_t ACCEL_CONFIG= 0x1c;
        uint8_t ACCEL_XOUT_H= 0x3B;
        uint8_t ACCEL_XOUT_L= 0x3C;
        uint8_t ACCEL_YOUT_H= 0x3D; 
        uint8_t	ACCEL_YOUT_L= 0x3E;
        uint8_t	ACCEL_ZOUT_H= 0x3F;
        uint8_t	ACCEL_ZOUT_L= 0x40;
        uint8_t	TEMP_OUT_H	= 0x41;
        uint8_t	TEMP_OUT_L	= 0x42;
        uint8_t	GYRO_XOUT_H	= 0x43;
        uint8_t	GYRO_XOUT_L	= 0x44;
        uint8_t	GYRO_YOUT_H	= 0x45;
        uint8_t	GYRO_YOUT_L	= 0x46;
        uint8_t	GYRO_ZOUT_H	= 0x47;
        uint8_t	GYRO_ZOUT_L	= 0x48;
        uint8_t PWR_MGMT_1  = 0x6B;
        uint8_t PWR_MGMT_2  = 0x6C;
        uint8_t WHO_AM_I    = 0x75;
        uint8_t	SlaveAddress= 0xD0;
}*MPU6050_Register;

ç„¶åä½¿ç”¨å¦‚ä¸‹ä»£ç : 

```

å…¶é”™è¯¯åŸå› æ˜¯åœ¨åˆ›å»ºæŒ‡é’ˆæ—¶å¹¶æ²¡æœ‰åˆ›å»ºå¯¹è±¡, å³æ²¡æœ‰ä½¿ç”¨  new åˆ›å»ºä¸€ä¸ªæ–°çš„æŒ‡é’ˆå¯¹è±¡ï¼Œ å› è€Œæˆäº†è¿·é€”æŒ‡é’ˆ
```cpp title:åœ¨MPU6050_Initä¸­åŠ å…¥è¿™ä¸€å¥
MPU6050_Register = new MPU60x0_REGISTER(); // caution!!! -> initialize the structre object



```

ä»£ç æ€»ä½“æ•´ç†å¦‚ä¸‹:
```cpp title:I2C_func.h
#ifndef I2C_FUNC_H
#define I2C_FUNC_H
#include "stm32f10x.h"

void I2C2_INITFUNCTION(void);
uint8_t I2C2_WaitEvent(uint32_t I2C_EVENT, uint32_t timeout);


#endif // !I2C_FUNC_H

```

```cpp title:I2C_func.C
#include "I2C_func.h"

/// @brief wait for a event occured, 
/// @param I2C_EVENT 
/// @param timeout can be set about to 10000 
/// @return if event occurs, return 0, or timeout return 1;
uint8_t I2C2_WaitEvent(uint32_t I2C_EVENT, const uint32_t timeout)
{
    uint32_t temp = timeout;
	while (I2C_CheckEvent(I2C2, I2C_EVENT) != SUCCESS){
        temp--;
        if (temp <= 0){
            return 1;
        }
    }
    return 0;
}

void I2C2_INITFUNCTION(void){
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, FunctionalState::ENABLE);  // start the I2C2 Clock
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, FunctionalState::ENABLE);

    GPIO_InitTypeDef* GPIO_InitStruct = new GPIO_InitTypeDef();
    GPIO_InitStruct->GPIO_Mode = GPIOMode_TypeDef::GPIO_Mode_AF_OD;  // use I2C port settings 
    GPIO_InitStruct->GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
    GPIO_InitStruct->GPIO_Speed = GPIOSpeed_TypeDef::GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, GPIO_InitStruct);

    I2C_InitTypeDef* I2C_InitStruct = new I2C_InitTypeDef();
    I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
    I2C_InitStruct->I2C_Ack = I2C_Ack_Enable;  // Enable Automatically acknowledge
    I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_InitStruct->I2C_ClockSpeed = 100000;  // 50kHz, if use 400000 is 400kHz
    I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
    I2C_InitStruct->I2C_OwnAddress1 = 0xCF;
    I2C_Init(I2C2, I2C_InitStruct);
    I2C_Cmd(I2C2, FunctionalState::ENABLE);
}

```

```cpp title:main.cpp
#include "stm32f10x.h"
#include "OLED.h"
#include "Delay.h"
#include "I2C_func.h" 
#include <vector>
#define MPU6050_Address 0xD0

uint32_t time_out_set = 10000;

using namespace std;

struct MPU60x0_REGISTER{
    public:
        uint8_t SMPLRT_DIV  = 0x19;
        uint8_t CONFIG      = 0x1A;
        uint8_t GYRO_CONFIG = 0x1B; 
        uint8_t ACCEL_CONFIG= 0x1c;
        uint8_t ACCEL_XOUT_H= 0x3B;
        uint8_t ACCEL_XOUT_L= 0x3C;
        uint8_t ACCEL_YOUT_H= 0x3D; 
        uint8_t	ACCEL_YOUT_L= 0x3E;
        uint8_t	ACCEL_ZOUT_H= 0x3F;
        uint8_t	ACCEL_ZOUT_L= 0x40;
        uint8_t	TEMP_OUT_H	= 0x41;
        uint8_t	TEMP_OUT_L	= 0x42;
        uint8_t	GYRO_XOUT_H	= 0x43;
        uint8_t	GYRO_XOUT_L	= 0x44;
        uint8_t	GYRO_YOUT_H	= 0x45;
        uint8_t	GYRO_YOUT_L	= 0x46;
        uint8_t	GYRO_ZOUT_H	= 0x47;
        uint8_t	GYRO_ZOUT_L	= 0x48;
        uint8_t PWR_MGMT_1  = 0x6B;
        uint8_t PWR_MGMT_2  = 0x6C;
        uint8_t WHO_AM_I    = 0x75;
        uint8_t	SlaveAddress= 0xD0;
}*MPU6050_Register;  // don't forget use new to initialize

// write one byte to specific register
bool MPU6050_ErrorFlag = false;

void MPU6050_WriteRegister(uint8_t addr, uint8_t value){
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);    // Generate Start Signal
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, time_out_set)) MPU6050_ErrorFlag = true; // EV5

    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Transmitter);  // 1001000 + 0(Write Bit)
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,time_out_set)) MPU6050_ErrorFlag = true;  // EV6 
    
    I2C_SendData(I2C2, addr);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING, time_out_set)) MPU6050_ErrorFlag = true; // EV8
    
    I2C_SendData(I2C2, value);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED, time_out_set)) MPU6050_ErrorFlag = true; // EV8_1
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
}

// use a vector to storge the data readed from MPU6050
uint8_t MPU6050_ReadRegister(uint8_t addr){
    uint8_t value = 0x00;
    // write register address
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, time_out_set)) MPU6050_ErrorFlag = 1;
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Transmitter);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED, time_out_set)) MPU6050_ErrorFlag = 1;
    I2C_SendData(I2C2, addr);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED, time_out_set)) MPU6050_ErrorFlag = 1;
    
    // regenerate start condition and receive data 
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, time_out_set)) MPU6050_ErrorFlag = 1;  // wait for event 5; 
    I2C_Send7bitAddress(I2C2, MPU6050_Address, I2C_Direction_Receiver);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED, time_out_set)) MPU6050_ErrorFlag = 1; // event 8
    
    // disable data transfer
    I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE);
    if (I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_RECEIVED, time_out_set)) MPU6050_ErrorFlag = 1;
    
    value = I2C_ReceiveData(I2C2);

    // dont't forget reset the acknowledge config bit 
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
    I2C_AcknowledgeConfig(I2C2, FunctionalState::ENABLE);
    return value;
}

void MPU6050_Init(){
    I2C2_INITFUNCTION();  // InitI2C2;
    MPU6050_Register = new MPU60x0_REGISTER();  // ****** importat ******** 

    MPU6050_WriteRegister(MPU6050_Register->PWR_MGMT_1,0x01);    // disble sleep, use X oscialltor clock for improved stability
    MPU6050_WriteRegister(MPU6050_Register->PWR_MGMT_2, 0x00);   // 
    MPU6050_WriteRegister(MPU6050_Register->SMPLRT_DIV, 0x09);   // sample rate is 1kHz==accelerometer out put rate
    MPU6050_WriteRegister(MPU6050_Register->CONFIG, 0x06);       // 8kHz Fs, FSYNC disabled 
    MPU6050_WriteRegister(MPU6050_Register->GYRO_CONFIG, 0x08);  // not use self-test, 500 degree/s range
    MPU6050_WriteRegister(MPU6050_Register->ACCEL_CONFIG, 0x08); // not use self-test, not use HPF
}

uint16_t accx = 0, accy = 0, accz = 0; // 16-bit 
uint16_t omgx = 0, omgy = 0, omgz = 0; 

uint16_t assemble_byte(uint16_t byte_H, uint16_t byte_L){
    return (byte_H<<8) | byte_L;
}

void Refresh_Display(){
    uint8_t byte_H = 0, byte_L = 0;
    byte_H = MPU6050_ReadRegister(MPU6050_Register->ACCEL_XOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->ACCEL_XOUT_L);
    accx = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->ACCEL_YOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->ACCEL_YOUT_L);
    accy = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->ACCEL_ZOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->ACCEL_ZOUT_L);
    accz = assemble_byte(byte_H, byte_L);
    // get omega;
    byte_H = MPU6050_ReadRegister(MPU6050_Register->GYRO_XOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->GYRO_XOUT_L);
    omgx = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->GYRO_YOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->GYRO_YOUT_L);
    omgy = assemble_byte(byte_H, byte_L);
    byte_H = MPU6050_ReadRegister(MPU6050_Register->GYRO_ZOUT_H);
    byte_L = MPU6050_ReadRegister(MPU6050_Register->GYRO_ZOUT_L);
    omgz = assemble_byte(byte_H, byte_L);
}

int main(){
    OLED_Init();
    OLED_ShowString(1,1, "Init...");
    
    MPU6050_Init();
    Delay_s(1);
    OLED_ShowString(1,1,"       ");
    while (1){
        Refresh_Display();
        OLED_ShowString(1,1, "Device ID:0x");
        OLED_ShowHexNum(1,13, MPU6050_ReadRegister(MPU6050_Register->WHO_AM_I), 2);
        OLED_ShowHexNum(2,1, accx, 4);
        OLED_ShowHexNum(3,1, accy, 4);
        OLED_ShowHexNum(4,1, accz, 4);
        
        OLED_ShowHexNum(2,6, omgx, 4);
        OLED_ShowHexNum(3,6, omgy, 4);
        OLED_ShowHexNum(4,6, omgz, 4);

        if (MPU6050_ErrorFlag) OLED_ShowString(4,8, "Err!");
    }
}

```

# I2C é€šä¿¡åè®®è½¯ä»¶ç¼–ç¨‹ 

> [!NOTE] æ³¨æ„ 
> ç›¸å¯¹äºI2Cçš„ç¡¬ä»¶é€šä¿¡, **è½¯ä»¶ç¼–ç¨‹æœ‰æ›´å¥½çš„ç¨³å®šæ€§**,  åŒæ—¶, åœ¨è¯»å–éƒ¨åˆ†æ•°æ®æ—¶,**ä¸ä¼šå‡ºç°ç¡¬ä»¶çš„è¯»ä¸å‡ºé—®é¢˜**, å¦å¤–ç¡¬ä»¶ä¹Ÿä¸ä¼šå‡ºç°å¡æ­»é—®é¢˜

å¦å¤–æ³¨æ„çš„æ˜¯, å¤–éƒ¨å¿…é¡»è¦æ¥ä¸Šä¸Šæ‹‰ç”µé˜», 

å¯¹äºI2Cçš„åˆå§‹åŒ–, ä»¥åŠå¯åŠ¨å’Œåœæ­¢, åªéœ€è¦ä½¿ç”¨å¦‚ä¸‹ä»£ç : 
```cpp 
#define OLED_W_SCL(x) GPIO_WriteBit(GPIOB, GPIO_Pin_12, (BitAction)(x))
#define OLED_W_SDA(x) GPIO_WriteBit(GPIOB, GPIO_Pin_13, (BitAction)(x))

void OLED_I2C_Init(void)
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;    // å¼€æ¼è¾“å‡ºæ¨¡å¼, ä»…ç”¨äºI2Cé€šä¿¡ç­‰æ¨¡å¼, ä»…ä½ç”µå¹³æœ‰é©±åŠ¨
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	// ********  æ³¨æ„ä¸è¦å¿˜äº†åˆå§‹åŒ–é«˜ç”µå¹³ ******** 
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}

void OLED_I2C_Start(void){
    OLED_W_SDA(1);
    OLED_W_SCL(1);
    OLED_W_SDA(0);
}

void OLED_I2C_Stop(void)
{
	OLED_W_SDA(0);
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}
```

å…¶ä¸­é‡å®šä¹‰ç«¯å£é™¤äº†å®å®šä¹‰ä¹‹å¤–, è¿˜å¯ä»¥å®šä¹‰å‡½æ•°çš„æ–¹æ³•è¿›è¡Œ; åŒæ—¶, å®šä¹‰å‡½æ•°å¯ä»¥åŠ ä¸Šå¯¹åº”çš„å»¶æ—¶, æ›´å¥½åœ°æ–¹ä¾¿äº†ç¨‹åºçš„ç§»æ¤.

> [!NOTE] Title
> åœ¨å®é™…åº”ç”¨ä¸­, Startéœ€è¦å…¼å®¹é‡å¤èµ·å§‹æ¡ä»¶,  å› æ­¤éœ€è¦

ç¡çœ æ¨¡å¼æ—¶, å†™å…¥å¯„å­˜å™¨æ˜¯æ— æ•ˆçš„; 



åœ¨I2Cçš„æ€»çº¿æ—¶åºä¸­, ç”±äºæ˜¯é«˜ä½å…ˆè¡Œåˆ¶, æ‰€ä»¥æ¯ä¸€æ¬¡
```cpp
void OLED_I2C_SendByte(uint8_t Byte)
{
	OLED_W_SCL(0); Â // é¦–å…ˆåœ¨ä¼ è¾“æ•°æ®è¿‡ç¨‹ä¸­å…ˆè¦æ‹‰ä½æ€»çº¿ (åˆ«å¿˜äº†è¿™ä¸€å¥)
	uint8_t i;
	for (i = 0; i < 8; i++)
	{
		OLED_W_SDA(Byte & (0x80 >> i));
		OLED_W_SCL(1);
		OLED_W_SCL(0);
	}
	OLED_W_SCL(1);	//é¢å¤–çš„ä¸€ä¸ªæ—¶é’Ÿï¼Œä¸å¤„ç†åº”ç­”ä¿¡å·, (ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªwait Ackä»£æ›¿)
	OLED_W_SCL(0);
}
```

è€Œå†™æŒ‡ä»¤åªéœ€è¦
```cpp
void OLED_WriteCommand(uint8_t Command)
{
	OLED_I2C_Start();
	OLED_I2C_SendByte(0x78);		//ä»æœºåœ°å€
	OLED_I2C_SendByte(0x00);		//å†™å‘½ä»¤
	OLED_I2C_SendByte(Command); 
	OLED_I2C_Stop();
}
```

å¡æ­»çš„é‡è¦é—®é¢˜è§£å†³:
åœ¨è¯»å–è¿‡ç¨‹ä¸­, å¾€å¾€ä¼šå‡ºç°å¡æ­»çš„é—®é¢˜, ä¸”åªæœ‰æ•´ä¸ªä¸Šç”µå¤ä½å¯ä»¥è§£å†³, æ­¤æ—¶æŸ¥æ‰¾å‡ºæ­»å¾ªç¯åœ¨è¿™é‡Œå‘ç”Ÿ: 

```cpp 
void I2C2_WaitEvent(unsigned int I2C_EVENT, unsigned int timeout)
{
    uint16_t temp = timeout;
	if (temp == 0) return;
    while (I2C_CheckEvent(I2C2, I2C_EVENT) != SUCCESS){
        temp--;
        if (temp == 0){
            I2C2_ErrorFlag = true;
        }
    }
}
```
æ³¨æ„! å…¶åŸå› æ˜¯ç­‰å¾…äº‹ä»¶å‡ºç°ä¹‹åæ²¡æœ‰return , å¯¼è‡´ä¸€ç›´æ­»å¾ªç¯; è§£å†³æ–¹æ³•æ˜¯åœ¨è®¾ç½®flag = trueä¹‹ååŠ ä¸Šreturn
```cpp 
void I2C2_WaitEvent(unsigned int I2C_EVENT, unsigned int timeout)
{
    uint16_t temp = timeout;
	if (temp == 0) return;
    while (I2C_CheckEvent(I2C2, I2C_EVENT) != SUCCESS){
        temp--;
        if (temp == 0){
            I2C2_ErrorFlag = true;
            return;
        }
    }
}
```

# MPU6050é€šè¿‡ç§»æ¤DMPå®ç°è®¾å¤‡çš„æ¬§æ‹‰è§’æµ‹é‡
ä½¿ç”¨DMPå¯ä»¥å°†åŸå…ˆçš„æ•°æ®ç›´æ¥è½¬æ¢ä¸ºå››å…ƒæ•°è¿›è¡Œè¾“å‡º ï¼Œ ä»è€Œå¾—åˆ°å¯¹åº”çš„æ¬§æ‹‰è§’

æˆ‘ä»¬åœ¨æ­¤å¤„ä¸ä½¿ç”¨åœ°ç£ä¼ æ„Ÿå™¨å’Œæ°”å‹é«˜åº¦è®¡, è€Œå®é™…ä¸Šå¯ä»¥é…åˆHMC5883åœ°ç£ä¼ æ„Ÿå™¨å’ŒBMP180é«˜åº¦è®¡ç­‰ç­‰è¿›è¡Œæ¬§æ‹‰è§’æµ‹é‡;(ä¹Ÿæœ‰AK8975ç³»åˆ—ä¸‰è½´ç½—ç›˜ç­‰ç­‰) 

DMPèµ„æ–™\\Embedded_MotionDriver_5.1\\core\\driver\\eMPL  ä¸­æ‰¾åˆ° inv_mpu.c, inv_mpu.h, dmpmap.h, dmpKey.hç­‰ç­‰

DMP å³ Digital Motion Processor, 
é¦–å…ˆ, åœ¨ MPU6050ä¸­, éœ€è¦é€šè¿‡å¯¹åº”çš„è¾“å‡ºè·å–6è½´æˆ–è€…9è½´çš„æ—‹è½¬çŸ©é˜µå’Œå››å…ƒæ•°(quaternion)çš„èåˆæ¼”ç®—æ•°æ®, æ³¨æ„çš„æ˜¯éœ€è¦DMAæ”¯æŒ; 

å‚è€ƒ7.9éƒ¨åˆ†, DMPæ‰€äº§ç”Ÿçš„å€¼æ˜¯äº§ç”Ÿåœ¨å¯„å­˜å™¨ä¸­çš„, å¯ä»¥ä»DMPå¯„å­˜å™¨è¿›è¡Œè·å–, ä¹Ÿå¯ä»¥å­˜å‚¨åœ¨FIFOä¸­è¿›è¡Œç¼“å†²
$$a + x i + y j  + z k$$
å…¶ä¸­, ijkå‡ä¸ºè™šæ•°; è€Œå•ä½å‘é‡ç»•è½´(a,b,c)çš„æ—‹è½¬è§’åº¦å¯ä»¥è¡¨ç¤ºä¸º:
$$\cos \frac{\theta}{2}  + \sin \frac{\theta}{2} \cdot (ai+ bj + ck)$$

é¦–å…ˆæ‰¾åˆ°`c_cpp _Properties.json`æ–‡ä»¶å¤¹, å¹¶definesä¸­å®šä¹‰MPU6050
![[attachments/Pasted image 20240223113650.png]]

```cpp
"MPU6050",
STM32F10X_MD,
USE_DMP,
MPL_LOG_NDEBUG=1,
EMPL,
MPU6050,
EMPL_TARGET_STM32F1
```

é¦–å…ˆæˆ‘ä»¬ç¼–å†™I2Cä¼ è¾“å’Œè¯»å–å¤šä¸ªå­—èŠ‚çš„ç¨‹åº, ç”¨äº

> [!caution] æ³¨æ„
> å¯¹äºè¯»å–æ—¶åº, è¦æ±‚å…ˆç­‰åˆ°å­—èŠ‚åˆ°è¾¾å¯„å­˜å™¨äº‹ä»¶å‘ç”Ÿä¹‹å, å†è¯»å–æ•°æ®, å’Œå‘é€æ•°æ®åˆšå¥½ç›¸å. 

å¯ç§»æ¤çš„è¿ç»­è¯»å–çš„I2Cå‡½æ•°å¦‚ä¸‹:
```cpp
/// @brief general I2C write function, use length to sepcify the length of data to write
/// @param slave_address slave device address 
/// @param reg_addr address of register to start to write 
/// @param legnth length of data to write 
/// @param Data   Data Array 
void I2C2_Write(uint8_t slave_address, uint8_t reg_addr, uint8_t length, uint8_t* Data){
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, I2C2_time_out); // EV5
    
    I2C_Send7bitAddress(I2C2, slave_address, I2C_Direction_Transmitter);
    I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED, I2C2_time_out);  // EV6 
    I2C_SendData(I2C2, reg_addr);
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING, I2C2_time_out); // EV8
    for (int i = 0; i< length; i++){
        I2C_SendData(I2C2,  Data[i]);
        I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING, I2C2_time_out); // EV8
    }
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED,I2C2_time_out * 2);  // EV 8_2;
    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
}

/// @brief use I2C2 bus to read the data needed to Data Array;
/// @param slave_address slave device address 
/// @param reg_addr register address 
/// @param length length of data, must be >= 1
/// @param Data Data Array @attention you should have a big enough array to storge the data to read 
/// @note  this function would firstly locate the register probe to specified location and then receive data
void I2C2_Read(uint8_t slave_address, uint8_t reg_addr, uint8_t length, uint8_t *Data){
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, I2C2_time_out);              // EV5

    I2C_Send7bitAddress(I2C2, slave_address, I2C_Direction_Transmitter);
    I2C2_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED, I2C2_time_out);// EV6

    I2C_SendData(I2C2, reg_addr);
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED, I2C2_time_out);         // EV8_2

    // regenerate start condition
    I2C_GenerateSTART(I2C2, FunctionalState::ENABLE);
    I2C2_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT, I2C2_time_out);              // EV5
    I2C_Send7bitAddress(I2C2, slave_address, I2C_Direction_Receiver);
    I2C2_WaitEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED, I2C2_time_out);   // EV6

    for (int i = 0; i < length -1; i++){
        I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_RECEIVED, I2C2_time_out);        // EV7
        Data[i] = I2C_ReceiveData(I2C2);
    }
    I2C_AcknowledgeConfig(I2C2, FunctionalState::DISABLE); // disable the acknowedgement
    
    I2C2_WaitEvent(I2C_EVENT_MASTER_BYTE_RECEIVED, I2C2_time_out);            // EV7
    Data[length - 1] = I2C_ReceiveData(I2C2);

    I2C_GenerateSTOP(I2C2, FunctionalState::ENABLE);
    I2C_AcknowledgeConfig(I2C2, FunctionalState::ENABLE); // re-enable the acknowledgement
}

```

æ­¤æ—¶æˆ‘ä»¬æ˜¾ç¤ºé™€èºä»ªæ•°æ®, åªéœ€å‡ è¡Œä»£ç :
```cpp 
I2C2_Read(MPU6050_Address, MPU6050_Register->ACCEL_XOUT_H, 6, Data1);
I2C2_Read(MPU6050_Address, MPU6050_Register->GYRO_XOUT_H, 6, Data2);
for (int i = 0; i < 6; i++){
	OLED_ShowHexNum(1, 1 + 2 * i, Data1[i], 2);
	OLED_ShowHexNum(3, 1 + 2 * i, Data2[i], 2);
}
```

å‚è€ƒæˆ˜èˆ°STM32å¼€å‘æ¿åº“å‡½æ•°éƒ¨åˆ†çš„ä»£ç ç§»æ¤, é¦–å…ˆ :  
å¯¹äºmget_ms, å®é™…ä¸Šæ˜¯ä¸ªç©ºå‡½æ•°, åœ¨æˆ‘ä»¬çš„ç¨‹åºä¸­æ²¡æœ‰ç”¨åˆ°; 

```cpp title:inv_mpu.cä¸­get_msçš„ä½¿ç”¨
// ç©ºå‡½æ•°
#define get_ms      mget_ms
void mget_ms(unsigned long *time)
{
}
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°, åœ¨MPU6050çš„éƒ¨åˆ†, å¯„å­˜å™¨å·²ç»åœ¨ reg éƒ¨åˆ†ç»™å‡ºäº†å…¨éƒ¨çš„å®šä¹‰; 
![[attachments/Pasted image 20240223200632.png]]
å°†å…¶ä¿®æ”¹å¦‚ä¸‹: 
![[attachments/Pasted image 20240223212546.png]]

```cpp title:å¤šé‡ifdefçš„ç”¨æ³•
#if defined EMPL_TARGET_MSP430 || defined MOTION_DRIVER_TARGET_MSP430 || defined MOTION_DRIVER_TARGET_STM32F10X
```

å¯¹äºreg_int_cb, ç›´æ¥æ³¨é‡Šæ‰å³å¯: 
![[attachments/Pasted image 20240223213645.png]]

å¦å¤–æ³¨æ„: ==å¤æ•°æµ®ç‚¹è½¬æ¢ä¸ºæ•´å½¢ä¼šå‡ºé”™,å› æ­¤éœ€è¦åˆ†åˆ«æŒ‰ç…§æ­£è´Ÿè¿›è¡Œè½¬æ¢ä¹‹åè¿›è¡Œæ˜¾ç¤º==
```cpp title:è´Ÿæ•°è½¬æ¢æ˜¾ç¤ºé€»è¾‘
if (accx > 0) OLED_ShowChar(2,1,'+'); else {OLED_ShowChar(2,1,'-'); accx = -accx;}
```

å¦‚å›¾, dmpè·å–çš„ä»£ç å®é™…ä¸Šæ˜¯åœ¨ inv_mpu.c ä¸‹çš„`mpu_dmp_get_data`å‡½æ•°, å¦‚ä¸‹å›¾æ‰€ç¤º: 
![[attachments/Pasted image 20240224092810.png|800]]

åœ¨ç¨‹åºä¸­, èŠ¯ç‰‡æ˜¯ä»¥ç»“æ„ä½“çš„å¯¹è±¡stå‘½åçš„, å…·ä½“å¦‚ä¸‹:
```cpp title:èŠ¯ç‰‡å¯¹è±¡st
static struct gyro_state_s st={
Â  &reg,
Â  &hw,
Â  {0},
Â  &test
};
```


å¯¹äºMPU6050èŠ¯ç‰‡, æœ‰ä¸€ä¸ªFIFO (å…ˆå…¥å…ˆå‡º)å¯„å­˜å™¨,å¯ä»¥ç”¨æ¥è¿›è¡Œæš‚å­˜ä¸€äº›æ•°æ®. è€ŒFIFOå¯„å­˜å™¨ç”¨äºç®¡ç†å“ªäº›æ•°æ®å°†è¢«æ”¾åˆ°FIFOä¸­è¿›è¡Œå¯„å­˜; å…¶ä¸­é™¤äº†åŠ é€Ÿåº¦å’Œé™€èºä»ªçš„æ•°æ®ä»¥å¤–, è¿˜å¯ä»¥å­˜å‚¨æ¸©åº¦ä¼ æ„Ÿä¸å…¶ä»–é™„åŠ çš„æ•°æ®; 
å¯¹åº”çš„æœ‰ä¸€ä¸ªFIFO counteræ¥è®°å½•FIFOä¸­çš„å­—èŠ‚æ•°;

å¯¹äºç»“æ„ä½“,  

```cpp title:ç»“æ„ä½“å†…å®¹
/* Gyro driver state variables. */
struct gyro_state_s {
Â  Â  const struct gyro_reg_s *reg;
Â  Â  const struct hw_s *hw;
Â  Â  struct chip_cfg_s chip_cfg;
Â  Â  const struct test_s *test;
}
```

è¿™é‡Œä½¿ç”¨äº†Cè¯­è¨€ä¸­ç»“æ„ä½“åˆå§‹åŒ–å¯¹è±¡, æŒ‰ç…§å‡ºç°çš„å…ˆåé¡ºåºè¿›è¡Œåˆå§‹åŒ–ç»“æ„ä½“
```cpp title:è¿™ä¸ªä»£ç åˆ›å»ºäº†ç»“æ„ä½“å¯¹è±¡,å…±æœ‰ä¸‰ä¸ªå¯¹è±¡reg,hw,test
// è¿™ä¸ªå®é™…ä¸Šæ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥, å°†
static struct gyro_state_s st={
Â  &reg,
Â  &hw,
Â  {0},
Â  &test
};
// è¿™ä¸ªè¯­å¥çš„å«ä¹‰ç›¸å½“äºæ˜¯å°†regåœ°å€èµ‹ç»™ä¸Šé¢å®šä¹‰ä¸­çš„reg, è€Œchip_cfgèµ‹å€¼ä¸º{0}
```
ä¸Šè¿°çš„è¿™å‡ ä¸ªå¯¹è±¡å®é™…ä¸Šæ˜¯å®šä¹‰åœ¨ inv_mpu.c æ–‡ä»¶æœ¬èº«ä¸­çš„, é€šè¿‡æ”¾ä¸Šé¼ æ ‡å¯ä»¥çœ‹åˆ°:
![[attachments/Pasted image 20240224102250.png]]
å®šä¹‰éƒ¨åˆ†å¦‚ä¸‹: 
![[attachments/Pasted image 20240224103011.png]]
ä¸ºäº†ä¿è¯ä»æœºåœ°å€æ­£ç¡®, æˆ‘ä»¬åœ¨ä¿®æ”¹åçš„ä»£ç ä¸­å¯ä»¥æ‰¾åˆ°: 
```cpp title:hwçš„å®šä¹‰
const struct hw_s hw = {
    0x68,	 //addr       -> å®é™…ä¸Šæ˜¯è°ƒç”¨I2Cä¼ å…¥çš„ä»æœºåœ°å€, 0110 1000 
    1024,	 //max_fifo -> 
    118,	     //num_reg
    340,	 //temp_sens
    -521,	 //temp_offset
    256	     //bank_size
#if defined AK89xx_SECONDARY
    ,.compass_fsr    = AK89xx_FSR
#endif
};
```
è€Œæˆ‘ä»¬å®šä¹‰çš„ä»æœºåœ°å€ä½0xD0 `#define MPU6050_Address 0xD0` , å³ 1101 0000

å¦å¤–å¯ä»¥æŸ¥çœ‹åˆ°mpu_initçš„æ ¼å¼æ˜¯ç›´æ¥ä¼ å…¥åœ°å€çš„, å› æ­¤æˆ‘ä»¬åº”å½“ä½¿ç”¨0xD0ä½œä¸ºå¯¹åº”çš„åœ°å€; å› æ­¤éœ€è¦å°†hwéƒ¨åˆ†ä¼ å…¥çš„addrå‚æ•°æ›´æ”¹ä¸º0xD0
```cpp 
if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
->
I2C2_Write(MPU6050_Address, MPU6050_Register->PWR_MGMT_1, 1, data); // å®é™…ä¸Šæ˜¯ç±»ä¼¼äºè¿™ä¸ªå‡½æ•°
```



åœ¨.hæ–‡ä»¶ä¸­, æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å…¶æä¾›çš„å¤§é‡å‡½æ•°:
```cpp title:mpuç›¸å…³å‡½æ•°
/* Set up APIs */
int mpu_init(struct int_param_s *int_param);
int mpu_init_slave(void);
int mpu_set_bypass(unsigned char bypass_on);

/* Configuration APIs */
int mpu_lp_accel_mode(unsigned char rate);
int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
    unsigned char lpa_freq);
int mpu_set_int_level(unsigned char active_low);
int mpu_set_int_latched(unsigned char enable);

int mpu_set_dmp_state(unsigned char enable);
int mpu_get_dmp_state(unsigned char *enabled);

int mpu_get_lpf(unsigned short *lpf);
int mpu_set_lpf(unsigned short lpf);

int mpu_get_gyro_fsr(unsigned short *fsr);
int mpu_set_gyro_fsr(unsigned short fsr);

int mpu_get_accel_fsr(unsigned char *fsr);
int mpu_set_accel_fsr(unsigned char fsr);

int mpu_get_compass_fsr(unsigned short *fsr);

int mpu_get_gyro_sens(float *sens);
int mpu_get_accel_sens(unsigned short *sens);

int mpu_get_sample_rate(unsigned short *rate);
int mpu_set_sample_rate(unsigned short rate);
int mpu_get_compass_sample_rate(unsigned short *rate);
int mpu_set_compass_sample_rate(unsigned short rate);

int mpu_get_fifo_config(unsigned char *sensors);
int mpu_configure_fifo(unsigned char sensors);

int mpu_get_power_state(unsigned char *power_on);
int mpu_set_sensors(unsigned char sensors);

int mpu_set_accel_bias(const long *accel_bias);

/* Data getter/setter APIs */
int mpu_get_gyro_reg(short *data, unsigned long *timestamp);
int mpu_get_accel_reg(short *data, unsigned long *timestamp);
int mpu_get_compass_reg(short *data, unsigned long *timestamp);
int mpu_get_temperature(long *data, unsigned long *timestamp);

int mpu_get_int_status(short *status);
int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
    unsigned char *sensors, unsigned char *more);
int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
    unsigned char *more);
int mpu_reset_fifo(void);

int mpu_write_mem(unsigned short mem_addr, unsigned short length,
    unsigned char *data);
int mpu_read_mem(unsigned short mem_addr, unsigned short length,
    unsigned char *data);
int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
    unsigned short start_addr, unsigned short sample_rate);

int mpu_reg_dump(void);
int mpu_read_reg(unsigned char reg, unsigned char *data);
int mpu_run_self_test(long *gyro, long *accel);
int mpu_register_tap_cb(void (*func)(unsigned char, unsigned char));
```

å®é™…ä¸Š, åœ¨inv_mpu.cä¸­, æˆ‘ä»¬éœ€è¦ç¼–å†™å¯¹åº”çš„åˆå§‹åŒ–å‡½æ•°, æ¥ä¿è¯

```cpp title:æ­£ç‚¹åŸå­æ·»åŠ çš„ä»£ç éƒ¨åˆ†
// void function 
void mget_ms(unsigned long *time){
}

#define q30  1073741824.0f   // è¿™ä¸ªæ˜¯longè½¬æ¢æˆfloatæ—¶çš„ä½™æ•°
static signed char gyro_orientation[9] = { 1, 0, 0, 0, 1, 0,0, 0, 1};  // é™€èºä»ªæ–¹å‘æ§åˆ¶ 

u8 run_self_test(void)
{
	int result;
	//char test_packet[4] = {0};
	long gyro[3], accel[3]; 
	result = mpu_run_self_test(gyro, accel);
	if (result == 0x3) 
	{
		/* Test passed. We can trust the gyro data here, so let's push it down to the DMP */
		float sens;
		unsigned short accel_sens;
		mpu_get_gyro_sens(&sens);
		gyro[0] = (long)(gyro[0] * sens);
		gyro[1] = (long)(gyro[1] * sens);
		gyro[2] = (long)(gyro[2] * sens);
		dmp_set_gyro_bias(gyro);
		mpu_get_accel_sens(&accel_sens);
		accel[0] *= accel_sens;
		accel[1] *= accel_sens;
		accel[2] *= accel_sens;
		dmp_set_accel_bias(accel);
		return 0;
	}else return 1;
}

unsigned short inv_orientation_matrix_to_scalar(
    const signed char *mtx)
{
    unsigned short scalar; 
    /*
       XYZ  010_001_000 Identity Matrix
       XZY  001_010_000
       YXZ  010_000_001
       YZX  000_010_001
       ZXY  001_000_010
       ZYX  000_001_010
     */
    scalar = inv_row_2_scale(mtx);
    scalar |= inv_row_2_scale(mtx + 3) << 3;
    scalar |= inv_row_2_scale(mtx + 6) << 6;

    return scalar;
}

unsigned short inv_row_2_scale(const signed char *row)
{
    unsigned short b;

    if (row[0] > 0)
        b = 0;
    else if (row[0] < 0)
        b = 4;
    else if (row[1] > 0)
        b = 1;
    else if (row[1] < 0)
        b = 5;
    else if (row[2] > 0)
        b = 2;
    else if (row[2] < 0)
        b = 6;
    else
        b = 7;      // error
    return b;
}

// mpu6050 dmp init function
u8 mpu_dmp_init(void)
{
	u8 res=0;
	MPU_IIC_Init();
	if(mpu_init()==0)  // init mpu_6050
	{
		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);
		if(res)return 1;
		res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);
		if(res)return 2;
		res=mpu_set_sample_rate(DEFAULT_MPU_HZ);
		if(res)return 3; 
		res=dmp_load_motion_driver_firmware();
		if(res)return 4; 
		res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));
		if(res)return 5; 
		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|
	DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
		    DMP_FEATURE_GYRO_CAL);
		if(res)return 6; 
		res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);	//Ã‰Ã¨Ã–ÃƒDMPÃŠÃ¤Â³Ã¶Ã‹Ã™Ã‚ÃŠ(Ã—Ã®Â´Ã³Â²Â»Â³Â¬Â¹Ã½200Hz)
		if(res)return 7;   
		res=run_self_test();		//Ã—Ã”Â¼Ã¬
		if(res)return 8;    
		res=mpu_set_dmp_state(1);	//ÃŠÂ¹Ã„ÃœDMP
		if(res)return 9;     
	}else return 10;
	return 0;
}

u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
{
	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
	unsigned long sensor_timestamp;
	short gyro[3], accel[3], sensors;
	unsigned char more;
	long quat[4]; 
	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))return 1;	 
	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
	**/
	/*if (sensors & INV_XYZ_GYRO )
	send_packet(PACKET_TYPE_GYRO, gyro);
	if (sensors & INV_XYZ_ACCEL)
	send_packet(PACKET_TYPE_ACCEL, accel); */
	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
	**/
	if(sensors&INV_WXYZ_QUAT) 
	{
		q0 = quat[0] / q30; 
		q1 = quat[1] / q30;
		q2 = quat[2] / q30;
		q3 = quat[3] / q30;
		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
	}else return 2;
	return 0;
}

```

é‡å¯å¯èƒ½æ˜¯Acknowedgeä½çš„é—®é¢˜




ä¿®æ”¹éƒ¨åˆ†å¦‚ä¸‹: 
![[attachments/Pasted image 20240224193233.png]]

åœ¨åŸå…ˆçš„æ–‡ä»¶ä¸­, `gyro_reg_s` å’Œ `gyro_reg_s reg` ä¸­çš„éƒ¨åˆ†å¹¶ä¸åŒ, å¯¼è‡´å¯„å­˜å™¨è¯»å–å¤±è´¥; å› æ­¤æˆ‘ä»¬éœ€è¦å¢åŠ å’Œå‡å°‘å¯¹åº”çš„å¯„å­˜å™¨, æ¥è®©æœ€ç»ˆå¾—åˆ°æ­£ç¡®çš„å¯„å­˜å™¨éƒ¨åˆ†;

æºæ–‡ä»¶ä¸­é”™è¯¯çš„éƒ¨åˆ†å¦‚å›¾: 
![[attachments/Pasted image 20240224194427.png|700]]
```cpp title:æ³¨é‡Šæ‰çš„ä¸‰ä¸ªéƒ¨åˆ†å¦‚ä¸‹:
struct gyro_reg_s {
    unsigned char who_am_i;
    unsigned char rate_div;
    unsigned char lpf;
    unsigned char prod_id;
    unsigned char user_ctrl;
    unsigned char fifo_en;
    unsigned char gyro_cfg;
    unsigned char accel_cfg;
    // unsigned char accel_cfg2;
    // unsigned char lp_accel_odr;
    unsigned char motion_thr;
    unsigned char motion_dur;
    unsigned char fifo_count_h;
    unsigned char fifo_r_w;
    unsigned char raw_gyro;
    unsigned char raw_accel;
    unsigned char temp;
    unsigned char int_enable;
    unsigned char dmp_int_status;
    unsigned char int_status;
    // unsigned char accel_intel;
    unsigned char pwr_mgmt_1;
    unsigned char pwr_mgmt_2;
    unsigned char int_pin_cfg;
    unsigned char mem_r_w;
    unsigned char accel_offs;
    unsigned char i2c_mst;
    unsigned char bank_sel;
    unsigned char mem_start_addr;
    unsigned char prgm_start_h;
}
```

å…¶ä½™åŸºæœ¬å…¨éƒ¨ç…§æ¬æ­£ç‚¹åŸå­çš„ä»£ç , å°±å¯ä»¥è®¡ç®—å§¿æ€è§’äº†; 
å…¶ä¸­, ä¸»è¦ä¸ç²¾ç¡®çš„åŸå› ä¸»è¦æ˜¯ 1: æœ¬èº«çš„ä¸ç²¾ç¡®é—®é¢˜ 2: æ²¡æœ‰åŠ ä¸Šç£åŠ›è®¡, å¾€å¾€ä¼šå¯¼è‡´ Yaw è§’ç¼“æ…¢æ¼‚ç§»ä»è€Œå¯¼è‡´è¯¯å·® ;


èŠ¯ç‰‡çš„çŠ¶æ€å¯ä»¥é€šè¿‡åŒ¿åå››è½´ä¸Šä½æœºæ¥è¿›è¡Œæ˜¾ç¤º, é¦–å…ˆæ‰“å¼€ä¸²å£å’ŒåŸºæœ¬æ”¶ç  ; 
![[attachments/Pasted image 20240224214214.png|600]]


AF1CDD0288286E4DEC663140EEF6000000000000F467104E02890000000

00 88 AF 1C DD 02 88 28 6E 4D F0 A6 E6 2C ED A0 00 00 00 00 00 00 C5 C9 17 53 FD A5 00 00 00 00 6C

88 AF 1C DD 02 88 28 6E 4D F0 B6 E5 94 ED A2 00 00 00 00 00 00 C5 B6 17 45 FD A3 00 00 00 00 C2

æ‰“å¼€é«˜çº§æ¥æ”¶å³å¯å®ç°æ“ä½œé£æ§; 
éœ€è¦è¯´æ˜çš„æ˜¯, å¦‚æœå‡ºç°ç¨‹åºå¡æ­»æƒ…å†µ, æ˜¯**ULinkä¾›ç”µä¸ç¨³, ä½¿ç”¨å¤–åŠ ä¸€æ ¹USBæ•°æ®çº¿è¿›è¡Œä¾›ç”µå³å¯ ,  æ¥åœ¨ä¸²å£éƒ¨åˆ†.** 

## 一、STM32实时时钟相关外设与应用
RTC (Real Time Clock) 部分(p481), 对于RTC外设, 和备份寄存器BKP, 电源控制PWR部分

实际上, VBAT 是用于连接备用电池的部分， 可以给备份寄存器等等进行供电; <mark style="background: transparent; color: red">BKP 中的数据需要VBAT引脚提供备用电池来进行维持的</mark>; 可以通过BKP在断电时临时保存一些数据; 

对于实时时钟RTC, 在按下复位按键时， 时间会继续运行，不会复位(前提是VBAT接入时钟备用电源 `->` BKP, PWR); 

> [!NOTE] 说明
> 对于RTC晶振不起振的情况,  卡死在晶振起振的部分;


### (1) Unix 时间戳
Unix 时间戳(Unix TimeStamp)可以使用 time.h 中提供的函数进行各种形式数据的转换; 包括Linux, Window和安卓系统均使用 Unix 时间戳
定义: 时间戳是一个计数器; 实际上是从UTC/GMT 的1970年1月1日(伦敦时间)经过的秒数, 但是不考虑闰秒; 
其中RTC主要的特点是硬件电路简化, 同时简化计算间隔的部分;  缺点是占用软件资源;

由于32位的部分会在2038年溢出, 而目前的系统主要采用64位数据进行

STM32的核心计数器是32位的秒计数器; (无符号32位寄存器, 2106年溢出部分);  **通过不同的时区偏移得到当地时间**;  不同时区的时间戳共用一个秒计数器; 之后**使用小时进行偏移**; 

GMT : 伦敦标准时间, 以地球自转为基础, 自转一周的时间为24小时(实际上地球自转时间不固定);
UTC : 铯原子钟 -> 原子钟计时一天时间和地球自转的时间不同, 当误差超过0.9s时, UTC 执行闰秒;
在UTC时钟中, <mark style="background: transparent; color: red">闰秒机制需要保证时间可能为60s时的情况</mark>;  而时间戳不考虑闰秒， 因此每次闰秒时， 会产生1s的误差; 

### (2) time.h 的使用

|                           |                                                     |
| ------------------------- | --------------------------------------------------- |
| `time (time _t*);`        | 获取系统时钟 (time_t是秒计数器数据类型)                            |
| struct  tm* gmtime        | 秒计数器转换为GMT时间 (struct  tm 是日期时间数据类型名, 并且在time.h中有定义) |
| struct  tm* localtime     | 秒计数器转换为当地日期时间                                       |
| time_t mktime(struct tm*) | 日期时间转换秒计数器(当地时间);                                   |
| char * ctime              | time _ t 转换为字符串类型;                                  |
| asctime()                 | 将struct tm类型转换为字符串指针类型                              |
| strftime()                | 和asctime()相同, 但是可以自定义字符串格式化输出;                      |

在time.h中定义的结构体如下: (其中，直接进行获取tm中的值即可, 其中月份需要 + 1, 年份+1900, 同时以日为开始, tm_isdst), 实际上可以使用mktime()获取到; 
```cpp
struct tm {
    int tm_sec;   /* seconds after the minute, 0 to 60
                     (0 - 60 allows for the occasional leap second) */
    int tm_min;   /* minutes after the hour, 0 to 59 */
    int tm_hour;  /* hours since midnight, 0 to 23 */
    int tm_mday;  /* day of the month, 1 to 31 */
    int tm_mon;   /* months since January, 0 to 11 */
    int tm_year;  /* years since 1900 */
    int tm_wday;  /* days since Sunday, 0 to 6 */
    int tm_yday;  /* days since January 1, 0 to 365 */
    int tm_isdst; /* Daylight Savings Time flag */
    union {       /* ABI-required extra fields, in a variety of types */
        struct {
            int __extra_1, __extra_2;
        };
        struct {
            long __extra_1_long, __extra_2_long;
        };
        struct {
            char *__extra_1_cptr, *__extra_2_cptr;
        };
        struct {
            void *__extra_1_vptr, *__extra_2_vptr;
        };
    };
};
```

```cpp 
char * tm_ptr = new char();

time_t *time_ptr;
time_t tim = time(nullptr); // 获取系统时钟(注意stm32不适用)
time(time_ptr);

struct tm *time_cnt = new tm();  // 建议初始化值; 
time_cnt = gmtime(time_cnt*); // 
time_cnt2 =  localtime();           // 根据电脑设置的时区进行 
```

另外通过mktime, 可以给定年月日， 直接返回星期数(会顺便计算之后回填); 
`time_t mktime(struct tm*);`

```cpp
char t[50];
%h %m %s //分别为时分秒部分
```

另外clock函数可以计算程序开始执行之后的时间; difftime(); 计算差值;

## 二、BKP 寄存器
Backup registers, 当VDD电源被切断时, 可以使用VBAT(1.8-3.6V)进行供电, 来维持系统的运行; 而**系统在待机模式下被唤醒， 或者系统电源复位时， 不会复位该寄存器**;

正常供电电路中, 必须保证VDDA(模拟部分供电), VDD_1, VDD_2, VDD_3 (对应数字部分的供电); 均为系统的主电源; VBAT为备用电池, 只有正极的; 

手册中建议VBAT当不使用时，可以连接到主电源并接入100nF电容到地; 
在中小容量设备中 , bkp为20byte, 而大容量为84byte; (小容量从DR1- DR10,  大容量从DR1-DR42); 

其他功能包括:
- TAMPER(PC13) 引脚产生的侵入检测(清除BKP中的所有内容), 使用上拉电阻加线，实现防拆设计; 同时**主电源断电之后侵入检测仍然有效**;  
- **使用 RTC 引脚输出RTC校准时钟， 闹钟脉冲和秒脉冲**;
- <mark style="background: transparent; color: red">存储 RTC 时钟校准寄存器</mark>; 

在主电源有电时， VBAT不会使用到(自动切换); 
包括控制寄存器， 状态寄存器，RTC时钟校准寄存器和数据寄存器部分; 
![[Excalidraw/1. Unix 时间戳与BKP寄存器的使用 2024-03-01 01.17.41|400]]

## 三、RTC 简介 
### (1) 基本功能
可以给系统提供时钟可日历的功能; 需要说明的是， 必须挂载备用电池和RTC晶振部分;  
具有**32位的可编程计数器, 对应Unix时间戳的秒计数器**, 读取时可以直接<mark style="background: transparent; color: red">先获取到秒信息再转换， 而写入时只需转换之后写入</mark>即可; 

实际提供给RTC模块的时钟由RTCCLK进行提供， 往往频率都较高; 
因此具有<mark style="background: transparent; color: red">20位的分频器</mark> , 使得能够将频率降到1Hz; 可以选择最高2^20大小的分频, 从而适配不同RTCCLK;

RTC时钟源可以选择为: 
- HSE(8MHz)/128;  即8MHz主晶振;
- LSE(32.768kHz); 外部低速晶振(接在OSC32_IN, OSC32_OUT(PC14, PC15)上接入外部低速晶振) `->` 一般取32.768kHz,  <mark style="background: transparent; color: red">作为内部RTC的专用时钟</mark>;  直接选择2^15分频即可; 实际上只需自然溢出; 板上已经自带有对应的外部低速专用晶振; 
- LSI  RC振荡器(40kHz);  一般精度没有外部低速晶振高; 主要是提供给看门狗(WWDG)作为时钟; 
需要注意的是， <b><mark style="background: transparent; color: blue">只有LSE的时钟可以通过VBAT备用电池供电; </mark></b> , 因此我们总是选择32.768kHz作为系统的RTC晶振; (分频得到1Hz秒信号来更改32位计数器);

### (2) 结构框图 
RTC 是APB1总线上的外设; 
![[Excalidraw/1. Unix 时间戳与BKP寄存器的使用 2024-03-01 01.40.06|800]]
在RCC中可以配置RTC的时钟来源, 然后配置RTC_PRL(控制重装值), RTC_DIV(自减计数器), 
**通过DIV和PRL同时控制分频数**， 通过重装次数控制计数器每隔多少次溢出一次;

RTC_ALR可以设定闹钟， **当CNT和ALR为相同时, 闹钟触发中断**， 可以用于唤醒待机模式等等;  (对于周期性闹钟， 需要闹钟完毕之后， 设置下一次的触发时间)
RTC的中断包括秒中断(每秒一次), OWF(32位秒溢出中断), RTC_Alarm 闹钟中断; 

推荐的备用电源的连接和简单连接如图:
![[attachments/Pasted image 20240301015413.png]]

![[attachments/Pasted image 20240301015902.png]]

常用的备用电池可以选择CR2032常用的备用纽扣电池等等
![[attachments/Pasted image 20240301020357.png]]
1. 除了PWR, BKP的时钟， 另外还要**设置DBP位**;
2. **RTC等待同步操作**: 为了保证RTC在主电源掉电正常工作,  RTC寄存器都是在RTCCLK下同步的; 因此PCLK读取时往往会不同步(RTC上升沿才更新RTCCLK)， 因此需要进行寄存器同步;  让RTC的值同步到APB1总线上; 
3. 配置模式标志位 
4. 等待更新操作 

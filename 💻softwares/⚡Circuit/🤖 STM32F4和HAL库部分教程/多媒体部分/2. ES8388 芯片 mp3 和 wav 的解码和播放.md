对于 ES8388 芯片支持 I2S 和 SAI 接口通信, 其中WM8978也支持I2S通信接口,  而VS1053 使用 SPI 进行通信。
对于 VS1053, 支持硬件 SPI 直接发送 wav 和 mp3数据解码, 而es8388 有更好的音质, 但是需要进行软件解码。

RIFF (Resource Interchange File Format), 支持MS ADPCM, CCITT , ALAW 等等多种压缩算法, 一般的采样率都是 44100 Hz, 能够存放高质量音频。
WAV 是经过压缩算法的 PCM(未压缩) 格式。

参考[[💻softwares/⚡Circuit/🎮STM32教程/五、扩展模块/stm32读取和播放SD卡中的音乐mp3和wav文件|stm32读取和播放SD卡中的音乐mp3和wav文件]] 以及 [[💻softwares/⚡Circuit/🎮STM32教程/六、语音识别模块教程讲解/STM32F103RET6的DAC模块和音频输出|DAC模块和音频输出]] 部分, 
重要的是采样率 sample rate 和采样位数 (16, 32)

我们实际上需要将 SPI3 复用为 I2S 输出给

第一, RIFF Chunk 
```c
typedef __PACKED_STRUCT
 {
  uint32_t ChunkID;   /* chunk id;这里固定为"RIFF",即 0X46464952 */
  uint32_t ChunkSize ;   /* 集合大小;文件总大小-8 */
  uint32_t Format;   /* 格式;WAVE,即 0X45564157 */
} ChunkRIFF ;
```

其二, FMT Chunk 
```c
typedef struct
{
  uint32_t   ChunkID;       /* 0 */ /* chunk id;这里固定为"fmt ",即 0X20746D66 */ 
  uint32_t   FileSize;      /* 4 */   /* 子集合大小(不包括 ID 和 Size) */  -> 一般为 8 
  uint32_t   FileFormat;    /* 8 */  /* 音频格式;0X01,表示线性 PCM;0X11 表示 IMA ADPCM */
  uint32_t   SubChunk1ID;   /* 12 */   /* 通道数量;1,表示单声道;2,表示双声道; */ 
  uint32_t   SubChunk1Size; /* 16*/  /* 采样率;0X1F40,表示 8Khz */ 
  uint16_t   AudioFormat;   /* 20 */   /* 字节速率=采样率*通道数*(ADC位数/8) */  -> 计算 bitrate 
  uint16_t   NbrChannels;   /* 22 */   /* 块对齐(字节)=通道数*(ADC位数/8) */ 
  uint32_t   SampleRate;    /* 24 */   /* 单个采样的位数;16位PCM,设置为16 */  
  
  uint32_t   ByteRate;      /* 28 */
  uint16_t   BlockAlign;    /* 32 */  
  uint16_t   BitPerSample;  /* 34 */  
  uint32_t   SubChunk2ID;   /* 36 */   
  uint32_t   SubChunk2Size; /* 40 */   
}WAVE_FormatTypeDef;
```

其三, 有一个可选的 FACT Chunk, 
```c
typedef __PACKED_STRUCT 
{ 
	uint32_t ChunkID; 			/* chunk id;这里固定为"fact",即 0X74636166; */ 
	uint32_t ChunkSize; 		/* 子集合大小(不包括 ID 和 Size);这里为:4 */ 
	uint32_t DataFactSize; 		/* 数据转换为PCM格式后的大小 */ 
}ChunkFACT; 					/* fact 块 */
```

最后是 DATA Chunk, 其 bit 位的形式是 : 
![[attachments/Pasted image 20240727104433.png]]
对于 24位量化, 是  低> 中> 高 进行播放的;
一般只需要获取到 wav 数据并**通过I2S送给 wm8978 即可**。

## 二、STM32F4 的 I2S 外设简介
### (1) STM32 I2S 外设简介
I2S (Inter IC Sound) 是一种音频数据传输指定的总线标准。是一种传输 PCM 编码音频数据流的外设, 支持<mark style="background: transparent; color: red">全双工, 半双工和主从模式</mark>, 而主模式是 STM32F4, WM8978 是从模式。
对于SPI1没有相关的I2S外设, 仅有 SPI2, SPI3 支持。
I2S最少有3根信号线: 
1. SCK/SCLK/BCLK(一个时钟传输1bit数据), 频率 = 声道数 * 采样频率 * 采样位数;  
2. LRCK (左右时钟, 帧时钟/WS), 用于声道选择; **其中 "1" 表示传输右声道的数据, "0" 表示传输左声道的数据**, 其有**频率 = 采样率**(一个周期中, 同时采样右声道和左声道的数据)
3. SDATA(1-2根串行数据线):  当一根时, 为半双工; 双线时为全双工; 
4. (optional) MCLK (系统时钟, 用于将系统时钟更好的同步, 频率 = 128或 256* samplerate), <mark style="background: transparent; color: red">本板使用 PC6(I2S2-MCK) 作为 I2S_MCLK 部分</mark>;
I2S 具有 Philips(I2S)标准, 左对齐 MSB 标准 和右对齐(LSB) 标准。
数据在跟随 LRCLK 传输, <mark style="background: transparent; color: red">在 BCLK 的第二个上升沿时， 传输 MSB 部分</mark>(首先需要等待一个周期)， 一般允许32 位数据传输, 如果数据不足, 则后面补 0; 

对于 ES8388 是一种双 ADC/DAC 通道, 放大器以及数组音效, 模拟混合增益功能的音频解码器。同时有数字音效,模拟混合等功能。
<mark style="background: transparent; color: red">DAC 信噪比为 96db, ADC 信噪比 95db, 支持左右声道音量独立调节, 支持主机和从机模式</mark>。

对于 STM32F4 的 I2S 部分, 支持全双工和半双工通信, 支持主从, 可编程8位线性预分频器， 实现 8-192kHz的精确采样。支持 16, 24, 32 位的数据格式。支持<b><mark style="background: transparent; color: blue">MSB对齐, LSB对齐, 飞利浦标准</mark></b>, 同时支持DMA传输，数据方向固定 MSB 在前,并且支持主时钟输出。
• Master clock may be output to drive an external audio component. Ratio is fixed at 256 × FS (where FS is the audio sampling frequency) -> 必须设置为 256 倍 Master Clock 时钟同步频率。

### (2) STM32 I2S 发生器时钟
对于 I2S 外设, 其时钟来自 I2S_CLK 部分, 一般采用 I2S CKIN 部分, 在时钟树中, I2S 时钟是来自于 /R 部分的 PLL2SCK, 也可以来自于 I2S_CKIN(外部提供);
![[attachments/Pasted image 20240727211914.png]]
而锁相环 PLL2CLK 部分是通过HSE (8MHz)其中 PLLCLK 是 168MHz, 即 8Mhz * 336 / M / P  ; (M = 8, P = 2)参考[[💻softwares/⚡Circuit/🤖 STM32F4和HAL库部分教程/基本内容/3. HAL库时钟初始化|3. HAL库时钟初始化]], 而 Q 一般设置为 7, 即 48 MHz 的频率， <mark style="background: transparent; color: red">其中有两个锁相环, 其中一般 PLL1SN 固定为336部分</mark> 

I2S 的时钟频率是: 
$$ I2S \space Clocks  =  8MHz * PLL2SN / 8(M)  / PLL2SR   $$
而参考p908 I2S 外设时钟生成结构框图得到:
![[attachments/Pasted image 20240727213224.png]]
I2SxCLK 需要根据 fs 配置分频系数。而设置采样率的方案如下: 
![[attachments/Pasted image 20240727213414.png]]
一般主模式下的时钟频率计算如上: 其中 fs 为频率;
对于左右声道, 每次传输2个数据, 则:
$$ Fs = \frac{I2SCLK}{32 * 2 * (2 * I2SDIV + ODD) * 4 } $$
其中 I2SDIV 和 ODD 均为分频系数, ODD = 0-1, I2SDIV = 2~255 , 而 R 取值范围2-7
因此
1. I2S Clk =  1MHz * PLL2SN/PLL2SR (t = 2-7), 范围48 Mhz- 168Mhz, 
2. Fs = I2SClk / (256 * (2 * I2SDIV +  ODD))
需要说明的是, 上述方法一般仅能得到具有误差的采样率,<mark style="background: transparent; color: red"> 而需要零误差的情况下, 会采用 I2S_CKIN 外部时钟</mark>, 能够得到最为精确的结果。 

一般而言, 按照不同的采样率, 其对应的最佳 PLLI2SN, PLLI2SR, I2SDIV, ODD 等组合如下所示:
![[attachments/Pasted image 20240727214618.png]]
注意: 仅有I2S停止时, 才能进行 SPI, I2S 的切换， 并设置 SPI_I2SCFG中的 I2SMOD =1
I2SE 位, 设置1时, 使能 I2S 外设, 必须设置完 I2SMOD 之后才能进行继续设置。

I2SSTD 设置 I2S 标准, CKPOL 设置空闲时的 CLK 电平为低电平。而预分频器寄存器设置8位的预分频。另外, SPI_CR2 用于使能 SPI 或者 I2S的 DMA 请求, 用于使能发送缓冲区的 DMA 请求。

### (3) ESP8388 说明
根据 ES8388 电路连线图, 框图和引脚图如下所示: 
![[attachments/Pasted image 20240727122410.png]]
封装为 QFN28, 其中29脚EP 一般接地,  <mark style="background: transparent; color: red">通过I2C接口或者 SPI接口进行命令传输, 配置其全双工 SPI 模式, 其中 IIC 接口需要CE = 0/1,  SPI需要 CE 产生下降沿部分。</mark> 
![[attachments/Pasted image 20240727122444.png]]
对于 PB8,  PB9 在原理图中作为音频的 I2C 接口, 同时支持 I2S 标准(MSB传输), MSB 标准, LSB 标准, DSP/PCM 标准。
**ADSOUT 即 ADC数据输出(SPIx-extSD)**, 第二, ES8388 要求, MCLK 时钟频率必须为256fs, 其中 fs = 音频采样率。

具体参考 Chip Control and Power Management 
R0 寄存器: 包含SCP_Reset(1将其软复位),  VMIDSEL\[1:0\] 用于控制 VMID, 用于校正噪声, <mark style="background: transparent; color: red">而 R1 寄存器(控制寄存器2)控制模拟部分的复位。 当设置PdnAna 为 0 时, 模拟部分才会工作, 即才能听到声音</mark>。

对于 Register2: 
![[attachments/Pasted image 20240727160633.png]]
其中 滤波器重置部分用于重置 ADC DEM等, dac_PDN重置 DACDEM 等等(均需要设置为0), 包括 adcVref_PDN 和 dacVref_PDN 均需要设置为0进行控制。

R4 是电源管理的寄存器, <mark style="background: transparent; color: red">R8 用于配置主从模式的控制寄存器</mark>， 同时BLCK_INV用于控制左右声道反相, BLCKDIV 用于控制主时钟分频, 一般选用不分频。
R9 寄存器控制 MIC 的左右通道增益大小, 具体如下:
![[attachments/Pasted image 20240727161717.png]]
R9, R10 为控制寄存器1, 2; 其中 R10 控制输入通道以及R11的DS差分输入选择。
R12: DATSEL 控制是否换用ADC通道, 
R13为ADC控制寄存器5，<mark style="background: transparent; color: red">其中ADCFsRatio控制主时钟相对于采样率的倍率</mark>, 一般设置为 00010 (256), 默认为 768;
R16， R17分别控制左右声道 ADC 输入(采集外部声音)的衰减。
R18 控制 ALC(Automatic Level Control, 自动电平控制) <mark style="background: transparent; color: red">ALCSEL = 11 为立体声控制, 音效更好</mark>, 
从 R23 开始是对于 DAC 的控制, <mark style="background: transparent; color: red">重要的是 DACWL, 往往设置为 100 (32位数据长度), 往往会提供更好的音质。ADCFORMAT 设置 DAC 的数据格式, 使用I2S格式(00)</mark>, 
R24中, **DACFsMode, 用于设置单速和双倍速模式, 一般设置为0**, DACFsRatio 设置应当和前面保持一致(00010为256)
R26, R27 中的 LDACVOL , RDACVOL 控制左右声道的衰减, 最高为 96db;

当配置静音时, 可以使用 R29(1Dh) 的ZeroL和ZeroR 配置位, 
R29 -> Mono 控制单声道输出, 一般默认0(Stereo), SE 设置3D音效效果, 分别体现3D 效果强弱。

另外<mark style="background: transparent; color: red">R39 设置DAC的混音器开关,</mark>
![[attachments/Pasted image 20240727170834.png]]
![[attachments/Pasted image 20240727170912.png]]
时钟控制如下: 
其中 slrck 设置ADC, DAC是否共用 LRC 
![[attachments/Pasted image 20240727170928.png]]
I2S 原理框图如下:  
![[attachments/Pasted image 20240727175042.png]]
对于 SPI 和 I2S 共用部分,  I2SMOD位部分可以, 

SD 为串行数据引脚,
WS 为字选择，用于切换左右声道, 频率 = 音频采样率, 映射到 NSS 部分 
CK 为串行时钟 (SCK/BCLK), 在I2S_CK 部分从 I2S clock Generator 中可以找到。
I2S2ext_SD  为相关的拓展引脚, 用于全双工
MCK 当 I2S 配置为主模式切 SPI_I2SPR 的 MCKOE 为1时, 被使能。  
对于 I2S_ext , 只能用于全双工且始终工作在从模式下, 此时两线均可以用于发送和接收。

I2S 支持以下四种数据和帧格式组合: 
![[attachments/Pasted image 20240727180620.png]]

> [!caution] 注意
> The 24-bit and 32-bit data frames need two CPU read or write operations to/from the SPI_DR or two DMA operations if the DMA is preferred for the application. For 24-bit data frame specifically, the 8 nonsignificant bits are extended to 32 bits with 0-bits (by hardware).
> 即在24或者32位下, 需要两次DMA操作

支持的 Philips 标准传输的 I2S 时序图如下: 
![[attachments/Pasted image 20240727180930.png]]
注意: SPI_DR 是16位 的寄存器, 在24位模式下的数据传输, 必须对SPI_DR执行两次读取或者写入操作。


> [!caution] 注意
> 从SD卡中得到的 wav 数据流是**低字节在前高字节**在后的,  因此16位存储时需要使用 `buff_i2s[i+1] <<8 +  buff_i2s[i]`, `SPI_DR = (uint16_t) buff_i2s[i-1]` 类似的操作，写入时会自动补齐 0 

### (4) 原理图部分说明
对于 LIN1 和 RIN 1, 接入的是 MIC_P 和 MIC_N, 即传入 DAC数据, 通道输入为 LINE_IN  部分, 而输出通道为 LOUT1, LOUT2 部分, 连接 PHONE 用于耳机输出(常见型号有 PJ-313, PJ-313B 和 PJ-320B， PJ326 等)
![[attachments/Pasted image 20240727220452.png]]
对于喇叭部分, 其输出仅来源于输出入通道2 (SPK_IN)

其二, <mark style="background: transparent; color: red">对于 DMA 数据的设置需要设为双缓冲循环模式</mark> , 以方便填充数据部分。

- 音频连接器接口设计参考 https://www.youtube.com/watch?v=PO96PH5BNr4 , 隐僻连接器 (TRS)-> Tip, Ring, Sleeve)  具体如下:
![[attachments/9169 1.png|550]]
参考下图, 实际上**含有的带弯折图部分是一个动触点**, 一般对于音频连接器,另外也有耳机兼容麦克风的接头(如PJ327系列), 

实际上, 一般下面的2和10是闭合的, 插入时, 下面的动开关2和10断开; 
参考[waht is audio jack switch](https://www.cuidevices.com/blog/understanding-audio-jack-switches-and-schematics)
![[attachments/Pasted image 20240727223903.png|750]]

<mark style="background: transparent; color: red">一般1脚即最靠近外部的引脚是接地的。</mark> 2 为 left 左声道, 一般连接音频信号的正极(LOUT1), 3 为 Right 右声道(ROUT1), 一般连接音频信号的负极。 
![[attachments/Pasted image 20240727225225.png|300]]
可以设计电路如图:
![[attachments/Pasted image 20240727225846.png]]

## 三、双缓冲I2S原理与DMA机制讲解
首先必须申请两片内存 M0AR，M1AR 部分, 程序填充好 M0AR （过程中 CPU 填充另外的内存M1AR）之后, 自动切换到 M1AR, 此时CPU填充 M0AR 部分, 
> [!caution] 注意
> 必须保证在发送过程中将另一个寄存器填满, 因此需要开启传输完成中断函数, 保证即时填满数据

| 函数                  | 说明                      |
| ------------------- | ----------------------- |
| es8388_init()       | ES8388初始化               |
| es8388_i2s_cfg()    | ES8388音频接口设置            |
| es8388_wres_cfg()   | 设置输出工作模式                |
| es8388_hpvol_set()  | 设置耳机音量                  |
| es8388_spkvol_set() | 设置扬声器音量                 |
| es8388_adda_cfg()   | ES8388 DAC/ADC配置        |
| es8388_mic_gain()   | ES8388 MIC增益(MIC PGA增益) |
| es8388_output_cfg() | ES8388输出配置              |
| es8388_alc_ctrl()   | ES8388 ALC控制            |
| es8388_input_cfg()  | ES83888 ADC输入配置         |

在 I2C 中， 起始信号是 0(Start) + 001000 + AD0 + RW 部分, 此处将 AD0 设置为0) 
可以通过 Es8388_write (0x2e或者 0x2f), 即寄存器 R46, R47 

双缓冲 DMA 是调用 `HAL_DMAEx_MultiBufferStart()` 函数进行设置的, 而<mark style="background: transparent; color: red">其中每个数据发送完毕之后, 硬件自动切换为下一个缓冲同时进入中断服务函数</mark>, **中断服务函数中, 执行切换缓冲区操作, 而主函数中执行填充数据到刚发送完的缓冲区操作。**

对于双缓冲区的 DMA 传输中断的编写: 仍然采用两个标志位的方式:
```c
volatile uint8_t wav_dma_ht_flag = 0;	 // half transfer 
volatile uint8_t wav_dma_tc_flag = 0;    // complete transfer 
```

如果是单缓冲区, 分成两个部分, 可以这样写:
```c
/// @brief get the flag of the DMA2_Channel3 and set the reading flag. 
void DMA2_Channel3_IRQHandler(void){
    if (DMA_GetITStatus(DMA2_IT_HT3) == SET){  // Half Transfer
        wav_dma_ht_flag = 1;
        wav_dma_tc_flag = 1;
        DMA_ClearITPendingBit(DMA2_IT_HT3);
    }else if (DMA_GetITStatus(DMA2_IT_TC3) == SET){  // Transfer Complete
        wav_dma_ht_flag = 0;
        wav_dma_tc_flag = 1;
        DMA_ClearITPendingBit(DMA2_IT_TC3);
    }
}
```

而对于双缓冲区的情况下, 往往需要判断上一个传输完成的是哪个缓冲区: 此时可以判断 DMA stream x 的 CT 位 (bit19), 表示current target;  其中:
0 表示 the currrent target memory is mem0;
1 表示 the currrent target memory is mem1;

另外需要注意的是, 发送的顺序其实和读取的顺序是不同的, 如下图所示:
![[attachments/Pasted image 20240730105149.png]]
对于<mark style="background: transparent; color: red"> 16 bit 的音频, 是可以直接读取数据直接填充到原始的 buff 中进行发送的</mark>, 

其二, 对于 I2S 的初始化, 参考[[💻softwares/⚡Circuit/🤖 STM32F4和HAL库部分教程/外设部分/2. DMA 外设的使用及DMA加速W25Q128|2. DMA 外设的使用及DMA加速W25Q128]], 中间不得缺少这两句:
```c
    /*##-5- Configure the NVIC for SPI #########################################*/
    HAL_NVIC_SetPriority(W25Qxx_SPI_IRQn, 0, 2);
    HAL_NVIC_EnableIRQ(W25Qxx_SPI_IRQn);
```
在SPI_CR2中即必须使能 TXDMAEN 位, 才能保证
![[attachments/Pasted image 20240730113816.png]]
实际上是调用了 `__HAL_I2S_ENABLE_IT` 来设置其中的CR2 寄存器, 应当使能这个中断, 才能让:
```c
__HAL_I2S_ENABLE_IT(&es8388_i2s_handler, I2S_IT_TXE);
__HAL_I2S_ENABLE(&es8388_i2s_handler);  /* start I2S enable bit -> must be added */  
// 这一句必须在初始化之后加上, 否则无法进入中断
```

> [!caution] 中断请求使能和处理使能函数的理解
> 对于 I2S 等等的TX标志位, 是没有相应的清除函数的(这是因为满后如果没有发送的仍然会置一), <b><mark style="background: transparent; color: red">我们需要使能 IRQ  但是不使能 IT </mark></b>, <b><mark style="background: transparent; color: blue">其中 IRQ(Interrupt Request) 表示特定的中断线请求,  即启用这个来保证请求可以发送到 DMA 部分, 而 __HAL_ENABLE_IT 是用于满足中断条件时, 触发中断处理程序</mark></b>，因此我们在使用DMA时一般不会调用 `__HAL_ENABLE_IT`, 但是需要使能 IRQn 请求。

上面部分即 SPI2 TX DMA请求使能, 但是这样实际上没有使能 I2S 的TX中断, **目前只能考虑使用直接操作 CR2 寄存器使能中断**:
```c

```


其二, **注意 DMA 请求的 TCIFx 部分, 对应TCIF0是针对Stream的部分, 因此对应的中断应当设置为 DMA_TCIF0_4**表示Stream4的中断, 

## 四、HAL 库的硬件 I2C 使用 
对于 I2C，一般首先都需要使用软件初始化并产生停止信号来停止总线的所有设备, 以避免总线死锁。
```c
/**
 * @brief       产生IIC停止信号
 * @param       无
 * @retval      无
 */
void iic_stop(void)
{
    IIC_SDA(0);     /* STOP信号: 当SCL为高时, SDA从低变成高, 表示停止信号 */
    iic_delay();
    IIC_SCL(1);
    iic_delay();
    IIC_SDA(1);     /* 发送I2C总线结束信号 */
    iic_delay();
}
```
在 硬件 I2C 的初始化中, 可以加入如下的中断函数, 用于将 HAL 库中的 I2C 事件中断继承初始的事件中断:
```c title:硬件I2C中断使用
/**
  * @brief  This function handles I2C event interrupt request.
  * @param  None
  * @retval None
  * @Note   This function is redefined in "main.h" and related to I2C data transmission
  */
void I2Cx_EV_IRQHandler(void)
{
  HAL_I2C_EV_IRQHandler(& I2CxHandle);
}

/**
  * @brief  This function handles I2C error interrupt request.
  * @param  None
  * @retval None
  * @Note   This function is redefined in "main.h" and related to I2C error
  */
void I2Cx_ER_IRQHandler(void)
{
  HAL_I2C_ER_IRQHandler(& I2CxHandle);
}
```

参考文章 [HAL库STM32常用外设教程（九）—— I2C通信（读写EEPROM](https://blog.csdn.net/That_Assassin/article/details/135981146) ,  可知:
首先 HAL 库提供了一个方便的函数用于检查是否存在: 
```c
if (HAL_I2C_IsDeviceReady(&es8388_i2c_handler, addr,10, 1000)== HAL_OK)
```

需要注意的是, 其中retry 一般不能设的太小, 可以设为10左右的值就可以基本上保证每次都初始化成功。
```c
HAL_I2C_IsDeviceReady(&es8388_i2c_handler,ES8388_ADDR, 10, 200); 
```
第二, 使用软件方法解除I2C 总线的死锁问题:
```c
void ES8388_Unlock(void){
    /** Use GPIO for Init */
    ES8388_GPIO_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    GPIO_InitStruct.Pin = ES8388_I2C_SCL_PIN;
    HAL_GPIO_Init(ES8388_I2C_SCL_GPIO, &GPIO_InitStruct);
    GPIO_InitStruct.Pin = ES8388_I2C_SDA_PIN;
    HAL_GPIO_Init(ES8388_I2C_SDA_GPIO, &GPIO_InitStruct);
    
    /** Generate Stop Signal In GPIO Mode */ 
    HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    /* write 16 clock pulse */
    for (int i = 0; i < 16; i++) {
        HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_RESET);
        HAL_Delay(2);
        HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
        HAL_Delay(2);
    }
    /* Stop Singal  */
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_RESET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SCL_GPIO, ES8388_I2C_SCL_PIN, GPIO_PIN_SET);
    HAL_Delay(2);
    HAL_GPIO_WritePin(ES8388_I2C_SDA_GPIO, ES8388_I2C_SDA_PIN, GPIO_PIN_SET);
    HAL_Delay(300);
}
```
其中, **如果需要初始化 EEPROM，只需给出其地址 0xA0 即可，而板载的地址也包括ES8388,其地址为0x20**; IIC 总线实际上如下所示:
![[attachments/Pasted image 20240728171409.png]]
对于硬件 I2C 的发送和接收函数, 重要的是如下几个函数:

| 函数 (Function)             | 功能描述 (Function Description) |
|---------------------------|-----------------------------|
| HAL_I2C_IsDeviceReady()   | 检查目标设备就绪状态                  |
| HAL_I2C_Master_Transmit() | 以主机发送数据到指定的从机设备             |
| HAL_I2C_Master_Receive()  | 以主机接收指定的从机设备发送来的数据          |
| HAL_I2C_Slave_Transmit()  | 以从机发送数据给主机，仅当主机请求时          |
| HAL_I2C_Mem_Write()       | 以主机模式向指定的从机设备内部地址写入数据       |
| HAL_I2C_Mem_Read()        | 以主机模式读取指定的从机设备内部地址的数据       |

注意使用使用 IT 是带中断式的读取和写入, 其中专门用于存储器读写的，具体如下:

| 函数名                        | 函数功能描述                   | 关联的回调函数                      |
|----------------------------|--------------------------|------------------------------|
| HAL_I2C_Master_Transmit_IT | 主设备向某个地址的从设备发送一定长度的数据    | HAL_I2C_MasterTxCpltCallback |
| HAL_I2C_Master_Receive_IT  | 主设备从某个地址的从设备接收一定长度的数据    | HAL_I2C_MasterRxCpltCallback |
| HAL_I2C_Master_Abort_IT    | 主设备主动中止中断传输过程            | HAL_I2C_AbortCpltCallback    |
| HAL_I2C_Slave_Receive_IT   | 作为从设备接收一定长度的数据           | HAL_I2C_SlaveRxCpltCallback  |
| HAL_I2C_Slave_Transmit_IT  | 作为从设备发送一定长度的数据           | HAL_I2C_SlaveTxCpltCallback  |
| HAL_I2C_Mem_Write_IT       | 向某个从设备的指定存储地址开始写入一定长度的数据 | HAL_I2C_MemTxCpltCallback    |
| HAL_I2C_Mem_Read_IT        | 从某个从设备的指定存储地址开始读取一定长度的数据 | HAL_I2C_MemRxCpltCallback    |
| HAL_I2C_ErrorCallback      | 所有中断方式传输函数中出现错误时调用       | 无                            |

General Call address detection，广播呼叫检测。设置为Disable表示禁止广播呼叫，不对地址0x00应答；否则，就是允许广播呼叫，对地址0x00应答。

实际写入函数和
```c
HAL_StatusTypeDef	EP24C_WriteOneByte(uint16_t memAddress, uint8_t byteData)
{
	HAL_StatusTypeDef result=HAL_I2C_Mem_Write(&I2C_HANDLE, DEV_ADDR_24CXX, memAddress,
			EP24C_MEMADD_SIZE, &byteData, 1, EP24C_TIMEOUT);
	return	result;
}
HAL_StatusTypeDef	EP24C_ReadOneByte(uint16_t memAddress, uint8_t *byteData)
{
	HAL_StatusTypeDef result=HAL_I2C_Mem_Read(&I2C_HANDLE, DEV_ADDR_24CXX, memAddress,
			EP24C_MEMADD_SIZE, byteData, 1,EP24C_TIMEOUT);
	return	result;
}
```

其中大小采用 I2C_MEMADD_SIZE_8BIT  8位地址部分
说明: **在硬件I2C传输中只需要定义一个固定的 I2C 地址(按8位算, 或者7位左移1位)**, **HAL 库会自动加上 R/W其中写为0,读为1, 进行发送, 需要注意，在读写过程中, 一定要加上等待函数**;

```c
void EEPROM_test(){
	EEPROM_i2cInit();
	/** Use EEPROM as test */
	if (HAL_I2C_IsDeviceReady(&es8388_i2c_handler, 0xA0, 5, 1000)== HAL_OK){
		printf("EEPROM is ready\r\n");
	}
	uint8_t data = 0x55, res = 0;
	if (HAL_I2C_Mem_Write(&es8388_i2c_handler, 0xA0, 0, I2C_MEMADD_SIZE_8BIT, &data, 1, 0xffff)){
		printf("Write failed\r\n");
		return 1;
	}
	HAL_Delay(10);    /* This Delay must be add during the write and read */
	if (HAL_I2C_Mem_Read(&es8388_i2c_handler, 0xA0, 0, I2C_MEMADD_SIZE_8BIT, &res, 1, 0xffff)){
		printf("Read failed\r\n");
		return 1;
	};
	printf("res: %x\r\n", res);
}
```

参考 原理图
![[attachments/Pasted image 20240728202441.png]]
以及程序框图, ADC是接入 LIN 和 RIN 部分的, 因此不使用 MIC 可以考虑不开启 ADC, 
![[attachments/Pasted image 20240728202456.png|800]]
同时, LIN 和 RIN 对于 DACR, DACL 中也有选择通道, 可以选用是否进行获取。

R4 寄存器用于配置 LOUT1, LOUT2, ROUT1, ROUT2 的音频, <mark style="background: transparent; color: red">在板载的部分, ROUT2 和 LOUT2 是用电容混音后, 接入 SPK_IN 喇叭部分的, 而 LOUT1, ROUT1 接入 PHONE  耳机输出接口 </mark> 

此时， 写入和读取寄存器的函数可以如下方法进行:
```c
/**
 * @brief Write the register of ES8388
 * @note  The register address is 8-bit, and the data is 8-bit 
 * 
 */
uint8_t ES8388_write_reg(uint16_t reg_addr, uint8_t data){
    uint8_t res = 0;
    res = HAL_I2C_Mem_Write(&es8388_i2c_handler,ES8388_ADDR ,reg_addr,I2C_MEMADD_SIZE_8BIT, &data, 1, ES8388_TIMEOUT);
    HAL_Delay(2);  // This Delay must be add during the write and next operation */
    return res;
}

/**
 * @brief Read the register of ES8388
 * @param reg_addr 
 * @param data 
 * @return  
 */
uint8_t ES8388_read_reg(uint16_t reg_addr, uint8_t *data){
    uint8_t res = 0;
    res = HAL_I2C_Mem_Read(&es8388_i2c_handler, ES8388_ADDR, reg_addr, I2C_MEMADD_SIZE_8BIT, data, 1, ES8388_TIMEOUT);
    HAL_Delay(2); // This Delay must be add during the write and next operation */
    return res;
}
```

对于 DMA 初始化，采用 I2S 作为触发源, 参考[[💻softwares/⚡Circuit/🤖 STM32F4和HAL库部分教程/外设部分/2. DMA 外设的使用及DMA加速W25Q128|DMA 外设的使用及DMA加速W25Q128]] 部分, 类似SPI地, **使用 SPI2_TX 作为触发源**, 即使用 DMA1 Stream4, Channel0 部分;


采样率时钟配置需要用到如下的两个重要函数 : 
其中 PeriphCLKConfig 用于配置  PLLI2SN, PLLI2SR 部分, 
```c
HAL_RCCEx_PeriphCLKConfig(&ES8388_I2S_PeriphCLKInit);
HAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit);
#define __HAL_RCC_I2S_CONFIG(__SOURCE__) (MODIFY_REG(RCC->CFGR, RCC_CFGR_I2SSRC, (__SOURCE__))) 
```

其中第三个是设置时钟源, 有如下两个参数:
- `RCC_I2SCLKSOURCE_PLLI2S`：使用 PLLI2S 作为 I2S 时钟源。
- `RCC_I2SCLKSOURCE_EXT`：使用外部时钟作为 I2S 时钟源。

在 HAL_SPI_I2S_Init 函数中就有了相关的波特率设置, 但是需要注意:
```c
   -@- Make sure that either:
        (+@) I2S PLL clock is configured or
        (+@) External clock source is configured after setting correctly
             the define constant EXTERNAL_CLOCK_VALUE in the stm32f4xx_hal_conf.h file.
```
其中 EXTERNAL_CLOCK_VALUE = 12288000U (即12.288MHz)

其中 Init 函数调用了这个函数: 
```c
HAL_RCCEx_GetPeriphCLKFreq
```

实际上是这样写的 : 
```c
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
  uint32_t srcclk = 0U;
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
  switch (PeriphClk)
  {
  case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
      switch (srcclk)
      {
      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
      case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
          break;
        }
      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */
      case RCC_I2SCLKSOURCE_PLLI2S:
        {
#if defined(STM32F411xE)
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
#else
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
          break;
        }
        /* Clock not enabled for I2S*/
      default:
        {
          frequency = 0U;
          break;
        }
      }
      break;
    }
  default:
    {
       break;
    }
  }
  return frequency;
}
```

根据: 
$$ I2S \space Clocks  =  8MHz * PLL2SN / 8(M)  / PLL2SR   $$
我们只需要设置PLL2SN = 86,   PLL2SR = 7, 则对应的频率为  12.28571MHz, 与12.288MHz误差为 0.018%, 符合预期。

因此实际上只要这样写即可: 
```c
uint8_t musicplayer_setSampleRate(uint32_t audio_freq){
    __HAL_RCC_I2S_CONFIG(RCC_I2SCLKSOURCE_PLLI2S);    /* use PLLI2S as I2S clock source */
    
    RCC_PLLI2SInitTypeDef i2s_clk = {0};
    i2s_clk.PLLI2SN = 86;
    i2s_clk.PLLI2SR = 7;
    HAL_RCCEx_EnablePLLI2S(&i2s_clk);
    
    __HAL_I2S_DISABLE(&es8388_i2s_handler);
    es8388_i2s_handler.Init.AudioFreq = audio_freq;
    ES8388_Init(audio_freq);
    __HAL_I2S_ENABLE(&es8388_i2s_handler);
    return 0;
}
```


![[attachments/Pasted image 20240729152302.png]]
需要注意的是, 在初始化中断完成之后, 一定要清除对应中断的标志位, 这样才能够进行:
```c
__HAL_DMA_CLEAR_FLAG(&es8388_dma_handler, ESP8388_I2S_DMA_TC_FLAG);   /** Clear DMA transfer complete flag */
```



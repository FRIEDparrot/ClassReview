## 1. GBK 编码 
一般  GBK 采用双字节编码, 共有 23940 个码位, 收录 21886 个汉字(21003)和符号(883), GB2312 是专用简体的中文编码, 而 GBK 是其扩充部分;

由于 GBK 文件较大而 GB2312 比较小, 所以对于小 Flash 部分, 可以采用 GB2312 编码, 

| 字符集         | 编码长度       | 说明                         |
| ----------- | ---------- | -------------------------- |
| ASCII       | 1个字节       | 拉丁字母编码，仅128个编码，最简单         |
| GB2312      | 2个字节       | 简体中文字符编码，包含约6000多汉字编码      |
| GBK         | 2个字节       | 对GB2312的扩充，支持繁体中文，约2W多汉字编码 |
| BIG5        | 2个字节       | 繁体中文字符编码，在台湾、香港用的多         |
| **UNICODE** | **一般2个字节** | **国际标准编码，支持各国文字**          |

编码规则简介: GBK 编码中, 由于 ASCII 码的编码范围是 0-127, 而高字节最小是 0x81 (129) 作为区分。

| 字节        | 范围              | 说明                          |
| --------- | --------------- | --------------------------- |
| 第一字节（高）   | 0X81~0XFE       | 共126个区（不包括0X00~0X80，以及0XFF） |
| 第二字节（低）   | 0X40~0X7E       | 63个编码（不包括0X00~0X39，以及0X7F）  |
| 0X80~0XFE | 127个编码（不包括0XFF） |                             |

一般使用 printf %x 可以直接获取汉字的 GBK 编码, 一般只需要搜索在点阵字库中的位置, 即可找到对应的字库点阵进行取模, 描点和还原;(一个点仅有0,1两种)

一般对于 16 x 16 的点阵(256byte)**一个字为 16 x 16/8 = 32byte, 23940个汉字占用的空间为 0.76 MB 左右**, 可以使用 W25Q64 等进行存储。 

首先是字库 (常见的有12/16/24)大小的字库;(**一般采用ATK-XFONT即可制作字库**),进入字库模式, 自行制作即可。
![[attachments/Pasted image 20240722185836.png]]
设置取模方式如图: 
![[attachments/Pasted image 20240722190157.png|600]]

生成 .txt 以及 .bin 文件, 
首先, 重点是**先获取汉字点阵的相对位置, 由于文件读取比较慢, 所以一般可以通过跳转文件指定位置的方式进行读取** 

通过ASCII 查找汉字: 通过低字节判断
1. GBKL < 0x7F时，Hp = ((GBKH – 0x81) * 190 + (GBKL – 0x40)) * csize
2. GBKL > 0x7F时，Hp = ((GBKH – 0x81) * 190 + (GBKL – 0x41)) * csize 

其中，首先根据 GBKH 判断出所在的区, 每个区共有 63 + 127 共 190 个编码; 此时, 判断GBKL, 当 GBKL < 0x7F,  使用 + (GBKL - 0x40); 否则使用 + (GBKL - 0x41, 跳过0x7F)

| 字节      | 范围        | 说明                          |
| ------- | --------- | --------------------------- |
| 第一字节（高） | 0X81~0XFE | 共126个区（不包括0X00~0X80，以及0XFF） |
| 第二字节（低） | 0X40~0X7E | 63个编码（不包括0X00~0X39，以及0X7F）  |
|         | 0X80~0XFE | 127个编码（不包括0XFF）             |

此时，我们定义 CSIZE = 2bytes (16), 则可以**定位到点阵的存储位置**。而发送汉字时, 发送的是GBK编码, 此时即可直接从 bin 中获取相应的位置;

一般而言, 为了取模的大小是8的整倍数, 我们往往使用 12, 16, 24 大小的进行取模和字库制作。

## 2. Unicode 转 GBK 
另外, **unicode 转 gbk 文件**(ugbk), 另外, 对于FATFS使用长文件名时, 会使用 ffunicode.c 中的 uni2oem936 和 oem2uni936, 这导致会占用极大的 Flash(172kb). 因此一般使用:
```c
#define FF_USE_LFN		0
```

如果定义为 1, 则会导致占用约 500kb Flash, 而不为1时, 则不支持长度为 12 以上的命名;

实际上, ffunicode.c 文件的函数仅有最下方调用的3个, 而大数组可以通过文件直接存储。
因此我们可以考虑将 uni2oem936 数组和 oem2uni936 转换为 bin 文件 (C2B 转换); 然后直接通过将文件存储在


## 3. ILI9341 触屏硬件SPI移植部分
在触屏函数中， TP_Read_AD 是通过 SPI 方法读取触屏坐标的函数, 在高速滑动中, 读取的坐标不一定相同。因此一般使用多次读取和舍弃最值的方法: 下面的代码首先读 READ_TIMES = 5次, 排序后, 前后舍弃 1 个数, 其余3个读取的值作平均得到触屏的触摸点坐标。
```c
uint16_t TP_Read_XOY(uint8_t cmd)
{
    uint16_t i, j;
    uint16_t buf[READ_TIMES];
    uint16_t sum=0;
    uint16_t temp;
    for(i=0;i<READ_TIMES;i++){   // read 5 times
        buf[i]=TP_Read_AD(cmd);
    }
    /** sort the data in ascending order */
    for(i=0;i<READ_TIMES-1; i++)
    {
        for(j=i+1;j<READ_TIMES;j++)
        {
            if(buf[i]>buf[j]) 
            {
                /** Switch the i,j  */
                temp=buf[i];
                buf[i]=buf[j];
                buf[j]=temp;
            }
        }
    }
    sum=0;
    for(int i=LOST_VAL;i<READ_TIMES-LOST_VAL;i++){
        sum+=buf[i];
    }
    temp=sum/(READ_TIMES-2*LOST_VAL);
    return temp;
}
```

我们可以采用更快的方式: 
1. 首先读取 6 个数, 将最大值和最小值先赋值`buf[0]`, 使用一个for循环依次比较; 当获取到读数之后, <mark style="background: transparent; color: red">减去最大值和最小值</mark>, 剩余 4 个数; 此时除4的操作可以使用 >> 2 来代替, 以获得更高的运算效率。

修改的函数如下:
```c
uint16_t TP_Read_XOY(uint8_t cmd)
{
    /** read 6 times, throw the maximum and minimum, return the average of others */
    uint16_t i, j;
    uint16_t buf[6];  
    uint16_t sum=0;
    uint16_t maxval, minval;

    /*** Change to Hardware SPI read later */
    for(i=0;i< 6; i++){   // read 5 times
        buf[i]=TP_Read_AD(cmd);
    }

    maxval = buf[0]; minval = buf[0];
    for (i = 0; i < 6; i++)
    {
        if (buf[i] > maxval) maxval = buf[i];
        else if (buf[i] < minval) minval = buf[i];
        sum += buf[i];
    }
    sum -= (maxval + minval); 
    return (sum >> 2);
}
```


对于触屏的状态, 使用了一个独热编码进行定义:
```c
tp_dev.sta|=TP_CATH_PRES;       // 捕获状态
tp_dev.sta |= TP_PRES_DOWN;   // 按下状态
```


对于传输的移植方式: 首先查找 XPT2046 驱数据手册:
![[attachments/Screenshot_20240724_122252_com.microsoft.skydrive.png|900]]
时钟在空闲为低电平(CPOL = 0), 在上升沿获取数据(CPHA = 0)
另外上图可以看出, 在传输 Command 之后, 实际上需要一个时钟进行等待, 然后<mark style="background: transparent; color: red">第二个时钟从位11开始传输, 因此我们首先传输两个0xff</mark>,得到的**第一个左移5位，第二个右移3位相加, 得到的即为所获得的屏幕坐标**。

重点需要注意的是 CS 的操作, 每次读写完一个字节之后都要进行 先拉下后释放片选, 因此必须将片选操作套在循环内, 不能放在循环外面 (这样一周就少了5次)

## 4. 中文字模GBK编码和文件读取
理论上的字模为从高到低排列:
{0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x41,0x80,0x5F,0x00,0x61,0x04,0x41,0x04,} 而实际上文件存储的 0x00 数据更多，如图所示:
![[attachments/Pasted image 20240724224914.png]]
实际字模每4个之间有一个0x00填充, 这是由于生成问题造成的; 
原始编码方法如图: 一定要仔细核对汉字编码是否正确和紧凑:
![[attachments/Pasted image 20240724230030.png|1200]]

```c
uint8_t LCD_ShowGBK(uint16_t x, uint16_t y, uint8_t *buff, uint8_t font_size){
	uint8_t width;
	switch (font_size){
	case GBK_FONT_SIZE_12:
					width = 12;
					break;
	case GBK_FONT_SIZE_16:
					width = 16;
					break;
	case GBK_FONT_SIZE_24:
					width = 24;
					break;
	default:
		return 1;  // no font input 
	}
	POINT_COLOR = BLACK;
    for (uint8_t i = 0; i < width; i++) {
        uint16_t tmp = ((uint16_t)buff[2* i]  << 8)  + (buff[2* i + 1]);
		/** from up to down to fill the y coor */
		for (uint8_t j = 0; j < width; j++){
			if (tmp & 0x8000){
				ILI9341_DrawPoint(x + i, y + j);
			}
			tmp <<= 1;
		}
    }
	return 0;
}
```

对应的获取编码的代码如下:   
```c
/// @brief get the matrix of pixels from gbk code 
/// @param gbk_code  
/// @param buff 	 buffer to receive the matrix of pixels 
/// @param font_size use  GBK_FONT_SIZE_12, GBK_FONT_SIZE_16, GBK_FONT_SIZE_24
/// @note  Flash  must be initialized before using gbk
/// @return 0: succeed ,1 file open error, 2: not valid gbk code 
uint8_t GBK_FONT_GetCode(uint16_t gbk_code, uint8_t* buff, uint8_t font_size){
	FIL fp; uint8_t font_size_bytes;
	uint8_t hb = (gbk_code >> 8), lb = (gbk_code & 0xff);

	printf("hb: %x, lb: %x\r\n", hb, lb);

	char fname[MAX_ABSOLUTE_PATH_LENGTH];
	if ((gbk_info.Font_exist & font_size) == 0){
		return 1;   // no font file 
	}
	switch (font_size){
	case GBK_FONT_SIZE_12:
					sprintf(fname, "%s/%s/%s", W25Qxx_ROOTDIRECTORY, FONT_FOLDER, GBK12_STD_FONT_FILE_NAME);
					font_size_bytes = gbk_info.gbk12size;
					break;
	case GBK_FONT_SIZE_16:
					sprintf(fname, "%s/%s/%s", W25Qxx_ROOTDIRECTORY, FONT_FOLDER, GBK16_STD_FONT_FILE_NAME);
					font_size_bytes = gbk_info.gbk16size;
					break;
	case GBK_FONT_SIZE_24:
					sprintf(fname, "%s/%s/%s", W25Qxx_ROOTDIRECTORY, FONT_FOLDER, GBK24_STD_FONT_FILE_NAME);
					font_size_bytes = gbk_info.gbk24size;
					break;
	}

	/*** Firstly, judge if the character is in gbk ***/
	if (hb < 0x81 || lb < 0x40 || lb == 0xff || hb == 0xff){
		return 2;
	}
	FRESULT res = f_open(&fp, fname, FA_READ);
	if (res != FR_OK){
		return 1;
	}
	unsigned long font_addr = 0 ;
	if (lb < 0x7f){  // GBK Code  
		font_addr = ((unsigned long)190 * (hb - 0x81) + lb - 0x40) * font_size_bytes;
	}
	else if (lb > 0x7f)
	{
		font_addr = ((unsigned long)190 * (hb - 0x81) + lb - 0x41) * font_size_bytes;
	}else{
		printf("unknwon GBK code: %x%x\r\n", hb, lb);
	}
	if (f_lseek(&fp, font_addr)!=FR_OK || f_read(&fp, buff, font_size_bytes, NULL)!=FR_OK){ // file destrooyed
		f_close(&fp);
		return 1;
	}
	f_close(&fp);
	return 0;
}
```

## 一、FreeRTOS 简介
### (1) FreeRTOS 任务调度基本原理
RTOS (real-time operating system)  实时操作系统，用于执行CPU的调度和多任务并行处理。
首先创建多个任务, 并且在多任务中可以进行调度。并使用一个滴答定时器进行计时, 实现多任务管理。[^1]

[^1]: 注意前提: 两个任务优先级相同时, 则可以通过滴答定时器进行计时和任务调度切换。
RTOS 在一个时间片中, 也只能执行一个任务, 而切换原理是通过滴答定时器在不同任务之间进行调度切换的。(在FreeRTOS 中, 这个是time service task 概念, 也叫dameon task)
![[Excalidraw/5. STM32F4 的 FREERTOS 操作系统移植 2024-07-16 20.34.00|700]]


对于不同优先级的部分， **裸机一般通过中断进行, 但不能够处理较多的事情。如果通过中断置标志位, 也不能直接进行更高优先级顺序的任务调度, 实时性差。**

而RTOS操作系统, 仍然也是<mark style="background: transparent; color: red">创建一个更高优先级的任务</mark>。更高优先级的任务会立即抢占低优先级任务。但是，==**更高优先级的任务中仍然具有空余部分(系统), 此时则将其可以分配给低优先级任务让其执行**==。对于中断服务程序,可以抢占任务进行执行。

一般而言, 裸机称为前后台系统;  前台为中断函数; 后台为系统应用程序; 
而对于 RTOS 系统, 具有:
1. **任务分治, 实时性好**
2. 每个任务均有各自的无限循环。<mark style="background: transparent; color: red">通过延时函数进行任务调度</mark>, 
3. 任务的不同优先级可以进行**相互的抢占**。
4. **任务堆栈特点** : 低优先级的任务会高优先级的打断点继续执行。因此会通过任务堆栈进行获取, 每个任务均有各自栈空间，保存断点信息。
中断可以打断任何任务。

FreeRTOS 一般比较轻量级, 并且易于移植。 另外软件优先级方法实际上是不限优先级个数的, 而硬件优先级情况下, 则32位单片机限制在 32 个优先级(0-31), **数字越大优先级越高**，可以设置同样的优先级。

由于任务堆栈大小不同, 多任务情况下, 堆栈大小可能要求比较高。
支持抢占， 协程，时间片流转式任务调度。

另外就资料而言, UCOS 资料更加齐全, 而 FreeRTOS 比较少。
需要注意: <mark style="background: transparent; color: red">任务切换是和芯片架构密切相关的, 因此必须了解 Cortex-M4 内核, 才能了解 FreeRTOS 的实际使用方法。</mark>

### (2) FreeRTOS 基础知识
**任务调度器**: 使用调度算法决定当前执行的任务。

首先, FreeRTOS 支持三种调度方式:
1. 抢占式调度: 高优先级任务抢占低优先级任务(数值大, 则优先)。
2. 时间片调度: 多任务优先级相同, 则每个系统时钟节拍都会切换任务。
3. 协程式调度(不再更新): 当前执行任务将会一直执行(实时性不好)

每个任务就绪时, 则会开始运行, 并抢占。一般在<mark style="background: transparent; color: red">系统延时或者等待信号量时, 会阻塞进程</mark> 
在FreeRTOS 中, <b><mark style="background: transparent; color: blue">一个时间片等于 Systick 中断周期</mark></b>，中断周期一般设置为 1ms; 如果没有执行到时间片边界, 则丢掉其余的时间片, 仅按照一个时间片为周期运行。

**任务状态**: 共有4种状态: 
1. **运行态** (同一时间仅有1个任务在运行态)
2. **就绪态** (准备好但是没有被执行)
3. **阻塞态** (使用Delay 或等待信号阻塞)
4. **挂起态** 调用 vTaskSuspend 进入任务的挂起状态。对应的 vTaskResume() 函数进行解除挂起状态。(可以不执行对应的任务)
具体转换图如下所示:
![[attachments/Pasted image 20240716223758.png]]

<mark style="background: transparent; color: red">除了运行态以外, 其他的每个状态均有其对应的任务列表</mark>, 类似于链表属性, 将任务进行
1. 就绪列表: `pxReadyTasksLists[x]`, 其中 x 为优先级(0-31, 硬件方法比较高效),一般从其中挑选并执行。当有任务时置一, 从大到小找到对应的最高优先级部分, 即可开始运行。
2. 阻塞列表: `pxDelayedTaskList` , 恢复阻塞后，回到就绪列表。
3. 挂起列表: `xSuspendedTaskList` , 解除挂起后, 回到就绪列表。

对于相同优先级的任务, 会按照如图结构连接到就绪列表中。 实际上是一个链表指针结构
![[attachments/Pasted image 20240716224123.png|900]]
此处使用 FreeRTOS 10.5.1 进行stm32开发板的移植

### (3) 源码基本结构
对于 FreeRTOS 组件, FreeRTOS-plus 中提供了 TCP, UDP 等等组件, 一般我们一般使用第三方组件进行实现。 tools 中为工具文件。

在 FreeRTOS > Source 中, 有文件: 

| 名称              | 描述                    |
| --------------- | --------------------- |
| include         | ==内包含了FreeRTOS的头文件==  |
| portable        | ==内包含了FreeRTOS的移植文件== |
| croutine.c      | 协程相关文件(不用不加)          |
| event_groups.c  | 事件相关文件(可不添加)          |
| list.c          | ==列表相关文件==            |
| queue.c         | ==队列相关文件==            |
| stream_buffer.c | 流式缓冲区相关文件 (可不加)       |
| tasks.c         | ==任务相关文件==            |
| timers.c        | 软件定时器相关文件 (如果不用不加)    |
这些均为和移植密切相关的文件。 其中 list, queue 和 task 均为核心文件。

在 portable 中找到 cortex-M4 部分, 并必须有如下的两个文件夹:

| 文件夹     |           |
| ------- | --------- |
| RVDS    | 不同内核的芯片部分 |
| MemMang | 内存管理部分    |

### (4) FreeRTOS 实际移植过程
1. 添加 FreeRTOS 源码 
2. 将 port.h 修改为  FreeRTOSConfig.h 文件并添加到工程
3. 修改 System 文件夹  (sys.c,  delay.c m usart.c), 定义 USE_OS
4. 修改中断相关文件 Systick 中断, SVC 中断和 PendSV 中断 
5. 验证移植是否成功

一般首先添加两个文件夹 Middlewares/FreeRTOS_Core, 以及 Middlewares/FreeRTOS_PORT 部分;

使用带有**整套内存管理的工程进行移植**部分。首先保证内存管理 malloc 正常进行; 第二, 使用定时器部分的 bTimer.h 和 bTimer.c 部分, 也添加到移植部分。

在此处仅使用 heap_4的算法4进行内存管理。 CORE 添加路径下的全部源码,而 PORT仅添加 heap_4.c 和 port.c 部分。
![[attachments/Pasted image 20240717004918.png]]
然后将 portmacro.h 放到 Include 文件夹里面方便管理; 

最后直接从例程DEMO 中找到 FreeRTOSConfig.h , 复制到Include文件夹下(注意不一定是最新版的);

> [!NOTE] 说明
> 官方对于 FreeRTOSConfig.h 文件编写办法做了详细的说明, 详细见 https://www.freertos.org/a00110.html 

然后修改 Config 文件: 
首先, FreeRTOSConfig 中没有 SystemCoreClock 定义, 而这个定义是在 stm32f4xx 中的, 因此可以添加 `extern uint32_t SystemCoreClock` 使用该文件中变量; 
然后参考例程添加: 1. 为了配置优先级, 使用这一句:
```c
#define configUSE_PORT_OPTIMISED_TASK_SELECTION         1     /* 1: 使用硬件计算下一个要运行的任务, 0: 使用软件算法计算下一个要运行的任务, 默认: 0 */
```
2. 修改断言函数:
```c
#define vAssertCalled(char, int) printf("Error: %s, %d\r\n", char, int)
#define configASSERT(x) if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )
```

删除 usart.c,  delay.c 等中的 UCOS 相关内容, 其中 delay.c 仅保留 systick_handler 句柄和 init 函数; 并将 if use_OS 部分改为
```c
#incude "FreeRTOS.h"
#include "task.h"
``` 

修改 UART_Handler 为:
```c
void USART_UX_IRQHandler(void)
{
    HAL_UART_IRQHandler(&g_uart1_handle);       /* 调用HAL库中断处理公用函数 */

    uint32_t timeout = 0;
    uint32_t maxDelay = 0x1FFFF;
    while (HAL_UART_GetState(&g_uart1_handle)
    != HAL_UART_STATE_READY) /* 等待就绪 */
    {
        timeout++; /* 超时处理 */
        if(timeout > maxDelay){
            {
            break;
            }
        }
        timeout=0;
        /* 一次处理完成之后，重新开启中断并设置 RxXferCount 为 1 */
        while (HAL_UART_Receive_IT( &g_uart1_handle, (uint8_t *)g_rx_buffer,  RXBUFFERSIZE) != HAL_OK)
        {
            timeout++;/* 超时处理 */
            if (timeout > maxDelay)
            {
            break;
            }
        }
    }
}
```
修改 systick_handler 如下图:
```c
void SysTick_Handler(void)
{
    uint32_t ulPreviousMask;
    
    HAL_IncTick();
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
    {
        ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
        
        /* Increase the  RTOS clock */
        if (xTaskIncrementTick() != pdFALSE){
            /* Pend a context switch  */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
}
```

delay_init 主要修改 systick 的重装值, 其中使用 168 为参数, 则 168 Mhz 
$$Tick = \frac{1}{configTICK\_RATE\_{HZ}} =  \frac{1}{168 MHz} * reload$$
则容易给出reload 计算公式(见代码)
```c 
void delay_init(uint16_t sysclk)
{
#if SYS_SUPPORT_OS                                      /* 如果需要支持OS */
    uint32_t reload;
#endif
    g_fac_us = sysclk;                                  /* 由于在HAL_Init中已对systick做了配置，所以这里无需重新配置 */
#if SYS_SUPPORT_OS                                      /* 如果需要支持OS. */
    reload = sysclk;                                    /* 每秒钟的计数次数 单位为M */
    reload *= 1000000 / configTICK_RATE_HZ;             /* 根据delay_ostickspersec设定溢出时间,reload为24位
                                                         * 寄存器,最大值:16777216,在168M下,约合0.09986s左右
                                                         */
    
    SysTick->CTRL |= 1 << 1;                            /* 开启SYSTICK中断 */
    SysTick->LOAD = reload;                             /* 每1/delay_ostickspersec秒中断一次 */
    SysTick->CTRL |= 1 << 0;                            /* 开启SYSTICK */
#endif
}
```

延时微秒直接套用原先裸机移植函数:
```c
void delay_us(uint32_t nus)
{
    uint32_t ticks;
    uint32_t told, tnow, tcnt = 0;
    uint32_t reload = SysTick->LOAD;        /* LOAD的值 */
    ticks = nus * g_fac_us;                 /* 需要的节拍数 */
    
    told = SysTick->VAL;                    /* 刚进入时的计数器值 */
    while (1)
    {
        tnow = SysTick->VAL;
        if (tnow != told)
        {
            if (tnow < told)
            {
                tcnt += told - tnow;        /* 这里注意一下SYSTICK是一个递减的计数器就可以了 */
            }
            else
            {
                tcnt += reload - tnow + told;
            }
            told = tnow;
            if (tcnt >= ticks) 
            {
                break;                      /* 时间超过/等于要延迟的时间,则退出 */
            }
        }
    }
}
```

最后参考 FreeRTOSConfig.h 中的定义:
```c
#define configPRIO_BITS       		__NVIC_PRIO_BITS // 这个在HAL 库有相关定义  
```

修改stm32f407xx.h下面的4U为4, 否则会出现运算错误:
```
#define __NVIC_PRIO_BITS          4U       /*!< STM32F4XX uses 4 Bits for the Priority Levels */
```

然后修改中断部分, 首先, 中断函数it.c 就已经提供了SVC, PendSV 中断函数, 而 SysTick 中断函数已经在 delay 中定义了。因此修改 stm32f4xx_it.c文件如下 : 
```
#include "../sys/sys.h"

#if (!SYS_SUPPORT_OS)
/**
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}

/**
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
}

/**
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
}
#endif
```

最后, port.c 中提供了 SysTICK Hndler 的实现, 此处将其注释掉。
```c title:port.c中有如下几个函数，其中将xPortSysTickHandler注释掉
void xPortSysTickHandler( void ) 
__asm void xPortPendSVHandler (void )
__asm void vPortSVCHandler( void )
```

编译得到如下报错:
![[attachments/Pasted image 20240717095322.png]]
参考例程修改 FreeRTOSConfig.h, 修改:
```
#define configCHECK_FOR_STACK_OVERFLOW	0
#define configUSE_IDLE_HOOK                             0                       /* 1: 使能空闲任务钩子函数, 无默认需定义  */
#define configUSE_TICK_HOOK                             0
```
构建成功, 则  FreeRTOS 框架移植完成。

### (5) 应用程序编写和测试
编写 freeRTOS 程序实现两个灯一个以 1s 间隔闪烁, 另一个以 2s 间隔闪烁，测试程序代码如下:(保存为FreeRTOStask.c来测试)
创建任务的代码为: `xTaskCreate(task2, "task2", TASK2_STACK_SZ, NULL, TASK2_PRIOR, &task2_handler);`

```c
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"

/*  at first , define the  task heap size */
#define TASK1_PRIOR     1
#define TASK1_STACK_SZ  128 

#define TASK2_PRIOR     1
#define TASK2_STACK_SZ  128 

static TaskHandle_t task1_handler;
static TaskHandle_t task2_handler;

void task1(void *pvParameters);
void task2(void *pvParameters);

void freertostask(void){
    xTaskCreate( (TaskFunction_t)    task1,
                 (const char*   )    "task1",       // task name 
                 (uint16_t      )    TASK1_STACK_SZ,
                 (void*         )    NULL,
                 (UBaseType_t   )    TASK1_PRIOR,
                 (TaskHandle_t* )    &task1_handler
                );
    xTaskCreate(task2, "task2", TASK2_STACK_SZ, NULL, TASK2_PRIOR, &task2_handler);
    vTaskStartScheduler();
}

void task1(void *pvParameters){
    while (1)
    {   
        HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_9);
        vTaskDelay(1000);
    }
}

void task2(void *pvParameters){
    while (1)
    {
        HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_10);
        vTaskDelay(2000);
    }
}

```

## 二、FreeRTOS 系统配置文件说明
参考 https://freertos.org/a00110.html 
**支持 FREERTOS 的配置和裁剪, 并进行 API 函数的使能和失能**。
FreeRTOS 中, **主要有三类宏定义**:

| ConfigUSE | INCLUDE               | 其他配置项                                |
| --------- | --------------------- | ------------------------------------ |
| 功能的配置和裁剪  | 用于配置FreeRTOS中的可选API函数 | PendSVC 和SVC 中断服务的宏定义, 一般通过port.c 定义 |

对于**具有默认值自定义的宏部分, 在FreeRTOS.h 中有相关的定义**, 

#### 1. 内核和基本宏定义
例如抢占式调度和协程式调度配置(高优先级的不能打断低优先级):
```c
#define configUSE_PREEMPTION // Set to 1 to use the preemptive RTOS scheduler, or 0 to use the cooperative RTOS scheduler
.
#define configMAX_PRIORITIES                         5      // 最高优先级, 一般设置为32, 注意: 当启用 configUSE_PORT_OPTIMISED_TASK_SELECTION 1 时, 则会之后直接覆盖   // 
#define configMINIMAL_STACK_SIZE                128  // (按字计算的堆栈大小) *4 
#define configMAX_TASK_NAME_LEN                 16  //  任务最大名字长度
```

FreeRTOS ports **have two methods of selecting the next task to execute** - a generic method, and a method that is specific to that port.
**if use 0, use Generic Method, 1 use port specific Method**; 
```c
#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0    // 
```

注意: 通用任务调度方法一般效率比较低, 而 port specific method 为硬件优先级调度方法。对 stm32 仅支持 32 个任务优先级。是基于 `Count Leading Zeros [CLZ]` 计算前导0 结构来进行实现的。

#### 2. 系统时钟相关宏定义
```c
// 下面几个 FreeRTOS 的宏是定义系统时钟的 
#define configCPU_CLOCK_HZ                      60000000   // 一般设置为 SystemCoreClock 
#define configSYSTICK_CLOCK_HZ              60000000/8 // Systick, F1仅有 Systick 设定被打开,  而F4 不需打开 ;  配置滴答定时器, 注意时钟源频率与内核频率不同时需要定义; 
#define configTICK_RATE_HZ                        1000   //  SysTick 的时钟滴答频率
#define configUSE_16_BIT_TICKS                  0          // 
#define configTICK_TYPE_WIDTH_IN_BITS           TICK_TYPE_WIDTH_16_BITS  //  定义
```
对于定义的 SystemClock, 在stm32f407xx.c中有定义:
```
uint32_t SystemCoreClock = 16000000; 
```
而实际上在 Main 函数中的 `SystemClock_Config()` 会调用 `HAL_RCC_ClockConfig` **重新设定SystemCoreClock** 最终设定为 168000000 为CPU主频;

注意:**有时, SysTick 时钟频率来源可能和内核频率不同; 对于 Cortex-M4 内核是相同的, 但是 Cortex-M3 内核中 SysTick 的 HCLK 进行 8 分频, 即 9MHz; 这是F1 和F4的唯一设置区别**。另外, 不需要相关定义, 已经自动设置为 / 8 的部分; 

对于 `configUSE_16_BIT_TICKS` 定义为 1 时, 则为 16 位无符号整形数据; 定义为 0 时, 为 32 位无符号整形;(一般均0即可)

#### 3. 任务模式和调度设置宏
![[attachments/Pasted image 20240717152913.png]]
对于实际执行过程中, 主城序可以创建 IDLE 模式但仍然运行的程序(空闲任务), 但 IDLE_SHOULD_YIELD 决定IDLE(包括Delay产生的空闲任务)是否会被 Ready 的抢占。
```txt
#define configUSE_TICKLESS_IDLE                 0     // low power tickless mode 
#define configIDLE_SHOULD_YIELD                1      // IDLE 模式
#define configUSE_TASK_NOTIFICATIONS      1     // 任务之间消息传递
#define configTASK_NOTIFICATION_ARRAY_ENTRIES   3 
```

<mark style="background: transparent; color: red">任务之间的消息传递</mark>包括**信号量(semaphore), 事件标志组和消息邮箱**,信号量包括如下几类:
```
#define configUSE_MUTEXES                       0             //  互斥信号量
#define configUSE_RECURSIVE_MUTEXES             0  // 递归互斥信号量
#define configUSE_COUNTING_SEMAPHORES           0 // 计数信号量
```
其中 notification array entries 设定了**消息数组的长度,**。

队列集, 时间片调度
```txt
#define configUSE_QUEUE_SETS                    0
#define configUSE_TIME_SLICING                   1   // 默认1

#define configUSE_ALTERNATIVE_API               0 /* Deprecated! */
#define configQUEUE_REGISTRY_SIZE               1 
```

用于每个任务分配一个 newlib structure (不是内核部分，一般可以不用)
```txt
#define configUSE_NEWLIB_REENTRANT       0   
```

#### 4. 内存管理设置宏 
```c
/* Memory allocation related definitions. */
#define configSUPPORT_STATIC_ALLOCATION             0
#define configSUPPORT_DYNAMIC_ALLOCATION            1
#define configKERNEL_PROVIDED_STATIC_MEMORY         1
#define configTOTAL_HEAP_SIZE                       10240
```

一般使用的是 任务堆栈 20-75kb 的方式, 而 **动态内存(configSUPPORT_DYNAMIC_ALLOCATION )** 可以从编译器的内存堆中进行自动分配。
```c
#define configAPPLICATION_ALLOCATED_HEAP  0                      /* 1 时, 需要手动分配内存 */
#define configSTACK_ALLOCATION_FROM_SEPARATE_HEAP 0  /* 1 时, 手动实现内存分配函数 */
#define configENABLE_HEAP_PROTECTOR                 1
```

#### 5. HOOK 函数设置宏
```c
/* Hook function related definitions. */
#define configUSE_IDLE_HOOK                     0
#define configUSE_TICK_HOOK                     0
#define configCHECK_FOR_STACK_OVERFLOW          0
#define configUSE_MALLOC_FAILED_HOOK            0
#define configUSE_DAEMON_TASK_STARTUP_HOOK      0
#define configUSE_SB_COMPLETED_CALLBACK         0
```

首先介绍 `configUSE_DAEMON_TASK_STARTUP_HOOK` 进程守护函数, 实际上仅在第一次 demon task 运行之前被调用， 并且**所有初始化函数 Any application initialisation code that needs the RTOS to be running can be placed in the hook function**. 

FreeRTOS 中具有定时器服务函数 **timer service(or daemon) task**. 一般的 API 函数均可以使用标准 FreeRTOS 队列给 timer service task 发送命令; 

而我们一般为了进行初始化, 都使用 configUSE_DAEMON_TASK_STARTUP_HOOK 进行 HOOK 函数初始化配置。

#### 6. 应用设置相关宏
首先, 在FreeRTOS 部分除了任务还有应用程序,  对于 Application co-routine 
```c
#define configENABLE_BACKWARD_COMPATIBILITY     0
#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5
#define configUSE_MINI_LIST_ITEM                1
#define configSTACK_DEPTH_TYPE                  uint32_t
#define configMESSAGE_BUFFER_LENGTH_TYPE        size_t
#define configHEAP_CLEAR_MEMORY_ON_FREE         1
#define configUSE_APPLICATION_TASK_TAG          0
#define configCHECK_HANDLER_INSTALLATION        1
```

## 三、任务创建和删除API等函数
### (1) 动态任务创建
在 task.c 的 outline  中可以找到相关的 API 函数定义(也可以在INCLUDE 宏中进行查看):
![[attachments/Pasted image 20240717171007.png]] 

```c
xTaskCreate();           // 动态控制任务, 自动堆空间分配
xTaskCreateStatic(); //  栈空间由用户提供 
xTaskDelete();  // 删除
```

其中 x 表示函数返回值为 long 类型的, 而 v 开头是 void 返回类型;
而**xTaskCreate() 会返回是否创建成功, 其中返回 pdPASS 表示创建成功, 其余为创建失败**;
```txt
#define pdPASS                                   ( pdTRUE )
#define pdFAIL                                   ( pdFALSE )
#define errQUEUE_EMPTY                           ( ( BaseType_t ) 0 )
#define errQUEUE_FULL                            ( ( BaseType_t ) 0 )

/* FreeRTOS error definitions. */
#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY    ( -1 )
#define errQUEUE_BLOCKED                         ( -4 )
#define errQUEUE_YIELD                           ( -5 )
```

一般当申请堆栈过大时, 会返回 `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY` 
实际通过申请任务控制块 `struct tskTaskControlBlock`(TCB) 分配内存
```c
/*
 * Task control block.  A task control block (TCB) is allocated for each task,
 * and stores task state information, including a pointer to the task's context
 * (the task's run time environment, including register values)
 */
typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel aware debuggers. */
{
    volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */

    #if ( portUSING_MPU_WRAPPERS == 1 )
        xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    #endif
	
    ListItem_t xStateListItem;                  /*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    ListItem_t xEventListItem;                  /*< Used to reference a task from an event list. */
    UBaseType_t uxPriority;                     /*< The priority of the task.  0 is the lowest priority. */
    StackType_t * pxStack;                      /*< Points to the start of the stack. */
    char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

    #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
        StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */
    #endif

    #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    #endif

    #if ( configUSE_TRACE_FACILITY == 1 )
        UBaseType_t uxTCBNumber;  /*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
        UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace code. */
    #endif

    #if ( configUSE_MUTEXES == 1 )
        UBaseType_t uxBasePriority; /*< The priority last assigned to the task - used by the priority inheritance mechanism. */
        UBaseType_t uxMutexesHeld;
    #endif

    #if ( configUSE_APPLICATION_TASK_TAG == 1 )
        TaskHookFunction_t pxTaskTag;
    #endif

    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
        void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    #endif

    #if ( configGENERATE_RUN_TIME_STATS == 1 )
        configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*< Stores the amount of time the task has spent in the Running state. */
    #endif

    #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )
        configTLS_BLOCK_TYPE xTLSBlock; /*< Memory block used as Thread Local Storage (TLS) Block for the task. */
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
        volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    #endif

    /* See the comments in FreeRTOS.h with the definition of
     * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
    #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
        uint8_t ucStaticallyAllocated;                     /*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
    #endif

    #if ( INCLUDE_xTaskAbortDelay == 1 )
        uint8_t ucDelayAborted;
    #endif

    #if ( configUSE_POSIX_ERRNO == 1 )
        int iTaskErrno;
    #endif
} tskTCB;
```

其中 `StackType_t *pxTopofStack;  /* 任务堆栈栈顶*/` 为TCB第一个成员,  uxPriority 为任务优先级;
`char pcTaskName[ configMAX_TASK_NAME_LEN ]` 记录任务名;
```c
if (xTaskCreate(task2, "task2", TASK2_STACK_SZ, NULL, TASK2_PRIOR, &task2_handler) !=  pdPASS){
        vAssertCalled("task2", 1);
    }
```

对于静态创建任务函数:前5个参数完全相同, 返回 NULL  创建失败, 否则返回其他值;

> [!NOTE] 空闲任务
> 在 RTOS 中, 必须定义空闲任务; 而静态创建必须定义空闲任务, 任务堆栈以及 TCB;
> 需要实现 `vApplicationGetIdleTaskMemory()` (空闲任务内存赋值) 和  `vApplicationGetTimerTaskMemory()` (软件定时器内存赋值, 可选);
```
puxStackBuffer;   /* 给定一个固定大小的数组, 用户分配 */
pxTaskBuffer;       /* 任务控制块指针, 用于分配 */
```

对于调用 vTaskDelete 时, 如果传入 NULL , 则删除当前正在执行的任务自身。

> [!caution] 
> 当传入参数为NULL 时, 空闲任务会**负责释放删除任务中的系统分配的内存**(会添加到等待删除列表,然后在空闲任务删除); 而<mark style="background: transparent; color: red">用户在任务删除前申请的内存, 需要在任务被删除提前进行释放, 否则会导致内存泄露</mark>

在删除任务后, 系统会<mark style="background: transparent; color: red">更新下一个任务的阻塞时间， 以防被删除的任务是下一个阻塞超时任务</mark>

vTaskStartScheduler 函数可以<mark style="background: transparent; color: red">开启任务调度管理器</mark>, 即开启整个程序运行。
另外, FreeRTOS 也提供了**查询剩余堆栈大小的 API 函数**(`_uxTaskGetStackHighWaterMark`) 

对于FreeRTOS，任务切换是在中断中进行的, 而如果需要阻止中断, 就要在 vTask 中调用 "进入临界区" 函数 `TaskENTER_CRITICAL();` 

因此一般采用如下的启动函数架构:
```c
taskENTER_CRITICAL();
xTaskCreate(task1,"task1",TASK1_STACK_SZ, NULL, TASK1_PRIOR, &task1_handler);

if (xTaskCreate(task2, "task2", TASK2_STACK_SZ, NULL, TASK2_PRIOR, &task2_handler) !=  pdPASS){
	vAssertCalled("task2", 1);
}
xTaskCreate(task3, "task3", 128, NULL, 2 , &task3_handler);
vTaskDelete(NULL);
taskEXIT_CRITICAL();
```

对于检测按键的函数, 方法一是每间隔100ms较短时间进行检测一次, 直接放在While 循环中;
需要注意的是, 如果删除函数句柄时, 函数不在运行或者已经被删除过, 则会发生错误, 解决方法是判断是否为 NULL: 
```c
/* Check for the KEY1, stop the */
void task3(void *pvParameters){
    while (1)
    {
        if (KEY0_PRESSED){
            vTaskDelay(20);
            if (KEY0_PRESSED){
                HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9,  GPIO_PIN_SET);
                vTaskDelete(task1_handler);
                vTaskDelay(20); // 
            }
        }
        vTaskDelay(100);  // Test Button Per 100ms;
    }
}
```
需要注意的是, 此时按键长度一般是需要超过 100ms 的, 否则将不会被检测到, 而一种比较好的方法是通过外部中断等等进行创建任务(首先判断任务是否在运行)。

### (2) 静态创建任务方法
对于静态方法, 实时性好, 内存碎片化较低, 但是灵活性比较差。当开启静态方法后, 空闲任务的空间一定是使用static 分配的。

需要实现以下的两个函数: 
```c
vApplicationGetIdleTaskMemory();
vApplicationGetTimerTaskMemory();
```

首先, 第一个函数都是针对空闲任务的, 因此只需给定一个任务堆栈即可。空闲函数的内存分配可以定义如下:
```c
/** FreeRTOS Interface functions            */
static StaticTask_t idle_task_tcb;   // 
static StackType_t  idle_task_stack[configMINIMAL_STACK_SIZE];

static StaticTask_t timer_task_tcb;
static StackType_t  timer_task_stack[configMINIMAL_STACK_SIZE];

/** The IDLE task memory Allocation */
void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, 
                                    StackType_t ** ppxIdleTaskStackBuffer, 
                                        uint32_t *pulIdleTaskStackSize ){
    (*ppxIdleTaskTCBBuffer) = &idle_task_tcb;  /* firstly, use a tcb for the static  */
    (*ppxIdleTaskStackBuffer) = idle_task_stack;
    (*pulIdleTaskStackSize)   = configMINIMAL_STACK_SIZE;
}

void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer,
                                        StackType_t ** ppxTimerTaskStackBuffer,
                                        uint32_t * pulTimerTaskStackSize ){
    (* ppxTimerTaskTCBBuffer)  =  &timer_task_tcb;
    (* ppxTimerTaskStackBuffer)= timer_task_stack;
    (*pulTimerTaskStackSize)   = configMINIMAL_STACK_SIZE;
}
```

另外, 静态创建函数时, 都是**返回相应的空闲任务句柄的**;
```c
task1_handler = xTaskCreateStatic(task1,"task1",TASK1_STACK_SZ, NULL, TASK1_PRIOR, puxStackBuffer_task1, &task1_tcb);
```

一般都会使用动态创建的方法。

> [!NOTE] 临界区保护
> 在动态创建任务的过程中, 如果希望任务不被预先的执行一次，需要调用 `taskENTER_CRITICAL();` 和 `taskEXIT_CRITICAL();` 来进入任务临界区, 阻断中断的进行。然后在其中创建任务。

### (3) 任务的挂起和恢复方法 
From ISR 是中断专用的API函数, 用于在中断中进行处理，例如 xTaskResumeFromISR(); 会在中断中恢复任务的进行。
```c
vTaskSuspend(task2_handler);
vTaskResume(task2_handler);
xTaskResumeFromISR();  
```

其中 xTaskResumeFromISR 返回值为:

| pdTRUE                                      | pdFALSE              |
| ------------------------------------------- | -------------------- |
| 任务恢复之后, 需要进行任务切换(恢复任务的优先级更大) -> 需要手动执行任务切换。 | 恢复之后不需要进行任务切换(优先级较低) |

因此一般使用该函数的方法为:
```c
 void vAnExampleISR( void )
 {
     BaseType_t xYieldRequired;

     // Resume the suspended task.
     xYieldRequired = xTaskResumeFromISR( xHandle );

     // We should switch context so the ISR returns to a different task.
     // NOTE:  How this is done depends on the port you are using.  Check
     // the documentation and examples for your port.
     portYIELD_FROM_ISR( xYieldRequired );   // 实际上内部会判断是否为 pTRUE , 如果是则进行切换
 }
```

注意**中断中调用该函数, 则中断优先级不能高于 FreeRTOS 管理的最高优先级 (5-15), 即不能在 0-4 优先级部分**;

中断优先级问题出现时, 会调用 port.c 中的函数:
```c
/* Priority grouping:  The interrupt controller (NVIC) allows the bits
 * that define each interrupt's priority to be split between bits that
 * define the interrupt's pre-emption priority bits and bits that define
 * the interrupt's sub-priority.  For simplicity all bits must be defined
 * to be pre-emption priority bits.  The following assertion will fail if
 * this is not the case (if some bits represent a sub-priority).
 *
 * If the application only uses CMSIS libraries for interrupt
 * configuration then the correct setting can be achieved on all Cortex-M
 * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
 * scheduler.  Note however that some vendor specific peripheral libraries
 * assume a non-zero priority group setting, in which cases using a value
 * of zero will result in unpredictable behaviour. */
configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
```

https://www.freertos.org/RTOS-Cortex-M3-M4.html 

**中断优先级分组**: 优先级只能用作抢占式, 而不能用作子优先级。
configMAX_SYSCALL_INTERRUPT_PRIORITY 定义了最大的系统程序中的中断优先级。

FreeRTOS 的中断优先级分组, 首先是通过 `__NVIC_PRIO_BITS` 定义的 (使用 RTOS 时,在OS启动之前, 所有的中断都必须通过 NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 ) 来进行定义);
with the noticeable exception of the STM32 driver library. **If you are using an STM32 with the STM32 driver library then ensure all the priority bits are assigned to be preempt priority bits by calling NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 ); before the RTOS is started.**

而 configMAX_SYSCALL_INTERRUPT_PRIORITY  **决定了FreeRTOS 能够管理的最高优先级**(初始设定为5, 越小优先级越高),  例如: **HAL_NVIC_SetPriority  (KEY2_IRQn, 5,0);** 

注意: 
<b><mark style="background: transparent; color:red">never leave the priority of an interrupt that uses the interrupt safe RTOS API at its default value</mark></b>. 
```txt
/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
#define configMAX_SYSCALL_INTERRUPT_PRIORITY    ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
```

在 FreeRTOS 的 FromISR 函数中, 该函数不能在比  configMAX_SYSCALL_INTERRUPT_PRIORITY 定义更高优先级的中断中 使用。而这个Interrupt Service 的Priority设置至少比 configMAX_SYSCALL_INTERRUPT_PRIORITY 相等或者更大(即比系统逻辑优先级低)
it is essential that interrupt service routines that make use of the RTOS API have a logical priority equal to or below that set by the configMAX_SYSCALL_INTERRUPT_priority

> [!caution] 中断优先级
> **中断函数中调用的 freeRTOS API 函数, 则该中断的优先级不能高于 FREERTOS 管理的最高中断优先级。**

例如, 在中断中恢复某个 task ，则必须保证该中断的优先级抢占优先级至少为 5 
因此一般都是先设置为 4, 抢占优先级最高可以设置为 16;
```c
  *         @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority
  *                                    0 bits for subpriority
```

### (4) 内核中断相关控制和 FreeRTOS 中断原理
共有 8 位宽, 256 个优先级; 仅高4位, 提供16级优先级部分;
HAL_Init 函数中有对应的 优先级 Config(默认设置为Group4部分)

中断服务流 ISR (Interrupt Service Routine), Cortex-M4 具有三个系统中断的优先级配置寄存器, 包括 SHPR1, SHPR2, SHPR3; 

其中重点包括 SysTick 的优先级和 PendSV 中断的优先级。 

![[attachments/Screenshot_20240718_113128_com.microsoft.skydrive.png|700]]
其中系统 SysTick 优先级是固定的, 但 FREERTOS 会对 PendSV 和 Systick 的优先级做重新配置。

```c title:port.c,xPortStartScheduler
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI; 
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
```

实际上是通过 configKERNEL_INTERRUPT_PRIORITY 进行的, 其中 PendSV 是 16 -24, 而最终 LOWEST_InTERRUTP_PRIORITY 是 15, 15 << 4  (高4位优先级配置)
<b><mark style="background: transparent; color: red">最终是将 PENDSV 和 SYSTICK_PRI 均设置为15，即优先级均为最低</mark></b>, 即**中断不会阻塞其他中断的响应。但是必定会阻塞任务**。

主要的三个中断相关寄存器有 PRIMASK, FAULTMASK 和 BASEPRI, 其中 PRImASK 关闭所有中断(除了Hard等), 而 PRIMASK 位也对
![[attachments/Screenshot_20240718_115345_com.microsoft.skydrive.png|800]]
![[attachments/Screenshot_20240718_115400_com.microsoft.skydrive.png|800]]
![[attachments/Screenshot_20240718_115532_com.microsoft.skydrive.png|800]]
FreeRTOS 利用 BASEPRI 设置来控制优先级部分。 一般当BASEPRI 设置为某个值时, **优先级号大于等于(优先级低于该值)该值**的中断都会被关闭。但是设为0时, 不关闭任何中断。(例如设定为 0x50, (5 << 4), 则小于5的优先级均会被关闭, 0-4 正常执行)因此, **FREERTOS 使用 portDISABLE_INTERRUPTS 会将中断优先级小于5的全部关闭**, 
![[attachments/Pasted image 20240718120811.png]]
总体而言的部分如图所示:
![[attachments/Pasted image 20240718121141.png]]
1、中断服务函数的优先级需在FreeRTOS所管理的范围内
2、在中断服务函数里边需调用FreeRTOS的API函数，必须使用带“FromISR”后缀的函数

其中 portENABLE_INTERRUPTS 中, 

首先写一个定时器程序, 注意 TIM2_tbInitStruct.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; 这个是**设置输入滤波器的时钟分频**。第二注意 HAL_TIM_Base_Start 和 HAL_TIM_Base_Start_IT 的区别。
```c
void Timer_Init(){
    __HAL_RCC_TIM2_CLK_ENABLE();

    /** Since TIM2 Is APB APB1(42MHz) Pherpherical, Clk Freq is 84MHz */
    TIM2_tbInitStruct.Instance = TIM2;
    TIM2_tbInitStruct.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
    TIM2_tbInitStruct.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
    TIM2_tbInitStruct.Init.CounterMode   = TIM_COUNTERMODE_UP;
    TIM2_tbInitStruct.Init.Prescaler     = 8400 - 1;
    TIM2_tbInitStruct.Init.Period        = 2500 - 1;
    TIM2_tbInitStruct.Init.RepetitionCounter = 0;
    
    if (HAL_TIM_Base_Init(&TIM2_tbInitStruct)!= HAL_OK){
        Error_Handler();
    }

    HAL_TIM_Base_Start_IT(&TIM2_tbInitStruct);
    
    __HAL_RCC_TIM3_CLK_ENABLE();
    TIM3_tbInitStruct.Instance = TIM3;
    TIM3_tbInitStruct.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
    TIM3_tbInitStruct.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
    TIM3_tbInitStruct.Init.CounterMode   = TIM_COUNTERMODE_UP;
    TIM3_tbInitStruct.Init.Prescaler     = 4200 - 1;
    TIM3_tbInitStruct.Init.Period        = 2500 - 1;
    TIM3_tbInitStruct.Init.RepetitionCounter = 0;
    
    if (HAL_TIM_Base_Init(&TIM3_tbInitStruct)) {
        Error_Handler();
    }
    HAL_TIM_Base_Start_IT(&TIM3_tbInitStruct);

    /** NVIC Configuration -------------------- */

    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    HAL_NVIC_SetPriority(TIM2_IRQn, 4, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
    HAL_NVIC_SetPriority(TIM3_IRQn, 6, 0);
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
}
```

在 FreeRTOS 的临界段代码中, 必须均被完整运行, 不可以被打断。即进入临界区时必须关闭中断。
注意: 一般使用taskENTERCritical  和 exit Critical 来阻止中断的进行;  理论上效果是相同的, 实际taskENTERCritical 有效。
实际上, 中断进入临界区之后会自动退出临界区，因此 DISABLE_INTERRUPTS 实际上没啥用; 另外 ,  uxCritical  Nesting 是中断嵌套层数, 退出时要进行嵌套退出。

除了taskENTER_CRITICAL (), taskEXIT_CRITICAL (), 还有 taskENTER_CRITICAL_FROM_ISR () 和 taskEXIT_CRITICAL_FROM_ISR(); 
注意 : 由于临界区**直接屏蔽中断, 一定要保证其中各项耗时短**; 

### (5) 任务调度器的挂起和恢复部分
任务调度器挂起**不关闭中断部分**, **防止任务之间的资源的争夺**。

| vTaskSuspendAll () | vTaskResumeAll ()<br> |
| ------------------ | --------------------- |
| 挂起调度器              | 恢复调度器                 |

实际上是挂起 pendSV 中断, 即只需  uxSchedulerSuspend 返回 pdTRUE  

注意: 在任务被挂起时，实际上**滴答定时器节拍数**是不会自增的,(在portmacro.h中xTickCount变量是否自增)
最后在vTaskResumeAll 时, 会补齐丢失的节拍数(xPendedCounts);

**注意: 有时调用以 x开头的函数, 必须注意之后返回是否切换的部分。如果切换, 则必须进行处理** (尤其是FromISR)

### (6) 其他 API 函数简介 
 
| 函数                            | 描述               |
| ----------------------------- | ---------------- |
| uxTaskPriorityGet()           | 获取任务优先级          |
| vTaskPrioritySet()            | 设置任务优先级          |
| uxTaskGetNumberOfTasks()      | 获取系统中任务的数量       |
| uxTaskGetSystemState()        | 获取所有任务状态信息       |
| vTaskGetInfo()                | 获取指定单个的任务信息      |
| xTaskGetCurrentTaskHandle()   | 获取当前任务的任务句柄      |
| xTaskGetHandle()              | 根据任务名获取该任务的任务句柄  |
| uxTaskGetStackHighWaterMark() | 获取任务的任务栈历史剩余最小值  |
| eTaskGetState()               | 获取任务状态           |
| vTaskList()                   | 以“表格”形式获取所有任务的信息 |
| vTaskGetRunTimeStats()        | 获取任务的运行时间        |

## 四、FreeRTOS 常用数据结构
### (1) 列表和列表项
实际上即为链表结构; 实际上是一个**双向循环链表**。是一种非连续的存储结构, 可以随时改变列表项数目;
每个列表项均为一个任务; FreeRTOS 中列表 xList 用于存放相同优先级的所有任务。

主要文件在 list.c 和 list.h 中; MiniListItem_t 列表项仅用于标记列表末尾和挂载其他插入的列表项;

```c
typedef struct xLIST
{
    	listFIRST_LIST_INTEGRITY_CHECK_VALUE			/* 校验值 */
    	volatile UBaseType_t uxNumberOfItems;			/* 列表中的列表项数量 */
   	ListItem_t * configLIST_VOLATILE pxIndex			/* 用于遍历列表项的指针 */
    	MiniListItem_t xListEnd					/* 末尾列表项 */
    	listSECOND_LIST_INTEGRITY_CHECK_VALUE		/* 校验值 */
} List_t;
```
其中两个校验值是用于调试和检查值检测过程中是否被破坏的; 一般用于调试;
![[attachments/Pasted image 20240718163813.png|250]]
其中 pxIndex 指向某一个项; 而列表中的 `void *pvOwner` 指向列表项, 一般是任务的指针。 pxContainer 指向回溯其所在的列表。 
```c
struct xLIST_ITEM
{
    	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/* 用于检测列表项的数据完整性 */
    	configLIST_VOLATILE TickType_t xItemValue				/* 列表项的值 */
     	struct xLIST_ITEM * configLIST_VOLATILE pxNext		/* 下一个列表项 */
  	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious		/* 上一个列表项 */
    	void * pvOwner							/* 列表项的拥有者 */
    	struct xLIST * configLIST_VOLATILE pxContainer; 			/* 列表项所在列表 */
   	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/* 用于检测列表项的数据完整性 */
};
typedef struct xLIST_ITEM ListItem_t; 
```

插入之后变为如下结构:
![[attachments/Pasted image 20240718164727.png]]
相关函数使用包括: 
ListItem_t ， 通过 -> xItemValue 来进行升序排列插入 

| vListInitialize()      |                                                                       |
| ---------------------- | --------------------------------------------------------------------- |
| vListInitializeItem () | 将某个列表项的 pxContainer 初始化为 NULL, 即不属于任何列表                               |
| vListInsertEnd()       | 插入到 **pxIndex指针所指向的列表项的前面**(一般是插在列表项最后面,尾部接末尾列表项), 并**更新 pxIndex 指针** |
| vListInsert()          | 有序插入(插入后, 升序排列)                                                       |
| uxvListRemove()        | 将某个列表项从所在列表中删除 (仍然判断pxIndex是否相等)                                      |

### (2) 队列和队列项 
对于队列, 有大量的类型设定, 其中信号量也是队列的一种, 定义如下: 
```c
/* For internal use only.  These definitions *must* match those in queue.c. */
#define queueQUEUE_TYPE_BASE                  ( ( uint8_t ) 0U )
#define queueQUEUE_TYPE_SET                   ( ( uint8_t ) 0U )
#define queueQUEUE_TYPE_MUTEX                 ( ( uint8_t ) 1U )  
#define queueQUEUE_TYPE_COUNTING_SEMAPHORE    ( ( uint8_t ) 2U )
#define queueQUEUE_TYPE_BINARY_SEMAPHORE      ( ( uint8_t ) 3U )    // 二值信号量
#define queueQUEUE_TYPE_RECURSIVE_MUTEX       ( ( uint8_t ) 4U )     // 互斥递归信号量 
```

| 函数                   | 描述       |
| -------------------- | -------- |
| xQueueCreate()       | 动态方式创建队列 |
| xQueueCreateStatic() | 静态方式创建队列 |
![[attachments/Pasted image 20240718173420.png]]

![[attachments/Pasted image 20240718173649.png]]
![[attachments/Pasted image 20240718173747.png]]

| 函数                           | 描述                         |
| ---------------------------- | -------------------------- |
| xQueueCreateSet()            | 创建队列集                      |
| xQueueAddToSet()             | 队列添加到队列集中                  |
| xQueueRemoveFromSet()        | 从队列集中移除队列                  |
| xQueueSelectFromSet()        | 获取队列集中有有效消息的队列             |
| xQueueSelectFromSetFromISR() | 在中断中获取队列集中有有效消息的队列         |
| xQueueSend()                 | 往队列的尾部写入消息                 |
| xQueueSendToBack()           | 同 xQueueSend()             |
| xQueueSendToFront()          | 往队列的头部写入消息                 |
| xQueueOverwrite()            | 覆写队列消息（只用于队列长度为 1 的情况）     |
| xQueueSendFromISR()          | 在中断中往队列的尾部写入消息             |
| xQueueSendToBackFromISR()    | 同 xQueueSendFromISR()      |
| xQueueSendToFrontFromISR()   | 在中断中往队列的头部写入消息             |
| xQueueOverwriteFromISR()     | 在中断中覆写队列消息（只用于队列长度为 1 的情况） |


在 xQueueGenericSend 中, 首先会判断队列的非空闲数量(pxQueue->uxMessagesWaiting);  而信号量总代表计数值(二值仅有1, 0), 主要实现的逻辑函数如下: 
```c
if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) ){
	//  uxMessagesWaiting 是信号量;  
	traceQUEUE_SEND( pxQueue );
	xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );  // 将数据复制到队列; 在这个函数中， 首先获取  pxQueue->uxMessagesWaiting 的值,  并调用  pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;  即将  uxMessagesWaiting  加一 ; (也即释放信号量)
		/* If there was a task waiting for data to arrive on the
		 * queue then unblock it now. */
		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
		{
			if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
			{
				/* The unblocked task has a priority higher than
				 * our own so yield immediately.  Yes it is ok to do
				 * this from within the critical section - the kernel
				 * takes care of that. */
				queueYIELD_IF_USING_PREEMPTION();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xYieldRequired != pdFALSE ){
			/* This path is a special case that will only get
			 * executed if the task was holding multiple mutexes and
			 * the mutexes were given back in an order that is
			 * different to that in which they were taken. */
			queueYIELD_IF_USING_PREEMPTION();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
}
taskEXIT_CRITICAL();
return pdPASS;
```

### (3) 队列集
#### 1. 队列集简介
对于队列, 传递的消息为同一种数据类型, 而需要在任务间传递不同数据类型的消息， **则可以使用队列集**。

队列集可以对**多个队列或者信号量进行监听**, 其中==**不论何消息到达均可以退出阻塞状态**==;
一般当等待接收队列之后, 获取信号量时; 则会导致等待后继续阻塞。 

而对于队列集中, 首先等待多个队列情况, 然后通过if 判断接收到的数据是何种类型;

| 函数                           | 描述                                   | 失败返回   | 成功返回   |
| ---------------------------- | ------------------------------------ | ------ | ------ |
| xQueueCreateSet()            | 创建队列集                                | NULL   |        |
| xQueueAddToSet()             | 队列添加到队列集中                            | pdFAIL | pdPASS |
| xQueueRemoveFromSet()        | **从队列集中移除队列**                        | pdFAIL | pdPASS |
| xQueueSelectFromSet()        | 任务**获取队列集中有有效消息的队列**(也可以查看哪个信号量被释放了) | NULL   | 消息队列句柄 |
| xQueueSelectFromSetFromISR() | 在**中断中获取**队列集中有有效消息的队列               |        |        |
|                              |                                      |        |        |

> [!CAUTION] 注意 
> 注意: **队列在被添加到队列集或者从队列集移除之前, 不能有有效消息**

```c title:队列集完整示例代码
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "main.h"

/*  at first , define the  task heap size */
#define TASK1_PRIOR     1
#define TASK1_STACK_SZ  128 

#define TASK2_PRIOR     1
#define TASK2_STACK_SZ  128

static TaskHandle_t task1_handler;
static TaskHandle_t task2_handler;

QueueHandle_t que_h1;
SemaphoreHandle_t que_h2;
QueueSetHandle_t que_set_h1;

void task1(void *pvParameters);
void task2(void *pvParameters);

#define KEY1_PRESSED  !HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_3)
#define KEY2_PRESSED  !HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_2)
#define KEY0_PRESSED  !HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_4)

/** Queue Set Experiment */

/** FreeRTOS Interface functions            */
void freertostask(void){

    que_h1 = xQueueCreate(10,24 * sizeof(char));  // 10 length, 24 bytes size 
    configASSERT(que_h1 != NULL);  // if create failed, assert;
    que_h2 = xSemaphoreCreateBinary();
    configASSERT(que_h2 != NULL);
    que_set_h1 = xQueueCreateSet(2);   /** Queue  Set Create */
    configASSERT(que_set_h1 != NULL);

    xQueueAddToSet(que_h1, que_set_h1);
    xQueueAddToSet(que_h2, que_set_h1);

    taskENTER_CRITICAL();
    xTaskCreate(task1, "task1", configMINIMAL_STACK_SIZE,  NULL,  1 , &task1_handler);
    xTaskCreate(task2, "task2", configMINIMAL_STACK_SIZE,  NULL,  1 , &task2_handler);
    taskEXIT_CRITICAL();
    
    vTaskStartScheduler();  //  Start the Task Manager 
}

void task1(void *pvParameters){
    while (1)
    {
        if (KEY1_PRESSED){
            vTaskDelay(20);
            if (KEY1_PRESSED){
                while (KEY1_PRESSED);
                configASSERT(xQueueSend(que_h1,"Hello, world", 0) == pdPASS);  /**  */
            }
            vTaskDelay(20); 
        }

        if (KEY2_PRESSED){
            vTaskDelay(20);
            if (KEY2_PRESSED){
                while (KEY2_PRESSED);
                configASSERT(xSemaphoreGive(que_h2) == pdPASS);
            }
            vTaskDelay(20);
        }
    }
}

/** read the message in  */
void task2(void *pvParameters){
    char buff[24];
    while (1)
    {   
        QueueHandle_t hque = xQueueSelectFromSet(que_set_h1,  0);
        if (hque!=NULL){
            // judge the semphore or 
            if (hque ==  que_h1){
                configASSERT(xQueueReceive(que_h1, buff, 0) == pdPASS); // receive the message 
                printf("receive: %s\r\n",buff);
            }else if(hque == que_h2){
                configASSERT(xSemaphoreTake(que_h2,0)==pdPASS);
                printf("signal taked\r\n");
            }else{
                configASSERT(0);
            }
        }
        // vTaskDelay(1000);
    }
}
```

## 五、信号量的使用
任务之间的传递包括==**信号量、事件标志组和消息邮箱**==, 而信号量包括 
1. 二值信号量(0, 1) 
2. 计数型信号量 (0, 1, ... n ) 
3. 互斥型信号量 (由于二值信号量存在优先级翻转问题, 而互斥信号量会有优先级继承)
4. 递归互斥信号量 

信号量用于解决同步问题的机制, 可以实现对共享资源的有序访问。例如使用某个信号量标志是否能够进行或者是否相应的资源, 用于实现多任务的共享。 
创建信号量时, 只需分配信号量结构体。
例如, 对于一个**标志资源数量的计数型信号量**; 不同的任务均可访问(释放和获取)此信号量。可以用于传递状态等等。

首先, 为了使能信号量的使用, 必须在 Config.h 中定义: `#define  configUSE_TASK_NOTIFICATIONS    1` 同时需要在引用的文件中 `#include  "semphr.h"` (这个用于使能任务间直接的消息传递,包括信号量、事件标志组和消息邮箱)
### (1) 二值信号量
#### 1. 基本概念
对于二值信号量,本质是一个长度为1的队列, 仅有空(0)和满(1)队列两种情况。代表二值的情况。
一般可以用于互斥访问, <mark style="background: transparent; color: red">任务同步</mark>等等; 

支持任务和中断进行释放和获取。其中 xSemaphoreGive 和 xSemaphoreGiveFromISR 是释放信号量(将其置1, 即可用状态)。
而任务可以通过 xSemaphoreTake 和 xSemaphoreTakeFromISR 来获取二值信号量, 即将其置零。

在获取二值信号量时, 可以设置阻塞时间, 用于任务等待， 直到信号量被释放, 则获取成功。
相关 API 函数:

| 函数                             | 说明            | 返回(Suc) | 返回(fail )     |
| ------------------------------ | ------------- | ------- | ------------- |
| xSemaphoreCreateBinary()       | 使用动态方式创建二值信号量 |         | NULL          |
| xSemaphoreCreateBinaryStatic() | 使用静态方式创建二值信号量 |         | NULL          |
| xSemaphoreGive()               | 释放信号量         | pdPASS  | errQUEUE_FULL |
| xSemaphoreGiveFromISR()        | 在中断中释放信号量     | pdPASS  | errQUEUE_FULL |
| xSemaphoreTake()               | 获取信号量         | pdTRUE  | pdFALSE       |
| xSemaphoreTakeFromISR()        | 在中断中获取信号量     | pdTRUE  | pdFALSE       |
实际上, 二值信号量调用的是长度 1 的通用队列创建函数; 

```c
/**  首先创建二值信号量 */
SemaphoreHandle_t  semap1;   // 全局定义一个二值信号量类型

semap1 = xSemaphoreCreateBinary();
if (semap1 == NULL) Error_Handler();
```

实际上, xSemaphoreGive 即调用了 xQueueGenericSend 函数, 即队列发送 NULL 给队列;  且阻塞时间设置为 0;  返回 pdPASS ; 获取二值信号量支持阻塞时间。

需要注意的是, 释放信号量时, 如果已经被释放了, 即计数值已经是1, 由于在 Create Binary 时调用了 
 `( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );`  部分, 则 `pxQueue->uxMessagesWaiting < pxQueue->uxLength`  的条件是不成立的。
此时执行: `if( xTicksToWait == ( TickType_t ) 0 )` -> return errQUEUE_FULL;结果;

获取信号量支持设置阻塞时间;

一直等待的方法一是直接使用死循环并判断; 而方法二是设置一个较大的等待时间, 让任务处于一直等待状态, 不过这样会有超时退出机制:
```c
/** 方法一  */
while (1)
{
	if (xSemaphoreTake( hsemap1 ,  0 ) == pdPASS){  //  get the  semaphore
		HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_10);
	}
}

/** 方法二  */
err = xSemaphoreTake(semphore_handle,portMAX_DELAY); /* 获取信号量并死等 */
if(err == pdTRUE)
{
	printf("获取信号量成功\r\n");
}else printf("已超时%d\r\n",++i);
```

#### 2. 优先级翻转 
优先级翻转是由于二值信号量的抢占特性, 当有中等优先级事件抢占低优先级事件时, 高优先级的任务反而慢执行, 而低(中等)优先级任务优先执行的现象。 这是由于低优先级任务执行过程中被中等优先级继续抢占得到的。

> [!NOTE] 
> 优先级翻转在抢占式内核中是非常常见的，但是在实时操作系统中是不允许出现优先级翻转的，因为优先级翻转会破坏任务的预期顺序，可能会导致未知的严重后果。

这是由于任务之间的信号量抢占导致的。
 
### (2) 计数型信号量
计数型信号量相当于队列长度大于1时的队列; 即可以**容纳多个资源**; 同样地可以通过 xSemaphoreGive(), xSemaphoreTake() 来表示;

用于<mark style="background: transparent; color: red">事件计数和资源管理</mark>部分,对于事件计数时, 一般**初始时设置为0**, 首先**需要确定队列长度的上限**, 有效资源数目等等; 而资源管理时, 由于资源数量是确定的, 初始值一般**设置为最大的资源数目**。

相关 API 函数为:

| 函数                               | 描述              | 失败     |
| -------------------------------- | --------------- | ------ |
| xSemaphoreCreateCounting()       | 使用动态方法创建计数型信号量。 | NULL   |
| xSemaphoreCreateCountingStatic() | 使用静态方法创建计数型信号量  | pdFAIL |
| uxSemaphoreGetCount()            | 获取信号量的计数值       | 不会失败   |


```c
SemaphoreHandle_t  hsemap1;
xSemaphoreCreateCounting( uxMaxCount, uxInitialCount );    // 设定最大值和初始值 
uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting; // 实际 GetCount 执行的函数, 返回是一个整数;
```

### (3) 互斥信号量
互斥信号量是用于解决优先级翻转问题而设置的信号量; 即为<mark style="background: transparent; color: red">拥有优先级继承的二值信号量, 往往互斥访问的应用; 而二值信号往往用于同步的应用</mark>;

如果互斥信号量, 例如低优先级L和高优先级H均需要获取信号量, 此时 L 和 H 均具有同等的优先级, 对于其他希望抢占 L 的 M, 如果不使用该信号量, 则无法抢占, 直到 L 执行到尾部。

优先级继承即当信号量被 H 释放后, L 会具有相同的优先等级, 此时 H 的阻塞时间仅仅是 L 的执行时间。降低了优先级翻转的危害。
![[attachments/Pasted image 20240718222423.png]]

没有中断级的函数
> [!caution] 
> 互斥信号量不能用于中断函数中, 只能用于任务中; -> 由于有优先级继承
> 中断服务函数不能等待互斥信号量和阻塞。

释放和获取完全相同。
创建方法是 xSemaphoreCreateMutex(); 

```c title:代码备份
#include "FreeRTOS.h"
#include "task.h"
#include  "semphr.h"
#include "main.h"
#include "portmacro.h"

/*  at first , define the  task heap size */
#define TASK1_PRIOR     1
#define TASK1_STACK_SZ  128 

#define TASK2_PRIOR     1
#define TASK2_STACK_SZ  128 

static TaskHandle_t task1_handler;
static TaskHandle_t task2_handler;
static TaskHandle_t task3_handler;

SemaphoreHandle_t  hsemap1;

void task1(void *pvParameters);
void task2(void *pvParameters);
void task3(void *pvParameters);

#define KEY1_PRESSED  !HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_3)
#define KEY2_PRESSED  !HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_2)
#define KEY0_PRESSED  !HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_4)

/** FreeRTOS Interface functions            */
static StaticTask_t idle_task_tcb;   // 
static StackType_t  idle_task_stack[configMINIMAL_STACK_SIZE];

static StaticTask_t timer_task_tcb;
static StackType_t  timer_task_stack[configMINIMAL_STACK_SIZE];

static StackType_t  puxStackBuffer_task1[TASK1_STACK_SZ];
static StaticTask_t task1_tcb;

/** The IDLE task memory Allocation */
void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, 
                                    StackType_t ** ppxIdleTaskStackBuffer, 
                                        uint32_t *pulIdleTaskStackSize ){
    (*ppxIdleTaskTCBBuffer) = &idle_task_tcb;  /* firstly, use a tcb for the static  */
    (*ppxIdleTaskStackBuffer) = idle_task_stack;
    (*pulIdleTaskStackSize)   = configMINIMAL_STACK_SIZE;
}


void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer,
                                        StackType_t ** ppxTimerTaskStackBuffer,
                                        uint32_t * pulTimerTaskStackSize ){
    (* ppxTimerTaskTCBBuffer)  =  &timer_task_tcb;
    (* ppxTimerTaskStackBuffer)= timer_task_stack;
    (*pulTimerTaskStackSize)   = configMINIMAL_STACK_SIZE;
}

void freertostask(void){
    taskENTER_CRITICAL();
    
    hsemap1 = xSemaphoreCreateBinary();
    
    configASSERT(hsemap1 != NULL);  // if create failed, assert;
    xSemaphoreTake(hsemap1,  0);    /** firstly, take the semaphore */


    task1_handler = xTaskCreateStatic(task1,"task1",TASK1_STACK_SZ, NULL, TASK1_PRIOR, puxStackBuffer_task1, &task1_tcb);
    if (task1_handler == NULL){
        vAssertCalled("task1", 1);
    }
    if (xTaskCreate(task2, "task2", TASK2_STACK_SZ, NULL, TASK2_PRIOR, &task2_handler) !=  pdPASS){
        vAssertCalled("task2", 1);
    }
    if (xTaskCreate(task3, "task3", 128 , NULL, 2 , &task3_handler)!= pdPASS){
        vAssertCalled("task3", 1);
    }
    taskEXIT_CRITICAL();
    
    vTaskStartScheduler();  //  Start the Task Manager 
}

void task1(void *pvParameters){
    while (1)
    {
        HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_9);
        vTaskDelay(1000);
    }
}

void task2(void *pvParameters){
    while (1)
    {
        if (xSemaphoreTake( hsemap1 ,  0 ) == pdPASS){  //  get the  semaphore
            HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_10);
        }
    }
}


/* Check for the KEY1, stop the */
void task3(void *pvParameters){
    while (1)
    {
        if (KEY0_PRESSED){
            vTaskDelay(20);
            if (KEY0_PRESSED){
                HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9,  GPIO_PIN_SET);
                vTaskDelete(task1_handler);
                while (KEY0_PRESSED);
                vTaskDelay(20); // 
            }
        }
        if (KEY1_PRESSED){   /** suspend test  */
            vTaskDelay(20);
            if (KEY1_PRESSED){
                uint16_t t = 0;
                while (KEY1_PRESSED) {
                    vTaskDelay(1);
                    if (t < 2000) {
                        t++;
                    }
                }
                if (t < 1000){
                    printf("task2 suspend\r\n");
                    vTaskSuspend(task2_handler);
                }else{
                    printf("task2 resumed\r\n");
                    BaseType_t xYieldRequired;
                    xYieldRequired = xTaskResumeFromISR(task2_handler); 
                    portYIELD_FROM_ISR(xYieldRequired);
                }
            }
            vTaskDelay(20);
        }
        /**  */
        if  (KEY2_PRESSED){
            // give the semaphore 
            vTaskDelay(20);
            if (KEY2_PRESSED){
                while (KEY2_PRESSED);
                BaseType_t err;
                if ( hsemap1 != NULL){
                    err = xSemaphoreGive(hsemap1) != pdPASS;
                    if (err  == pdPASS) { // give succeed 
                        
                    }else{
                        printf("hsemap1 give failed\r\n");
                    }
                }
            }
            vTaskDelay(20);
            // xSemaphoreCreateCounting(, );
            uxSemaphoreGetCount()
        }
        vTaskDelay(100);  // Test Button Per 100ms;
    }
}

void task4(void *pvParameters){
    while (1)
    {
        
    }
}

```

## 六、事件标志组
事件标志组是用一个位表示事件是否发生的部分; 而事件标志组是事件标志位的集合;实际上仅是一个整数, 一个位表示一个事件(**高8位不能表示事件**)

任意任务或者中断均可以读写; 可以等待某一位或者多位同时成立; 实际类型取决于 configUSE_16_BIT_TICKS 宏定义(0时为32位); 
```c
EventBites_t  
```

最多存储24个事件标志;

| 函数                            | 描述               | 失败      | 成功返回                             |
| ----------------------------- | ---------------- | ------- | -------------------------------- |
| xEventGroupCreate()           | 使用动态方式创建事件标志组    | NULL    |                                  |
| xEventGroupCreateStatic()     | 使用静态方式创建事件标志组    |         | 清零之前的标志位值                        |
| xEventGroupClearBits()        | 清零事件标志位          |         |                                  |
| xEventGroupClearBitsFromISR() | 在中断中清零事件标志位      |         |                                  |
| xEventGroupSetBits()          | 设置事件标志位          |         | 事件组中的事标志位值(第二个参数0x02格式), 可以取多个事件 |
| xEventGroupSetBitsFromISR()   | 在中断中设置事件标志位      |         |                                  |
| xEventGroupWaitBits()         | 等待事件标志位          | pdFALSE | 可以等待多个位成立的进行;pdTRU               |
| xEventGroupSync()             | 设置事件标志位，并等待事件标志位 |         |                                  |


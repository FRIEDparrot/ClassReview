é¦–å…ˆ, ä½¿ç”¨GPIOå£çš„ç§»æ¤æ“ä½œæ¯”è¾ƒç®€å•, å·²ç»æ”¾åœ¨æ¨¡æ¿æ–‡ä»¶ä¸­äº†ã€‚

## 1. è¡¥å……çŸ¥è¯†
#### (1) HAL ä¸­æ–­ä½¿ç”¨ 
ä¸­æ–­çš„è®¾å®šä½¿ç”¨ä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°å°±å¯ä»¥äº†(ä¸éœ€è¦ä½¿ç”¨ç»“æ„ä½“)
ä½¿èƒ½ä¸­æ–­æ—¶å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/äºŒã€ä¸­æ–­, å®šæ—¶å™¨ä¸ADè½¬æ¢/ä¸€ã€EXTIå¤–éƒ¨ä¸­æ–­ä¸çº¢å¤–è®¡æ¬¡|ä¸€ã€EXTIå¤–éƒ¨ä¸­æ–­ä¸çº¢å¤–è®¡æ¬¡]]
```c
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);  // ä¼˜å…ˆçº§ç»„
HAL_NVIC_SetPriority(RTC_WKUP_IRQn, 2, 2);   // è®¾ç½®æŠ¢å å’Œå“åº”ä¼˜å…ˆçº§ 
// ä½¿èƒ½æŸä¸ªä¸­æ–­
HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
```
ä¸Šè¿°ä¸­æ–­è®¾ç½®å®é™…ä¸Šæ˜¯ä» core-cm4æ–‡ä»¶ä¸­çš„éƒ¨åˆ†è¿›è¡Œæ‰§è¡Œçš„ã€‚
å¯¹äº Cortex-M4 å†…æ ¸, å…·æœ‰å¦‚ä¸‹çš„ç³»ç»Ÿä¸­æ–­ä¼˜å…ˆçº§: 
```c
Â  /****** Â Cortex-M4 Processor Exceptions Numbers ****************************************************************/
Â  NonMaskableInt_IRQn Â  Â  Â  Â  = -14, Â  Â /*!< 2 Non Maskable Interrupt*/
Â  MemoryManagement_IRQn Â  Â  Â  = -12, Â  Â /*!< 4 Cortex-M4 Memory Management Interrupt*/
Â  BusFault_IRQn Â  Â  Â  Â  Â  Â  Â  = -11, Â  Â /*!< 5 Cortex-M4 Bus Fault Interrupt Â */
Â  UsageFault_IRQn Â  Â  Â  Â  Â  Â  = -10, Â  Â /*!< 6 Cortex-M4 Usage Fault Interrupt*/
Â  SVCall_IRQn Â  Â  Â  Â  Â  Â  Â  Â  = -5, Â  Â  /*!< 11 Cortex-M4 SV Call Interrupt*/
Â  DebugMonitor_IRQn Â  Â  Â  Â  Â  = -4, Â  Â  /*!< 12 Cortex-M4 Debug Monitor Interrupt*/
Â  PendSV_IRQn Â  Â  Â  Â  Â  Â  Â  Â  = -2, Â  Â  /*!< 14 Cortex-M4 Pend SV InterruptÂ */
Â  SysTick_IRQn Â  Â  Â  Â  Â  Â  Â  Â = -1, Â  Â  /*!< 15 Cortex-M4 System Tick Interrupt */
```

æ³¨æ„: ä¸­æ–­å’Œäº‹ä»¶çš„åŒºåˆ†åœ¨äº, äº‹ä»¶ä¸éœ€è¦CPUå¤„ç†, ä¸€èˆ¬ç”±ç¡¬ä»¶è‡ªåŠ¨å®Œæˆã€‚

åœ¨ F407 éƒ¨åˆ†å…±æœ‰ 16 æ¡ä¸­æ–­çº¿å‡å¯ä»¥ç”³è¯·ä¸­æ–­, 82æ¡å¯å±è”½çš„ä¸­æ–­é€šé“, NMI ä¸ºä¸å¯å±è”½ä¸­æ–­(CSS, RCC å®‰å…¨ç³»ç»Ÿ)ã€‚å¯¹äºå¤–éƒ¨ä¸­æ–­æœ‰16æ¡é€šé“(0-4, 5-9, 10-15); GPIOä¸Šçš„å¤–éƒ¨ä¸­æ–­çº¿ä½¿ç”¨Px å…±äº«ä¸€ä¸ªä¸­æ–­çº¿çš„æ–¹å¼ã€‚
F1 è¾“å…¥æ¨¡å¼ä½¿ç”¨ AFIO å¯„å­˜å™¨è®¾ç½®, F4, F7 ç­‰ä½¿ç”¨ SYSCFG å¯„å­˜å™¨è®¾ç½® EXTI å’Œ IO çš„æ˜ å°„å…³ç³»(æ³¨æ„éœ€è¦ä½¿ç”¨è¾“å…¥æ¨¡å¼)ã€‚

```c
// åœ¨ä¹‹å‰éœ€è¦é¢å¤–è®¾ç½® EXTI, å±è”½å’Œä¸Šä¸‹è¾¹æ²¿çš„é€‰æ‹©ã€‚

```

ä¸­æ–­å‡½æ•°ä»ç„¶å¯ä»¥é‡‡ç”¨.s æ–‡ä»¶ä¸­çš„éƒ¨åˆ†ï¼Œ ä½†æ˜¯è¿™æ ·ä»ç„¶éœ€è¦æ¸…é™¤æ ‡å¿—ä½ã€‚ä¸€èˆ¬ä½¿ç”¨ç±»ä¼¼ `__HAL_GPIO_EXTI_CLEAR_IT` å³å¯ã€‚

> [!caution] HAL åº“ä¸­æ–­æœåŠ¡å›è°ƒå¤„ç†æœºåˆ¶
> æˆ‘ä»¬å¾€å¾€ä¹Ÿä½¿ç”¨ HAL åº“è¿›è¡Œä¸­æ–­æœåŠ¡å›è°ƒå¤„ç†ã€‚
> é¦–å…ˆ, ä»ç¡¬ä»¶ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­, é¦–å…ˆä¼šè°ƒç”¨ä¸€ä¸ªHAL åº“çš„ä¸­æ–­å¤„ç†å…¬ç”¨å‡½æ•°, è¿›è¡Œå¼‚å¸¸å¤„ç†å’Œæ¸…é™¤ä¸­æ–­æ ‡å¿—ã€‚HAL åº“ä¸­å«æœ‰å¤šç§å›è°ƒå‡½æ•°ã€‚ç”¨äº HALæ•°æ®å¤„ç†ã€‚å¤„ç†å®Œåè¿”å›ä¸­æ–­æœåŠ¡å‡½æ•°å†è¿”å› main 

F4 å…±æœ‰ 23 æ¡ EXTI çº¿,ä¾‹å¦‚: é¦–å…ˆé…ç½®å¥½ GPIO, ç„¶åä½¿èƒ½å¯¹åº”å¤–éƒ¨ä¸­æ–­å³å¯é€šè¿‡GPIOè§¦å‘ä¸­æ–­äº†ã€‚
```c
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);  // ä¼˜å…ˆçº§ç»„
HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 2);   // è®¾ç½®æŠ¢å å’Œå“åº”ä¼˜å…ˆçº§ 
HAL_NVIC_EnableIRQ(EXTI0_IRQn);     // ä½¿èƒ½æŸä¸ªä¸­æ–­ 
```

#### (2) HAL åº“çš„ä¸­æ–­å¤„ç†ä½¿ç”¨æ–°è§„åˆ™
é¦–å…ˆä¾‹å¦‚å¤–éƒ¨ä¸­æ–­, å…¬å…±å¤„ç†å‡½æ•°åœ¨ hal_gpio.c ä¸­, å¯ä»¥æ‰¾åˆ°å¦‚ä¸‹çš„ä¸¤ä¸ªå‡½æ•°:
```c
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
```

å…¶å®é™…å®šä¹‰å¦‚ä¸‹:(é¦–å…ˆé€šè¿‡Get_ITè·å–åˆ°å¯¹åº”çš„éƒ¨åˆ†ï¼Œç„¶åå…ˆæ¸…é™¤ï¼Œå†æ‰§è¡Œ HAL_GPIO_EXTI_Callback)
```c
/**
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}

/**
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(GPIO_Pin);
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
```

æ­¤æ—¶, æˆ‘ä»¬éœ€è¦é‡å®šä¹‰ä¸‹é¢è¿™ä¸ªå‡½æ•°å³å¯:
```c
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
```

#### (3) ä¸²å£çš„æ³¢ç‰¹ç‡è®¾ç½®
å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/ä¸‰ã€ä¸²å£ä¸é€šä¿¡åè®®/1. USARTä¸²å£é€šä¿¡è®²è§£|1. USARTä¸²å£é€šä¿¡è®²è§£]],  F4 çš„éƒ¨åˆ†å’Œ F1 æœ‰ä¸åŒ: 
å…¶ä¸»è¦åŒºåˆ«æ˜¯æ—¶é’Ÿæ¥æºå’Œæ³¢ç‰¹ç‡è®¾ç½®ã€‚
![[attachments/Pasted image 20240714171252.png]]
æ¥æºäº fpCLKx (å…·ä½“å–å†³äºæŒ‚è½½çš„æ€»çº¿), æ³¢ç‰¹ç‡è®¡ç®—ä¸º:
$$DIV  = \frac{f_{ck}}{8 * (2-   OVER8)  * USARTDIV}$$
F4 å…·æœ‰16å€æˆ–è€…8å€è¿‡é‡‡æ ·(OVER8), å³è®¾ç½®OVER8=0æ—¶ï¼Œä¸F1åŸºæœ¬ä¸€è‡´ã€‚
è‡³äºå°æ•°éƒ¨åˆ†, è¿›è¡Œä¸Šè¿°å¤„ç†å³å¯(å4ä½æ˜¯å°æ•°éƒ¨åˆ†è®¾ç½®)ã€‚

8å€è¿‡é‡‡æ ·æ—¶, ä¸è€ƒè™‘å°æ•°éƒ¨åˆ†ä½, å¹¶ä¸”å¿…é¡»ä¿æŒFraction3 ä½æ¸…é›¶;

#### (4) USART çš„ä½¿ç”¨æ–¹æ³•
```c
/* UART handler declaration */
UART_HandleTypeDef UartHandle;

  UartHandle.Instance          = USARTx;
  
  UartHandle.Init.BaudRate     = 9600;
  UartHandle.Init.WordLength   = UART_WORDLENGTH_8B;
  UartHandle.Init.StopBits     = UART_STOPBITS_1;
  UartHandle.Init.Parity       = UART_PARITY_NONE;
  UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
  UartHandle.Init.Mode         = UART_MODE_TX_RX;
  UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
  if(HAL_UART_Init(&UartHandle) != HAL_OK)
  {
    Error_Handler();
  }
```

æ³¨æ„ç”¨åˆ°callback å‡½æ•°æ—¶, hal_conf ä¸­å¯„å­˜å™¨ä¸­æ–­ä½¿èƒ½ä¹Ÿä¸éœ€è¦æ‰“å¼€(è¿™ä¸ªæ˜¯åˆå§‹åŒ–)
ä¸€èˆ¬, é¦–å…ˆåœ¨å®é™…çš„ä¸­æ–­å‡½æ•°IRQnä¸­è°ƒç”¨ HAL çš„ä¸­æ–­å‡½æ•°: 
```c
extern UART_HandleTypeDef UartHandle;
/**
  * @brief  This function handles DMA RX interrupt request.  
  * @param  None
  * @retval None   
  */
void USARTx_DMA_RX_IRQHandler(void)
{
  HAL_DMA_IRQHandler(UartHandle.hdmarx);
}

/**
  * @brief  This function handles DMA TX interrupt request.
  * @param  None
  * @retval None   
  */
void USARTx_DMA_TX_IRQHandler(void)
{
  HAL_DMA_IRQHandler(UartHandle.hdmatx);
}

/**
  * @brief  This function handles USARTx interrupt request.
  * @param  None
  * @retval None
  */
void USARTx_IRQHandler(void)
{
  HAL_UART_IRQHandler(&UartHandle);
}
```

å°±å•å•ä¸²å£éƒ¨åˆ†åˆå§‹åŒ–å‡½æ•°ç¤ºä¾‹å¦‚ä¸‹:
```c
UartHandle.Instance          = USARTx;

UartHandle.Init.BaudRate     = 9600;
UartHandle.Init.WordLength   = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits     = UART_STOPBITS_1;
UartHandle.Init.Parity       = UART_PARITY_NONE;
UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
UartHandle.Init.Mode         = UART_MODE_TX_RX;
UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
if(HAL_UART_Init(&UartHandle) != HAL_OK)
  {
    Error_Handler();
  }
```
éœ€è¦æ³¨æ„çš„æ˜¯, åœ¨ä¸²å£ä¸­å¿…é¡»ç¼–å†™ MSP åˆå§‹åŒ–å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–GPIO, æ—¶é’Ÿç­‰ç­‰ã€‚<mark style="background: transparent; color: red">(æ³¨æ„: ä½¿ç”¨åˆ°DMAæ—¶, å¯¹äºDMAçš„åˆå§‹åŒ–å’Œé…ç½®ä¹Ÿå¿…é¡»åŠ åœ¨ MSPInit å‡½æ•°ä¸­)</mark> 

> [!caution] MSPInit è¯´æ˜
> MSP Init æ˜¯å…¬å…±çš„åˆå§‹åŒ–å‡½æ•°, å³è°ƒç”¨æ—¶, ä¼šå…ˆè°ƒç”¨ MSP Init è¿›è¡Œå…±ç”¨çš„åˆå§‹åŒ–ã€‚

```c
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
  static DMA_HandleTypeDef hdma_tx;
  static DMA_HandleTypeDef hdma_rx;
  
  GPIO_InitTypeDef  GPIO_InitStruct;
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();   // __HAL_RCC_GPIOA_CLK_ENABLE()
  USARTx_RX_GPIO_CLK_ENABLE();   // __HAL_RCC_GPIOA_CLK_ENABLE()
  /* Enable USART2 clock */
  USARTx_CLK_ENABLE();   // __HAL_RCC_USART2_CLK_ENABLE();
  /* Enable DMA1 clock */
  DMAx_CLK_ENABLE();      //  __HAL_RCC_DMA1_CLK_ENABLE() 
  
  /*##-2- Configure peripheral GPIO ##########################################*/  
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
  GPIO_InitStruct.Mode   = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
  
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
    
  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
    
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
  /*##-3- Configure the DMA streams ##########################################*/
  /* Configure the DMA handler for Transmission process */
  hdma_tx.Instance                 = USARTx_TX_DMA_STREAM;
  
  hdma_tx.Init.Channel             = USARTx_TX_DMA_CHANNEL;
  hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
  hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_tx.Init.MemInc              = DMA_MINC_ENABLE;
  hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_tx.Init.Mode                = DMA_NORMAL;
  hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;
  hdma_tx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
  hdma_tx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  hdma_tx.Init.MemBurst            = DMA_MBURST_INC4;
  hdma_tx.Init.PeriphBurst         = DMA_PBURST_INC4;
  
  HAL_DMA_Init(&hdma_tx);   
  
  /* Associate the initialized DMA handle to the the UART handle */
  __HAL_LINKDMA(huart, hdmatx, hdma_tx);
    
  /* Configure the DMA handler for Transmission process */
  hdma_rx.Instance                 = USARTx_RX_DMA_STREAM;
  
  hdma_rx.Init.Channel             = USARTx_RX_DMA_CHANNEL;
  hdma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
  hdma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_rx.Init.MemInc              = DMA_MINC_ENABLE;
  hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_rx.Init.Mode                = DMA_NORMAL;
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;
  hdma_rx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
  hdma_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  hdma_rx.Init.MemBurst            = DMA_MBURST_INC4;
  hdma_rx.Init.PeriphBurst         = DMA_PBURST_INC4; 

  HAL_DMA_Init(&hdma_rx);
    
  /* Associate the initialized DMA handle to the the UART handle */
  __HAL_LINKDMA(huart, hdmarx, hdma_rx);
    
  /*##-4- Configure the NVIC for DMA #########################################*/
  /* NVIC configuration for DMA transfer complete interrupt (USARTx_TX) */
  HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, 0, 1);
  HAL_NVIC_EnableIRQ(USARTx_DMA_TX_IRQn);
    
  /* NVIC configuration for DMA transfer complete interrupt (USARTx_RX) */
  HAL_NVIC_SetPriority(USARTx_DMA_RX_IRQn, 0, 0);   
  HAL_NVIC_EnableIRQ(USARTx_DMA_RX_IRQn);
  
  /* NVIC configuration for USART TC interrupt */
  HAL_NVIC_SetPriority(USARTx_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(USARTx_IRQn);
}
```
åœ¨ HAL åº“ä¸­, ç›´æ¥æä¾›äº†DMAä¸²å£å‘é€å‡½æ•°, æ–¹æ³•æ˜¯
```c
HAL_UART_Transmit_DMA(&UartHandle, (uint8_t*)aTxBuffer, TXBUFFERSIZE)
```

æœ€ç»ˆä¿®æ”¹ callback å›è°ƒå‡½æ•°å³å¯: 
```c
/**
  * @brief  Tx Transfer completed callback
  * @param  UartHandle: UART handle. 
  * @note   This example shows a simple way to report end of DMA Tx transfer, and 
  *         you can add your own implementation. 
  * @retval None
  */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
{
  /* Set transmission flag: transfer complete */
  UartReady = SET;

  /* Turn LED6 on: Transfer in transmission process is correct */
  BSP_LED_On(LED6); 
}

/**
  * @brief  Rx Transfer completed callback
  * @param  UartHandle: UART handle
  * @note   This example shows a simple way to report end of DMA Rx transfer, and 
  *         you can add your own implementation.
  * @retval None
  */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
{
  /* Set transmission flag: transfer complete */
  UartReady = SET;
  
  /* Turn LED4 on: Transfer in reception process is correct */
  BSP_LED_On(LED4);
}

/**
  * @brief  UART error callbacks
  * @param  UartHandle: UART handle
  * @note   This example shows a simple way to report transfer error, and you can
  *         add your own implementation.
  * @retval None
  */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
{
  /* Turn LED3 on: Transfer error in reception/transmission process */
  BSP_LED_On(LED3); 
}
```


## 2. STM32F4 çš„ SPI æ¨¡å¼å’Œ Dual SPI æ¨¡å¼
### (1) SPI å’Œ NOR Flash é©±åŠ¨
CS ä¸€èˆ¬ä½¿ç”¨ $\overline{CS}$ï¼Œ è¡¨ç¤ºä½ç”µå¹³æœ‰æ•ˆã€‚ ä¸€èˆ¬ 50MHz ä»¥ä¸‹çš„ SPI é€šä¿¡å‡å¯ä»¥è¿›è¡Œ, å®é™…ä¸Šæ— é™åˆ¶ã€‚

å¯¹äºå…¼å®¹åŠåŒå·¥æ¨¡å¼ä¸‹, SPI å¯ä»¥é€šè¿‡ MOSI è¿›è¡Œæ¥æ”¶æ•°æ®ã€‚
å¯¹äº F1 å’Œ F4 çš„SPIç»“æ„å‡æ˜¯ç›¸åŒçš„, å› æ­¤å¯ä»¥ç›´æ¥å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/ä¸‰ã€ä¸²å£ä¸é€šä¿¡åè®®/4. SPI é€šä¿¡åè®®ä¸W25Q64 FlashèŠ¯ç‰‡|SPI é€šä¿¡åè®®ä¸W25Q64 FlashèŠ¯ç‰‡]]; 
è€Œå¯¹äº F7 å’Œ H7 éƒ¨åˆ†, åˆ™ä¸ç›¸åŒã€‚å¹¶å¯ä»¥è¿›è¡ŒMOSIå’ŒMISO äº¤æ¢

ä¸€èˆ¬F1,F4, F7 ç³»åˆ—çš„ MCU å‡æœ‰ 3 ä¸ª SPI; åˆ†åˆ«ä¸º:

|           | SPI1 | SPI2 | SPI3 |
| --------- | ---- | ---- | ---- |
| NSS       | PA4  | PB12 | PA15 |
| SCL       | PA5  | PB13 | PB3  |
| MISO      | PA6  | PB14 | PB4  |
| SDA(MOSI) | PA7  | PB15 | PB5  |

è€Œ H7 ç³»åˆ—çš„ SPI æœ‰ 6 ä¸ªã€‚ä¸€èˆ¬åœ¨æ ‡å‡†åº“ä¸­, å¿…é¡»å¾ªç¯åˆ¤æ–­ TXE çš„å€¼ã€‚è€Œ HAL åº“ä¸­,  å¾€å¾€ç”µé˜»å±ç­‰ç­‰, ä¹Ÿå¯ä»¥é€šè¿‡è½¯ä»¶æ¨¡æ‹Ÿå®ç° SPIã€‚ F1, F4 å¯ä»¥å®ç° 8-16ä½ä¼ è¾“; è€Œ  H7, å¯ä»¥å®ç° 4-32ä½ä¼ è¾“(å¸§æ ¼å¼)ã€‚

å¯¹äº SPI ç›¸å…³ HAL åº“éƒ¨åˆ†, ä¸»è¦å‡½æ•°å¦‚ä¸‹:
```c
__HAL_RCC_SPIx_CLK_ENABLE();
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout);

HAL_SPI_Init();

__HAL_SPI_ENABLE(&spi_handler);    // ä½¿èƒ½SPIå¤–è®¾
```

å…¶ä¸­ Spi_HandlerTypedef æ˜¯å®ä¾‹åŒ–å¯¹è±¡; SPI_InitTypeDef æ˜¯åˆå§‹åŒ–ç»“æ„ä½“, é€šè¿‡.Init è®¿é—®ã€‚

å¯¹äºé«˜é€Ÿä¼ è¾“, é¢„åˆ†é¢‘å€¼é€‰æ‹©2å³å¯; è€ŒH7ä¹Ÿæœ‰IOSWrap éƒ¨åˆ†; 

æ¿è½½çš„ W25Q128 Flash èŠ¯ç‰‡, é»˜è®¤ä½¿ç”¨ SPI1å¤ç”¨åˆ°PB3- PB5éƒ¨åˆ†, æ“ä½œ W25Q128 èŠ¯ç‰‡; ç±»ä¼¼çš„ NM25Q128, BY25Q128; ä»å¼•è„šä¸Šå‡æ˜¯å…¼å®¹çš„ã€‚å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ®STM32æ•™ç¨‹/ä¸‰ã€ä¸²å£ä¸é€šä¿¡åè®®/4. SPI é€šä¿¡åè®®ä¸W25Q64 FlashèŠ¯ç‰‡|4. SPI é€šä¿¡åè®®ä¸W25Q64 FlashèŠ¯ç‰‡|SPI é€šä¿¡åè®®ä¸W25Q64 FlashèŠ¯ç‰‡]]

Flash åŒ…æ‹¬NOR Flash å’Œ NAND Flash ä¸¤ç§ç±»å‹, å³ä»æ•°å­—é—¨ç”µè·¯ 
NOR FLash æ˜¯åŸºäºå­—èŠ‚çš„è¯»å†™, æ”¯æŒ XIP, æ— åå—; 
NAND Flash é€Ÿåº¦æ¯” EEPROM ç¨æ…¢ï¼ŒåŸºäºå—è¯»å†™ã€‚å¦å¤–**å¯èƒ½æœ‰åå—**(æœ‰ä½å¤±æ•ˆ)ã€‚ä¸æ”¯æŒ XIP 

NOR Flash å¾€å¾€ç”¨äº 25Qxx, ROM ç­‰ç­‰;  è€ŒNAND Flash å¾€å¾€ç”¨äºUç›˜ç­‰å¤§å®¹é‡è®¾å¤‡ã€‚

å¯¹W25Q64,  SPI ä¼ è¾“æ—¶åºæ”¯æŒæ¨¡å¼ 0 (CPOL = 0, CPHA = 0) å’Œæ¨¡å¼3(CPOL = 1 , CPHA = 1)
![[attachments/Pasted image 20240715104112.png]]
æ”¯æŒåŒçº¿å’Œå››çº¿ SPI.  æŒ‰4 kb Sector, 64kb block; æ¯é¡µ 256byte, æŒ‰å­—èŠ‚ç¼–åœ°å€ã€‚å…± 2^24 bytes (16MBå†…å­˜ç©ºé—´)

| addr | operation |  |
| ---- | ---- | ---- |
| 06h | write enable |  |
| 04h | write disable |  |
| 05h | write status-register1 | read BUSY bit |
| 02h | page program | 256kb page write |
| 20h | Sector Erase |  |
| D8h | Block Erase |  |
| C7h/60h | Chip Erase |  |
| 9Fh | JDDEC ID |  |
| 03h | Read Data | no  page limit |

æ³¨æ„: ä¿®æ”¹ SPI ä¼ è¾“é€Ÿåº¦, åˆ™ä¸€èˆ¬éœ€è¦<mark style="background: transparent; color: red">æ“ä½œSPI1_CR1å¯„å­˜å™¨ä¸­çš„æ³¢ç‰¹ç‡æ§åˆ¶æ¥è¿›è¡Œä¿®æ”¹</mark>;
```c
void spi1_set_speed(uint8_t speed)
{
    assert_param(IS_SPI_BAUDRATE_PRESCALER(speed)); /* åˆ¤æ–­æœ‰æ•ˆæ€§ */
    __HAL_SPI_DISABLE(&g_spi1_handler);             /* å…³é—­SPI */
    g_spi1_handler.Instance->CR1 &= 0XFFC7;         /* ä½3-5æ¸…é›¶ï¼Œç”¨æ¥è®¾ç½®æ³¢ç‰¹ç‡ */
    g_spi1_handler.Instance->CR1 |= speed << 3;     /* è®¾ç½®SPIé€Ÿåº¦ */
    __HAL_SPI_ENABLE(&g_spi1_handler);              /* ä½¿èƒ½SPI */
}
```
ä¹Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹éƒ¨åˆ†:
```cpp
void spi1_set_speed(SPI_HandleTypeDef *hspi,uint32_t BaudRatePrescaler){
	hspi.Init.BaudRatePrescaler = BaudRatePrescaler;
	HAL_SPI_Init(hspi, SPI.....);
	__HAL_SPI_DISABLE(hspi);
}
```

å‚è€ƒ[[ğŸ’»softwares/âš¡Circuit/ğŸ¤– STM32F4å’ŒHALåº“éƒ¨åˆ†æ•™ç¨‹/åŸºæœ¬å†…å®¹/4. ç³»ç»Ÿæ—¶é’Ÿçš„ä½¿ç”¨å’Œåˆå§‹åŒ–+å¤ç”¨IOæ˜ å°„|4. ç³»ç»Ÿæ—¶é’Ÿçš„ä½¿ç”¨å’Œåˆå§‹åŒ–+å¤ç”¨IOæ˜ å°„]], **åœ¨SPIåˆå§‹åŒ–æ—¶, å¿…é¡»æ³¨æ„çš„æ˜¯, å‡¡æ˜¯å¤–è®¾, å¿…é¡»åˆå§‹åŒ–å¤ç”¨å™¨**ï¼Œ å³é…ç½®ä¸­å¿…é¡»æœ‰:

```c
GPIO_InitStructure.Alternate = GPIO_AF5_SPI1; Â  Â // must add this to configure multiplexer
```

åˆå§‹åŒ–ä»£ç å¦‚ä¸‹(å…¶ä¸­AF5_SPI1æ˜¯é…ç½®å¤ç”¨å™¨:)
```c
// Clock Cofiguration
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_SPI1_CLK_ENABLE();
// RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);

GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.Pin = GPIO_PIN_5|GPIO_PIN_7;  // SCL:PA5, SDA:PA7
GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
GPIO_InitStructure.Pull = GPIO_PULLUP;
GPIO_InitStructure.Alternate = GPIO_AF5_SPI1;    // must add this to configure multiplexer
HAL_GPIO_Init(GPIOA,  &GPIO_InitStructure);        

// ** PA3, PA6 as DC **
GPIO_InitStructure.Pin = GPIO_PIN_4|GPIO_PIN_6;   // use PA4 as RST, PA6 as DC
GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; 		 // Push-Pull Output 
GPIO_InitStructure.Speed = GPIO_SPEED_FAST;		 // 50MHz Speed
GPIO_InitStructure.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA,  &GPIO_InitStructure);	  		            // Init GPIOA 
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6,  GPIO_PIN_SET);
```

### (2) QSPI éƒ¨åˆ†
å½“é©±åŠ¨å¸¦æœ‰ QSPI æ¥å£çš„ Flash ç­‰æ—¶ï¼Œå¯ä»¥ä½¿ç”¨åŒçº¿ QSPI éƒ¨åˆ†ã€‚
å½“QSPIæ›´æ”¹ä¸º IO0 å’Œ IO1 åŒå‘ IO å£ã€‚ä½†å‡å˜ä¸ºåŠåŒå·¥é€šä¿¡ã€‚
F1, F4 å‡æ²¡æœ‰  QSPI å¤–è®¾, è€Œ F7, H7 ç­‰æ‰æœ‰ QSPI å¤–è®¾ã€‚
æœ‰SDR (å•å€æ•°æ®é€Ÿç‡) æ¨¡å¼å’Œ DDR (åŒå€é€Ÿç‡æ¨¡å¼, åœ¨åŒè¾¹æ²¿éƒ½è¿›è¡Œ), å…·ä½“è¿™ä¸ªä¹Ÿéœ€è¦å¤–è®¾è¿›è¡Œæ”¯æŒ

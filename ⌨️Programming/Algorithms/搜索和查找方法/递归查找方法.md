
````ad-check
title: 62.约瑟夫环问题
collapse:close
[详细解释](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/)

![[Pasted image 20230315195437.png|500]]

![[Pasted image 20230315194634.png|500]]

```cpp 
class Solution {
public:
	int lastRemaining(int n, int m) {
		return f(n, m);
	}

	int f(int n, int m) {
		if (n == 1) {
			return 0;
		}
		int x = f(n - 1, m);
		return (m + x) % n;
	}
};
```

上式的递归法可以改写称为迭代法 : 如下，避免使用栈空间

```cpp 
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0; // 初始迭代时刻 f(1, m)的值
        for (int i = 2; i != n + 1; ++i) {
            f = (m + f) % i; // 对应述解法中的(m + x) % n;
        }
        return f;
    }
};
```

上述题目也可以使用暴力进行求解，但是必定会超出时间限制
```cpp 
class Solution {
public:
    int lastRemaining(int n, int m) {
        // 暴力解法
        vector<bool> exist(n, true);
        int index = 0;
        int elim = 0; // 消除人数
        while (elim < n-1){
            for (int j = m-1; j> 0;index = (index + 1)%n){ // 前两人
                if (exist[index]) j--; // 存活
            }
            for (;exist[index] != true; index = (index+1)%n); // 跳过其中的死亡者
            exist[index] = false; elim +=1;
        }
        int i = 0;
        for (; !exist[i]; i++);
        return i;
    }
};
```
````

[[⌨️Programming/Data Structure/课程笔记/第三章 栈和队列的链式存储#三、递归算法|栈和队列与递归结合的典型问题]]


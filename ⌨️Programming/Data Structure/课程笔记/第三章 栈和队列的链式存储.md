## ä¸€ã€æ ˆçš„é“¾å¼å­˜å‚¨å®šä¹‰æ–¹æ³•
### (1) ä¸åŒç§ç±»æ ˆçš„å®šä¹‰å’Œä½¿ç”¨
å¯¹äºæ ˆçš„è¿ç»­å­˜å‚¨çš„æ•°ç»„å®šä¹‰ï¼Œ å¯ä»¥å‚è€ƒ[[âŒ¨ï¸Programming/Data Structure/C++åŸºç¡€çŸ¥è¯†/å¤ä¹  æ ˆå’Œé˜Ÿåˆ—|æ ˆçš„æ•°ç»„å®šä¹‰æ–¹æ³•]]

å¯¹äºæ ˆçš„é“¾å¼å­˜å‚¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥é“¾è¡¨çš„å¤´ç»“ç‚¹ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œ é¦–å…ˆï¼Œç©ºæ ˆçš„ `data = NULL` , è€Œç¬¬ä¸€æ¬¡å…¥æ ˆæ—¶ï¼Œä¸æ’å…¥å…ƒç´ ï¼Œä¹‹åå…¥æ ˆæ—¶ï¼Œä¼šä¿®æ”¹å¤´ç»“ç‚¹ä¸ºæ ˆé¡¶å…ƒç´ å¹¶ä¸”è¿”å›å¤´ç»“ç‚¹

å…¶ä¼˜ç‚¹æ˜¯åŠ¨æ€åˆ†é…å†…å­˜ï¼Œä¸å‡ºç°æ ˆæ»¡çš„æƒ…å†µ

å¦ä¸€ç§æ–¹æ³•æ˜¯ä»¥å¤´ç»“ç‚¹çš„nextèŠ‚ç‚¹ä½œä¸ºæ ˆé¡¶å…ƒç´ ï¼Œæ¯ä¸€æ¬¡è¿›æ ˆæ—¶åªéœ€è¦ä½¿ç”¨å¤´æ’æ³•æ’å…¥å…ƒç´ ï¼Œåˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼Œåªéœ€è¦çœ‹top-> next == NULL å³å¯

`````ad-note
title: å¯åˆ†é…å­˜å‚¨ç©ºé—´çš„è¿ç»­æ ˆä»£ç å®ç°
collapse: close

æœ€åˆåˆå§‹åŒ–top = -1
åœ¨åˆ†é…æ–°çš„ç©ºé—´æ—¶ï¼Œæ–°åˆ›å»ºæŒ‡é’ˆå¹¶å¤åˆ¶ä¸€ä»½å¯¹åº”çš„å…ƒç´ ç»™æ–°çš„æ•°ç»„

å¦å¤–ä¸‹é¢åœ¨æ ˆä¸­å†™å¥½äº†templateç±»å‹ï¼Œtemplate å‡½æ•°æ”¾åœ¨å¤–éƒ¨å®šä¹‰æ—¶ä¸€å®šè¦åœ¨æ¯ä¸ªå‡½æ•°å‰é¢éƒ½åŠ ä¸Štemplate
```cpp 
#include <iostream>
#define MAX_STACK_SIZE 100
#define STACK_SIZE_INCREASE 10
using namespace std;

template<class ElemType>
// é¡ºåºæ ˆç±»å‹
class SeqStack{
public:
	SeqStack() {
		InitSeqStack();
	};
	void push(ElemType elem);
	ElemType pop();
	bool isEmpty();
private:
	ElemType* Elem = new ElemType[MAX_STACK_SIZE];
	// åŸºäºæ•°ç»„çš„è¿ç»­å­˜å‚¨çš„æ ˆ
	void InitSeqStack();  // å°†å…¶ç§æœ‰åŒ–ï¼Œä½¿ç”¨æ—¶ç›´æ¥åˆå§‹åŒ–
	int top = -1;
	int size = MAX_STACK_SIZE;
};

template<class ElemType>
// åˆ›å»ºé¡ºåºæ ˆç±»å‹, topæŒ‡å‘çš„æ˜¯æ ˆçš„é¡¶éƒ¨å…ƒç´ 
void SeqStack<ElemType>::InitSeqStack(){ // æœ€åˆä½¿ç”¨top = -1æ¥æ„é€ ä¸€ä¸ªç©ºæ ˆ
	this->top = -1;
}

// å…¥æ ˆ
template<class ElemType>
void SeqStack<ElemType>::push(ElemType elem) {
	if (!this) return; // æ­¤æ—¶sä¸ºç©ºæŒ‡é’ˆ
	if (this->top < this->size-1) { // å¦‚æœæ ˆæ»¡ï¼Œåˆ™éœ€è¦é‡æ–°åˆ†é…ç©ºé—´æœ€å¤š98
		this->top++;
		this->Elem[this->top] = elem; // è®¿é—®å†…éƒ¨çš„
	}
	else { // é‡æ–°åˆ†é…ç©ºé—´ï¼Œç„¶åå¤åˆ¶ä¸€ä»½åŸå…ˆçš„æ•°ç»„ç»™æ–°çš„å¢åŠ çš„æ•°ç»„
		this->top++;
		this->size += STACK_SIZE_INCREASE;
		ElemType* s2 = new ElemType[this->size + STACK_SIZE_INCREASE];
		ElemType* p = this->Elem;
		for (int i = 0; i < this->size; i++) {
			s2[i] = this->Elem[i];
		}
		delete p;
		this->Elem = s2; // å°†æŒ‡é’ˆå€¼èµ‹å€¼ç»™s2;
		// ç”±äºæ˜¯æŒ‡é’ˆï¼Œä¸ç®—å±€éƒ¨å˜é‡
	}
}

// å‡ºæ ˆ
template<class ElemType>
ElemType SeqStack<ElemType>::pop() {
	// å¦‚æœæ ˆä¸ºç©ºï¼Œåˆ™è¿”å›ç©ºï¼Œä¸è¿›è¡Œpopæ“ä½œ
	if (this!=NULL && this->top != -1) {
		ElemType e = this->Elem[this->top];
		(this->top)--;
		return e;
	}
	else {
		return NULL; 
	}
}

// åˆ¤æ–­ä¸€ä¸ªæ ˆæ˜¯å¦ä¸ºç©º
template<class ElemType>
bool SeqStack<ElemType>::isEmpty(){
	return this->top == -1;
}

/* Test Code*/
int main() {
	SeqStack<int>* s1 = new SeqStack<int>();
	for (int i = 0; i < 250; i++) {
		s1->push(i);
	}
	cout << s1->pop() << endl;
	return 0;
}
```

`````

````ad-note
title: é“¾è¡¨å‹æ ˆçš„ä»£ç å®ç°
collapse:close

ä¸‹é¢çš„ä»£ç ç»™å‡ºäº†ä¸€ä¸ªé“¾è¡¨å­˜å‚¨ç±»å‹æ ˆçš„å®ç°

```cpp 
#include <iostream>
#include <vector>
using namespace std;
typedef int DataType;

// æ ˆï¼Œå…¶ä¸­å¤´ç»“ç‚¹ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œ å°¾ç»“ç‚¹ä¸ºæ ˆåº•å…ƒç´ 
typedef struct stack{
	// å¯¹äºé“¾å¼å­˜å‚¨çš„æ ˆï¼Œä¸å­˜åœ¨æº¢å‡ºçš„æƒ…å†µ
	stack* next = NULL;
	DataType data = NULL; // 0
};

// æ’å…¥å¹¶æ›´æ–°å¤´ç»“ç‚¹ä¸ºæ–°çš„æ ˆé¡¶
stack* push(stack* top, DataType data) { 
	if (!top->data == NULL) {
		// è¿™ä¸ªä¸è¦ä½¿ç”¨data == NULLæ¥å®ç°ï¼Œç”¨!topæ¥è¿›è¡Œå®ç°
		top->data = data; // æœ€ä¸‹é¢çš„ä¸€ä¸ªçš„nextå¿…å®šä¸ºnull
	}
	else {
		stack* Node = new stack();
		Node->next = top;
		Node->data = data; // æ³¨æ„èµ‹å€¼
		top = Node;
	}
	return top;
}

stack* pop(stack* top, DataType* data) {
	// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œå¹¶ä½¿ç”¨æŒ‡é’ˆå°†å‡ºæ ˆå…ƒç´ æ›´æ–°åˆ°dataä¸­
	if (top->data == NULL) { // ç©ºæ ˆ
		cout << "pop failed!" << endl;
	} 
	else if (top->next == NULL) {
		(*data) = top->data;
		top->data = NULL;
	}
	else{
		(*data) = top->data;
		stack* p = top;
		top = top->next;
		delete p; // é‡Šæ”¾pæŒ‡é’ˆçš„å†…å­˜ç©ºé—´, newå¯¹è±¡ä½¿ç”¨deleteè¿›è¡Œé‡Šæ”¾
	}
	return top;
}

int main() {
	int s1, s2;
	cin >> s1 >> s2;
	vector<int> v1, v2; // æ³¨æ„å‘é‡åˆå§‹åŒ–æ—¶ï¼Œä¸ç”¨å…ˆåˆ†é…
	int input;
	for (int i = 0; i < s1; i++) {
		cin >> input;
		v1.push_back(input);
	}
	for (int i = 0; i < s2; i++) {
		cin >> input;
		v2.push_back(input);
	}

	stack* T = new stack();  // æ–°å»ºä¸€ä¸ªstackç»“æ„ä½“

	for (int i = 0, j = 0; !(s1 == i && s2 == j);){
		if (i == s1) {
			T = push(T, v2[j]); j++;
		}
		else if (j ==  s2) {
			T = push(T, v1[i]); i++;
		}
		else {
			if (v1[i] < v2[j]) {
				T = push(T, v1[i]); i++;
			}
			else {
				T = push(T, v2[j]); j++;
			}
		}
	}

	DataType output;
	for (int i = 0; i < s1 + s2; i++) {
		T = pop(T, &output);
		cout << output << " ";
	}
	return 0;
}
```
````

`````ad-note
title:å¸¦æœ‰templateçš„é“¾æ ˆä»£ç 
collapse:close
```cpp 
#include <iostream>
#include <vector>
using namespace std;

template <typename DataType>
struct Stack { // å®šä¹‰ç±»å‹ï¼Œä¸‹é¢çš„stackæ˜¯å®ä¾‹åŒ–ç”¨çš„
	// å¯¹äºé“¾å¼å­˜å‚¨çš„æ ˆï¼Œä¸å­˜åœ¨æº¢å‡ºçš„æƒ…å†µ
	Stack* next = NULL;
	DataType data = NULL;
};

// æ ˆï¼Œä¸å¸¦å¤´ç»“ç‚¹ï¼Œå¤´æŒ‡é’ˆä¸ºæ ˆé¡¶å…ƒç´ ï¼Œ å°¾ç»“ç‚¹ä¸ºæ ˆåº•å…ƒç´ 
template <class DataType>
class LinkStack { // ä¹‹åè€ƒè™‘é‡è½½é—®é¢˜
public:
	LinkStack() {
		InitStack();
	};
	void push(DataType data);
	DataType pop();
	// åœ¨ç±»å†…å®šä¹‰æ ˆ
private:
	Stack<DataType>* top = NULL;  // å®šä¹‰ä¸€ä¸ªæ ˆé¡¶æŒ‡é’ˆ
	void InitStack();
};

template <class DataType>
void LinkStack<DataType>::InitStack() {
	this->top = new Stack<DataType>; // nextå’Œdataè‡ªåŠ¨åˆå§‹åŒ–ä¸ºNULL
}

// æ’å…¥å¹¶æ›´æ–°å¤´ç»“ç‚¹ä¸ºæ–°çš„æ ˆé¡¶
template <class DataType>
void LinkStack<DataType>::push(DataType data) {
	if (top->data == NULL) {
		top->data = data; // æœ€ä¸‹é¢çš„ä¸€ä¸ªçš„nextå¿…å®šä¸ºnull
	}
	else {
		Stack<DataType>* Node = new Stack<DataType>();
		Node->next = top;
		Node->data = data; // æ³¨æ„èµ‹å€¼
		top = Node;
	}
}

template <class DataType>
DataType LinkStack<DataType>::pop() {
	// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œå¹¶ä½¿ç”¨æŒ‡é’ˆå°†å‡ºæ ˆå…ƒç´ æ›´æ–°åˆ°dataä¸­
	if (top->data == NULL) return NULL; // ç©ºæ ˆ
	else if (top->next == NULL){ // åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œè¿›è¡Œå¼¹å‡º
		DataType data = top->data;
		top->data = NULL;
		return data;
	}
	else{
		DataType data = top->data;
		Stack<DataType>* p = top;
		top = top->next;
		delete p; // é‡Šæ”¾pæŒ‡é’ˆçš„å†…å­˜ç©ºé—´, newå¯¹è±¡ä½¿ç”¨deleteè¿›è¡Œé‡Šæ”¾
		return data;
	}
}

int main() {
	LinkStack<int> T;  // æ–°å»ºä¸€ä¸ªstackç»“æ„ä½“
	for (int i = 0; i < 100; i++) {
		T.push(i);
	}
	for (int i = 0; i < 100; i++) {
		cout << T.pop() << " ";
	}
	return 0;
}

```
`````

å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ ä¸Šè¿°æ–¹æ³•å®šä¹‰çš„æ˜¯ä¸å¸¦å¤´ç»“ç‚¹çš„æ ˆï¼Œå¦‚æœå®šä¹‰å¸¦æœ‰å¤´ç»“ç‚¹çš„æ ˆï¼Œ åˆ™å¾€å¾€`top -> next`æŒ‡å‘æ ˆé¡¶çš„å…ƒç´ ï¼Œ`top`æŒ‡å‘æ ˆé¡¶çš„ä¸‹ä¸€ä¸ªå…ƒç´ 

åœ¨c++ä¸­ï¼Œå®šä¹‰æ ˆåªéœ€è¦ä½¿ç”¨`#include<stack>` å°±å¯ä»¥äº†ï¼Œ å¹¶ä½¿ç”¨
`stack<int> s1`æ¥å®šä¹‰æ ˆ

å¾€å¾€å¯ä»¥ä½¿ç”¨`copy`çš„æ–¹æ³•æ¥å¤åˆ¶æ ˆä¸­çš„å…ƒç´ ç„¶åé‡æ–°åˆ†é…æ ˆç©ºé—´ï¼Œ å¦‚

```cpp 
int main() {
	int a[3] = { 1,2,3 };
	int b[5];
	std::copy(begin(a), end(a), begin(b));
	cout << b[0];
	return 0;
}
```

### (2) å¤šæ ˆå…±äº«æŠ€æœ¯
å¯¹äºè¿ç»­å­˜å‚¨çš„æ ˆï¼Œä¸ºäº†é˜²æ­¢ç”±äºå¯¹æ ˆçš„ç©ºé—´ä¼°è®¡ä¸è¶³ä¸ºå¯¼è‡´çš„æ ˆçš„æº¢å‡ºï¼Œå¯ä»¥ä½¿ç”¨å¤šä¸ªæ ˆæ¥å…±äº«ä¸€ä¸ªè¶³å¤Ÿå¤§çš„æ•°ç»„ç©ºé—´ï¼Œé€šè¿‡åˆ©ç”¨æ ˆçš„åŠ¨æ€ç‰¹æ€§è¿›è¡Œå­˜å‚¨ç©ºé—´ç›¸äº’è¡¥å……
```cpp 
#define MAZ_STACK_SIZE 100
typedef struct DStack{
DataType Stack[MAX_STACK_SIZE];
int top[2] = {-1, M}; // å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ, åˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªæ ˆé¡¶, å…¶ä¸­top[0]ä¸º0å·æ ˆ, [1]ä¸º1å·æ ˆ
}

void InitStack(DStack* stack){
	S->top[0] = -1; // 0å·æ ˆ
	S->top[1] = M; // 1å·æ ˆçš„æ ˆåº•ä¸ºM
}

// å¯¹äºåˆ¤æ–­æ ˆå·²æ»¡çš„æ“ä½œï¼Œåªéœ€è¦åˆ¤æ–­:
S->top[0] + 1 == S->top[1];
```

### (3) é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼çš„å®ç°æ–¹æ³•
#### 1. é€†æ³¢å…°è¡¨è¾¾å¼çš„æ„é€ 
æ³¨æ„è¾“å…¥ä¸€æ•´è¡Œæ•°å¯ä»¥ä½¿ç”¨
`getline(cin, s);`
æ¥è¿›è¡Œå®ç°
ä¸€è¡Œè¾“å…¥å¤šä¸ªæ•°å­—åˆ°ç©ºæ ¼ä¹‹åbreak:
```cpp 
while (cin >> input){
		Que.push(input);
		if (cin.get() == '\n') break;
	}
```

é€†æ³¢å…°è¡¨è¾¾å¼çš„ç»“æ„ä¸º : 

| ä¸­ç¼€è¡¨è¾¾å¼         | é€†æ³¢å…°è¡¨è¾¾å¼    |
|---------------|-----------|
| A + B         | A B +     |
| A * B         | A B *     |
| A +B * C      | A B C * + |
| A * ( B + C ) | A B C + * |

æ„é€ æ–¹æ³•å‚è€ƒå¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç«  
[é€†æ³¢å…°è¡¨è¾¾å¼](https://www.cnblogs.com/lanhaicode/p/10776166.html)

æ¯ä¸€æ¬¡ï¼Œå¯¹äºå³æ‹¬å·å‡ºç°æ—¶ï¼Œæ‰¾åˆ°æœ€è¿‘çš„å·¦æ‹¬å·ï¼Œå¹¶å°†å·¦å³æ‹¬å·å†…çš„éƒ¨åˆ†å¼¹å‡ºæ ˆsignStk
æˆ‘ä»¬ä»¥å¦‚ä¸‹çš„è¡¨è¾¾å¼è®¡ç®—ä¸ºä¾‹ï¼š
$$a * b+ c +(d*e+f*g) *h$$

![[Reverse_Poland_Expression.jpg|è¿‡ç¨‹å‚è€ƒ|1200]]
åˆ™å¾—å‡ºçš„é€†æ³¢å…°è¡¨è¾¾å¼ä¸ºï¼š 
$$ab*cde*fg+h*++$$
åœ¨signæ ˆå‡ºæ ˆå’Œå…¥æ ˆçš„è¿‡ç¨‹ä¸­ï¼Œåœ¨signä¸­çš„æ“ä½œæ•°ï¼Œ<mark style="background: transparent; color: yellow">è¶Šé è¿‘æ ˆé¡¶ï¼Œä¼˜å…ˆçº§è¶Šé«˜</mark>ï¼Œä¸è¿‡ä»…é™äºå·¦æ‹¬å·åé¢çš„éƒ¨åˆ†

å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé‡åˆ°è¿ç®—ç¬¦æ¯”è¿™ä¸ªé«˜çš„éƒ¨åˆ†(å³ä¸Šè¿°è¿‡ç¨‹ä¸­çš„ç¬¬1, 2æ­¥)ï¼Œåˆ™<mark style="background: transparent; color: yellow">å°†å‰é¢å…¨éƒ¨ä¼˜å…ˆçº§æ›´ä½çš„è¿ç®—ç¬¦å…¨éƒ¨å‡ºæ ˆï¼Œç„¶åå°†è‡ªå·±å…¥æ ˆ</mark>ï¼Œä½†æ˜¯é‡åˆ°å·¦æ‹¬å·æ—¶ï¼Œä¸ç”¨æ‰§è¡Œå‡ºæ ˆæ“ä½œ ã€‚

å¯ä»¥ç»™å¦å¤–ä¸€ä¸ªæ³¢å…°è¡¨è¾¾å¼çš„æ±‚å€¼ç¤ºä¾‹
$$5 ^ 3 + 2 * 1$$
æ ˆåˆ†åˆ«ä¸º

| num  | 5   | ^   | 3   | 2   | 1   | 
| ---- | --- | --- | --- | --- | --- |
| sign | +   | *   |     |     |     |

å‡ºæ ˆåçš„é€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼ä¸ºï¼š 

| num  | 5   | ^   | 3   | 2   | 1   | *   | +   |
| ---- | --- | --- | --- | --- | --- | --- | --- |
| sign |     |     |     |     |     |     |     |

`````ad-note
title: å°†è¡¨è¾¾å¼è½¬æ¢ä¸ºé€†æ³¢å…°è¡¨è¾¾å¼çš„ä»£ç ç¤ºä¾‹
collapse: close
å…¶ä¸­è¿ç®—å˜é‡ä»¥a,b,cç­‰ç­‰è¡¨ç¤º
```cpp 
#include<iostream>
#include<stack>
#include<string>
#include<unordered_map>
using namespace std;

// ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å¯¹åº”çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§
unordered_map<char, int> Priority = {
	{'+',1},
	{'-',1},
	{'*',2},
	{'/',2},
	{'^',3},
	{'(',4},
	{')',4}
};

int main() {
	string s;
	getline(cin, s);
	stack<char> numStk, signStk;
	for (char ch : s) { 
		// è¿›è¡Œå…¥æ ˆå’Œå‡ºæ ˆæ“ä½œ, è¾“å‡ºé€†æ³¢å…°è¡¨è¾¾å¼
		if (ch >= 97 && ch <= 122) { 
			// å­—ç¬¦a-z 
			numStk.push(ch);  // æ”¾å…¥æ•°å­—
		}
		else if (Priority.count(ch)) {
			// è¾“å…¥çš„éƒ¨åˆ†ä¸ºè¿ç®—ç¬¦, æ³¨æ„æ ˆæœ‰å¯èƒ½æ˜¯ç©ºçš„
			if (signStk.empty()) {
				signStk.push(ch);
			}
			else if (ch == ')') {  // é¦–å…ˆåˆ¤æ–­å³æ‹¬å·
				while (signStk.top() != '(') {
					numStk.push(signStk.top());
					signStk.pop();
				}
				signStk.pop(); // å‡ºæ ˆ(å¹¶èˆå¼ƒ
			}
			else if (Priority[ch] < Priority[signStk.top()]) {
				// å‰ä¸€ä¸ªè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§åˆ«æ¯”è¿™ä¸ªå¤§ï¼Œåˆ™æŒç»­å‡ºæ ˆç›´åˆ°é‡åˆ°å·¦æ‹¬å·
				// æ³¨æ„: è¿™é‡Œçš„ä»£ç å¹¶ä¸å®Œå…¨æ­£ç¡®ï¼Œé‡åˆ°ä¼˜å…ˆçº§æ¯”åŸå§‹è¿ç®—ç¬¦æ›´å°çš„æ—¶ï¼Œä¹Ÿä¼šç»ˆæ­¢
				while (!signStk.empty() && signStk.top() != '(') {
					numStk.push(signStk.top());
					signStk.pop();
				}
				// ç„¶åè¿™ä¸ªè¿ç®—ç¬¦å…¥æ ˆ
				signStk.push(ch);
			}
			else {
				signStk.push(ch); // è¿ç®—ç¬¦å…¥æ ˆ
			}
		}
	}
	// è¡¨è¾¾å¼éå†å®Œæ¯•åï¼Œå¯¹è¿ç®—ç¬¦æ ˆå†…çš„éƒ¨åˆ†è¿›è¡Œå‡ºæ ˆ
	while (!signStk.empty()) {
		numStk.push(signStk.top());
		signStk.pop();
	}

	stack<char> preStk;

	while (!numStk.empty()) {
		preStk.push(numStk.top());
		numStk.pop();
	}

	while (!preStk.empty()) {
		cout << preStk.top();
		preStk.pop();
	}
	return 0;
}
```

`````

#### 2. æœ‰æ•ˆè¡¨è¾¾å¼çš„åˆ¤æ–­ä»£ç ç¤ºä¾‹
è§é—®é¢˜[[ğŸ“˜ClassNotes/ğŸ—£ï¸English/ğŸ–Šï¸Learning_Notes/â”LeeCode Problems/å­—ç¬¦ä¸²çš„æ‹¬å·åŒ¹é…é—®é¢˜]]

#### 3. é€†æ³¢å…°è¡¨è¾¾å¼çš„è¿ç®—

åœ¨è®¡ç®—è¿™äº›è¡¨è¾¾å¼çš„å€¼æ—¶ï¼Œé€šè¿‡å°†æ•°å­—å…¥æ ˆï¼Œé‡åˆ°**è¿ç®—ç¬¦**ååœ¨æŠŠæ•°å­—å‡ºæ ˆï¼Œ**è®¡ç®—**ï¼Œè®¡ç®—å®Œå†æ¬¡å…¥æ ˆã€‚ä¸€ç›´å¾ªç¯â€¦â€¦
![[attachments/Pasted image 20230324195855.png|500]]

## äºŒã€é˜Ÿåˆ—çš„é“¾å¼å®šä¹‰æ–¹æ³•
### (1) è¿ç»­å­˜å‚¨çš„é˜Ÿåˆ—å®šä¹‰æ–¹æ³•
åœ¨è¿ç»­å­˜å‚¨çš„é˜Ÿåˆ—å®šä¹‰ä¸­ï¼Œä¼šå®šä¹‰ä¸€ä¸ªfronté˜Ÿé¦–æ•°å­—å’Œä¸€ä¸ªrearé˜Ÿå°¾æ•°å­—
å…¶ä¸­font è¡¨ç¤º**é˜Ÿé¦–çš„å…ƒç´ **, rearè¡¨ç¤º**é˜Ÿå°¾å…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ **
å› æ­¤å¯ä»¥ç›´æ¥é€šè¿‡frontæ¥è¿›è¡Œè®¿é—®
[[âŒ¨ï¸Programming/Data Structure/C++åŸºç¡€çŸ¥è¯†/å¤ä¹  æ ˆå’Œé˜Ÿåˆ—#ä¸€ã€é˜Ÿåˆ—|è¿ç»­å­˜å‚¨é˜Ÿåˆ—çš„å®šä¹‰]]

`````ad-summary
title:å¸¦templateçš„è¿ç»­é˜Ÿåˆ—å®šä¹‰
collapse:close

```cpp 
#include <iostream>
#define MAX_QUEUE_SIZE 100
using namespace std;

// æ³¨æ„: é€šè¿‡æ­¤ç§æ–¹å¼å®šä¹‰çš„è¿ç»­å­˜å‚¨çš„é˜Ÿåˆ—å¯èƒ½ä¼šäº§ç”Ÿæº¢å‡ºæƒ…å†µ
template <typename DataType>
struct queueNode {
	// é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨
	DataType* Data = new DataType[MAX_QUEUE_SIZE];
	int rear;
	int front;
};

template <class DataType>
class SeqQueue{
public:
	SeqQueue() {
		InitQueue();
	}
	bool IsEmpty();
	void push(DataType data);
	void ClearQueue();
	int GetQueueLength();
	DataType pop();

private:
	void InitQueue();
	queueNode<DataType> queue;
};

template <class DataType>
void SeqQueue<DataType>::InitQueue() { 
	// åˆå§‹åŒ–é“¾å¼å­˜å‚¨çš„é˜Ÿåˆ—
	queue.front = 0;
	queue.rear = 0;
	// å…¶ä¸­front = rearæ—¶,é˜Ÿåˆ—ä¸ºç©º
}

template <class DataType>
int SeqQueue<DataType>::GetQueueLength() {
	return queue.rear - queue.front;
}

template <class DataType>
void SeqQueue<DataType>::ClearQueue() { 
	// æ¸…ç©ºé˜Ÿåˆ—
	queue->front = 0;
	queue->rear = 0;
}

template <class DataType>
bool SeqQueue<DataType>::IsEmpty() {
	return queue.rear == queue.front;
}

template <class DataType>
void SeqQueue<DataType>::push(DataType data) {
	if (queue.rear < MAX_QUEUE_SIZE -1 ) {
		queue.Data[queue.rear++] = data;
	}
}

template <class DataType>
DataType SeqQueue<DataType>::pop() {
	if (IsEmpty()) return NULL; // ç©ºé˜Ÿï¼Œç›´æ¥è¿”å›
	else {
		return queue.Data[queue.front++];
	}
}

int main() {
	SeqQueue<int> q;
	cout << q.IsEmpty()<< endl;
	for (int i = 0; i < 20; i++) {
		q.push(i);
	}
	cout << q.GetQueueLength() << endl;
	for (int i = 0; i < 20; i++) {
		cout << q.pop() << " ";
	}
	cout << endl;
	cout << q.IsEmpty() << endl;
	return 0;
}
```

`````

### (2) å¾ªç¯é˜Ÿåˆ—éƒ¨åˆ†
å¯¹äºå¾ªç¯é˜Ÿåˆ—çš„å®šä¹‰ï¼Œåœ¨é˜Ÿåˆ—æ»¡æ—¶ï¼Œrear = front, é˜Ÿåˆ—ç©ºæ—¶ï¼Œrear = front ï¼Œ åˆ™åœ¨pushæ—¶éœ€è¦è¿›è¡Œåˆ¤æ–­é˜Ÿä¼ç©ºè¿˜æ˜¯é˜Ÿä¼æ»¡
<mark style="background: transparent; color: yellow">æ–¹æ³•ä¸€æ˜¯æµªè´¹ä¸€ä¸ªç©ºé—´æ¥è¿›è¡Œåˆ¤æ–­</mark>ï¼Œ å³ $(rear+1)\%size = front$ æ—¶ä¸ºé˜Ÿæ»¡ï¼Œè€Œ$rear =front$æ—¶é˜Ÿç©º
<mark style="background: transparent; color: yellow">æ–¹æ³•äºŒæ˜¯åœ¨æ€»ç»“æ„ä½“ä¸­å®šä¹‰lengthæ¥å­˜å‚¨ç›®å‰é˜Ÿä¼ä¸­çš„å…ƒç´ ä¸ªæ•°</mark>
ä¸¤ç§æ–¹æ³•å‡éœ€è¦ä½¿ç”¨å¤šä½™çš„ä¸€ä¸ªç©ºé—´ï¼Œä¸è¿‡åœ¨æ—¶é—´ä¸Šç¬¬äºŒç§æ¯æ¬¡éœ€è¦è¿ç®—é•¿åº¦

### (3) é“¾å¼å­˜å‚¨çš„é˜Ÿåˆ—å®šä¹‰æ–¹æ³•
é“¾å¼å­˜å‚¨çš„é˜Ÿåˆ—åœ¨<mark style="background: transparent; color: red">èŠ‚ç‚¹ç»“æ„ä½“ä¸­ä»…å®šä¹‰ä¸€ä¸ªnextæŒ‡é’ˆ, å½¢æˆå•å‘é“¾è¡¨çš„æ ¼å¼</mark>
è€Œåœ¨ç»“æ„ä½“å¼çš„å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦å¦å¤–å®šä¹‰ä¸€ä¸ªç»“æ„ä½“==å­˜å‚¨é˜Ÿé¦–å’Œé˜Ÿå°¾==å³å¯

```cpp 
typedef struct Node{
DataType data;
struct *next;
};

typedef struct LinkQueue{
Node *font;
Node *rear;
};
```

æ­¤å¤„ä½¿ç”¨class ä¸­çš„ç§æœ‰å˜é‡å®šä¹‰é˜Ÿé¦–å’Œé˜Ÿå°¾æŒ‡é’ˆ

`````ad-summary
title: ç±»å®šä¹‰ä»£ç 
collapse: close
rearæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ 
```cpp 
#include <iostream>
using namespace std;

template <typename DataType>
struct QueueNode {
	DataType data = NULL;
	QueueNode* next = NULL; // å­˜å‚¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
};

template <class DataType>
class LinkQueue {
public:
	LinkQueue() {
		InitQueue();
	}
	void push(DataType data);
	DataType pop();
	bool IsEmpty();
	DataType GetHead();

private:
	void InitQueue();
	QueueNode<DataType>* front;
	QueueNode<DataType>* rear;
};

// ä½¿ç”¨å¸¦å¤´ç»“ç‚¹çš„æ–¹å¼è¿›è¡Œåˆå§‹åŒ–
template <class DataType>
void LinkQueue<DataType>::InitQueue() {
	front = new QueueNode<DataType>(); // ä½¿ç”¨é¢å¤–çš„å¤´æŒ‡é’ˆ
	rear = front; // å¤´æŒ‡é’ˆå’Œå°¾æŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªèŠ‚ç‚¹
	// front->next = NULL: åˆå§‹åŒ–æŒ‡é’ˆä¸ºNULL
}

// å…¥é˜Ÿï¼ŒrearæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ 
template <class DataType>
void LinkQueue<DataType>::push(DataType data) {
	QueueNode<DataType>* Q = new QueueNode<DataType>(); //
	rear ->next = Q;
	rear = rear->next;
	rear ->data = data;
}

// å‡ºé˜Ÿï¼Œhead-> nextä¸ºå¤´å…ƒç´ 
template <class DataType>
DataType LinkQueue<DataType>::pop() {
	// å®é™…popçš„dataåº”è¯¥æ˜¯front-> next -> data
	QueueNode<DataType>* Q = front;
	front = front->next;
	DataType data = front->data;
	delete Q;
	front->data = NULL; // è®¾ç½®ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸ºå¤´ç»“ç‚¹
	return data;
}

template <class DataType>
bool LinkQueue<DataType>::IsEmpty() {
	return rear == front;
}

template <class DataType>
DataType LinkQueue<DataType>::GetHead() { 
	// è®¿é—®é˜Ÿé¦–å…ƒç´ 
	if (!front->next) return NULL;  // ç©ºé˜Ÿ
	return front->next->data;
}

int main() {
	LinkQueue<int> Q;
	for (int i = 0; i < 100; i++) {
		Q.push(i);
	}

	for (int i = 0; i < 100; i++) {
		cout << Q.pop() << " ";
	}
	return 0;
}
```

`````

## ä¸‰ã€é€’å½’ç®—æ³•
#### (1) æ±‰è¯ºå¡”ç®—æ³•
å¯¹äºæ±‰è¯ºå¡”è¿™ä¸€ç§å…¸å‹çš„é€’å½’æ±‚è§£ç®—æ³•

å¯¹äº$n=1$æ—¶ï¼Œ åˆ™åªéœ€å°†$1$å·åœ†ç›˜ä»$X$ç§»åŠ¨åˆ°$Z$ä¸Š
å¯¹äº$n > 1$æ—¶ï¼Œé¦–å…ˆå°†å‹åœ¨$n$å·åœ†ç›˜ä¸Šé¢çš„$n-1$ä¸ªåœ†ç›˜ç§»åŠ¨åˆ°å¡”åº§$Y$ä¸Š

æ€»å…±ç®—æ³•æ˜¯ä¸‰ä¸ªç›˜ï¼Œæ¯æ¬¡å°†ä¸Šé¢çš„$n-1$ä¸ªçœ‹æˆæ•´ä½“
![[Excalidraw/ç¬¬ä¸‰ç«  æ ˆå’Œé˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨ 2023-03-27 18.53.24|400]]
```cpp 
#include <iostream>
using namespace std;

void move(int n, char X, char Z) {
	cout << n << " " <<  X << "->" << Z << endl;
}

// ä»xç§»åŠ¨åˆ°z, Y è¾…åŠ©
void Hanoi_Tower(int n, char X, char Y, char Z) {
	if (n == 1) {
		move(1, X, Z);
	}
	else {
		Hanoi_Tower(n - 1, X, Z, Y); // å°†n-1å±‚é€’å½’æ”¾åˆ°Yä¸Š, å…¶ä¸­ä½¿ç”¨Zä½œä¸ºè¾…åŠ©å¡”
		move(n, X, Z);
		Hanoi_Tower(n - 1, Y, X, Z); // å°†n-1å±‚ä»Yé€’å½’æ”¾åˆ°Zä¸Š, ä½¿ç”¨Xä¸ºè¾…åŠ©å¡”
	}
}

int main() {
	Hanoi_Tower(5, 'X', 'Y', 'Z');
	return 0;
}
```

#### (2) æ•°å­—æ‹†åˆ†æ–¹å¼çš„è®¡ç®—
ç»™å®šä¸€ä¸ªæ•°å­— 5 ç»™å‡ºå…¶æ‰€æœ‰æ‹†åˆ†æ–¹å¼
(1) 1+4å’Œ4+1è®°ä¸ºä¸¤ç§æ–¹å¼
å…¶åŸç†æ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢æ–¹æ³• 

````ad-check
title: åŒæ‹†åˆ†æ–¹å¼çš„ç®—æ³•
collapse:close
æ‹†åˆ†æ–¹æ³•æ˜¯ä¸æ‹†å‡º0æ¥ï¼Œè¿™æ ·å¯¹äºæ•°å­—5å…±æœ‰16ç§æ‹†åˆ†æ–¹å¼

```cpp 
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

stack<int> res;  

int cnt = 0;

void PrintResult() {
	stack<int> pre(res); // å¤åˆ¶ä¸€ä»½
	cout << pre.top();
	pre.pop(); // å‡ºæ ˆ
	while (!pre.empty()) {
		cout << " + " << pre.top();
		pre.pop();
	}
	cout << endl;
}

// ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´ ç»“æ„çš„æ•°å­—
void dfs(int n) {
	if (n == 0) {
		PrintResult(); // è¾“å‡ºæ ˆé‡Œé¢ç°æœ‰çš„æ•°
		res.pop(); 
		if (!res.empty())res.pop();
		// å¼¹å‡ºæœ€åä¸¤ä¸ªæ•°,å…¶å®æ˜¯æ ¹æ®æœç´¢çš„ç‰¹ç‚¹è¿›è¡Œçš„
		cnt++;
	}
	else {
		// åŠ å…¥ç»“æœæ•°ç»„
		for (int i = 1; i <= n; i++) {
			res.push(i);
			dfs(n - i);
		}
	}
}

// æ•°å­—çš„æ‹†åˆ†æ–¹å¼, ä½¿ç”¨æ ‘å½¢ç»“æ„è¿›è¡Œæ‹†åˆ†, 
int main() {
	int num = 5;
	dfs(num);
	cout << "total split ways : " << cnt << endl;
	return 0;
}
```

````

(2) 1+4å’Œ4+1ä¸ºä¸€ç§æ–¹å¼

æ–¹æ³•ä¸€æ˜¯é‡‡ç”¨é™åºæ‹†åˆ†çš„æ–¹å¼ï¼Œ åˆ©ç”¨ç¬¬ä¸€ä¸ªæ‹†å‡ºæ¥çš„ä¸åŒï¼Œå°±äº§ç”Ÿäº†ä¸åŒçš„ç»“æœ
ä¸‹å›¾ä¸­, 5æœ‰7ç§æ‹†åˆ†æ–¹å¼
![[attachments/Pasted image 20230327210131.png|400]]
ä¹Ÿå¯ä»¥ä½¿ç”¨å‡åºæ‹†åˆ†çš„ç®—æ³•ï¼Œæ­¤æ—¶å·²ç»æ‹†å‡º2æ¥çš„éƒ¨åˆ†ï¼Œæ°¸è¿œæ‹†ä¸å‡º1ï¼Œå³æ¯ä¸€æ¬¡ç•™ä¸‹çš„æ•°ä¸å¾—å°äºåŸæ•°
````ad-note
title: ä»£ç å®ç°
collapse: close
```cpp 
#include <iostream>
using namespace std;

int cnt = 0;

// ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢, è¿›è¡Œæ•°å­—æ‹†åˆ†
void dfs(int n, int pre_detach) {
	if (n == 0) {  // æ‹†å‡º0ï¼Œåˆ™count+1;
		cnt++;
	}
	else {
		// æ‹†å‡ºi,å‰©ä¸‹n-i, ç”±äºæ˜¯å‡åºæ‹†è§£, n-iä¸å¾—å°äºi
		for (int i = 1; i <= n; i++) {
			// è¿›è¡Œé™åºæ‹†è§£, æ‹†å‡ºi,ä½†æ˜¯iå¿…é¡»å°äºä¸Šä¸€æ¬¡æ‹†å‡ºçš„æ•°
			if (i <= pre_detach) {
				dfs(n - i, i);
			}
		}
	}
}

// æ•°å­—çš„æ‹†åˆ†æ–¹å¼, ä½¿ç”¨æ ‘å½¢ç»“æ„è¿›è¡Œæ‹†åˆ†, 
int main() {
	int num = 6;
	dfs(num, num);  // ä½¿ç”¨ä¸€ä¸ªå¤Ÿå¤§çš„æ•°ä¿è¯æ‹†åˆ†è¿›è¡Œä¸‹å»

	cout << "total split ways : " << cnt << endl;
	return 0;
}
```
````

ç»“æœçš„è¾“å‡º: 
å®šä¹‰ä¸€ä¸ªå¤§å°ä¸ºmçš„å…¨å±€å˜é‡æ•°ç»„aï¼Œåœ¨æ‹†åˆ†è¿‡ç¨‹ä¸­ï¼Œè®°å½•æœç´¢çš„å±‚æ•°ï¼Œæ ¹æ®å±‚æ•°æ¥è¿›è¡Œè¾“å‡ºæ•°ç»„çš„å‰é¢éƒ¨åˆ†

#### (3) ç©·ä¸¾nä½mè¿›åˆ¶æ•°
ä½¿ç”¨æ ‘å½¢ç»“æ„è¡¨ç¤ºmè¿›åˆ¶æ•°çš„ç©·ä¸¾ç®—æ³•ï¼Œåˆ™ : 
![[Excalidraw/ç¬¬ä¸‰ç«  æ ˆå’Œé˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨ 2023-03-27 21.19.08|200]]

```cpp 
#include <iostream>
#include <vector>
using namespace std;

int cnt = 0;
// n,m,vecç›´æ¥ä¼ å…¥,  startæ˜¯
void bfs(int n,int m, int start, vector<int> vec) {
	int i;
	if (start == 0) i = 1;
	else i = 0;
	if (start < n) { // æ­¤æ—¶æœ€å¤§ä¸ºn-1
		for (; i < m; i++) {
			vec[start] = i;
			bfs(n, m, start + 1, vec);
		}
	}
	else { // è¾“å‡ºè¿›åˆ¶æ•°ç»“æœ
		cnt++;
		for (int i = 0; i < vec.size(); i++) {
			cout << vec[i];
		}
		cout << endl;
	}
}

// ç©·ä¸¾nä½mè¿›åˆ¶æ•°çš„é—®é¢˜
int main() {
	int n = 2;
	int m = 5;
	vector<int> result(n); // ä½¿ç”¨å‘é‡è®°å½•
	bfs(n,m,0,result);
	cout << "total : " << cnt << endl;
	return 0;
}
```

#### (4) è¿·å®«é—®é¢˜

åªèƒ½å‘å³ä¸‹èµ°çš„é€’å½’æ–¹æ³•ï¼Œæ–¹æ³•ä¸€æ˜¯é‡‡ç”¨ç§»åŠ¨è®°å½•çš„æ–¹å¼ï¼Œæ¯ä¸€æ¬¡$row, col= n$å°±å¯ä»¥cnt++

æ–¹æ³•äºŒæ˜¯é‡‡ç”¨ä¸‹é¢çš„é€’å½’è°ƒç”¨
```cpp 
#include <iostream>
#include <vector>
using namespace std;
int wayTo(int lin, int col, vector<vector<bool>>maze) {
	if (!maze[lin][col]) return 0;
	if (lin == 0 && col == 0) return 1;
	else if (lin == 0) return wayTo(lin, col-1, maze);
	else if (col == 0) return wayTo(lin-1, col, maze);
	else return wayTo(lin - 1, col, maze) + wayTo(lin, col - 1, maze);
}
int main() {
	int n = 5;
	vector<bool> Ini(n, true);
	vector<vector<bool>> maze(n, Ini); // æ¯ä¸€ä¸ªå…ƒç´ éƒ½ä½¿ç”¨Iniè¿›è¡Œåˆå§‹åŒ–
	int A[4][2] = { {0,3}, {2,3}, {3,3},{3,1} };
	int x, y;
	for (int i = 0; i < 4; i++) {
		x = A[i][0]; y = A[i][1];
		maze[x][y] = false; // å µå¡è¿·å®«çš„è·¯
	}
	cout << wayTo(n - 1, n - 1, maze);
	return 0;
}
```

æœ‰å¤šå°‘æ ¼å¯ä»¥èµ° : ä½¿ç”¨ä¸€ä¸ª$4*2$æ•°ç»„å­˜å‚¨å¯¹åº”çš„ç§»åŠ¨æ–¹å¼ï¼Œ 
ç”±äºæœ€å¤šèµ°$n*n$ä¸ªæ ¼å­ï¼Œå¯ä»¥ä½¿ç”¨é€’å½’æ–¹æ³•è¿›è¡Œæ±‚è§£ï¼Œæ¯ä¸€æ¬¡é€’å½’row, columnï¼Œæ¯ä¸€æ¬¡é€’å½’$(row , column + 1), (row , column - 1),  (row +1, column) , (row -1, column)$

å¹¶ä¸”éœ€è¦åˆ¤æ–­è¶Šç•Œè¿”å›ï¼Œ 
è·³é©¬é—®é¢˜å®è´¨ä¸Šä¹Ÿæ˜¯<mark style="background: transparent; color: yellow">æ·±åº¦æœç´¢é—®é¢˜</mark>

#### (5) ç©·ä¸¾nä¸ªå…ƒç´ çš„æ’åˆ—
æ¯”å¦‚å¯¹äºå¦‚ä¸‹çš„5ä¸ªå…ƒç´ çš„æ’åˆ—çš„ç©·ä¸¾é—®é¢˜

| 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- |

å…¶åŸºæœ¬æ€è·¯æ˜¯ç©·ä¸¾ä»¥åé¢æ‰€æœ‰å…ƒç´ å¼€å¤´çš„æ•°
**é¦–å…ˆå°†ç¬¬ié¡¹æ”¾åœ¨æœ€é«˜ä½(ç¬¬tä½)ï¼Œ ç„¶åç›¸å½“äºç¬¬té¡¹å·²ç»å®‰æ’å¥½**
ç„¶åé€’å½’ç©·ä¸¾åé¢çš„å¼€å¤´æ–¹å¼ï¼Œå³ç©·ä¸¾å‰ä¸€ä½çš„æ‰€æœ‰å®‰æ’æ–¹å¼

| t= 0 | 1   | 2   | 3   | 4   | 5   |
| ---- | --- | --- | --- | --- | --- |
| t= 1 | 2   | 1   | 3   | 4   | 5   |
| t =2 | 3   | 2   | 1   | 4   | 5   |
| t =3 | 4   | 2   | 3   | 1   | 5   |
| t =4 | 5   | 2   | 3   | 4   | 1   |

ç„¶ååªè¦å°†t+1, ç„¶åç©·ä¸¾åé¢ä½çš„æ‰€æœ‰å®‰æ’æ–¹å¼å°±è¡Œäº†

```cpp 
#include <iostream>
#include <vector>
using namespace std;

int cnt = 0;
int n = 6;
int a[6] = { 1,2,3,4,5,6};

void output() {
	for (int i = 0; i < n; i++) {
		cout << a[i] << " ";
	}
	cout << endl; 
}

void dfs(int t) {
	// å½“t = næ—¶, é€’å½’ç»“æŸã€‚
	if (t == n) { // å‰é¢çš„å…ƒç´ å·²ç»å®‰æ’å¥½äº†,
		output();
		cnt++;
	}
	else {
		for (int i = t; i < n; i++) {
			swap(a[i], a[t]); // å…ˆç»™æœ€é«˜ä½æ”¾ä¸Šä¸€ä¸ªä»»æ„çš„æ•°
			dfs(t + 1);       // ç©·ä¸¾åé¢çš„æ‰€æœ‰æ•°çš„æ’åˆ—
			swap(a[i], a[t]); // ç©·ä¸¾å®Œä¹‹å, å…¨éƒ¨æ¢å›æ¥
			// å¿…é¡»ä¹‹åæ¢å›æ¥ä¿è¯æ¯æ¬¡éƒ½æ˜¯ä»ç¬¬tä½å¼€å§‹â€œå®‰æ’â€çš„
		}
	}
}

int main() {
	dfs(0);
	cout << "total split methods : " << cnt << endl;
	return 0;
}
```

#### (6) ç´ æ•°ç¯é—®é¢˜

å°†ä»**1åˆ°nè¿™nä¸ªæ•´æ•°å›´æˆä¸€ä¸ªåœ†ç¯**  
è‹¥å…¶ä¸­ä»»æ„2ä¸ªç›¸é‚»çš„æ•°å­—ç›¸åŠ ï¼Œç»“æœå‡ä¸ºç´ æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªç¯å°±æˆä¸ºç´ æ•°ç¯ã€‚

ç°è¦æ±‚è¾“å…¥ä¸€ä¸ªnï¼Œæ±‚nä¸ªæ•°å›´æˆä¸€åœˆæœ‰å¤šå°‘ç§ç´ æ•°ç¯ï¼Œ  
è§„å®šç¬¬ä¸€ä¸ªæ•°å­—æ˜¯1ã€‚å†™å‡ºç›¸åº”çš„çš„ç®—æ³•æ€æƒ³å¹¶ç¼–ç¨‹å®ç°ã€‚

`````ad-check
title: ç´ æ•°ç¯é—®é¢˜çš„ä»£ç å®ç°
collapse: close

```cpp 
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int cnt = 0;

// ä½¿ç”¨ChatGPTç”Ÿæˆçš„ç”Ÿæˆç´ æ•°æ•°ç»„çš„ä»£ç : 
vector<bool> sieve_of_eratosthenes(int n) {
    vector<bool> is_prime(n + 1, true);
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i) {  
                // æ³¨æ„è¿‡æ»¤æ˜¯ä»i*iå¼€å§‹çš„,è¿™æ˜¯ç”±äº,å°äºiçš„æ•°ä¹˜iå·²ç»è¢«éå†è¿‡äº†
                is_prime[j] = false;
            }
        }
    }
    return is_prime;
}

// æµ‹è¯•æ˜¯å¦èƒ½å¤Ÿå½¢æˆç´ æ•°ç¯
bool TestPrime(vector<int> vec, vector<bool> IsPrime) {
    int j;
    for (int i = 0; i < vec.size(); i++) {
        j = (i + 1) % vec.size();
        if (!IsPrime[vec[i] + vec[j]]) return false;
    }
    cnt++;
    return true;
}

void dfs(vector<int> vec, int t, vector<bool> IsPrime) {
    // t ä¸ºä½æ•°, 
    if (t == vec.size()) {
        if (TestPrime(vec, IsPrime)) { 
            // è¿›è¡Œæµ‹è¯•
            for (int n : vec) cout << n << " ";
            cout << endl;
        };
    }
    for (int i = t; i < vec.size(); i++) { 
        // é€’å½’è°ƒç”¨è‡ªèº«çš„å‡½æ•°
        swap(vec[t], vec[i]);
        dfs(vec, t + 1, IsPrime);
        swap(vec[t], vec[i]); // ä¿è¯æœ‰åºæ€§
    }
}

int main() {
    int n = 5;
    vector<int> vec = { 1,2,3,4,5,6};
    int m =  *max_element(vec.begin(), vec.end()); // å¯»æ‰¾å‘é‡ä¸­çš„æœ€å¤§å€¼
    vector<bool> IsPrime = sieve_of_eratosthenes(2 * m);// ç”Ÿæˆä¸€ä¸ªå¤§å°ä¸º2mçš„ç´ æ•°æ•°ç»„
    // ä½¿ç”¨é€’å½’æ–¹æ³•æ±‚è§£ç´ æ•°ç¯é—®é¢˜
    // å…¶ä¸­ä»»æ„2ä¸ªç›¸é‚»çš„æ•°å­—ç›¸åŠ , å¦‚æœç»“æœä¸ºç´ æ•°ï¼Œåˆ™ç§°ä¸ºç´ æ•°ç¯
    dfs(vec, 0, IsPrime);
    cout << "total count = " << cnt << endl;
    return 0;
}](<#include %3Ciostream%3E
#include <vector>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

int cnt = 0;

// ä½¿ç”¨ChatGPTç”Ÿæˆçš„ç”Ÿæˆç´ æ•°æ•°ç»„çš„ä»£ç : 
vector<bool> sieve_of_eratosthenes(int n) {
    vector<bool> is_prime(n + 1, true);
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i) {  
                // æ³¨æ„è¿‡æ»¤æ˜¯ä»i*iå¼€å§‹çš„,è¿™æ˜¯ç”±äº,å°äºiçš„æ•°ä¹˜iå·²ç»è¢«éå†è¿‡äº†
                is_prime[j] = false;
            }
        }
    }
    return is_prime;
}

// æµ‹è¯•æ˜¯å¦èƒ½å¤Ÿå½¢æˆç´ æ•°ç¯
bool TestPrime(vector<int> vec, vector<bool> IsPrime) {
    int j;
    for (int i = 0; i < vec.size(); i++) {
        j = (i + 1) % vec.size();
        if (!IsPrime[vec[i] + vec[j]]) return false;
    }
    cnt++;
    return true;
}

void dfs(vector<int> vec, int t, vector<bool> IsPrime) {
    // t ä¸ºä½æ•°,å½“ç›®å‰ä½æ•°ç­‰äºnæ—¶,è¿›è¡Œæµ‹è¯•
    if (t == vec.size() && TestPrime(vec, IsPrime)) {
        for (int n : vec) cout << n << " ";
        cout << endl;
    }
    for (int i = t; i < vec.size(); i++) { 
        // é€’å½’è°ƒç”¨è‡ªèº«çš„å‡½æ•°
        swap(vec[t], vec[i]);
        dfs(vec, t + 1, IsPrime);
        swap(vec[t], vec[i]);
        // ä¿è¯æœ‰åºæ€§
    }
}

int main() {
    int n = 5;
    vector<int> vec = { 1,2,3,4,5,6};
    int m =  *max_element(vec.begin(), vec.end()); // å¯»æ‰¾å‘é‡ä¸­çš„æœ€å¤§å€¼
    vector<bool> IsPrime = sieve_of_eratosthenes(2 * m);  // ç”Ÿæˆä¸€ä¸ªå¤§å°ä¸º2mçš„ç´ æ•°æ•°ç»„
    // ä½¿ç”¨é€’å½’æ–¹æ³•æ±‚è§£ç´ æ•°ç¯é—®é¢˜
    // å…¶ä¸­ä»»æ„2ä¸ªç›¸é‚»çš„æ•°å­—ç›¸åŠ , å¦‚æœç»“æœä¸ºç´ æ•°ï¼Œåˆ™ç§°ä¸ºç´ æ•°ç¯
    dfs(vec, 0, IsPrime);
    cout << "total count = " << cnt << endl;
    return 0;
}>)
```

`````

`````ad-check 
title: å…³äºèƒ½å¦å°†t=nçš„ç»ˆæ­¢æ¡ä»¶è®¾ç½®ä¸ºn-1çš„é—®é¢˜
collapse: close

å¦‚æœå°†t==nçš„ç»ˆæ­¢æ¡ä»¶è®¾ç½®ä¸ºt=n-1, åˆ™æ²¡æœ‰å»æšä¸¾æœ€åä¸€ç§å…ƒç´ çš„å¯èƒ½æ’åˆ—æƒ…å†µ

å…¶å®æŒ‰ç…§ä¸Šä¸€ç§æ€ç»´ï¼Œç”±äºæœ€å¤§ä¸‹æ ‡ä¸ºn-1ï¼Œæšä¸¾åˆ°æœ€åä¸€ä¸ªæ•°ç›´æ¥è¿›è¡Œè¾“å‡º,ç»ˆæ­¢æ¡ä»¶å¯ä»¥ç›´æ¥è®¾ç½®ä¸ºn-1, å› ä¸ºå¦‚æœæ”¾åˆ°nåªæ˜¯æ— æ„ä¹‰åœ°å°†æœ€åä¸€ä¸ªæ•°çš„1ç§æƒ…å†µåŠ ä¸€é

ä½†æ˜¯å¯¹äºç´ æ•°ç¯é—®é¢˜ï¼Œéœ€è¦æšä¸¾æœ€åä¸€ä¸ªæ•°åŠ ä¸Šå‰é¢çš„æ•°æ˜¯å¦ä¸ºç´ æ•°çš„æƒ…å†µ, å› æ­¤éœ€è¦æšä¸¾æœ€åä¸€ä¸ªæ•°çš„æ¡ä»¶
`````

### (7) è¿›å‡ºæ ˆçš„åºåˆ—çš„ç©·ä¸¾
é—®é¢˜: æœ‰1,2,3,4å…±4ä¸ªæ•°å­—, ä¾æ¬¡è¿›æ ˆï¼Œè€Œå‡ºæ ˆå¯éšæœºè¿›è¡Œï¼Œæ±‚æ‰€æœ‰å¯èƒ½çš„å‡ºæ ˆæ¬¡åº
æœ‰è¿›æ ˆå’Œå‡ºæ ˆä¸¤ç§æ“ä½œ
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨é€’å½’çš„æ–¹æ³•æ¥è§£å†³ï¼Œ æ¯ä¸€æ¬¡çš„ `return` å€¼ä¸ºè¿™ä¸€æ¬¡è¿›æ ˆå’Œè¿™ä¸€æ¬¡å‡ºæ ˆçš„æ–¹å¼ä¹‹å’Œï¼Œ è¿›æ ˆä¸º`f(a -1, b+1)` è€Œå‡ºæ ˆä¸º `f(a, b-1)` 

<mark style="background: transparent; color: yellow">ä¸»è¦éš¾ç‚¹æ˜¯ä½¿ç”¨ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ˜¯æ ˆä¸­çš„è½¦çš„æ•°é‡ï¼Œä¸€ä¸ªæ˜¯å¾…è¿›æ ˆçš„è½¦çš„æ•°é‡</mark>

```cpp 
#include <iostream>
using namespace std;
int f(int a, int b) {
	//å¾…è¿›æ ˆæ•°ï¼Œæ ˆä¸­æ•° 
	if (a == 0) return 1; //å¾…è¿›æ ˆè½¦æ•°ä¸º0ï¼Œæ ˆä¸­çš„åªèƒ½ä¾æ¬¡å‡ºæ ˆ 
	if (b == 0) return f(a-1, 1); // æ ˆä¸­è½¦æ•°ä¸º0ï¼Œåªèƒ½è¿›æ ˆ 
	return f(a-1, b+1) + f(a, b-1); // è¿›æ ˆå’Œå‡ºæ ˆ 
}
int main() {
    for (int i = 1; i <= 16; i++) {
    	cout << i << ": " << f(i, 0) << endl;
	}
    return 0;
}
```
å¦‚ 1324 
## å››ã€å…¶ä»–çŸ¥è¯†ç‚¹

**é€’å½’è¿›å±‚éœ€è¦åšçš„ä¸‰ä»¶äº‹**ï¼š
1. ä¿ç•™æœ¬å±‚å‚æ•°ä¸è¿”å›åœ°å€
2. ä¸ºè¢«è°ƒç”¨çš„å‡½æ•°åˆ†é…å­˜å‚¨åŒºï¼Œå¹¶ç»™ä¸‹ä¸€å±‚å‚æ•°èµ‹å€¼
3. å°†ç¨‹åºè½¬ä¹‰åˆ°è¢«è°ƒç”¨å‡½æ•°çš„å…¥å£å¤„

**è¢«è°ƒç”¨å‡½æ•°è¿”å›è°ƒç”¨å‡½æ•°**åšçš„ä¸‰ä»¶äº‹: 
1. ä¿å­˜è¢«è°ƒç”¨å‡½æ•°çš„è®¡ç®—ç»“æœ
2. é‡Šæ”¾è¢«è°ƒç”¨å‡½æ•°çš„æ•°æ®åŒºï¼Œ æ¢å¤ä¸Šå±‚å‚æ•°
3. ä¾ç…§è¢«è°ƒç”¨å‡½æ•°çš„è¿”å›åœ°å€å°†æ§åˆ¶è½¬ç§»ç»™å›è°ƒå‡½æ•°

